<Type Name="Delegate" FullName="System.Delegate">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1b76c85e1e9a70132f964767500d5f63f74d6880" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57951785" /></Metadata><TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Delegate = class&#xA;    interface ICloneable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt einen Delegaten dar. Hierbei handelt es sich um eine Datenstruktur, die auf eine statische Methode oder auf eine Klasseninstanz und eine Instanzenmethode dieser Klasse verweist.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Delegate> Klasse ist die Basisklasse für Delegattypen. Jedoch nur das System und der Compiler können ableiten explizit die <xref:System.Delegate> Klasse oder aus der <xref:System.MulticastDelegate> Klasse. Es ist auch nicht zulässig, einen neuen Typ von einem Delegattyp abzuleiten. Die <xref:System.Delegate> Klasse gilt keinen Delegattyp aufweisen; es ist eine Klasse, die zum Ableiten von Delegattypen verwendet.  
  
 Die meisten Sprachen implementieren eine `delegate` -Schlüsselwort und -Compiler für diese Sprachen sind in der Lage, abgeleitet der <xref:System.MulticastDelegate> Klasse; daher sollten Benutzer verwenden die `delegate` -Schlüsselwort von der Sprache.  
  
> [!NOTE]
>  Die common Language Runtime stellt eine `Invoke` Methode für jeden Delegattyp, mit der gleichen Signatur wie der Delegat. Sie müssen keinen zum Aufrufen dieser Methode explizit aus c#, Visual Basic oder Visual C++, da der Compiler sie automatisch aufrufen. Die `Invoke` Methode eignet sich [Reflektion](~/docs/framework/reflection-and-codedom/reflection.md) Wenn Sie die Signatur des Delegattyps suchen möchten.  
  
 Die common Language Runtime stellt jedem Delegattyp `BeginInvoke` und `EndInvoke` Methoden, an den asynchronen Aufruf des Delegaten zu aktivieren. Weitere Informationen zu diesen Methoden finden Sie unter [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 Die Deklaration eines Delegattyps richtet einen Vertrag, der die Signatur der mindesten eine Methode angibt. Ein Delegat ist eine Instanz einen Delegattyp aufweisen, die Verweise auf:  
  
-   Eine Instanzmethode einem Typ und einem Zielobjekt auf diesen Typ zugewiesen werden.  
  
-   Eine Instanzmethode eines Typs, mit den hidden- `this` Parameter in der Liste der formalen Parameter verfügbar gemacht werden. Der Delegat wird als eine offene Instanz Delegat.  
  
-   Eine statische Methode.  
  
-   Eine statische Methode und einem Zielobjekt, die auf den ersten Parameter der Methode zugewiesen werden. Der Delegat wird als über das erste Argument geschlossen werden.  
  
 Weitere Informationen zu Delegaten binden, finden Sie unter den <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> -methodenüberladung.  
  
> [!NOTE]
>  In der .NET Framework-Versionen 1.0 und 1.1 kann ein Delegat eine Methode darstellen, nur dann, wenn die Signatur der Methode genau die vom Typ Delegaten angegebene Signatur entspricht. Daher werden nur die ersten und dritten Aufzählungszeichen in der vorangehenden Liste unterstützt, und das erste Aufzählungszeichen erfordert eine genau übereinstimmen.  
  
 Wenn ein Delegat eine Instanzmethode geschlossene als erstes Argument (den meisten Fällen) darstellt, der Delegaten speichert einen Verweis auf den Einstiegspunkt der Methode und einem Verweis auf ein Objekt, das als Ziel bezeichnet, handelt es sich von einem Typ, der dem Typ zugewiesen werden, die definiert die -Methode. Wenn ein Delegat über eine offene Instanzmethode darstellt, speichert es einen Verweis auf den Einstiegspunkt der Methode. Die Signatur des Delegaten muss die ausgeblendeten enthalten `this` Parameter in der formalen Parameterliste; in diesem Fall der Delegaten verfügt nicht über einen Verweis auf ein Zielobjekt und einem Zielobjekt muss bereitgestellt werden, wenn der Delegat aufgerufen wird.  
  
 Wenn ein Delegat eine statische Methode darstellt, speichert der Delegat einen Verweis auf den Einstiegspunkt der Methode. Wenn ein Delegat eine statische Methode, die als erstes Argument geschlossene darstellt, speichert der Delegat einen Verweis auf den Einstiegspunkt der Methode und einem Verweis auf ein Zielobjekt, das den Typ des ersten Arguments der Methode zugewiesen werden. Wenn der Delegat aufgerufen wird, erhält das erste Argument der statischen Methode das Zielobjekt.  
  
 Die Aufrufliste eines Delegaten ist eine geordnete Menge von Delegaten in denen jedes Element der Liste genau eine der Methoden, die durch den Delegaten dargestellte aufruft. Eine Aufrufliste kann es sich um doppelte Methoden enthalten. Während eines Aufrufs werden Methoden in der Reihenfolge aufgerufen, in denen sie in der Aufrufliste angezeigt werden. Ein Delegat versucht, jede Methode in der Aufrufliste zu aufzurufen; Duplikate werden aufgerufen, nachdem für jedes Mal, die sie in der Aufrufliste angezeigt werden. Delegaten sind unveränderlich. nach der Erstellung wird die Aufrufliste eines Delegaten nicht geändert werden.  
  
 Delegaten werden bezeichnet als Multicast- oder mit den flexibel kombinierbaren, da ein Delegat kann eine oder mehrere Methoden aufrufen, und kann in Kombination von Vorgängen verwendet werden.  
  
 Kombinieren die Vorgänge, z. B. <xref:System.Delegate.Combine%2A> und <xref:System.Delegate.Remove%2A>, vorhandene Delegaten nicht geändert. Stattdessen gibt einen neuen Delegat mit den Ergebnissen des Vorgangs einen Delegaten unverändert oder `null`. Gibt eine Kombinationsoperation `null` Wenn das Ergebnis des Vorgangs ist ein Delegat, der nicht über mindestens eine Methode verweist. Eine Operation zum Kombinieren gibt einen unveränderten Delegaten zurück, wenn der angeforderte Vorgang keine Auswirkungen hat.  
  
> [!NOTE]
>  Verwaltete Sprachen verwenden die <xref:System.Delegate.Combine%2A> und <xref:System.Delegate.Remove%2A> Methoden, Delegaten Vorgänge zu implementieren. Beispiele hierfür sind die `AddHandler` und `RemoveHandler` Anweisungen in Visual Basic und die Operatoren "+=" und "=" auf Typen in c# zu delegieren.  
  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], generischen Delegattypen können über Variante Typparameter verfügen. Kontravariante Typparameter als Parametertypen des Delegaten verwendet werden können, und ein kovarianten Typparameter als Rückgabetyp verwendet werden kann. Dieses Feature ermöglicht den generischen Delegaten Typen, die erstellt werden, aus der gleichen generischen Typdefinition zuweisungskompatibel, wenn ihre Typargumente Verweistypen mit einer vererbungsbeziehung sind sein, wie unter [Kovarianz und Kontravarianz](~/docs/standard/generics/covariance-and-contravariance.md).  
  
> [!NOTE]
>  Generische Delegaten, die zuweisungskompatibel sind aufgrund der Varianz sind nicht unbedingt mit den flexibel kombinierbaren. Um mit den flexibel kombinierbaren sein, müssen die Typen exakt übereinstimmen. Nehmen wir beispielsweise an, dass eine Klasse mit dem Namen `Derived` stammt aus einer Klasse namens `Base`. Ein Delegat vom Typ `Action<Base>` (`Action(Of Base)` in Visual Basic) kann eine Variable des Typs zugewiesen werden `Action<Derived>`, aber die beiden Delegaten können nicht kombiniert werden, da die Typen nicht genau übereinstimmen.  
  
 Wenn eine aufgerufene Methode eine Ausnahme auslöst, beendet die Ausführung der Methode, die Ausnahme zurück an den Aufrufer des Delegaten übergeben wird und verbleibende Methoden in der Aufrufliste nicht aufgerufen werden. Die Ausnahme abfangen, im Aufrufer wird dieses Verhalten nicht geändert werden.  
  
 Wenn die Signatur der Methoden aufgerufen, indem ein Delegat über einen Rückgabewert enthält, gibt den Delegaten den Rückgabewert des letzten Elements in der Aufrufliste zurück. Wenn die Signatur einen Parameter, der als Verweis übergeben wird enthält, ist der endgültige Wert des Parameters das Ergebnis jeder Methode in der Aufrufliste, die nacheinander ausgeführt, und aktualisieren den Wert des Parameters an.  
  
 Am nächsten entspricht einen Delegaten in C# einem Funktionszeiger. Ein Delegat kann es sich um eine statische Methode oder Instanzmethode darstellen. Wenn der Delegat eine Instanzmethode darstellt, speichert der Delegaten nicht nur einen Verweis auf den Einstiegspunkt der Methode, sondern auch einen Verweis auf die Instanz der Klasse. Im Gegensatz zu Funktionszeigern sind Delegaten sind objektorientiert und typsicher.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie einen Delegaten, mit dem Namen definieren `myMethodDelegate`. Instanzen dieses Delegaten werden erstellt, für die eine Instanzmethode und eine statische Methode der geschachtelten `mySampleClass` Klasse. Der Delegat für die Instanzmethode erfordert eine Instanz von `mySampleClass`. Die `mySampleClass` Instanz wird gespeichert, in einer Variablen namens `mySC`.  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
    <related type="Article" href="https://msdn.microsoft.com/library/41972034-92ed-450a-9664-ab93fcc6f1fb">Asynchrones Aufrufen von synchronen Methoden</related>
    <related type="Article" href="~/docs/csharp/programming-guide/delegates/index.md">Delegaten (C#-Programmierhandbuch)</related>
    <related type="Article" href="~/docs/visual-basic/programming-guide/language-features/delegates/index.md">Delegaten (Visual Basic)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/1cdf3420-89c1-47c0-b796-aa984020e0f8">Gewusst wie: Definieren und Verwenden von Delegaten (C++/CLI)</related>
    <related type="Article" href="https://msdn.microsoft.com/library/b6f65241-e0ad-4590-a99f-200ce741bb1f">Behandeln und Auslösen von Ereignissen</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert einen neuen Delegaten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : obj * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target">Die Klasseninstanz, für die der Delegat <paramref name="method" /> aufruft.</param>
        <param name="method">Der Name der Instanzenmethode, die durch den Delegaten dargestellt wird.</param>
        <summary>Initialisiert einen Delegaten, der die angegebene Instanzenmethode für die angegebene Klasseninstanz aufruft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor kann nicht im Anwendungscode verwendet werden. Verwenden Sie zum Erstellen eines Delegaten durch Angeben des Namens einer Instanzmethode eine Überladung von der <xref:System.Delegate.CreateDelegate%2A> Methode, die einen Methodennamen und einem Zielobjekt angibt. Z. B. die <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> methodenüberladung erstellt einen Delegaten für eine Instanzmethode mit einem angegebenen Namen.  
  
 Dieser Konstruktor erstellt nur Delegaten für die Instanz. Eine Instanzmethode handelt es sich um eine Methode, die eine Instanz einer Klasse zugeordnet ist; eine statische Methode handelt es sich um eine Methode, die die Klasse selbst zugeordnet ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Beim Binden an die Zielmethode ist ein Fehler aufgetreten.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : Type * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="target" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="target">Der <see cref="T:System.Type" />, der die <paramref name="method" /> definierende Klasse darstellt.</param>
        <param name="method">Der Name der statischen Methode, die durch den Delegaten dargestellt wird.</param>
        <summary>Initialisiert einen Delegaten, der die angegebene statische Methode der angegebenen Klasse aufruft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor kann nicht im Anwendungscode verwendet werden. Um einen Delegaten erstellen, indem Sie den Namen einer statischen Methode angeben, verwenden Sie eine Überladung von der <xref:System.Delegate.CreateDelegate%2A> -Methode, die einen Methodennamen angibt, aber ein Zielobjekt ist nicht angegeben. Z. B. die <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> methodenüberladung erstellt einen statischen Delegaten für eine Methode mit dem angegebenen Namen.  
  
 Dieser Konstruktor erstellt die Delegaten für die nur statische Methoden. Eine Instanzmethode handelt es sich um eine Methode, die eine Instanz einer Klasse zugeordnet ist; eine statische Methode handelt es sich um eine Methode, die die Klasse selbst zugeordnet ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="target" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="target" /> ist keine <see langword="RuntimeType" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- oder - 
 <paramref name="target" /> stellt einen offenen generischer Typ dar.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="delegate.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine flache Kopie des Delegaten.</summary>
        <returns>Eine flache Kopie des Delegaten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Klon hat dieselbe <xref:System.Type>, Ziel, Methode und das Aufrufen der Liste wie der ursprüngliche Delegat.  
  
 Eine flache Kopie erstellt eine neue Instanz des gleichen Typs wie das ursprüngliche Objekt, und klicken Sie dann die nicht statische Felder des ursprünglichen Objekts kopiert. Wenn das Feld ein Werttyp ist, erfolgt eine Bit für Bit-Kopie des Felds. Wenn das Feld ein Verweistyp ist, wird der Verweis kopiert, aber das Objekt verwiesen wird, ist nicht; Zeigen Sie daher den Verweis in das ursprüngliche Objekt und der Verweis auf dem geklonten auf dasselbe Objekt. Im Gegensatz dazu dupliziert eine tiefe Kopie eines Objekts wird alles, was die Felder in das Objekt direkt oder indirekt verweist.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verkettet die Aufruflisten der angegebenen Multicastdelegaten.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate[] -&gt; Delegate" Usage="System.Delegate.Combine delegates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">Das zu kombinierende Array von Delegaten.</param>
        <summary>Verkettet die Aufruflisten eines Arrays von Delegaten.</summary>
        <returns>Ein neuer Delegat mit einer Aufrufliste, die aus der Verkettung der Aufruflisten der Delegaten im <paramref name="delegates" />-Array besteht. Gibt <see langword="null" /> zurück, wenn <paramref name="delegates" /> <see langword="null" /> ist, <paramref name="delegates" /> 0 Elemente enthält oder jeder Eintrag in <paramref name="delegates" /> <see langword="null" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die `delegates` Array enthält Einträge `null`, diese Einträge werden ignoriert.  
  
 Die Aufrufliste kann doppelte Einträge enthalten. d. h. die Einträge, die auf die gleiche Methode für das gleiche Objekt verweisen.  
  
> [!NOTE]
>  Generische Delegaten, die zuweisungskompatibel sind aufgrund der Varianz sind nicht unbedingt mit den flexibel kombinierbaren. Um mit den flexibel kombinierbaren sein, müssen die Typen exakt übereinstimmen. Nehmen wir beispielsweise an, dass eine Klasse mit dem Namen `Derived` stammt aus einer Klasse namens `Base`. Ein Delegat vom Typ `Action<Base>` (`Action(Of Base)` in Visual Basic) kann eine Variable des Typs zugewiesen werden `Action<Derived>`, wie unter [Kovarianz und Kontravarianz](~/docs/standard/generics/covariance-and-contravariance.md), aber die beiden Delegaten können nicht kombiniert werden, da die Typen bereitgestellt werden nicht exakt überein.  
  
 <xref:System.Delegate.Combine%2A> ist nützlich für das Erstellen von Ereignishandlern, die, dass mehrere Methoden jedes Mal bei einem Ereignis des Anrufs gewählt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Nicht alle Einträge ungleich null in <paramref name="delegates" /> sind Instanzen des gleichen Delegattyps.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Combine (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">Der Delegat, dessen Aufrufliste die erste Liste ist.</param>
        <param name="b">Der Delegat, dessen Aufrufliste die letzte Liste ist.</param>
        <summary>Verkettet die Aufruflisten zweier Delegaten.</summary>
        <returns>Eine neuer Delegat mit einer Aufrufliste, die aus der Verkettung der Aufruflisten von <paramref name="a" /> und <paramref name="b" /> in dieser Reihenfolge besteht. Gibt <paramref name="a" /> zurück, wenn <paramref name="b" /> gleich <see langword="null" /> ist, gibt <paramref name="b" /> zurück, wenn <paramref name="a" /> ein NULL-Verweis ist, und gibt einen NULL-Verweis zurück, wenn <paramref name="a" /> und <paramref name="b" /> NULL-Verweise sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Aufrufliste kann doppelte Einträge enthalten. d. h. die Einträge, die auf die gleiche Methode für das gleiche Objekt verweisen.  
  
> [!NOTE]
>  Generische Delegaten, die zuweisungskompatibel sind aufgrund der Varianz sind nicht unbedingt mit den flexibel kombinierbaren. Um mit den flexibel kombinierbaren sein, müssen die Typen exakt übereinstimmen. Nehmen wir beispielsweise an, dass eine Klasse mit dem Namen `Derived` stammt aus einer Klasse namens `Base`. Ein Delegat vom Typ `Action<Base>` (`Action(Of Base)` in Visual Basic) kann eine Variable des Typs zugewiesen werden `Action<Derived>`, wie unter [Kovarianz und Kontravarianz](~/docs/standard/generics/covariance-and-contravariance.md), aber die beiden Delegaten können nicht kombiniert werden, da die Typen bereitgestellt werden nicht exakt überein.  
  
 <xref:System.Delegate.Combine%2A> ist nützlich für das Erstellen von Ereignishandlern, die, dass mehrere Methoden jedes Mal bei einem Ereignis des Anrufs gewählt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Sowohl <paramref name="a" /> als auch <paramref name="b" /> sind nicht gleich <see langword="null" />, und <paramref name="a" /> und <paramref name="b" /> sind keine Instanzen desselben Delegatentyps.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member CombineImpl : Delegate -&gt; Delegate&#xA;override this.CombineImpl : Delegate -&gt; Delegate" Usage="delegate.CombineImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d">Der Multicastdelegat, dessen Aufrufliste an das Ende der Aufrufliste des aktuellen Multicastdelegaten angefügt werden soll.</param>
        <summary>Verkettet die Aufruflisten des angegebenen und des aktuellen Multicastdelegaten.</summary>
        <returns>Eine neuer Multicastdelegat, dessen Aufrufliste aus der Verkettung der Aufrufliste des aktuellen Multicastdelegaten mit der Aufrufliste von <paramref name="d" /> besteht, oder der aktuelle Multicastdelegat, wenn <paramref name="d" /><see langword="null" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gilt nur, wenn die aktuelle Delegaten multicast (mit den flexibel kombinierbaren).  
  
 Die aktuelle Implementierung löst einfach ein <xref:System.MulticastNotSupportedException>.  
  
 Die Aufrufliste kann doppelte Einträge enthalten. d. h. die Einträge, die auf die gleiche Methode für das gleiche Objekt verweisen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">Wird immer ausgelöst.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen Delegaten vom angegebenen Typs.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Der <see cref="T:System.Type" /> des zu erstellenden Delegaten.</param>
        <param name="method">Die <see cref="T:System.Reflection.MethodInfo" />, die die statische Methode oder Instanzmethode beschreibt, die der Delegat darstellen soll. In .NET Framework, Version 1.0 und 1.1, werden nur statische Methoden unterstützt.</param>
        <summary>Erstellt einen Delegaten vom angegebenen Typ, der die angegebene statische Methode darstellen soll.</summary>
        <returns>Ein Delegat vom angegebenen Typ, der die angegebene statische Methode darstellen soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .NET Framework, Version 1.0 und 1.1 erstellt diese methodenüberladung Delegaten für die nur statische Methoden. In .NET Framework, Version 2.0 kann diese methodenüberladung auch Instanz öffnen-methodendelegaten erstellen. Delegaten, die das ausgeblendete erste Argument von explizit angeben haben, also Instanzmethoden. Eine ausführlichere Erklärung finden Sie unter die allgemeinere <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> methodenüberladung, um alle Kombinationen von offenen oder geschlossenen Delegaten für die Instanz oder statische Methoden zu erstellen und optional ein erstes Argument angeben können.  
  
> [!NOTE]
>  Überladung dieser Methode sollte verwendet werden, wenn der Delegat nicht über die ersten Arguments, geschlossen wird, da er in diesem Fall etwas schneller ist.  
  
 Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> -methodenüberladung, und geben `true` für `throwOnBindFailure`.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, um nicht öffentliche Methoden zugreifen, wenn der Aufrufer erteilt wurde <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> kennzeichnen und Menge oder eine Teilmenge der Berechtigungssatz die nicht öffentliche Methoden an des Aufrufers des beschränkt ist zu gewähren davon. (Finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
## <a name="compatible-parameter-types-and-return-type"></a>Kompatible Parameter und Rückgabetypen  
 In .NET Framework, Version 2.0 müssen die Parametertypen und der Rückgabetyp eines Delegaten mit der Überladung dieser Methode erstellte kompatibel sein mit den Parametertypen und den Rückgabetyp der Methode, die der Delegat darstellt. die Typen müssen nicht genau übereinstimmen. Dies stellt eine Lockerung der Bindung-Verhalten in .NET Framework, Version 1.0 und 1.1 wird, in denen die Typen exakt übereinstimmen müssen.  
  
 Ein Parameter eines Delegaten ist mit dem entsprechenden Parameter einer Methode kompatibel, wenn der Typ des Delegatenparameters restriktiver ist als der Methodenparameter, da so gewährleistet ist, dass ein an den Delegaten übergebenes Argument problemlos an die Methode weitergeleitet werden kann.  
  
 Ebenso ist der Rückgabetyp eines Delegaten kompatibel mit dem Rückgabetyp einer Methode, wenn der Rückgabetyp der Methode restriktiver ist als der Rückgabetyp des Delegaten, da so gewährleistet ist, dass der Rückgabewert der Methode problemlos in den Rückgabetyp des Delegaten umgewandelt werden kann.  
  
 Angenommen, ein Delegat mit einem Parameter vom Typ <xref:System.Collections.Hashtable> und dem Rückgabetyp der <xref:System.Object> kann eine Methode mit einem Parameter des Typs darstellen <xref:System.Object> sowie einen Rückgabewert vom Typ <xref:System.Collections.Hashtable>.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Das erste Beispiel veranschaulicht die beiden Arten von Delegaten, die Überladung dieser Methode erstellt werden können: Öffnen Sie über eine Instanzmethode und über eine statische Methode.  
  
 Im zweiten Codebeispiel wird veranschaulicht, kompatible Parametertypen und Rückgabetypen.  
  
 **Beispiel 1**  
  
 Im folgenden Codebeispiel wird veranschaulicht, die zwei Möglichkeiten, die ein Delegat erstellt werden kann, verwenden diese Überladung von der <xref:System.Delegate.CreateDelegate%2A> Methode.  
  
> [!NOTE]
>  Es gibt zwei Überladungen der der <xref:System.Delegate.CreateDelegate%2A> Methode, die angeben, ein <xref:System.Reflection.MethodInfo> jedoch kein erstes Argument; ihre Funktionalität ist identisch, außer dass eine Ihnen die ermöglicht Angabe, ob bei Bindungsfehlern ausgelöst werden, und die andere löst immer eine. Dieses Codebeispiel verwendet beide Überladungen.  
  
 Das Beispiel deklariert eine Klasse `C` mit einer statischen Methode `M2` und eine Instanzmethode `M1`, und zwei Delegattypen: `D1` akzeptiert eine Instanz von `C` und eine Zeichenfolge, und `D2` nimmt eine Zeichenfolge.  
  
 Eine zweite Klasse namens `Example` enthält den Code, der den Delegaten erstellt.  
  
-   Ein Delegat vom Typ `D1`, der eine offene Instanzmethode darstellt, wird für die Instanzmethode erstellt `M1`. Eine Instanz muss übergeben werden, wenn der Delegat aufgerufen wird.  
  
-   Ein Delegat vom Typ `D2`, eine offene statische Methode darstellt, wird für die statische Methode erstellt `M2`.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Beispiel 2**  
  
 Im folgenden Codebeispiel wird veranschaulicht, die Kompatibilität der Parametertypen und Rückgabetypen.  
  
 Das Codebeispiel definiert eine Basisklasse, die mit dem Namen `Base` und eine Klasse namens `Derived` abgeleitet, die `Base`. Die abgeleitete Klasse verfügt über eine `static` (`Shared` in Visual Basic) Methode, die mit dem Namen `MyMethod` mit einem Parameter vom Typ `Base` und dem Rückgabetyp der `Derived`. Im Codebeispiel wird definiert auch einen Delegaten, der mit dem Namen `Example` , die einen Parameter vom Typ hat `Derived` und dem Rückgabetyp der `Base`.  
  
 Im Codebeispiel wird veranschaulicht, dass der Delegat, mit dem Namen `Example` können verwendet werden, um die Methode darstellen `MyMethod`. Die Methode kann an den Delegaten gebunden werden, da:  
  
-   Der Parametertyp des Delegaten (`Derived`) ist stärker eingeschränkt als der Parametertyp des `MyMethod` (`Base`), sodass es immer sicher an das Argument des Delegaten zu übergeben sind `MyMethod`.  
  
-   Der Rückgabetyp der `MyMethod` (`Derived`) ist stärker eingeschränkt als der Parametertyp des Delegaten (`Base`), sodass sie immer sicher, das den Rückgabetyp der Methode, die den Rückgabetyp des Delegaten umgewandelt werden kann.  
  
 Im Codebeispiel erzeugt keine Ausgabe.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> erbt nicht <see cref="T:System.MulticastDelegate" />.  
  
- oder - 
 <paramref name="type" /> ist keine <see langword="RuntimeType" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- oder - 
 <paramref name="method" /> ist keine statische Methode und die .NET Framework-Version ist 1.0 oder 1.1.  
  
- oder - 
 <paramref name="method" /> kann nicht gebunden werden.  
  
- oder - 
 <paramref name="method" /> ist keine <see langword="RuntimeMethodInfo" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">Die <see langword="Invoke" />-Methode von <paramref name="type" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="firstArgument" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Der <see cref="T:System.Type" /> des zu erstellenden Delegaten.</param>
        <param name="firstArgument">Das Objekt, an das der Delegat gebunden ist, oder <see langword="null" />, um <paramref name="method" /> als <see langword="static" /> (<see langword="Shared" /> in Visual Basic) zu behandeln.</param>
        <param name="method">Die <see cref="T:System.Reflection.MethodInfo" />, die die statische Methode oder Instanzmethode beschreibt, die der Delegat darstellen soll.</param>
        <summary>Erstellt einen Delegaten vom angegebenen Typ, der die angegebene statische Methode oder Instanzmethode mit dem angegebenen ersten Argument darstellt.</summary>
        <returns>Ein Delegat vom angegebenen Typ, der die angegebene statische Methode oder Instanzmethode darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen der Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> -methodenüberladung, und geben `true` für `throwOnBindFailure`. Diese beiden Überladungen bieten die flexibelste Möglichkeit zum Erstellen von Delegaten. Sie können diese verwenden, um Delegaten für statische oder Instanzmethoden zu erstellen und optional an das erste Argument.  
  
> [!NOTE]
>  Wenn Sie ein erstes Argument nicht angeben, verwenden Sie die <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> methodenüberladung für eine bessere Leistung.  
  
 Der Delegattyp und die Methode müssen kompatible Rückgabetypen haben. D. h. der Rückgabetyp der `method` muss der Rückgabetyp der zugewiesen werden können `type`.  
  
 Wenn `firstArgument` wird angegeben, wird es an übergeben `method` jedes Mal, wenn der Delegat aufgerufen wird; `firstArgument` hört sich an den Delegaten gebunden werden und der Delegat wird gesagt, über das erste Argument geschlossen ist. Wenn `method` ist `static` (`Shared` in Visual Basic), wird das Argument bereitgestellte beim Aufrufen des Delegaten Liste schließt alle Parameter außer dem ersten; aus, wenn `method` ist eine Instanzmethode `firstArgument` an der ausgeblendeten Instanz übergeben wird Parameter (dargestellt durch `this` in c# oder durch `Me` in Visual Basic).  
  
 Wenn `firstArgument` angegeben wird, der erste Parameter der `method` muss ein Verweistyp sein und `firstArgument` mit diesem Typ kompatibel sein muss.  
  
> [!IMPORTANT]
>  Wenn `method` ist `static` (`Shared` in Visual Basic) und der erste Parameter ist vom Typ <xref:System.Object> oder <xref:System.ValueType>, klicken Sie dann `firstArgument` kann ein Werttyp sein. In diesem Fall `firstArgument` automatisch eingeschlossen. Automatische Boxing erfolgt nicht für alle anderen Argumente, wie es in einer C#- oder Visual Basic-Funktion aufrufen würden.  
  
 Wenn `firstArgument` ist ein null-Verweis und `method` eine Instanzmethode ist das Ergebnis hängt von den Signaturen der Typ des Delegaten `type` und `method`:  
  
-   Wenn die Signatur der `type` schließt explizit die ersten verborgenen Parameter von `method`, der Delegaten gesagt, dass eine offene Instanzmethode darstellt. Wenn der Delegat aufgerufen wird, wird das erste Argument in der Liste der Argumente an den ausgeblendeten Instanz-Parameter übergeben `method`.  
  
-   Wenn die Signaturen der `method` und `type` übereinstimmen (d. h. alle Parametertypen sind kompatibel), und klicken Sie dann der Delegaten gesagt, dass er über einen null-Verweis geschlossen werden. Aufrufen des Delegaten entspricht dem Aufrufen einer Instanzmethode auf eine null-Instanz, die nicht besonders nützlich, etwas zu tun ist.  
  
 Wenn `firstArgument` ist ein null-Verweis und `method` ist statisch und das Ergebnis hängt von den Signaturen des Delegattyps `type` und `method`:  
  
-   Wenn die Signatur der `method` und `type` übereinstimmen (d. h. alle Parametertypen sind kompatibel), der Delegaten gesagt, dass eine offene statische Methode darstellt. Dies ist der häufigste Fall für statische Methoden. In diesem Fall erhalten Sie eine etwas bessere Leistung mithilfe der <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> -methodenüberladung.  
  
-   Wenn die Signatur der `type` beginnt mit dem zweiten Parameter der `method` der Rest der Parametertypen kompatibel sind, und die Delegaten gesagt, dass Sie über ein null-Verweis geschlossen werden. Wenn der Delegat aufgerufen wird, wird ein null-Verweis auf den ersten Parameter übergeben `method`.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, um nicht öffentliche Methoden zugreifen, wenn der Aufrufer erteilt wurde <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> kennzeichnen und Menge oder eine Teilmenge der Berechtigungssatz die nicht öffentliche Methoden an des Aufrufers des beschränkt ist zu gewähren davon. (Finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
## <a name="compatible-parameter-types-and-return-type"></a>Kompatible Parameter und Rückgabetypen  
 Die Parameter und Rückgabetypen eines Delegaten müssen mit den Parametertypen und den Rückgabetyp der Methode, die den Delegaten dargestellt kompatibel sein. die Typen müssen nicht genau übereinstimmen.  
  
> [!NOTE]
>  In .NET Framework, Version 1.0 und 1.1 müssen die Typen exakt übereinstimmen.  
  
 Ein Parameter eines Delegaten ist mit dem entsprechenden Parameter einer Methode kompatibel, wenn der Typ des Delegatenparameters restriktiver ist als der Methodenparameter, da so gewährleistet ist, dass ein an den Delegaten übergebenes Argument problemlos an die Methode weitergeleitet werden kann.  
  
 Ebenso ist der Rückgabetyp eines Delegaten kompatibel mit dem Rückgabetyp einer Methode, wenn der Rückgabetyp der Methode restriktiver ist als der Rückgabetyp des Delegaten, da so gewährleistet ist, dass der Rückgabewert der Methode problemlos in den Rückgabetyp des Delegaten umgewandelt werden kann.  
  
 Angenommen, ein Delegat mit einem Parameter vom Typ <xref:System.Collections.Hashtable> und dem Rückgabetyp der <xref:System.Object> kann eine Methode mit einem Parameter des Typs darstellen <xref:System.Object> sowie einen Rückgabewert vom Typ <xref:System.Collections.Hashtable>.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Bestimmen die Methoden kann ein Delegat darstellen.  
 Eine weitere nützliche Methode, die Flexibilität, die von dieser Überladung der bereitgestellten betrachten <xref:System.Delegate.CreateDelegate%2A> besteht darin, dass jeder angegebene Delegat vier verschiedene Kombinationen der Methodensignatur und Methodenart (statisch oder Instanz) darstellen kann. Betrachten Sie einen Delegattyp `D` mit einem Argument des Typs `C`. Im folgenden wird beschrieben, die Methoden `D` darstellen kann, wird den Rückgabetyp wird ignoriert, da es in allen Fällen entsprechen muss:  
  
-   `D` kann Instanzmethode, die genau ein Argument des Typs darstellen `C`, unabhängig davon, welchen Typ die Instanzmethode gehört. Wenn <xref:System.Delegate.CreateDelegate%2A> aufgerufen wird, `firstArgument` ist eine Instanz des Typs `method` angehört, und der resultierende Delegat wird gesagt, über diese Instanz geschlossen werden. (Im Grunde `D` kann auch über ein null-Verweis geschlossen werden, wenn `firstArgument` ein null-Verweis ist.)  
  
-   `D` kann eine Instanzmethode darstellen `C` , die keine Argumente verfügt. Wenn <xref:System.Delegate.CreateDelegate%2A> aufgerufen wird, `firstArgument` ist ein null-Verweis. Der resultierende Delegat stellt eine offene Instanz-Methode und eine Instanz von `C` müssen angegeben werden, bei jedem Aufruf erfolgte.  
  
-   `D` kann eine statische Methode, die ein des Typs Argument darstellen `C`, und dass die Methode in einen beliebigen Typ angehören kann. Wenn <xref:System.Delegate.CreateDelegate%2A> aufgerufen wird, `firstArgument` ist ein null-Verweis. Der resultierende Delegat stellt eine offene statische Methode und einer Instanz von `C` müssen angegeben werden, bei jedem Aufruf erfolgte.  
  
-   `D` können eine statische Methode darstellen, die zum Typ gehört `F` und verfügt über zwei Argumente des Typs `F` und `C`. Wenn <xref:System.Delegate.CreateDelegate%2A> aufgerufen wird, `firstArgument` ist eine Instanz der `F`. Der resultierende Delegat stellt eine statische Methode, die über diese Instanz geschlossen ist `F`. Beachten Sie, dass im Fall, in denen `F` und `C` denselben Typ aufweisen, die statische Methode verfügt über zwei Argumente des Typs. (In diesem Fall `D` wird über einen null-Verweis geschlossen, wenn `firstArgument` ein null-Verweis ist.)  
  
   
  
## Examples  
 Dieser Abschnitt enthält drei Codebeispiele aufgeführt. Das erste Beispiel veranschaulicht die vier Arten von Delegaten, die erstellt werden können: über eine Instanzmethode, öffnen Sie über eine Instanzmethode, öffnen Sie über eine statische Methode geschlossen und über eine statische Methode geschlossen.  
  
 Im zweiten Codebeispiel wird veranschaulicht, kompatible Parametertypen und Rückgabetypen.  
  
 Im dritten Codebeispiel wird einen einzelner Delegattyp definiert, und zeigt, dass alle Methoden, die den Delegattyp darstellen können.  
  
 **Beispiel 1**  
  
 Im folgenden Codebeispiel wird veranschaulicht, die vier Möglichkeiten, die ein Delegat kann mit dieser Überladung der erstellt werden die <xref:System.Delegate.CreateDelegate%2A> Methode.  
  
> [!NOTE]
>  Es gibt zwei Überladungen der <xref:System.Delegate.CreateDelegate%2A> Methode, die angeben, `firstArgument` und ein <xref:System.Reflection.MethodInfo>; ihre Funktionalität ist identisch, außer dass eine Ihnen die ermöglicht Angabe, ob bei Bindungsfehlern ausgelöst werden, und die andere löst immer eine. Dieses Codebeispiel verwendet beide Überladungen.  
  
 Das Beispiel deklariert eine Klasse `C` mit einer statischen Methode `M2` und eine Instanzmethode `M1`, sowie zwei Delegattypen: `D1` akzeptiert eine Instanz von `C` und eine Zeichenfolge, `D2` akzeptiert eine Zeichenfolge und `D3`verfügt über keine Argumente.  
  
 Eine zweite Klasse namens `Example` enthält den Code, der den Delegaten erstellt.  
  
-   Ein Delegat vom Typ `D2`, geschlossen für eine Instanz von `C`, wird für die Instanzmethode erstellt `M1`. Er wird aufgerufen, mit anderen Zeichenfolgen, um anzugeben, dass die gebundene Instanz von `C` wird immer verwendet.  
  
-   Ein Delegat vom Typ `D1`, der eine offene Instanzmethode darstellt, wird für die Instanzmethode erstellt `M1`. Eine Instanz muss übergeben werden, wenn der Delegat aufgerufen wird.  
  
-   Ein Delegat vom Typ `D2`, eine offene statische Methode darstellt, wird für die statische Methode erstellt `M2`.  
  
-   Schließlich einen Delegaten vom Typ `D3`, über eine Zeichenfolge geschlossen, wird für die statische Methode erstellt `M2`. Die Methode wird aufgerufen, um anzugeben, dass sie die gebundene Zeichenfolge verwendet wird.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Beispiel 2**  
  
 Im folgenden Codebeispiel wird veranschaulicht, die Kompatibilität der Parametertypen und Rückgabetypen.  
  
> [!NOTE]
>  Dieses Codebeispiel verwendet die <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> -methodenüberladung. Die Verwendung der anderen Überladungen dieser <xref:System.Reflection.MethodInfo> ist ähnlich.  
  
 Das Codebeispiel definiert eine Basisklasse, die mit dem Namen `Base` und eine Klasse namens `Derived` abgeleitet, die `Base`. Die abgeleitete Klasse verfügt über eine `static` (`Shared` in Visual Basic) Methode, die mit dem Namen `MyMethod` mit einem Parameter vom Typ `Base` und dem Rückgabetyp der `Derived`. Im Codebeispiel wird definiert auch einen Delegaten, der mit dem Namen `Example` , die einen Parameter vom Typ hat `Derived` und dem Rückgabetyp der `Base`.  
  
 Im Codebeispiel wird veranschaulicht, dass der Delegat, mit dem Namen `Example` können verwendet werden, um die Methode darstellen `MyMethod`. Die Methode kann an den Delegaten gebunden werden, da:  
  
-   Der Parametertyp des Delegaten (`Derived`) ist stärker eingeschränkt als der Parametertyp des `MyMethod` (`Base`), sodass es immer sicher an das Argument des Delegaten zu übergeben sind `MyMethod`.  
  
-   Der Rückgabetyp der `MyMethod` (`Derived`) ist stärker eingeschränkt als der Parametertyp des Delegaten (`Base`), sodass sie immer sicher, das den Rückgabetyp der Methode, die den Rückgabetyp des Delegaten umgewandelt werden kann.  
  
 Im Codebeispiel erzeugt keine Ausgabe.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Beispiel 3**  
  
 Das folgende Codebeispiel zeigt alle Methoden ein einzelner Delegattyp darstellen kann, mit der <xref:System.Delegate.CreateDelegate%2A> Methode, um die Delegaten zu erstellen.  
  
> [!NOTE]
>  Es gibt zwei Überladungen der <xref:System.Delegate.CreateDelegate%2A> Methode, die angeben, `firstArgument` und ein <xref:System.Reflection.MethodInfo>; ihre Funktionalität ist identisch, außer dass eine Ihnen die ermöglicht Angabe, ob bei Bindungsfehlern ausgelöst werden, und die andere löst immer eine. Dieses Codebeispiel verwendet beide Überladungen.  
  
 Im Codebeispiel werden zwei Klassen definiert `C` und `F`, und einen Delegattyp `D` mit einem Argument des Typs `C`. Die Klassen übereinstimmende statische und Instanzenmethoden `M1`, `M3`, und `M4`, und die Klasse `C` verfügt auch über eine Instanzmethode `M2` , die keine Argumente verfügt.  
  
 Eine dritte Klasse namens `Example` enthält den Code, der den Delegaten erstellt.  
  
-   Delegaten werden erstellt, z. B. Methode `M1` des Typs `C` und `F`; jede über eine Instanz des jeweiligen Typs geschlossen wird. Methode `M1` des Typs `C` zeigt die `ID` Eigenschaften der gebundenen Instanz und des Arguments.  
  
-   Ein Delegat erstellt wird, für die Methode `M2` des Typs `C`. Dies ist eine offene Instanz-Delegaten, in dem das Argument des Delegaten ausgeblendete erste Argument für die Instanzmethode darstellt. Die Methode hat keine anderen Argumente. Sie wird aufgerufen, als handele es sich um eine statische Methode.  
  
-   Delegaten werden erstellt, für die statische Methode `M3` des Typs `C` und `F`; Hierbei handelt es sich um open statische Delegaten.  
  
-   Schließlich werden die Delegaten für die statische Methode erstellt `M4` des Typs `C` und `F`; jede Methode verfügt über den deklarierenden Typ als erstes Argument und eine Instanz des Typs angegeben wird, damit die Delegaten über dem ersten Argument geschlossen werden . Methode `M4` des Typs `C` zeigt die `ID` Eigenschaften der gebundenen Instanz und des Arguments.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> erbt nicht <see cref="T:System.MulticastDelegate" />.  
  
- oder - 
 <paramref name="type" /> ist keine <see langword="RuntimeType" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- oder - 
 <paramref name="method" /> kann nicht gebunden werden.  
  
- oder - 
 <paramref name="method" /> ist keine <see langword="RuntimeMethodInfo" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">Die <see langword="Invoke" />-Methode von <paramref name="type" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Der <see cref="T:System.Type" /> des zu erstellenden Delegaten.</param>
        <param name="target">Die Klasseninstanz, für die <paramref name="method" /> aufgerufen wird.</param>
        <param name="method">Der Name der Instanzenmethode, die durch den Delegaten dargestellt werden soll.</param>
        <summary>Erstellt einen Delegaten vom angegebenen Typ, der die angegebene Instanzenmethode darstellt, die für die angegebene Klasseninstanz aufgerufen werden soll.</summary>
        <returns>Ein Delegat vom angegebenen Typ, der die angegebene Instanzenmethode darstellt, die für die angegebene Klasseninstanz aufgerufen werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt nur Delegaten für die Instanz. Eine Instanzmethode handelt es sich um eine Methode, die eine Instanz einer Klasse zugeordnet ist; eine statische Methode handelt es sich um eine Methode, die die Klasse selbst zugeordnet ist.  
  
 Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> -methodenüberladung angeben `false` für `ignoreCase` und `true` für `throwOnBindFailure`.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, um nicht öffentliche Methoden zugreifen, wenn der Aufrufer erteilt wurde <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> kennzeichnen und Menge oder eine Teilmenge der Berechtigungssatz die nicht öffentliche Methoden an des Aufrufers des beschränkt ist zu gewähren davon. (Finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="target" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> erbt nicht <see cref="T:System.MulticastDelegate" />.  
  
- oder - 
 <paramref name="type" /> ist keine <see langword="RuntimeType" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- oder - 
 <paramref name="method" /> ist keine Instanzenmethode.  
  
- oder - 
 <paramref name="method" /> kann nicht gebunden werden, z. B. weil sie nicht gefunden wurde.</exception>
        <exception cref="T:System.MissingMethodException">Die <see langword="Invoke" />-Methode von <paramref name="type" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Der <see cref="T:System.Type" /> des zu erstellenden Delegaten.</param>
        <param name="method">Die <see cref="T:System.Reflection.MethodInfo" />, die die statische Methode oder Instanzmethode beschreibt, die der Delegat darstellen soll.</param>
        <param name="throwOnBindFailure"><see langword="true" />, um eine Ausnahme auszulösen, wenn <paramref name="method" /> nicht gebunden werden kann, andernfalls <see langword="false" />.</param>
        <summary>Erstellt einen Delegaten vom angegeben Typ zum Darstellen der angegebenen statischen Methode mit dem angegebenen Verhalten bei Bindungsfehlern.</summary>
        <returns>Ein Delegat vom angegebenen Typ, der die angegebene statische Methode darstellen soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überladung dieser Methode kann offene statische methodendelegaten erstellen und öffnen die Instanz-Methode-Delegaten – d. h., Delegaten, die das ausgeblendete erste Argument von Instanzmethoden verfügbar zu machen. Eine ausführlichere Erklärung finden Sie unter die allgemeinere <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> methodenüberladung, die Ihnen ermöglicht, z. B. alle Kombinationen von offenen oder geschlossenen Delegaten zu erstellen oder statische Methoden.  
  
> [!NOTE]
>  Überladung dieser Methode sollte verwendet werden, wenn der Delegat nicht über die ersten Arguments, geschlossen wird, da er in diesem Fall etwas schneller ist.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, um nicht öffentliche Methoden zugreifen, wenn der Aufrufer erteilt wurde <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> kennzeichnen und Menge oder eine Teilmenge der Berechtigungssatz die nicht öffentliche Methoden an des Aufrufers des beschränkt ist zu gewähren davon. (Finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
## <a name="compatible-parameter-types-and-return-type"></a>Kompatible Parameter und Rückgabetypen  
 Die Parameter und Rückgabetypen eines Delegaten müssen mit den Parametertypen und den Rückgabetyp der Methode, die den Delegaten dargestellt kompatibel sein. die Typen müssen nicht genau übereinstimmen.  
  
> [!NOTE]
>  In .NET Framework, Version 1.0 und 1.1 müssen die Typen exakt übereinstimmen.  
  
 Ein Parameter eines Delegaten ist mit dem entsprechenden Parameter einer Methode kompatibel, wenn der Typ des Delegatenparameters restriktiver ist als der Methodenparameter, da so gewährleistet ist, dass ein an den Delegaten übergebenes Argument problemlos an die Methode weitergeleitet werden kann.  
  
 Ebenso ist der Rückgabetyp eines Delegaten kompatibel mit dem Rückgabetyp einer Methode, wenn der Rückgabetyp der Methode restriktiver ist als der Rückgabetyp des Delegaten, da so gewährleistet ist, dass der Rückgabewert der Methode problemlos in den Rückgabetyp des Delegaten umgewandelt werden kann.  
  
 Angenommen, ein Delegat mit einem Parameter vom Typ <xref:System.Collections.Hashtable> und dem Rückgabetyp der <xref:System.Object> kann eine Methode mit einem Parameter des Typs darstellen <xref:System.Object> sowie einen Rückgabewert vom Typ <xref:System.Collections.Hashtable>.  
  
   
  
## Examples  
 Dieser Abschnitt enthält zwei Codebeispiele. Das erste Beispiel veranschaulicht die beiden Arten von Delegaten, die Überladung dieser Methode erstellt werden können: Öffnen Sie über eine Instanzmethode und über eine statische Methode.  
  
 Im zweiten Codebeispiel wird veranschaulicht, kompatible Parametertypen und Rückgabetypen.  
  
 **Beispiel 1**  
  
 Im folgenden Codebeispiel wird veranschaulicht, die zwei Möglichkeiten, die ein Delegat erstellt werden kann, verwenden diese Überladung von der <xref:System.Delegate.CreateDelegate%2A> Methode.  
  
> [!NOTE]
>  Es gibt zwei Überladungen der der <xref:System.Delegate.CreateDelegate%2A> Methode, die angeben, ein <xref:System.Reflection.MethodInfo> jedoch kein erstes Argument; ihre Funktionalität ist identisch, außer dass eine Ihnen die ermöglicht Angabe, ob bei Bindungsfehlern ausgelöst werden, und die andere löst immer eine. Dieses Codebeispiel verwendet beide Überladungen.  
  
 Das Beispiel deklariert eine Klasse `C` mit einer statischen Methode `M2` und eine Instanzmethode `M1`, und zwei Delegattypen: `D1` akzeptiert eine Instanz von `C` und eine Zeichenfolge, und `D2` nimmt eine Zeichenfolge.  
  
 Eine zweite Klasse namens `Example` enthält den Code, der den Delegaten erstellt.  
  
-   Ein Delegat vom Typ `D1`, der eine offene Instanzmethode darstellt, wird für die Instanzmethode erstellt `M1`. Eine Instanz muss übergeben werden, wenn der Delegat aufgerufen wird.  
  
-   Ein Delegat vom Typ `D2`, eine offene statische Methode darstellt, wird für die statische Methode erstellt `M2`.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Beispiel 2**  
  
 Im folgenden Codebeispiel wird veranschaulicht, die Kompatibilität der Parametertypen und Rückgabetypen.  
  
> [!NOTE]
>  Dieses Codebeispiel verwendet die <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> -methodenüberladung. Die Verwendung der anderen Überladungen dieser <xref:System.Reflection.MethodInfo> ist ähnlich.  
  
 Das Codebeispiel definiert eine Basisklasse, die mit dem Namen `Base` und eine Klasse namens `Derived` abgeleitet, die `Base`. Die abgeleitete Klasse verfügt über eine `static` (`Shared` in Visual Basic) Methode, die mit dem Namen `MyMethod` mit einem Parameter vom Typ `Base` und dem Rückgabetyp der `Derived`. Im Codebeispiel wird definiert auch einen Delegaten, der mit dem Namen `Example` , die einen Parameter vom Typ hat `Derived` und dem Rückgabetyp der `Base`.  
  
 Im Codebeispiel wird veranschaulicht, dass der Delegat, mit dem Namen `Example` können verwendet werden, um die Methode darstellen `MyMethod`. Die Methode kann an den Delegaten gebunden werden, da:  
  
-   Der Parametertyp des Delegaten (`Derived`) ist stärker eingeschränkt als der Parametertyp des `MyMethod` (`Base`), sodass es immer sicher an das Argument des Delegaten zu übergeben sind `MyMethod`.  
  
-   Der Rückgabetyp der `MyMethod` (`Derived`) ist stärker eingeschränkt als der Parametertyp des Delegaten (`Base`), sodass sie immer sicher, das den Rückgabetyp der Methode, die den Rückgabetyp des Delegaten umgewandelt werden kann.  
  
 Im Codebeispiel erzeugt keine Ausgabe.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> erbt nicht <see cref="T:System.MulticastDelegate" />.  
  
- oder - 
 <paramref name="type" /> ist keine <see langword="RuntimeType" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- oder - 
 <paramref name="method" /> kann nicht gebunden werden, und <paramref name="throwOnBindFailure" /> ist <see langword="true" />.  
  
- oder - 
 <paramref name="method" /> ist keine <see langword="RuntimeMethodInfo" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">Die <see langword="Invoke" />-Methode von <paramref name="type" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Der <see cref="T:System.Type" /> des zu erstellenden Delegaten.</param>
        <param name="target">Der <see cref="T:System.Type" />, der die Klasse darstellt, die von <paramref name="method" /> implementiert wird.</param>
        <param name="method">Der Name der statischen Methode, die durch den Delegaten dargestellt werden soll.</param>
        <summary>Erstellt einen Delegaten vom angegebenen Typ, der die angegebene statische Methode der angegebenen Klasse darstellt.</summary>
        <returns>Ein Delegat vom angegebenen Typ, der die angegebene statische Methode der angegebenen Klasse darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt die Delegaten für die nur statische Methoden. Eine Instanzmethode handelt es sich um eine Methode, die eine Instanz einer Klasse zugeordnet ist; eine statische Methode handelt es sich um eine Methode, die die Klasse selbst zugeordnet ist.  
  
 Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> -methodenüberladung angeben `false` für `ignoreCase` und `true` für `throwOnBindFailure`.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, um nicht öffentliche Methoden zugreifen, wenn der Aufrufer erteilt wurde <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> kennzeichnen und Menge oder eine Teilmenge der Berechtigungssatz die nicht öffentliche Methoden an des Aufrufers des beschränkt ist zu gewähren davon. (Finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="target" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> erbt nicht <see cref="T:System.MulticastDelegate" />.  
  
- oder - 
 <paramref name="type" /> ist keine <see langword="RuntimeType" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- oder - 
 <paramref name="target" /> ist keine <see langword="RuntimeType" />.  
  
- oder - 
 <paramref name="target" /> ist ein offener generischer Typ. Das bedeutet, die <see cref="P:System.Type.ContainsGenericParameters" />-Eigenschaft ist <see langword="true" />.  
  
- oder - 
 <paramref name="method" /> ist keine <see langword="static" />-Methode (<see langword="Shared" />-Methode in Visual Basic).  
  
- oder - 
 <paramref name="method" /> kann nicht gebunden werden, z. B. weil sie nicht gefunden wurde, und <paramref name="throwOnBindFailure" /> ist gleich <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">Die <see langword="Invoke" />-Methode von <paramref name="type" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="firstArgument" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Ein <see cref="T:System.Type" />, der den Typ des zu erstellenden Delegaten darstellt.</param>
        <param name="firstArgument">Ein <see cref="T:System.Object" />, das das erste Argument der Methode ist, die der Delegat darstellt. Bei Instanzmethoden muss dieses mit dem Instanztyp kompatibel sein.</param>
        <param name="method">Die <see cref="T:System.Reflection.MethodInfo" />, die die statische Methode oder Instanzmethode beschreibt, die der Delegat darstellen soll.</param>
        <param name="throwOnBindFailure"><see langword="true" />, um eine Ausnahme auszulösen, wenn <paramref name="method" /> nicht gebunden werden kann, andernfalls <see langword="false" />.</param>
        <summary>Erstellt einen Delegaten vom angegebenen Typ, der die angegebene statische Methode oder Instanzmethode mit dem angegebenen ersten Argument und dem angegebenen Verhalten bei Bindungsfehlern darstellt.</summary>
        <returns>Ein Delegat des angegebenen Typs, der die angegebene statische Methode oder Instanzmethode darstellt, oder <see langword="null" />, wenn <paramref name="throwOnBindFailure" /> <see langword="false" /> ist und der Delegat nicht an <paramref name="method" /> gebunden werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese methodenüberladung und <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> methodenüberladung, die immer bei Bindungsfehlern auslöst, bieten die flexibelste Möglichkeit zum Erstellen von Delegaten. Sie können sie zum Erstellen von Delegaten für statische oder Instanzmethoden zur Verfügung, mit oder ohne ein erstes Argument verwenden.  
  
> [!NOTE]
>  Wenn Sie ein erstes Argument nicht angeben, verwenden Sie die <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> methodenüberladung für eine bessere Leistung.  
  
 Der Delegattyp und die Methode müssen kompatible Rückgabetypen haben. D. h. der Rückgabetyp der `method` muss der Rückgabetyp der zugewiesen werden können `type`.  
  
 Wenn `firstArgument` wird angegeben, wird es an übergeben `method` jedes Mal, wenn der Delegat aufgerufen wird; `firstArgument` hört sich an den Delegaten gebunden werden und der Delegat wird gesagt, über das erste Argument geschlossen ist. Wenn `method` ist `static` (`Shared` in Visual Basic), wird das Argument bereitgestellte beim Aufrufen des Delegaten Liste schließt alle Parameter außer dem ersten; aus, wenn `method` ist eine Instanzmethode `firstArgument` an der ausgeblendeten Instanz übergeben wird Parameter (dargestellt durch `this` in c# oder durch `Me` in Visual Basic).  
  
 Wenn `firstArgument` angegeben wird, der erste Parameter der `method` muss ein Verweistyp sein und `firstArgument` mit diesem Typ kompatibel sein muss.  
  
> [!IMPORTANT]
>  Wenn `method` ist `static` (`Shared` in Visual Basic) und der erste Parameter ist vom Typ <xref:System.Object> oder <xref:System.ValueType>, klicken Sie dann `firstArgument` kann ein Werttyp sein. In diesem Fall `firstArgument` automatisch eingeschlossen. Automatische Boxing erfolgt nicht für alle anderen Argumente, wie es in einer C#- oder Visual Basic-Funktion aufrufen würden.  
  
 Wenn `firstArgument` ist ein null-Verweis und `method` eine Instanzmethode ist das Ergebnis hängt von den Signaturen der Typ des Delegaten `type` und `method`:  
  
-   Wenn die Signatur der `type` schließt explizit die ersten verborgenen Parameter von `method`, der Delegaten gesagt, dass eine offene Instanzmethode darstellt. Wenn der Delegat aufgerufen wird, wird das erste Argument in der Liste der Argumente an den ausgeblendeten Instanz-Parameter übergeben `method`.  
  
-   Wenn die Signaturen der `method` und `type` übereinstimmen (d. h. alle Parametertypen sind kompatibel), und klicken Sie dann der Delegaten gesagt, dass er über einen null-Verweis geschlossen werden. Aufrufen des Delegaten entspricht dem Aufrufen einer Instanzmethode auf eine null-Instanz, die nicht besonders nützlich, etwas zu tun ist.  
  
 Wenn `firstArgument` ist ein null-Verweis und `method` ist statisch und das Ergebnis hängt von den Signaturen des Delegattyps `type` und `method`:  
  
-   Wenn die Signatur der `method` und `type` übereinstimmen (d. h. alle Parametertypen sind kompatibel), der Delegaten gesagt, dass eine offene statische Methode darstellt. Dies ist der häufigste Fall für statische Methoden. In diesem Fall erhalten Sie eine etwas bessere Leistung mithilfe der <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> -methodenüberladung.  
  
-   Wenn die Signatur der `type` beginnt mit dem zweiten Parameter der `method` der Rest der Parametertypen kompatibel sind, und die Delegaten gesagt, dass Sie über ein null-Verweis geschlossen werden. Wenn der Delegat aufgerufen wird, wird ein null-Verweis auf den ersten Parameter übergeben `method`.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, um nicht öffentliche Methoden zugreifen, wenn der Aufrufer erteilt wurde <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> kennzeichnen und Menge oder eine Teilmenge der Berechtigungssatz die nicht öffentliche Methoden an des Aufrufers des beschränkt ist zu gewähren davon. (Finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
## <a name="compatible-parameter-types-and-return-type"></a>Kompatible Parameter und Rückgabetypen  
 Die Parameter und Rückgabetypen eines Delegaten müssen mit den Parametertypen und den Rückgabetyp der Methode, die den Delegaten dargestellt kompatibel sein. die Typen müssen nicht genau übereinstimmen.  
  
> [!NOTE]
>  In .NET Framework, Version 1.0 und 1.1 müssen die Typen exakt übereinstimmen.  
  
 Ein Parameter eines Delegaten ist mit dem entsprechenden Parameter einer Methode kompatibel, wenn der Typ des Delegatenparameters restriktiver ist als der Methodenparameter, da so gewährleistet ist, dass ein an den Delegaten übergebenes Argument problemlos an die Methode weitergeleitet werden kann.  
  
 Ebenso ist der Rückgabetyp eines Delegaten kompatibel mit dem Rückgabetyp einer Methode, wenn der Rückgabetyp der Methode restriktiver ist als der Rückgabetyp des Delegaten, da so gewährleistet ist, dass der Rückgabewert der Methode problemlos in den Rückgabetyp des Delegaten umgewandelt werden kann.  
  
 Angenommen, ein Delegat mit einem Parameter vom Typ <xref:System.Collections.Hashtable> und dem Rückgabetyp der <xref:System.Object> kann eine Methode mit einem Parameter des Typs darstellen <xref:System.Object> sowie einen Rückgabewert vom Typ <xref:System.Collections.Hashtable>.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Bestimmen die Methoden kann ein Delegat darstellen.  
 Eine weitere nützliche Methode, die Flexibilität, die von dieser Überladung der bereitgestellten betrachten <xref:System.Delegate.CreateDelegate%2A> besteht darin, dass jeder angegebene Delegat vier verschiedene Kombinationen der Methodensignatur und Methodenart (statisch oder Instanz) darstellen kann. Betrachten Sie einen Delegattyp `D` mit einem Argument des Typs `C`. Im folgenden wird beschrieben, die Methoden `D` darstellen kann, wird den Rückgabetyp wird ignoriert, da es in allen Fällen entsprechen muss:  
  
-   `D` kann Instanzmethode, die genau ein Argument des Typs darstellen `C`, unabhängig davon, welchen Typ die Instanzmethode gehört. Wenn <xref:System.Delegate.CreateDelegate%2A> aufgerufen wird, `firstArgument` ist eine Instanz des Typs `method` angehört, und der resultierende Delegat wird gesagt, über diese Instanz geschlossen werden. (Im Grunde `D` kann auch über ein null-Verweis geschlossen werden, wenn `firstArgument` ist `null`.)  
  
-   `D` kann eine Instanzmethode darstellen `C` , die keine Argumente verfügt. Wenn <xref:System.Delegate.CreateDelegate%2A> aufgerufen wird, `firstArgument` ist ein null-Verweis. Der resultierende Delegat stellt eine offene Instanz-Methode und eine Instanz von `C` müssen angegeben werden, bei jedem Aufruf erfolgte.  
  
-   `D` kann eine statische Methode, die ein des Typs Argument darstellen `C`, und dass die Methode in einen beliebigen Typ angehören kann. Wenn <xref:System.Delegate.CreateDelegate%2A> aufgerufen wird, `firstArgument` ist ein null-Verweis. Der resultierende Delegat stellt eine offene statische Methode und einer Instanz von `C` müssen angegeben werden, bei jedem Aufruf erfolgte.  
  
-   `D` können eine statische Methode darstellen, die zum Typ gehört `F` und verfügt über zwei Argumente des Typs `F` und `C`. Wenn <xref:System.Delegate.CreateDelegate%2A> aufgerufen wird, `firstArgument` ist eine Instanz der `F`. Der resultierende Delegat stellt eine statische Methode, die über diese Instanz geschlossen ist `F`. Beachten Sie, dass im Fall, in denen `F` und `C` denselben Typ aufweisen, die statische Methode verfügt über zwei Argumente des Typs. (In diesem Fall `D` wird über einen null-Verweis geschlossen, wenn `firstArgument` ist `null`.)  
  
   
  
## Examples  
 Dieser Abschnitt enthält drei Codebeispiele aufgeführt. Das erste Beispiel veranschaulicht die vier Arten von Delegaten, die erstellt werden können: über eine Instanzmethode, öffnen Sie über eine Instanzmethode, öffnen Sie über eine statische Methode geschlossen und über eine statische Methode geschlossen.  
  
 Im zweiten Codebeispiel wird veranschaulicht, kompatible Parametertypen und Rückgabetypen.  
  
 Im dritten Codebeispiel wird einen einzelner Delegattyp definiert, und zeigt, dass alle Methoden, die den Delegattyp darstellen können.  
  
 **Beispiel 1**  
  
 Im folgenden Codebeispiel wird veranschaulicht, die vier Möglichkeiten, die ein Delegat kann mit dieser Überladung der erstellt werden die <xref:System.Delegate.CreateDelegate%2A> Methode.  
  
> [!NOTE]
>  Es gibt zwei Überladungen der <xref:System.Delegate.CreateDelegate%2A> Methode, die angeben, `firstArgument` und ein <xref:System.Reflection.MethodInfo>; ihre Funktionalität ist identisch, außer dass eine Ihnen die ermöglicht Angabe, ob bei Bindungsfehlern ausgelöst werden, und die andere löst immer eine. Dieses Codebeispiel verwendet beide Überladungen.  
  
 Das Beispiel deklariert eine Klasse `C` mit einer statischen Methode `M2` und eine Instanzmethode `M1`, sowie zwei Delegattypen: `D1` akzeptiert eine Instanz von `C` und eine Zeichenfolge, `D2` akzeptiert eine Zeichenfolge und `D3`verfügt über keine Argumente.  
  
 Eine zweite Klasse namens `Example` enthält den Code, der den Delegaten erstellt.  
  
-   Ein Delegat vom Typ `D2`, geschlossen für eine Instanz von `C`, wird für die Instanzmethode erstellt `M1`. Er wird aufgerufen, mit anderen Zeichenfolgen, um anzugeben, dass die gebundene Instanz von `C` wird immer verwendet.  
  
-   Ein Delegat vom Typ `D1`, der eine offene Instanzmethode darstellt, wird für die Instanzmethode erstellt `M1`. Eine Instanz muss übergeben werden, wenn der Delegat aufgerufen wird.  
  
-   Ein Delegat vom Typ `D2`, eine offene statische Methode darstellt, wird für die statische Methode erstellt `M2`.  
  
-   Schließlich einen Delegaten vom Typ `D3`, über eine Zeichenfolge geschlossen, wird für die statische Methode erstellt `M2`. Die Methode wird aufgerufen, um anzugeben, dass sie die gebundene Zeichenfolge verwendet wird.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Beispiel 2**  
  
 Im folgenden Codebeispiel wird veranschaulicht, die Kompatibilität der Parametertypen und Rückgabetypen.  
  
> [!NOTE]
>  Dieses Codebeispiel verwendet die <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> -methodenüberladung. Die Verwendung der anderen Überladungen dieser <xref:System.Reflection.MethodInfo> ist ähnlich.  
  
 Das Codebeispiel definiert eine Basisklasse, die mit dem Namen `Base` und eine Klasse namens `Derived` abgeleitet, die `Base`. Die abgeleitete Klasse verfügt über eine `static` (`Shared` in Visual Basic) Methode, die mit dem Namen `MyMethod` mit einem Parameter vom Typ `Base` und dem Rückgabetyp der `Derived`. Im Codebeispiel wird definiert auch einen Delegaten, der mit dem Namen `Example` , die einen Parameter vom Typ hat `Derived` und dem Rückgabetyp der `Base`.  
  
 Im Codebeispiel wird veranschaulicht, dass der Delegat, mit dem Namen `Example` können verwendet werden, um die Methode darstellen `MyMethod`. Die Methode kann an den Delegaten gebunden werden, da:  
  
-   Der Parametertyp des Delegaten (`Derived`) ist stärker eingeschränkt als der Parametertyp des `MyMethod` (`Base`), sodass es immer sicher an das Argument des Delegaten zu übergeben sind `MyMethod`.  
  
-   Der Rückgabetyp der `MyMethod` (`Derived`) ist stärker eingeschränkt als der Parametertyp des Delegaten (`Base`), sodass sie immer sicher, das den Rückgabetyp der Methode, die den Rückgabetyp des Delegaten umgewandelt werden kann.  
  
 Im Codebeispiel erzeugt keine Ausgabe.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Beispiel 3**  
  
 Das folgende Codebeispiel zeigt die Methoden, die ein einzelner Delegattyp darstellen kann.  
  
> [!NOTE]
>  Es gibt zwei Überladungen der <xref:System.Delegate.CreateDelegate%2A> Methode, die angeben, `firstArgument` und ein <xref:System.Reflection.MethodInfo>; ihre Funktionalität ist identisch, außer dass eine Ihnen die ermöglicht Angabe, ob bei Bindungsfehlern ausgelöst werden, und die andere löst immer eine. Dieses Codebeispiel verwendet beide Überladungen.  
  
 Im Codebeispiel werden zwei Klassen definiert `C` und `F`, und einen Delegattyp `D` mit einem Argument des Typs `C`. Die Klassen übereinstimmende statische und Instanzenmethoden `M1`, `M3`, und `M4`, und die Klasse `C` verfügt auch über eine Instanzmethode `M2` , die keine Argumente verfügt.  
  
 Eine dritte Klasse namens `Example` enthält den Code, der den Delegaten erstellt.  
  
-   Delegaten werden erstellt, z. B. Methode `M1` des Typs `C` und `F`; jede über eine Instanz des jeweiligen Typs geschlossen wird. Methode `M1` des Typs `C` zeigt die `ID` Eigenschaften der gebundenen Instanz und des Arguments.  
  
-   Ein Delegat erstellt wird, für die Methode `M2` des Typs `C`. Dies ist eine offene Instanz-Delegaten, in dem das Argument des Delegaten ausgeblendete erste Argument für die Instanzmethode darstellt. Die Methode hat keine anderen Argumente.  
  
-   Delegaten werden erstellt, für die statische Methode `M3` des Typs `C` und `F`; Hierbei handelt es sich um open statische Delegaten.  
  
-   Schließlich werden die Delegaten für die statische Methode erstellt `M4` des Typs `C` und `F`; jede Methode verfügt über den deklarierenden Typ als erstes Argument und eine Instanz des Typs angegeben wird, damit die Delegaten über dem ersten Argument geschlossen werden . Methode `M4` des Typs `C` zeigt die `ID` Eigenschaften der gebundenen Instanz und des Arguments.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> erbt nicht <see cref="T:System.MulticastDelegate" />.  
  
- oder - 
 <paramref name="type" /> ist keine <see langword="RuntimeType" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- oder - 
 <paramref name="method" /> kann nicht gebunden werden, und <paramref name="throwOnBindFailure" /> ist <see langword="true" />.  
  
- oder - 
 <paramref name="method" /> ist keine <see langword="RuntimeMethodInfo" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">Die <see langword="Invoke" />-Methode von <paramref name="type" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Der <see cref="T:System.Type" /> des zu erstellenden Delegaten.</param>
        <param name="target">Die Klasseninstanz, für die <paramref name="method" /> aufgerufen wird.</param>
        <param name="method">Der Name der Instanzenmethode, die durch den Delegaten dargestellt werden soll.</param>
        <param name="ignoreCase">Ein boolescher Wert, der angibt, ob die Groß- und Kleinschreibung beim Vergleichen des Methodennamens berücksichtigt werden soll.</param>
        <summary>Erstellt einen Delegaten vom angegebenen Typ, der die angegebene Instanzenmethode darstellt, die für die angegebene Klasseninstanz aufgerufen werden soll, wobei die Groß- und Kleinschreibung den Angaben entsprechend berücksichtigt bzw. nicht berücksichtigt wird.</summary>
        <returns>Ein Delegat vom angegebenen Typ, der die angegebene Instanzenmethode darstellt, die für die angegebene Klasseninstanz aufgerufen werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt nur Delegaten für die Instanz. Eine Instanzmethode handelt es sich um eine Methode, die eine Instanz einer Klasse zugeordnet ist; eine statische Methode handelt es sich um eine Methode, die die Klasse selbst zugeordnet ist.  
  
 Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> -methodenüberladung angeben `true` für `throwOnBindFailure`.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, um nicht öffentliche Methoden zugreifen, wenn der Aufrufer erteilt wurde <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> kennzeichnen und Menge oder eine Teilmenge der Berechtigungssatz die nicht öffentliche Methoden an des Aufrufers des beschränkt ist zu gewähren davon. (Finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="target" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> erbt nicht <see cref="T:System.MulticastDelegate" />.  
  
- oder - 
 <paramref name="type" /> ist keine <see langword="RuntimeType" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- oder - 
 <paramref name="method" /> ist keine Instanzenmethode.  
  
- oder - 
 <paramref name="method" /> kann nicht gebunden werden, z. B. weil sie nicht gefunden wurde.</exception>
        <exception cref="T:System.MissingMethodException">Die <see langword="Invoke" />-Methode von <paramref name="type" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Der <see cref="T:System.Type" /> des zu erstellenden Delegaten.</param>
        <param name="target">Der <see cref="T:System.Type" />, der die Klasse darstellt, die von <paramref name="method" /> implementiert wird.</param>
        <param name="method">Der Name der statischen Methode, die durch den Delegaten dargestellt werden soll.</param>
        <param name="ignoreCase">Ein boolescher Wert, der angibt, ob die Groß- und Kleinschreibung beim Vergleichen des Methodennamens berücksichtigt werden soll.</param>
        <summary>Erstellt einen Delegaten vom angegebenen Typ, der die angegebene statische Methode der angegebenen Klasse mit der angegebenen Berücksichtigung von Groß- und Kleinschreibung darstellt.</summary>
        <returns>Ein Delegat vom angegebenen Typ, der die angegebene statische Methode der angegebenen Klasse darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt die Delegaten für die nur statische Methoden. Eine Instanzmethode handelt es sich um eine Methode, die eine Instanz einer Klasse zugeordnet ist; eine statische Methode handelt es sich um eine Methode, die die Klasse selbst zugeordnet ist.  
  
 Überladung dieser Methode entspricht dem Aufrufen der <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> -methodenüberladung angeben `true` für `throwOnBindFailure`.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, um nicht öffentliche Methoden zugreifen, wenn der Aufrufer erteilt wurde <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> kennzeichnen und Menge oder eine Teilmenge der Berechtigungssatz die nicht öffentliche Methoden an des Aufrufers des beschränkt ist zu gewähren davon. (Finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="target" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> erbt nicht <see cref="T:System.MulticastDelegate" />.  
  
- oder - 
 <paramref name="type" /> ist keine <see langword="RuntimeType" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- oder - 
 <paramref name="target" /> ist keine <see langword="RuntimeType" />.  
  
- oder - 
 <paramref name="target" /> ist ein offener generischer Typ. Das bedeutet, die <see cref="P:System.Type.ContainsGenericParameters" />-Eigenschaft ist <see langword="true" />.  
  
- oder - 
 <paramref name="method" /> ist keine <see langword="static" />-Methode (<see langword="Shared" />-Methode in Visual Basic).  
  
- oder - 
 <paramref name="method" /> kann nicht gebunden werden, z. B. weil sie nicht gefunden wurde.</exception>
        <exception cref="T:System.MissingMethodException">Die <see langword="Invoke" />-Methode von <paramref name="type" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="target" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Der <see cref="T:System.Type" /> des zu erstellenden Delegaten.</param>
        <param name="target">Die Klasseninstanz, für die <paramref name="method" /> aufgerufen wird.</param>
        <param name="method">Der Name der Instanzenmethode, die durch den Delegaten dargestellt werden soll.</param>
        <param name="ignoreCase">Ein boolescher Wert, der angibt, ob die Groß- und Kleinschreibung beim Vergleichen des Methodennamens berücksichtigt werden soll.</param>
        <param name="throwOnBindFailure"><see langword="true" />, um eine Ausnahme auszulösen, wenn <paramref name="method" /> nicht gebunden werden kann, andernfalls <see langword="false" />.</param>
        <summary>Erstellt einen Delegaten vom angegebenen Typ, der die angegebene Instanzenmethode darstellt, die für die angegebene Klasseninstanz aufgerufen werden soll, wobei die Groß- und Kleinschreibung und das Verhalten bei Bindungsfehlern den Angaben entsprechend berücksichtigt bzw. nicht berücksichtigt wird.</summary>
        <returns>Ein Delegat vom angegebenen Typ, der die angegebene Instanzenmethode darstellt, die für die angegebene Klasseninstanz aufgerufen werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt nur Delegaten für die Instanz. Eine Instanzmethode handelt es sich um eine Methode, die eine Instanz einer Klasse zugeordnet ist; eine statische Methode handelt es sich um eine Methode, die die Klasse selbst zugeordnet ist.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, um nicht öffentliche Methoden zugreifen, wenn der Aufrufer erteilt wurde <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> kennzeichnen und Menge oder eine Teilmenge der Berechtigungssatz die nicht öffentliche Methoden an des Aufrufers des beschränkt ist zu gewähren davon. (Finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="target" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> erbt nicht <see cref="T:System.MulticastDelegate" />.  
  
- oder - 
 <paramref name="type" /> ist keine <see langword="RuntimeType" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- oder - 
 <paramref name="method" /> ist keine Instanzenmethode.  
  
- oder - 
 <paramref name="method" /> kann nicht gebunden werden, z. B. weil sie nicht gefunden wurde, und <paramref name="throwOnBindFailure" /> ist gleich <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">Die <see langword="Invoke" />-Methode von <paramref name="type" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="target" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="method" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Der <see cref="T:System.Type" /> des zu erstellenden Delegaten.</param>
        <param name="target">Der <see cref="T:System.Type" />, der die Klasse darstellt, die von <paramref name="method" /> implementiert wird.</param>
        <param name="method">Der Name der statischen Methode, die durch den Delegaten dargestellt werden soll.</param>
        <param name="ignoreCase">Ein boolescher Wert, der angibt, ob die Groß- und Kleinschreibung beim Vergleichen des Methodennamens berücksichtigt werden soll.</param>
        <param name="throwOnBindFailure"><see langword="true" />, um eine Ausnahme auszulösen, wenn <paramref name="method" /> nicht gebunden werden kann, andernfalls <see langword="false" />.</param>
        <summary>Erstellt einen Delegaten vom angegebenen Typ, der die angegebene statische Methode der angegebenen Klasse darstellt, wobei die Groß- und Kleinschreibung und das Verhalten bei Bindungsfehlern den Angaben entsprechend berücksichtigt bzw. nicht berücksichtigt wird.</summary>
        <returns>Ein Delegat vom angegebenen Typ, der die angegebene statische Methode der angegebenen Klasse darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode erstellt die Delegaten für die nur statische Methoden. Eine Instanzmethode handelt es sich um eine Methode, die eine Instanz einer Klasse zugeordnet ist; eine statische Methode handelt es sich um eine Methode, die die Klasse selbst zugeordnet ist.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, um nicht öffentliche Methoden zugreifen, wenn der Aufrufer erteilt wurde <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> kennzeichnen und Menge oder eine Teilmenge der Berechtigungssatz die nicht öffentliche Methoden an des Aufrufers des beschränkt ist zu gewähren davon. (Finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="type" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="target" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="method" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="type" /> erbt nicht <see cref="T:System.MulticastDelegate" />.  
  
- oder - 
 <paramref name="type" /> ist keine <see langword="RuntimeType" />. Siehe [Laufzeittypen in Reflektion](https://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  
  
- oder - 
 <paramref name="target" /> ist keine <see langword="RuntimeType" />.  
  
- oder - 
 <paramref name="target" /> ist ein offener generischer Typ. Das bedeutet, die <see cref="P:System.Type.ContainsGenericParameters" />-Eigenschaft ist <see langword="true" />.  
  
- oder - 
 <paramref name="method" /> ist keine <see langword="static" />-Methode (<see langword="Shared" />-Methode in Visual Basic).  
  
- oder - 
 <paramref name="method" /> kann nicht gebunden werden, z. B. weil sie nicht gefunden wurde, und <paramref name="throwOnBindFailure" /> ist gleich <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">Die <see langword="Invoke" />-Methode von <paramref name="type" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer verfügt nicht über die erforderlichen Berechtigungen für den Zugriff auf <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.DynamicInvoke : obj[] -&gt; obj" Usage="delegate.DynamicInvoke args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">Ein Array von Objekten, das die Argumente darstellt, die der durch den aktuellen Delegaten dargestellten Methode übergeben werden.  
  
- oder - 
 <see langword="null" />, wenn die durch den aktuellen Delegaten dargestellte Methode keine Argumente erfordert.</param>
        <summary>Ruft die durch den aktuellen Delegaten dargestellte Methode dynamisch (mit später Bindung) auf.</summary>
        <returns>Das Objekt, das von der durch den Delegaten dargestellten Methode zurückgegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft die <xref:System.Delegate.DynamicInvokeImpl%2A>-Methode auf.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Der Aufrufer verfügt nicht über Zugriff auf die Methode, die durch den Delegaten dargestellt wird (wenn die Methode z.B. privat ist).  
  
- oder - 
Anzahl, Reihenfolge oder Typ der in <paramref name="args" /> aufgeführten Parameter ist ungültig.</exception>
        <exception cref="T:System.ArgumentException">Die durch den Delegaten dargestellte Methode wird für ein Objekt oder eine Klasse aufgerufen, die die Methode nicht unterstützt.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Die durch den Delegaten dargestellte Methode ist eine Instanzenmethode, und das Zielobjekt ist <see langword="null" />.  
  
- oder - 
Eine der gekapselten Methoden löst eine Ausnahme aus.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member DynamicInvokeImpl : obj[] -&gt; obj&#xA;override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="delegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="args">Ein Array von Objekten, das die Argumente darstellt, die der durch den aktuellen Delegaten dargestellten Methode übergeben werden.  
  
- oder - 
 <see langword="null" />, wenn die durch den aktuellen Delegaten dargestellte Methode keine Argumente erfordert.</param>
        <summary>Ruft die durch den aktuellen Delegaten dargestellte Methode dynamisch (mit später Bindung) auf.</summary>
        <returns>Das Objekt, das von der durch den Delegaten dargestellten Methode zurückgegeben wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode implementiert die Methode <xref:System.Delegate.DynamicInvoke%2A> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Der Aufrufer verfügt nicht über Zugriff auf die Methode, die durch den Delegaten dargestellt wird (wenn die Methode z.B. privat ist).  
  
- oder - 
Anzahl, Reihenfolge oder Typ der in <paramref name="args" /> aufgeführten Parameter ist ungültig.</exception>
        <exception cref="T:System.ArgumentException">Die durch den Delegaten dargestellte Methode wird für ein Objekt oder eine Klasse aufgerufen, die die Methode nicht unterstützt.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Die durch den Delegaten dargestellte Methode ist eine Instanzenmethode, und das Zielobjekt ist <see langword="null" />.  
  
- oder - 
Eine der gekapselten Methoden löst eine Ausnahme aus.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="delegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das Objekt, das mit dem aktuellen Delegaten verglichen werden soll.</param>
        <summary>Bestimmt, ob das angegebene Objekt und der aktuelle Delegat vom gleichen Typ sind und die gleichen Ziele, Methoden und Aufruflisten besitzen.</summary>
        <returns><see langword="true" />, wenn <paramref name="obj" /> und der aktuelle Delegat die gleichen Ziele, Methoden und Aufruflisten aufweisen; andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die zwei Delegaten nicht vom gleichen Typ sind, sind sie nicht als gleich betrachtet.  
  
> [!IMPORTANT]
>  In .NET Framework, Version 1.0 und 1.1 wurden zwei Delegaten als gleich betrachtet, wenn ihre Ziele, Methoden und Aufruflisten gleich sind, selbst wenn die Delegaten mit unterschiedlichen Typen sind.  
  
 Die Methoden und Ziele werden wie folgt auf Gleichheit verglichen:  
  
-   Wenn die beiden Methoden, die zu vergleichenden beide statisch sind und die gleiche Methode für die gleiche Klasse, die Methoden werden als gleich betrachtet, und die Ziele auch als gleich betrachtet werden.  
  
-   Wenn die beiden Methoden, die zu vergleichenden Instanzmethoden sind und die gleiche Methode für das gleiche Objekt, die Methoden werden als gleich betrachtet, und die Ziele auch als gleich betrachtet werden.  
  
-   Andernfalls Methoden gelten als nicht gleich sind und die Ziele sind auch nicht als gleich.  
  
 Zwei Aufruflisten, als identisch betrachtet, nur, wenn sie die gleiche Reihenfolge aufweisen, und die entsprechenden Elemente aus den beiden Listen, die gleiche Methode und Ziel darstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Der Aufrufer verfügt nicht über Zugriff auf die Methode, die durch den Delegaten dargestellt wird (wenn die Methode z.B. privat ist).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="delegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Hashcode für den Delegaten zurück.</summary>
        <returns>Ein Hashcode für den Delegaten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Rückgabewert dieser Methode darf nicht zwei Gründen beibehalten werden. Zunächst kann die Hash-Funktion, einer Klasse geändert werden, zur besseren Verteilung, Rendern alle Werte aus der alten Hashfunktion nutzlos. Andererseits unbedingt die Standardimplementierung dieser Klasse nicht der gleiche Wert von verschiedenen Instanzen zurückgegeben werden.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="abstract member GetInvocationList : unit -&gt; Delegate[]&#xA;override this.GetInvocationList : unit -&gt; Delegate[]" Usage="delegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Aufrufliste des Delegaten zurück.</summary>
        <returns>Ein Array von Delegaten, das die Aufrufliste des aktuellen Delegaten darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder Delegat im Array stellt genau eine Methode dar.  
  
 Die Reihenfolge der Delegaten im Array ist der gleichen Reihenfolge, in der der aktuelle Delegat die Methoden aufruft, die diesen Delegaten darstellen.  
  
   
  
## Examples  
 Das folgende Beispiel weist drei Methoden auf einen Delegaten an. Es ruft dann die <xref:System.Delegate.GetInvocationList%2A> -Methode zum Abrufen die Gesamtzahl der die Methoden, die an den Delegaten zugewiesen wird, um die Delegaten in umgekehrter Reihenfolge ausgeführt und führen Sie die Methoden, deren Namen enthalten nicht die Teilzeichenfolge "File".  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="delegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die statische Methode ab, die durch den aktuellen Delegaten dargestellt wird.</summary>
        <returns>Eine <see cref="T:System.Reflection.MethodInfo" />, die die durch den aktuellen Delegaten dargestellte statische Methode beschreibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gilt nur, wenn der aktuelle Delegat eine statische Methode darstellt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Der Aufrufer verfügt nicht über Zugriff auf die Methode, die durch den Delegaten dargestellt wird (wenn die Methode z.B. privat ist).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="delegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="info">Wird nicht unterstützt.</param>
        <param name="context">Wird nicht unterstützt.</param>
        <summary>Wird nicht unterstützt.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Diese Methode wird nicht unterstützt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Method : System.Reflection.MethodInfo" Usage="System.Delegate.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Methode ab, die durch den Delegaten dargestellt wird.</summary>
        <value>Eine <see cref="T:System.Reflection.MethodInfo" />, die die durch den Delegaten dargestellte Methode beschreibt.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">Der Aufrufer verfügt nicht über Zugriff auf die Methode, die durch den Delegaten dargestellt wird (wenn die Methode z.B. privat ist).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Delegate * Delegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">Der erste der zu vergleichenden Delegaten.</param>
        <param name="d2">Der zweite der zu vergleichenden Delegaten.</param>
        <summary>Bestimmt, ob die angegebenen Delegaten gleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="d1" /> und <paramref name="d2" /> gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwei Delegaten vom gleichen Typ mit dem gleichen Ziele, Methoden und Aufruflisten enthält, werden als gleich betrachtet werden.  
  
 Wenn die zwei Delegaten nicht vom gleichen Typ sind, sind sie nicht als gleich betrachtet.  
  
> [!IMPORTANT]
>  In .NET Framework, Version 1.0 und 1.1 wurden zwei Delegaten als gleich betrachtet, wenn ihre Ziele, Methoden und Aufruflisten gleich sind, selbst wenn die Delegaten mit unterschiedlichen Typen sind.  
  
 Die Methoden und Ziele werden wie folgt auf Gleichheit verglichen:  
  
-   Wenn die beiden Methoden, die zu vergleichenden beide statisch sind und die gleiche Methode für die gleiche Klasse, die Methoden werden als gleich betrachtet, und die Ziele auch als gleich betrachtet werden.  
  
-   Wenn die beiden Methoden, die zu vergleichenden Instanzmethoden sind und die gleiche Methode für das gleiche Objekt, die Methoden werden als gleich betrachtet, und die Ziele auch als gleich betrachtet werden.  
  
-   Andernfalls Methoden gelten als nicht gleich sind und die Ziele sind auch nicht als gleich.  
  
 Zwei Aufruflisten, als identisch betrachtet, wenn sie die gleiche Reihenfolge aufweisen, und die entsprechenden Elemente aus den beiden Listen, die gleiche Methode und Ziel darstellen.  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Delegate * Delegate -&gt; bool" Usage="System.Delegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">Der erste der zu vergleichenden Delegaten.</param>
        <param name="d2">Der zweite der zu vergleichenden Delegaten.</param>
        <summary>Bestimmt, ob die angegebenen Delegaten ungleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="d1" /> und <paramref name="d2" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zwei Delegaten werden nicht als gleich betrachtet, wenn sie unterschiedliche Typen oder verschiedene Methoden, die verschiedene Ziele oder die Aufruflisten besitzen.  
  
 Wenn die zwei Delegaten nicht vom gleichen Typ sind, sind sie nicht als gleich betrachtet.  
  
> [!IMPORTANT]
>  In .NET Framework, Version 1.0 und 1.1 sind zwei Delegaten als gleich betrachtet, wenn ihre Ziele, Methoden und Aufruflisten gleich sind, selbst wenn die Delegaten mit unterschiedlichen Typen sind.  
  
 Die Methoden und Ziele werden wie folgt auf Gleichheit verglichen:  
  
-   Wenn die beiden Methoden, die zu vergleichenden beide statisch sind und die gleiche Methode für die gleiche Klasse, die Methoden werden als gleich betrachtet, und die Ziele auch als gleich betrachtet werden.  
  
-   Wenn die beiden Methoden, die zu vergleichenden Instanzmethoden sind und die gleiche Methode für das gleiche Objekt, die Methoden werden als gleich betrachtet, und die Ziele auch als gleich betrachtet werden.  
  
-   Andernfalls Methoden gelten als nicht gleich sind und die Ziele sind auch nicht als gleich.  
  
 Zwei Aufruflisten sind nicht gleich, wenn sie unterschiedliche Größen haben, verfügen, wenn sie anders angeordnet sind oder über mindestens ein Element aus einer Liste darstellt, eine Methode oder ein Ziel, das sich durch das entsprechende Element in der anderen Liste dargestellt.  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member Remove : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Remove (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Der Delegat, aus dem die Aufrufliste von <paramref name="value" /> entfernt werden soll.</param>
        <param name="value">Der Delegat, von dem die Aufrufliste stammt, die aus der Aufrufliste von <paramref name="source" /> entfernt werden soll.</param>
        <summary>Entfernt das letzte Vorkommen der Aufrufliste eines Delegaten aus der Aufrufliste eines anderen Delegaten.</summary>
        <returns>Ein neuer Delegat mit einer Aufrufliste, die aus der Aufrufliste von <paramref name="source" /> besteht, aus der das letzte Vorkommen der Aufrufliste von <paramref name="value" /> entfernt wurde, falls sich die Aufrufliste von <paramref name="value" /> in der Aufrufliste von <paramref name="source" /> befand. Gibt <paramref name="source" /> zurück, wenn <paramref name="value" /><see langword="null" /> ist oder die Aufrufliste von <paramref name="value" /> sich nicht innerhalb der Aufrufliste von <paramref name="source" /> befand. Gibt einen NULL-Verweis zurück, wenn die Aufrufliste von <paramref name="value" /> gleich der Aufrufliste von <paramref name="source" /> ist oder <paramref name="source" /> ein NULL-Verweis ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Aufrufliste von `value` entspricht einen zusammenhängenden Satz von Elementen in der Aufrufliste von `source`, klicken Sie dann die Aufrufliste von `value` hört sich innerhalb der Aufrufliste von `source`. Wenn die Aufrufliste von `value` tritt mehr als einmal in der Aufrufliste von `source`, das letzte Vorkommen entfernt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Der Aufrufer verfügt nicht über Zugriff auf die Methode, die durch den Delegaten dargestellt wird (wenn die Methode z.B. privat ist).</exception>
        <exception cref="T:System.ArgumentException">Die Delegattypen stimmen nicht überein.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveAll : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.RemoveAll (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">Der Delegat, aus dem die Aufrufliste von <paramref name="value" /> entfernt werden soll.</param>
        <param name="value">Der Delegat, von dem die Aufrufliste stammt, die aus der Aufrufliste von <paramref name="source" /> entfernt werden soll.</param>
        <summary>Entfernt alle Vorkommen der Aufrufliste eines Delegaten aus der Aufrufliste eines anderen Delegaten.</summary>
        <returns>Ein neuer Delegat mit einer Aufrufliste, die aus der Aufrufliste von <paramref name="source" /> besteht, aus der alle Vorkommen der Aufrufliste von <paramref name="value" /> entfernt wurden, falls sich die Aufrufliste von <paramref name="value" /> in der Aufrufliste von <paramref name="source" /> befand. Gibt <paramref name="source" /> zurück, wenn <paramref name="value" /><see langword="null" /> ist oder die Aufrufliste von <paramref name="value" /> sich nicht innerhalb der Aufrufliste von <paramref name="source" /> befand. Gibt einen NULL-Verweis zurück, wenn die Aufrufliste von <paramref name="value" /> gleich der Aufrufliste von <paramref name="source" /> ist, wenn <paramref name="source" /> nur eine Reihe von Aufruflisten enthält, die gleich der Aufrufliste von <paramref name="value" /> sind, oder <paramref name="source" /> ein NULL-Verweis ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Aufrufliste von `value` entspricht einen zusammenhängenden Satz von Elementen in der Aufrufliste von `source`, klicken Sie dann die Aufrufliste von `value` hört sich innerhalb der Aufrufliste von `source`. Wenn die Aufrufliste von `value` tritt mehr als einmal in der Aufrufliste von `source`, alle Vorkommen werden entfernt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Der Aufrufer verfügt nicht über Zugriff auf die Methode, die durch den Delegaten dargestellt wird (wenn die Methode z.B. privat ist).</exception>
        <exception cref="T:System.ArgumentException">Die Delegattypen stimmen nicht überein.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member RemoveImpl : Delegate -&gt; Delegate&#xA;override this.RemoveImpl : Delegate -&gt; Delegate" Usage="delegate.RemoveImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="d">Der Delegat, von dem die Aufrufliste stammt, die aus der Aufrufliste des aktuellen Delegaten entfernt werden soll.</param>
        <summary>Entfernt die Aufrufliste eines Delegaten aus der Aufrufliste eines anderen Delegaten.</summary>
        <returns>Ein neuer Delegat mit einer Aufrufliste, die aus der Aufrufliste des aktuellen Delegaten besteht, aus der die Aufrufliste von <paramref name="value" /> entfernt wurde, falls sich die Aufrufliste von <paramref name="value" /> in der Aufrufliste des aktuellen Delegaten befand. Gibt den aktuellen Delegaten zurück, wenn <paramref name="value" /><see langword="null" /> ist oder wenn die Aufrufliste von <paramref name="value" /> nicht innerhalb der Aufrufliste des aktuellen Delegaten gefunden wurde. Gibt <see langword="null" /> zurück, wenn die Aufrufliste von <paramref name="value" /> gleich der Aufrufliste des aktuellen Delegaten ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Aufrufliste von `value` entspricht einen zusammenhängenden Satz von Elementen in der Aufrufliste des aktuellen Delegaten, und klicken Sie dann auf die Aufrufliste von `value` gilt als in der Aufrufliste des aktuellen Delegaten auftreten. Wenn die Aufrufliste von `value` tritt auf, mehr als einmal in der Aufrufliste des aktuellen Delegaten, das letzte Vorkommen entfernt wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Der Aufrufer verfügt nicht über Zugriff auf die Methode, die durch den Delegaten dargestellt wird (wenn die Methode z.B. privat ist).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target : obj" Usage="System.Delegate.Target" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Klasseninstanz ab, für die der aktuelle Delegat die Instanzenmethode aufruft.</summary>
        <value>Das Objekt, für das der aktuelle Delegat die Instanzmethode aufruft, wenn der Delegat eine Instanzmethode darstellt, <see langword="null" />, wenn der Delegat eine statische Methode darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Instanzmethode handelt es sich um eine Methode, die eine Instanz einer Klasse zugeordnet ist; eine statische Methode handelt es sich um eine Methode, die die Klasse selbst zugeordnet ist.  
  
 Wenn der Delegat eine oder mehrere Instanzmethoden aufgerufen wird, gibt diese Eigenschaft das Ziel der letzten Instanzenmethode in der Aufrufliste an.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Beim Aufruf spät gebundene durch Mechanismen wie z. B. <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>