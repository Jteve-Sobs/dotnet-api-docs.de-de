<Type Name="AppDomain" FullName="System.AppDomain">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d3cc03d2b251007a09fa2c78bb363cc33a277f8d" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52244810" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.AppDomain" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomain&#xA;Inherits MarshalByRefObject&#xA;Implements _AppDomain, IEvidenceFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomain sealed : MarshalByRefObject, _AppDomain, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type AppDomain = class&#xA;    inherit MarshalByRefObject&#xA;    interface _AppDomain&#xA;    interface IEvidenceFactory" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Anwendungsdomäne dar. Dies ist eine isolierte Umgebung, in der Programme ausgeführt werden. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anwendungsdomänen, die durch dargestellt werden <xref:System.AppDomain> Objekte bieten Isolierung, entladen und Sicherheit von Grenzen für die Ausführung von verwaltetem Code.  
  
-   Verwenden Sie Anwendungsdomänen, um Aufgaben zu isolieren, die Sie einen Prozess dazu führen kann. Wenn der Status der der <xref:System.AppDomain> , die eine Aufgabe ausgeführt wird instabil ist, wird die <xref:System.AppDomain> können ohne Auswirkungen auf den Prozess entladen werden. Dies ist wichtig, wenn ein Prozess ohne Neustart über längere Zeiträume ausgeführt werden muss. Sie können auch Anwendungsdomänen verwenden, um Aufgaben zu isolieren, die keine Daten gemeinsam verwenden sollten.  
  
-   Wenn eine Assembly in der Standardanwendungsdomäne geladen wird, kann nicht werden aus dem Arbeitsspeicher entladen, während der Prozess ausgeführt wird. Wenn Sie eine zweite Anwendungsdomäne zum Laden und Ausführen der Assemblys zu öffnen, ist jedoch die Assembly entladen Wenn dieser Anwendungsdomäne entladen wird. Verwenden Sie dieses Verfahren, um das Workingset der lang andauernde Prozesse zu minimieren, die gelegentlich große DLLs verwenden.  
  
 In einem einzelnen Prozess können mehrere Anwendungsdomänen ausgeführt; Es ist jedoch keine eindeutige Korrelation zwischen Anwendungsdomänen und Threads. Mehrere Threads können zu einer einzelnen Anwendungsdomäne gehören, und zwar ein bestimmter Thread nicht auf einer einzelnen Anwendungsdomäne,, an einem beliebigen Zeitpunkt beschränkt ist ein Thread ausgeführt wird, in einer einzelnen Anwendungsdomäne.  
  
 Anwendungsdomänen werden erstellt, mit der <xref:System.AppDomain.CreateDomain%2A> Methode. <xref:System.AppDomain> Instanzen werden verwendet, um das Laden und Ausführen von Assemblys (<xref:System.Reflection.Assembly>). Wenn ein <xref:System.AppDomain> ist nicht mehr verwendet wird, kann Sie entladen werden.  
  
 Die <xref:System.AppDomain> -Klasse implementiert eine Reihe von Ereignissen, mit denen Anwendungen reagieren, wenn eine Assembly geladen wird, wenn eine Anwendungsdomäne entladen werden, oder wenn eine nicht behandelte Ausnahme ausgelöst wird.  
  
 Weitere Informationen zur Verwendung von Anwendungsdomänen finden Sie unter [Anwendungsdomänen](~/docs/framework/app-domains/application-domains.md).  
  
 Diese Klasse implementiert die <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, und <xref:System.Security.IEvidenceFactory> Schnittstellen.  
  
 Erstellen Sie einen remotefähigen Wrapper für ein <xref:System.AppDomain> Objekt. Auf diese Weise konnte einen Remoteverweis auf, die veröffentlicht <xref:System.AppDomain>, Verfügbarmachen von Methoden wie z. B. <xref:System.AppDomain.CreateInstance%2A> Remotezugriff und effektiv auf die Codezugriffssicherheit, zerstören <xref:System.AppDomain>. Böswillige Clients, die Verbindung mit dem Remote <xref:System.AppDomain> konnte erhalten Zugriff auf jede Ressource die <xref:System.AppDomain> selbst Zugriff hat. Erstellen nicht remotefähigen-Wrapper für jeden Typ, der erweitert <xref:System.MarshalByRefObject> implementiert Methoden, die von böswillige Clients verwendet werden können, um das Sicherheitssystem zu umgehen.  
  
> [!CAUTION]
>  Der Standardwert für die <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType> Eigenschaft `false`. Diese Einstellung ist für Dienste nicht sicher. Legen Sie diese Eigenschaft auf, um zu verhindern, dass Dienste teilweise vertrauenswürdigen Code herunterladen, `true`.  
  
   
  
## Examples  
 In diesem Beispiel wird gezeigt, wie zum Erstellen eines neuen <xref:System.AppDomain>, instanziieren Sie einen Typ in, neue <xref:System.AppDomain>, und die Kommunikation mit dem Objekt dieses Typs. Dieses Beispiel zeigt außerdem das Entladen der <xref:System.AppDomain> verursacht das Objekt, das Garbage Collection bereinigt werden.  
  
 [!code-cpp[AppDomainX#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainX/cpp/AppDomainX.cpp#1)]
 [!code-csharp[AppDomainX#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainX/cs/AppDomainX.cs#1)]
 [!code-vb[AppDomainX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainX/VB/AppDomainX.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07ea8438-7a34-49f0-a7e8-3d6ff7e4a482">Gewusst wie: Konfigurieren einer Anwendungsdomäne</related>
    <related type="Article" href="https://msdn.microsoft.com/library/ba1fa43e-49f5-47d9-bd7f-3024af16f4ba">Gewusst wie: Erstellen einer Anwendungsdomäne</related>
    <related type="Article" href="https://msdn.microsoft.com/library/1432aa2d-bd83-4346-bf3b-a1b7920e2aa9">Gewusst wie: Laden von Assemblys in eine Anwendungsdomäne</related>
    <related type="Article" href="https://msdn.microsoft.com/library/f356116d-e415-4f7c-a332-6e6a60227192">Gewusst wie: Entladen einer Anwendungsdomäne</related>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ActivationContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationContext As ActivationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ActivationContext ^ ActivationContext { ActivationContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActivationContext : ActivationContext" Usage="System.AppDomain.ActivationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Aktivierungskontext für die aktuelle Anwendungsdomäne ab.</summary>
        <value>Ein Objekt, das den Aktivierungskontext für die aktuelle Anwendungsdomäne darstellt, oder <see langword="null" />, wenn die Domäne keinen Aktivierungskontext besitzt.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.AppendPrivatePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendPrivatePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AppendPrivatePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member AppendPrivatePath : string -&gt; unit&#xA;override this.AppendPrivatePath : string -&gt; unit" Usage="appDomain.AppendPrivatePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.AppendPrivatePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Name des Verzeichnisses, das an den privaten Pfad angefügt werden soll.</param>
        <summary>Fügt den angegebenen Verzeichnisnamen an die Liste der privaten Pfade an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Verwendung dieser Eigenschaft wird nicht empfohlen, da es den Suchpfad für Assemblys ändern kann, nachdem sie bereits geladen wurden. Verwenden Sie stattdessen die <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>-Eigenschaft.  
  
 Die privaten Pfad oder relativen Suchpfads, ist der Pfad relativ zum des Basisverzeichnisses, in dem der Assemblyresolver nach privaten Assemblys Prüfpunkten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationIdentity As ApplicationIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ApplicationIdentity ^ ApplicationIdentity { ApplicationIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationIdentity : ApplicationIdentity" Usage="System.AppDomain.ApplicationIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Identität der Anwendung in der Anwendungsdomäne ab.</summary>
        <value>Ein Objekt, das die Anwendung in der Anwendungsdomäne identifiziert.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust" Usage="System.AppDomain.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Informationen ab, die die einer Anwendung gewährten Berechtigungen beschreiben und ob die Anwendung eine Vertrauensebene besitzt, die eine Ausführung zulässt.</summary>
        <value>Ein Objekt, das Informationen über Berechtigungen und Vertrauenswürdigkeit für die Anwendung in der Anwendungsdomäne kapselt.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ApplyPolicy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyPolicy (assemblyName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyPolicy(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ApplyPolicy : string -&gt; string" Usage="appDomain.ApplyPolicy assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Assemblyanzeigename in der von der <see cref="P:System.Reflection.Assembly.FullName" />-Eigenschaft bereitgestellten Form.</param>
        <summary>Gibt den Assemblyanzeigenamen nach dem Anwenden der Richtlinien zurück.</summary>
        <returns>Eine Zeichenfolge, die den Assemblyanzeigenamen nach dem Anwenden der Richtlinien enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.AppDomain.ApplyPolicy%2A> -Methode akzeptiert einen Anzeigenamen und gibt den Anzeigenamen nach der Richtlinie. Dies ist nützlich, wenn Sie eine Assembly mit der Richtlinie geladen werden, da es sich bei der ReflectionOnly Kontext keine Richtlinien angewendet werden müssen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyLoad As AssemblyLoadEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event AssemblyLoadEventHandler ^ AssemblyLoad;" />
      <MemberSignature Language="F#" Value="member this.AssemblyLoad : AssemblyLoadEventHandler " Usage="member this.AssemblyLoad : System.AssemblyLoadEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyLoad</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt beim Laden einer Assembly ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.AssemblyLoadEventHandler> Delegat für dieses Ereignis gibt an, welche Assembly geladen wurde.  
  
 Um einen Ereignishandler für dieses Ereignis zu registrieren, benötigen Sie die erforderlichen Berechtigungen, oder ein <xref:System.Security.SecurityException> ausgelöst.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.AppDomain.AssemblyLoad> Ereignis.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen angeben. Informationen dazu, wie Sie den vollqualifizierten Assemblynamen abzurufen, finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_AssemblyLoad#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CPP/assemblyload.cpp#1)]
 [!code-csharp[AppDomain_AssemblyLoad#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CS/assemblyload.cs#1)]
 [!code-vb[AppDomain_AssemblyLoad#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_AssemblyLoad/VB/assemblyload.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ AssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.AssemblyResolve : ResolveEventHandler " Usage="member this.AssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die Auflösung einer Assembly fehlschlägt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es ist Aufgabe des der <xref:System.ResolveEventHandler> für dieses Ereignis, die Assembly zurückzugeben, die angegeben wird die <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> -Eigenschaft oder null zurück, wenn die Assembly nicht erkannt wird. Die Assembly muss in einem Ausführungskontext geladen werden; Wenn sie in den ReflectionOnly-Kontext geladen wurde, schlägt fehl die Last, die aufgrund dieses Ereignis ausgelöst werden soll.  
  
 Anleitungen für die Verwendung dieses Ereignisses finden Sie unter [Laden von Assemblys Lösen von](~/docs/framework/app-domains/resolve-assembly-loads.md).  
  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> Eigenschaft gibt die Assembly, die das Laden der Assembly angefordert, die nicht aufgelöst werden konnte. Das Ladeprogramm möglicherweise z. B. keine Abhängigkeit von die angeforderte Assembly geladen werden, da die angeforderte Assembly und die dazugehörige Abhängigkeit nicht in den Suchpfad befinden. Zu wissen, die Identität der anfordernden Assembly kann nützlich bei der Suche nach der Abhängigkeit oder identifizieren Sie die richtige Version sein, wenn mehr als eine Version der Abhängigkeit verfügbar ist. Weitere Informationen finden Sie unter <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
> [!IMPORTANT]
>  Beginnend mit der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], <xref:System.ResolveEventHandler> Ereignis wird ausgelöst, für alle Assemblys, einschließlich der Assemblys. In früheren Versionen war das Ereignis nicht Ressourcenassemblys ausgelöst. Wenn das Betriebssystem lokalisiert ist, der Handler kann mehrmals aufgerufen werden: einmal für jede Kultur in der Kette der fallback.  
  
 Bei diesem Ereignis die <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> Eigenschaft gibt den Assemblynamen aus, bevor die Richtlinie angewendet wird.  
  
> [!IMPORTANT]
>  Wenn mehr als ein Ereignishandler für dieses Ereignis registriert ist, das Ereignis Handlersarecalled in der Reihenfolge, bis ein Ereignishandler einen Wert zurückgibt, die nicht `null`. Nachfolgende Ereignishandler werden ignoriert.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.AppDomain.AssemblyResolve> Ereignis.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen angeben. Informationen dazu, wie Sie den vollqualifizierten Assemblynamen abzurufen, finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AssemblyResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyResolve/CPP/assemblyresolve.cpp#1)]
 [!code-csharp[AssemblyResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyResolve/CS/assemblyresolve.cs#1)]
 [!code-vb[AssemblyResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyResolve/VB/assemblyresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
        <related type="Article" href="https://msdn.microsoft.com/library/5099e549-f4fd-49fb-a290-549edd456c6a">Auflösen beim Laden von Assemblys</related>
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseDirectory : string" Usage="System.AppDomain.BaseDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.BaseDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Basisverzeichnis ab, das der Assemblyresolver für die Suche nach Assemblys verwendet.</summary>
        <value>Das Basisverzeichnis, das der Assemblyresolver für die Suche nach Assemblys verwendet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft entspricht der <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> Eigenschaft. Sie können auch abgerufen werden mithilfe der <xref:System.AppDomain.GetData%2A> Methode mit der Zeichenfolge "ANWENDUNGSBASISVERZEICHNIS".  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine neue Anwendungsdomäne, Angeben eines Basis-Verzeichnisses mit, dass bei der Suche nach Assemblys in die Domäne laden. Anschließend wird die <xref:System.AppDomain.BaseDirectory%2A> Eigenschaft, um den Pfad des Basisverzeichnisses Pfade, für die Anzeige in der Konsole zu erhalten.  
  
 [!code-cpp[ADSetup#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetup/CPP/adsetup.cpp#1)]
 [!code-csharp[ADSetup#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetup/CS/adsetup.cs#1)]
 [!code-vb[ADSetup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetup/VB/adsetup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Informationen im Pfad selbst, sofern der Pfad ist in der Form "file://" oder \\\UNC\dir oder "c:\\". Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="P:System.AppDomainSetup.ApplicationBase" />
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearPrivatePath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearPrivatePath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearPrivatePath();" />
      <MemberSignature Language="F#" Value="abstract member ClearPrivatePath : unit -&gt; unit&#xA;override this.ClearPrivatePath : unit -&gt; unit" Usage="appDomain.ClearPrivatePath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearPrivatePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt den Pfad, der den Speicherort von privaten Assemblys angibt, auf die leere Zeichenfolge ("") zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der private Pfad ist relativ zu das Basisverzeichnis, das die common Language Runtime durchsucht, um private Assemblys zu suchen.  
  
 Weitere Informationen finden Sie unter <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie Sie mit der <xref:System.AppDomain.ClearPrivatePath%2A> Methode entfernen Sie alle Einträge aus der Liste der privaten Pfade zu suchen, wenn Assemblys geladen werden.  
  
 Diese Methode ist mittlerweile veraltet und sollte nicht für Neuentwicklungen verwendet werden.  
  
 [!code-cpp[ADClearPrivatePath#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADClearPrivatePath/CPP/adclearprivatepath.cpp#1)]
 [!code-csharp[ADClearPrivatePath#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADClearPrivatePath/CS/adclearprivatepath.cs#1)]
 [!code-vb[ADClearPrivatePath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADClearPrivatePath/VB/adclearprivatepath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearShadowCopyPath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearShadowCopyPath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearShadowCopyPath();" />
      <MemberSignature Language="F#" Value="abstract member ClearShadowCopyPath : unit -&gt; unit&#xA;override this.ClearShadowCopyPath : unit -&gt; unit" Usage="appDomain.ClearShadowCopyPath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearShadowCopyPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die Liste der Verzeichnisse mit gespiegelten Assemblys auf die leere Zeichenfolge ("") zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Schatten-kopieren-Pfad ist eine Liste von Verzeichnissen, in denen Schattenkopien Assemblys beim Übertragungsvorgang kopiert, werden gespeichert.  
  
 Weitere Informationen finden Sie unter <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> und [Schattenkopien von Assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="F:System.String.Empty" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Erstellen von Schattenkopien von Assemblys</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue Instanz eines angegebenen COM-Typs.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Name einer Datei, die eine Assembly enthält, in der der angeforderte Typ definiert ist.</param>
        <param name="typeName">Der Name des angeforderten Typs.</param>
        <summary>Erstellt eine neue Instanz eines angegebenen COM-Typs. Parameter geben den Namen einer Datei mit einer Assembly an, die den Typ und den Typnamen enthält.</summary>
        <returns>Ein Objekt, das ein Wrapper für die neue Instanz ist, die durch <paramref name="typeName" /> angegeben wird. Der Rückgabewert muss für den Zugriff auf das eigentliche Objekt entwrappt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um Objekte Remote zu erstellen, ohne dass den Typ lokal geladen.  
  
 Der Rückgabewert muss für den Zugriff auf das eigentliche Objekt entwrappt werden.  
  
 Ein <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> Attribut mit einem Wert von `true` müssen entweder explizit oder standardmäßig angewendet werden, die COM-Typ für diese Methode zum Erstellen einer Instanz dieses Typs; anderenfalls <xref:System.TypeLoadException> ausgelöst.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht  
  
 [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CPP/createcominstancefrom.cpp#1)]
 [!code-csharp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CS/createcominstancefrom.cs#1)]
 [!code-vb[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/VB/createcominstancefrom.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> oder <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Der Typ kann nicht geladen werden.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein öffentlicher parameterloser Konstruktor gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" /> ist eine abstrakte Klasse.  
  
- oder -  
Dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> ist eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.NullReferenceException">Das COM-Objekt, auf das verwiesen wird, ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyFile As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyFile, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name einer Datei, die eine Assembly enthält, in der der angeforderte Typ definiert ist.</param>
        <param name="typeName">Der Name des angeforderten Typs.</param>
        <param name="hashValue">Stellt den Wert des errechneten Hashcodes dar.</param>
        <param name="hashAlgorithm">Stellt den vom Assemblymanifest verwendeten Hashalgorithmus dar.</param>
        <summary>Erstellt eine neue Instanz eines angegebenen COM-Typs. Parameter geben den Namen einer Datei mit einer Assembly an, die den Typ und den Typnamen enthält.</summary>
        <returns>Ein Objekt, das ein Wrapper für die neue Instanz ist, die durch <paramref name="typeName" /> angegeben wird. Der Rückgabewert muss für den Zugriff auf das eigentliche Objekt entwrappt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um Objekte Remote zu erstellen, ohne dass den Typ lokal geladen.  
  
 Der Rückgabewert muss für den Zugriff auf das eigentliche Objekt entwrappt werden.  
  
 Ein <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> Attribut mit einem Wert von `true` müssen entweder explizit oder standardmäßig angewendet werden, die COM-Typ für diese Methode zum Erstellen einer Instanz dieses Typs; anderenfalls <xref:System.TypeLoadException> ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> oder <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Der Typ kann nicht geladen werden.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein öffentlicher parameterloser Konstruktor gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" /> ist eine abstrakte Klasse.  
  
- oder -  
Dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> ist die leere Zeichenfolge ("").</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.NullReferenceException">Das COM-Objekt, auf das verwiesen wird, ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDomain">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue Anwendungsdomäne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string -&gt; AppDomain" Usage="System.AppDomain.CreateDomain friendlyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Der angezeigte Name der Domäne.</param>
        <summary>Erstellt eine neue Anwendungsdomäne mit dem angegebenen Namen.</summary>
        <returns>Die neu erstellte Anwendungsdomäne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `friendlyName` -Parameters sollte für die Domäne in einer Weise zu identifizieren, die aussagekräftige Bezeichnung. Diese Zeichenfolge sollte für die Anzeige in Benutzeroberflächen geeignet ist.  
  
 Diese methodenüberladung verwendet die <xref:System.AppDomainSetup> Informationen von der Standardanwendungsdomäne.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht, in der Regel zum Erstellen einer Domäne mithilfe eines der <xref:System.AppDomain.CreateDomain%2A> Überladungen.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Bereitstellen von Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="P:System.AppDomain.FriendlyName" />
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Der angezeigte Name der Domäne. Dieser aussagekräftige Name zur Kennzeichnung der Domäne kann auf Benutzeroberflächen angezeigt werden. Weitere Informationen finden Sie unter <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Ein Beweis für die Identität des Codes, der in der Anwendungsdomäne ausgeführt wird. Übergeben Sie <see langword="null" />, um den Beweis der aktuellen Anwendungsdomäne zu verwenden.</param>
        <summary>Erstellt eine neue Anwendungsdomäne mit dem angegebenen Namen und den bereitgestellten Beweisen.</summary>
        <returns>Die neu erstellte Anwendungsdomäne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese methodenüberladung verwendet die <xref:System.AppDomainSetup> Informationen von der Standardanwendungsdomäne.  
  
 Wenn `securityInfo` ist nicht angegeben wird, wird der Beweis, aus der aktuellen Anwendungsdomäne verwendet.  
  
> [!IMPORTANT]
>  Verwenden Sie die Überladung dieser Methode nicht zum Erstellen von Sandbox-Anwendungsdomänen. Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], der Beweis, der für angegebene `securityInfo` wirkt sich nicht mehr auf den Berechtigungssatz für die Anwendungsdomäne. Verwenden der <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> -methodenüberladung, um die Sandbox-Anwendungsdomänen zu erstellen.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht, in der Regel zum Erstellen einer Domäne mithilfe eines der <xref:System.AppDomain.CreateDomain%2A> Überladungen.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Bereitstellen von Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Der angezeigte Name der Domäne. Dieser aussagekräftige Name zur Kennzeichnung der Domäne kann auf Benutzeroberflächen angezeigt werden. Weitere Informationen finden Sie unter <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Ein Beweis für die Identität des Codes, der in der Anwendungsdomäne ausgeführt wird. Übergeben Sie <see langword="null" />, um den Beweis der aktuellen Anwendungsdomäne zu verwenden.</param>
        <param name="info">Ein Objekt, das Initialisierungsinformationen für die Anwendungsdomäne enthält.</param>
        <summary>Erstellt eine neue Anwendungsdomäne mit dem angegebenen Namen, den angegebenen Beweisen und Anwendungsdomänen-Setupinformationen.</summary>
        <returns>Die neu erstellte Anwendungsdomäne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `info` wird Überladung dieser Methode nicht angegeben wird, verwendet werden. die <xref:System.AppDomainSetup> Informationen von der Standardanwendungsdomäne.  
  
 Wenn `securityInfo` ist nicht angegeben wird, wird der Beweis, aus der aktuellen Anwendungsdomäne verwendet.  
  
> [!IMPORTANT]
>  Verwenden Sie die Überladung dieser Methode nicht zum Erstellen von Sandbox-Anwendungsdomänen. Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], der Beweis, der für angegebene `securityInfo` wirkt sich nicht mehr auf den Berechtigungssatz für die Anwendungsdomäne. Verwenden der <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> -methodenüberladung, um die Sandbox-Anwendungsdomänen zu erstellen.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht, in der Regel zum Erstellen einer Domäne mithilfe eines der <xref:System.AppDomain.CreateDomain%2A> Überladungen.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Bereitstellen von Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, params System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup, grantSet As PermissionSet, ParamArray fullTrustAssemblies As StrongName()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info, System::Security::PermissionSet ^ grantSet, ... cli::array &lt;System::Security::Policy::StrongName ^&gt; ^ fullTrustAssemblies);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup * System.Security.PermissionSet * System.Security.Policy.StrongName[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info, grantSet, fullTrustAssemblies)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="friendlyName">Der angezeigte Name der Domäne. Dieser aussagekräftige Name zur Kennzeichnung der Domäne kann auf Benutzeroberflächen angezeigt werden. Weitere Informationen finden Sie in der Beschreibung von <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Ein Beweis für die Identität des Codes, der in der Anwendungsdomäne ausgeführt wird. Übergeben Sie <see langword="null" />, um den Beweis der aktuellen Anwendungsdomäne zu verwenden.</param>
        <param name="info">Ein Objekt, das Initialisierungsinformationen für die Anwendungsdomäne enthält.</param>
        <param name="grantSet">Ein Standardberechtigungssatz, der allen Assemblys gewährt wird, die in die neue Anwendungsdomäne geladen werden und über keine speziellen Berechtigungen verfügen.</param>
        <param name="fullTrustAssemblies">Ein Array von starken Namen, die Assemblys darstellen und in der neuen Anwendungsdomäne als vollständig vertrauenswürdig betrachtet werden sollen.</param>
        <summary>Erstellt eine neue Anwendungsdomäne mit angegebenem Namen, Beweis, Anwendungsdomänen-Setupinformationen, Standardberechtigungssatz und Array vollständig vertrauenswürdiger Assemblys.</summary>
        <returns>Die neu erstellte Anwendungsdomäne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Müssen Sie festlegen, die <xref:System.AppDomainSetup.ApplicationBase%2A> Eigenschaft der <xref:System.AppDomainSetup> -Objekt, das Sie, für die angeben `info`. Andernfalls wird eine Ausnahme ausgelöst.  
  
 Wenn `securityInfo` ist nicht angegeben wird, wird der Beweis, aus der aktuellen Anwendungsdomäne verwendet.  
  
 Die Informationen für `grantSet` und `fullTrustAssemblies` dient zum Erstellen einer <xref:System.Security.Policy.ApplicationTrust> -Objekt für die neue Anwendungsdomäne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Anwendungsdomäne ist <see langword="null" />.  
  
- oder -  
Die <see cref="P:System.AppDomainSetup.ApplicationBase" />-Eigenschaft ist nicht für das <see cref="T:System.AppDomainSetup" />-Objekt festgelegt, das für <paramref name="info" /> bereitgestellt ist.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">die Möglichkeit, eine Anwendungsdomäne zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Der angezeigte Name der Domäne. Dieser aussagekräftige Name zur Kennzeichnung der Domäne kann auf Benutzeroberflächen angezeigt werden. Weitere Informationen finden Sie unter <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Ein Beweis für die Identität des Codes, der in der Anwendungsdomäne ausgeführt wird. Übergeben Sie <see langword="null" />, um den Beweis der aktuellen Anwendungsdomäne zu verwenden.</param>
        <param name="appBasePath">Das Basisverzeichnis, das der Assemblyresolver für die Suche nach Assemblys verwendet. Weitere Informationen finden Sie unter <see cref="P:System.AppDomain.BaseDirectory" />.</param>
        <param name="appRelativeSearchPath">Der Pfad, in dem der Assemblyresolver nach privaten Assemblys suchen soll, mit einer relativen Angabe zum Basisverzeichnis. Weitere Informationen finden Sie unter <see cref="P:System.AppDomain.RelativeSearchPath" />.</param>
        <param name="shadowCopyFiles">Wenn <see langword="true" />, wird eine Spiegelung einer Assembly in diese Anwendungsdomäne geladen.</param>
        <summary>Erstellt eine neue Anwendungsdomäne mit dem angegebenen Namen unter Verwendung der Beweise, des Anwendungsbasispfads, des relativen Suchpfads und eines Parameters, der angibt, ob eine Schattenkopie einer Assembly in die Anwendungsdomäne geladen werden soll.</summary>
        <returns>Die neu erstellte Anwendungsdomäne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `securityInfo` ist nicht angegeben wird, wird der Beweis, aus der aktuellen Anwendungsdomäne verwendet.  
  
 Weitere Informationen zum Erstellen von Schattenkopien finden Sie unter <xref:System.AppDomain.ShadowCopyFiles%2A> und [Schattenkopien von Assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
> [!IMPORTANT]
>  Verwenden Sie die Überladung dieser Methode nicht zum Erstellen von Sandbox-Anwendungsdomänen. Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], der Beweis, der für angegebene `securityInfo` wirkt sich nicht mehr auf den Berechtigungssatz für die Anwendungsdomäne. Verwenden der <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> -methodenüberladung, um die Sandbox-Anwendungsdomänen zu erstellen.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht, in der Regel zum Erstellen einer Domäne mithilfe eines der <xref:System.AppDomain.CreateDomain%2A> Überladungen.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Bereitstellen von Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean, adInit As AppDomainInitializer, adInitArgs As String()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer ^ adInit, cli::array &lt;System::String ^&gt; ^ adInitArgs);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool * AppDomainInitializer * string[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles, adInit, adInitArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" />
        <Parameter Name="adInitArgs" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Der angezeigte Name der Domäne. Dieser aussagekräftige Name zur Kennzeichnung der Domäne kann auf Benutzeroberflächen angezeigt werden. Weitere Informationen finden Sie unter <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Ein Beweis für die Identität des Codes, der in der Anwendungsdomäne ausgeführt wird. Übergeben Sie <see langword="null" />, um den Beweis der aktuellen Anwendungsdomäne zu verwenden.</param>
        <param name="appBasePath">Das Basisverzeichnis, das der Assemblyresolver für die Suche nach Assemblys verwendet. Weitere Informationen finden Sie unter <see cref="P:System.AppDomain.BaseDirectory" />.</param>
        <param name="appRelativeSearchPath">Der Pfad, in dem der Assemblyresolver nach privaten Assemblys suchen soll, mit einer relativen Angabe zum Basisverzeichnis. Weitere Informationen finden Sie unter <see cref="P:System.AppDomain.RelativeSearchPath" />.</param>
        <param name="shadowCopyFiles">
          <see langword="true" />, um eine Schattenkopie einer Assembly in die Anwendungsdomäne zu laden.</param>
        <param name="adInit">Ein <see cref="T:System.AppDomainInitializer" />-Delegat, der eine Rückrufmethode darstellt, die beim Initialisieren des neuen <see cref="T:System.AppDomain" />-Objekts aufgerufen werden soll.</param>
        <param name="adInitArgs">Ein Array von Zeichenfolgenargumenten, das an die durch <paramref name="adInit" /> dargestellte Rückrufmethode übergeben werden soll, wenn das neue <see cref="T:System.AppDomain" />-Objekt initialisiert wird.</param>
        <summary>Erstellt eine neue Anwendungsdomäne mit dem angegebenen Namen unter Verwendung der Beweise, des Anwendungsbasispfads, des relativen Suchpfads und eines Parameters, der angibt, ob eine Schattenkopie einer Assembly in die Anwendungsdomäne geladen werden soll. Gibt eine Rückrufmethode an, die beim Initialisieren der Anwendungsdomäne aufgerufen wird, und ein Array von Zeichenfolgenargumenten, die an die Rückrufmethode übergeben werden sollen.</summary>
        <returns>Die neu erstellte Anwendungsdomäne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die durch dargestellte Methode `adInit` im Kontext der neu erstellte Anwendungsdomäne ausgeführt wird.  
  
 Wenn `securityInfo` ist nicht angegeben wird, wird der Beweis, aus der aktuellen Anwendungsdomäne verwendet.  
  
 Weitere Informationen zum Erstellen von Schattenkopien finden Sie unter <xref:System.AppDomain.ShadowCopyFiles%2A> und [Schattenkopien von Assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
> [!IMPORTANT]
>  Verwenden Sie die Überladung dieser Methode nicht zum Erstellen von Sandbox-Anwendungsdomänen. Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], der Beweis, der für angegebene `securityInfo` wirkt sich nicht mehr auf den Berechtigungssatz für die Anwendungsdomäne. Verwenden der <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> -methodenüberladung, um die Sandbox-Anwendungsdomänen zu erstellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Bereitstellen von Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue Instanz eines angegebenen Typs, der in einer angegebenen Assembly definiert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs, der in der angegebenen Assembly definiert ist.</summary>
        <returns>Ein Objekt, das ein Wrapper für die neue Instanz ist, die durch <paramref name="typeName" /> angegeben wird. Der Rückgabewert muss für den Zugriff auf das eigentliche Objekt entwrappt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft den Standardkonstruktor für `typeName`.  
  
 Finden Sie unter <xref:System.Reflection.AssemblyName> für das Format von `assemblyName`.  
  
 Ein Versuch des Aufrufs <xref:System.AppDomain.CreateInstance%2A> auf einem Ziel führt die Anwendungsdomäne, die nicht die aktuelle Anwendungsdomäne ist in einer erfolgreichen Laden der Assembly in der Zielanwendungsdomäne. Da ein <xref:System.Reflection.Assembly> ist nicht <xref:System.MarshalByRefObject>, wenn diese Methode versucht, Zurückgeben der <xref:System.Reflection.Assembly> für die geladene Assembly auf die aktuelle Anwendungsdomäne, versucht die common Language Runtime die Assembly in der aktuellen Anwendungsdomäne geladen und die Last schlägt möglicherweise fehl. Die Assembly, die in der aktuellen Anwendungsdomäne geladen wird möglicherweise von der Assembly unterscheiden, die zuerst geladen wurde, wenn sich die Path-Einstellungen für die zwei Anwendungsdomänen unterscheiden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> oder <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyName" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.NullReferenceException">Diese Instanz ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder Verzeichnis und für den Zugriff auf die Informationen im Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Möglichkeit, die nicht verwalteten Code aufrufen, wenn Sie eine Instanz eines Delegaten zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs, der in der angegebenen Assembly definiert ist. Ein Parameter gibt ein Array von Aktivierungsattributen an.</summary>
        <returns>Ein Objekt, das ein Wrapper für die neue Instanz ist, die durch <paramref name="typeName" /> angegeben wird. Der Rückgabewert muss für den Zugriff auf das eigentliche Objekt entwrappt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft den Standardkonstruktor für `typeName`.  
  
 Finden Sie unter <xref:System.Reflection.AssemblyName> für das Format von `assemblyName`.  
  
 Ein Versuch des Aufrufs <xref:System.AppDomain.CreateInstance%2A> auf einem Ziel führt die Anwendungsdomäne, die nicht die aktuelle Anwendungsdomäne ist in einer erfolgreichen Laden der Assembly in der Zielanwendungsdomäne. Da ein <xref:System.Reflection.Assembly> ist nicht <xref:System.MarshalByRefObject>, wenn diese Methode versucht, Zurückgeben der <xref:System.Reflection.Assembly> für die geladene Assembly auf die aktuelle Anwendungsdomäne, versucht die common Language Runtime die Assembly in der aktuellen Anwendungsdomäne geladen und die Last schlägt möglicherweise fehl. Die Assembly, die in der aktuellen Anwendungsdomäne geladen wird möglicherweise von der Assembly unterscheiden, die zuerst geladen wurde, wenn sich die Path-Einstellungen für die zwei Anwendungsdomänen unterscheiden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> oder <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyName" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.NullReferenceException">Diese Instanz ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Möglichkeit, die nicht verwalteten Code aufrufen, wenn Sie eine Instanz eines Delegaten zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für die Möglichkeit, Vorgänge auf alle Typmember aufzurufen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <param name="ignoreCase">Ein boolescher Wert, der angibt, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll.</param>
        <param name="bindingAttr">Eine Kombination von 0 oder mehr Bitflags, die die Suche nach dem <paramref name="typeName" />-Konstruktor beeinflussen. Wenn <paramref name="bindingAttr" /> 0 ist, wird eine Suche nach öffentlichen Konstruktoren mit Beachtung der Groß-/Kleinschreibung durchgeführt.</param>
        <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see cref="T:System.Reflection.MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn <paramref name="binder" /> den Wert null aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Die an den Konstruktor zu übergebenden Argumente. Dieses Array von Argumenten muss hinsichtlich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmen. Wenn der Standardkonstruktor gewünscht wird, muss <paramref name="args" /> ein leeres Array oder NULL sein.</param>
        <param name="culture">Kulturabhängige Informationen, die die Umwandlung von <paramref name="args" /> in die für den <paramref name="typeName" />-Konstruktor deklarierten formalen Typen bestimmen. Wenn <paramref name="culture" /> den Wert <see langword="null" /> hat, wird die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs, der in der angegebenen Assembly definiert ist. Parameter geben einen Binder, Bindungsflags, Konstruktorargumente, kulturspezifische Informationen zum Interpretieren von Argumenten und optionale Aktivierungsattribute an.</summary>
        <returns>Ein Objekt, das ein Wrapper für die neue Instanz ist, die durch <paramref name="typeName" /> angegeben wird. Der Rückgabewert muss für den Zugriff auf das eigentliche Objekt entwrappt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Finden Sie unter <xref:System.Reflection.AssemblyName> für das Format von `assemblyName`.  
  
 Ein Versuch des Aufrufs <xref:System.AppDomain.CreateInstance%2A> auf einem Ziel führt die Anwendungsdomäne, die nicht die aktuelle Anwendungsdomäne ist in einer erfolgreichen Laden der Assembly in der Zielanwendungsdomäne. Da ein <xref:System.Reflection.Assembly> ist nicht <xref:System.MarshalByRefObject>, wenn diese Methode versucht, Zurückgeben der <xref:System.Reflection.Assembly> für die geladene Assembly auf die aktuelle Anwendungsdomäne, versucht die common Language Runtime die Assembly in der aktuellen Anwendungsdomäne geladen und die Last schlägt möglicherweise fehl. Die Assembly, die in der aktuellen Anwendungsdomäne geladen wird möglicherweise von der Assembly unterscheiden, die zuerst geladen wurde, wenn sich die Path-Einstellungen für die zwei Anwendungsdomänen unterscheiden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> oder <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
- oder -  
 <paramref name="assemblyName" /> wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender Konstruktor gefunden.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.NullReferenceException">Diese Instanz ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Möglichkeit, die nicht verwalteten Code aufrufen, wenn Sie eine Instanz eines Delegaten zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für die Möglichkeit, Vorgänge auf alle Typmember aufzurufen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <param name="ignoreCase">Ein boolescher Wert, der angibt, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll.</param>
        <param name="bindingAttr">Eine Kombination von 0 oder mehr Bitflags, die die Suche nach dem <paramref name="typeName" />-Konstruktor beeinflussen. Wenn <paramref name="bindingAttr" /> 0 ist, wird eine Suche nach öffentlichen Konstruktoren mit Beachtung der Groß-/Kleinschreibung durchgeführt.</param>
        <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see cref="T:System.Reflection.MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn <paramref name="binder" /> den Wert null aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Die an den Konstruktor zu übergebenden Argumente. Dieses Array von Argumenten muss hinsichtlich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmen. Wenn der Standardkonstruktor gewünscht wird, muss <paramref name="args" /> ein leeres Array oder NULL sein.</param>
        <param name="culture">Kulturabhängige Informationen, die die Umwandlung von <paramref name="args" /> in die für den <paramref name="typeName" />-Konstruktor deklarierten formalen Typen bestimmen. Wenn <paramref name="culture" /> den Wert <see langword="null" /> hat, wird die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <param name="securityAttributes">Informationen, die zum Autorisieren der Erstellung von <paramref name="typeName" /> verwendet werden.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs, der in der angegebenen Assembly definiert ist. Parameter geben einen Binder, Bindungsflags, Konstruktorargumente, kulturspezifische Informationen zum Interpretieren von Argumenten, Aktivierungsattribute und die Autorisierung zum Erstellen des Typs an.</summary>
        <returns>Ein Objekt, das ein Wrapper für die neue Instanz ist, die durch <paramref name="typeName" /> angegeben wird. Der Rückgabewert muss für den Zugriff auf das eigentliche Objekt entwrappt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Finden Sie unter <xref:System.Reflection.AssemblyName> für das Format von `assemblyName`.  
  
 Ein Versuch des Aufrufs <xref:System.AppDomain.CreateInstance%2A> auf einem Ziel führt die Anwendungsdomäne, die nicht die aktuelle Anwendungsdomäne ist in einer erfolgreichen Laden der Assembly in der Zielanwendungsdomäne. Da ein <xref:System.Reflection.Assembly> ist nicht <xref:System.MarshalByRefObject>, wenn diese Methode versucht, Zurückgeben der <xref:System.Reflection.Assembly> für die geladene Assembly auf die aktuelle Anwendungsdomäne, versucht die common Language Runtime die Assembly in der aktuellen Anwendungsdomäne geladen und die Last schlägt möglicherweise fehl. Die Assembly, die in der aktuellen Anwendungsdomäne geladen wird möglicherweise von der Assembly unterscheiden, die zuerst geladen wurde, wenn sich die Path-Einstellungen für die zwei Anwendungsdomänen unterscheiden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> oder <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyName" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender Konstruktor gefunden.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.  
  
- oder -  
 <paramref name="securityAttributes" /> ist nicht <see langword="null" />. Wenn die Legacy-CAS-Richtlinie nicht aktiviert ist, sollte <paramref name="securityAttributes" /><see langword="null." /> sein.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.NullReferenceException">Diese Instanz ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Bereitstellen von Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für die Möglichkeit, Vorgänge auf alle Typmember aufzurufen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue Instanz eines angegebenen Typs.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs. Parameter geben die Assembly, in der der Typ definiert ist, und den Namen des Typs an.</summary>
        <returns>Eine Instanz des durch <paramref name="typeName" /> angegebenen Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine Hilfsmethode, die kombiniert <xref:System.AppDomain.CreateInstance%2A> und <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Diese Methode ruft den Standardkonstruktor für `typeName`.  
  
 Finden Sie unter <xref:System.Reflection.AssemblyName> für das Format von `assemblyName`. Finden Sie unter den <xref:System.Type.FullName%2A?displayProperty=nameWithType> -Eigenschaft für das Format der `typeName`.  
  
> [!NOTE]
>  Wenn Sie einen früh gebundener Aufruf einer Methode vornehmen `M` eines Objekts vom Typ `T1` , von zurückgegeben wurde <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, und dass die Methode einen früh gebundener Aufruf an eine Methode eines Objekts vom Typ macht `T2` in einer Assembly `C` außer der aktuelle Assembly oder auf die Assembly mit `T1`, Assembly `C` in der aktuellen Anwendungsdomäne geladen wird. Dieser Ladevorgang wird ausgeführt, selbst wenn die früh gebundene aufrufen, um `T1.M()` wurde versucht, im Hauptteil einer <xref:System.Reflection.Emit.DynamicMethod>, oder in anderen dynamisch generiertem Code. Wenn die aktuelle Domäne die Standarddomäne, die Assembly ist `C` kann nicht entladen werden, bis der Prozess beendet. Wenn die aktuelle Domäne später, beim Laden der Assembly versucht `C`, kann der Ladevorgang fehlschlagen.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die einfachste Möglichkeit zum Ausführen von Code in einer anderen Anwendungsdomäne. Das Beispiel definiert eine Klasse namens `Worker` von erbt <xref:System.MarshalByRefObject>. Die `Worker` Klasse definiert eine Methode, die den Namen der Anwendungsdomäne anzeigt, in der er ausgeführt wird. Das Beispiel erstellt Instanzen von `Worker` in der Standardanwendungsdomäne und in eine neue Anwendungsdomäne.  
  
> [!NOTE]
>  Die Assembly mit `Worker` muss in beide Anwendungsdomänen geladen werden, aber es kann andere Assemblys laden, die nur in der neuen Anwendungsdomäne vorhanden sind.  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> oder <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyName" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei mit dem Assemblymanifest, oder wenn Sie einen Typ aus einem Modul als der manifest-Datei erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs. Parameter geben die Assembly an, in der der Typ definiert ist, und den Namen des Typs und ein Array von Aktivierungsattributen.</summary>
        <returns>Eine Instanz des durch <paramref name="typeName" /> angegebenen Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine Hilfsmethode, die kombiniert <xref:System.AppDomain.CreateInstance%2A> und <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Diese Methode ruft den Standardkonstruktor für `typeName`.  
  
 Finden Sie unter <xref:System.Reflection.AssemblyName> für das Format von `assemblyName`. Finden Sie unter den <xref:System.Type.FullName%2A?displayProperty=nameWithType> -Eigenschaft für das Format der `typeName`.  
  
> [!NOTE]
>  Wenn Sie einen früh gebundener Aufruf einer Methode vornehmen `M` eines Objekts vom Typ `T1` , von zurückgegeben wurde <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, und dass die Methode einen früh gebundener Aufruf an eine Methode eines Objekts vom Typ macht `T2` in einer Assembly `C` außer der aktuelle Assembly oder auf die Assembly mit `T1`, Assembly `C` in der aktuellen Anwendungsdomäne geladen wird. Dieser Ladevorgang wird ausgeführt, selbst wenn die früh gebundene aufrufen, um `T1.M()` wurde versucht, im Hauptteil einer <xref:System.Reflection.Emit.DynamicMethod>, oder in anderen dynamisch generiertem Code. Wenn die aktuelle Domäne die Standarddomäne, die Assembly ist `C` kann nicht entladen werden, bis der Prozess beendet. Wenn die aktuelle Domäne später, beim Laden der Assembly versucht `C`, kann der Ladevorgang fehlschlagen.  
  
   
  
## Examples  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> oder <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyName" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Möglichkeit, die nicht verwalteten Code aufrufen, wenn Sie eine Instanz eines Delegaten zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für die Möglichkeit, Vorgänge auf alle Typmember aufzurufen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <param name="ignoreCase">Ein boolescher Wert, der angibt, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll.</param>
        <param name="bindingAttr">Eine Kombination von 0 oder mehr Bitflags, die die Suche nach dem <paramref name="typeName" />-Konstruktor beeinflussen. Wenn <paramref name="bindingAttr" /> 0 ist, wird eine Suche nach öffentlichen Konstruktoren mit Beachtung der Groß-/Kleinschreibung durchgeführt.</param>
        <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see cref="T:System.Reflection.MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn <paramref name="binder" /> den Wert null aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Die an den Konstruktor zu übergebenden Argumente. Dieses Array von Argumenten muss hinsichtlich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmen. Wenn der Standardkonstruktor gewünscht wird, muss <paramref name="args" /> ein leeres Array oder NULL sein.</param>
        <param name="culture">Ein kulturspezifisches Objekt, mit dem die Umwandlung von Typen geregelt wird. Wenn <paramref name="culture" /> den Wert <see langword="null" /> hat, wird die <see langword="CultureInfo" /> des aktuellen Threads verwendet.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. In der Regel ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält. Dies gibt die zum Aktivieren eines Remoteobjekts erforderliche URL an.  
  
Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <summary>Erstellt eine neue Instanz des angegebenen, in der angegebenen Assembly definierten Typs, die angibt, ob die Groß-/Kleinschreibung des Typnamens ignoriert wird, außerdem die Bindungsattribute und den Binder, mit denen der zu erstellende Typ ausgewählt wird, die Argumente des Konstruktors, die Kultur und die Aktivierungsattribute.</summary>
        <returns>Eine Instanz des durch <paramref name="typeName" /> angegebenen Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine Hilfsmethode, die kombiniert <xref:System.AppDomain.CreateInstance%2A> und <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Finden Sie unter <xref:System.Reflection.AssemblyName> für das Format von `assemblyName`. Finden Sie unter den <xref:System.Type.FullName%2A?displayProperty=nameWithType> -Eigenschaft für das Format der `typeName`.  
  
> [!NOTE]
>  Wenn Sie einen früh gebundener Aufruf einer Methode vornehmen `M` eines Objekts vom Typ `T1` , von zurückgegeben wurde <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, und dass die Methode einen früh gebundener Aufruf an eine Methode eines Objekts vom Typ macht `T2` in einer Assembly `C` außer der aktuelle Assembly oder auf die Assembly mit `T1`, Assembly `C` in der aktuellen Anwendungsdomäne geladen wird. Dieser Ladevorgang wird ausgeführt, selbst wenn die früh gebundene aufrufen, um `T1.M()` wurde versucht, im Hauptteil einer <xref:System.Reflection.Emit.DynamicMethod>, oder in anderen dynamisch generiertem Code. Wenn die aktuelle Domäne die Standarddomäne, die Assembly ist `C` kann nicht entladen werden, bis der Prozess beendet. Wenn die aktuelle Domäne später, beim Laden der Assembly versucht `C`, kann der Ladevorgang fehlschlagen.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der `ignoreCase` Parameter.  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> oder <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender Konstruktor gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
- oder -  
 <paramref name="assemblyName" /> wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Möglichkeit, die nicht verwalteten Code aufrufen, wenn Sie eine Instanz eines Delegaten zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für die Möglichkeit, Vorgänge auf alle Typmember aufzurufen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <param name="ignoreCase">Ein boolescher Wert, der angibt, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll.</param>
        <param name="bindingAttr">Eine Kombination von 0 oder mehr Bitflags, die die Suche nach dem <paramref name="typeName" />-Konstruktor beeinflussen. Wenn <paramref name="bindingAttr" /> 0 ist, wird eine Suche nach öffentlichen Konstruktoren mit Beachtung der Groß-/Kleinschreibung durchgeführt.</param>
        <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see cref="T:System.Reflection.MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn <paramref name="binder" /> den Wert null aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Die an den Konstruktor zu übergebenden Argumente. Dieses Array von Argumenten muss hinsichtlich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmen. Wenn der Standardkonstruktor gewünscht wird, muss <paramref name="args" /> ein leeres Array oder NULL sein.</param>
        <param name="culture">Ein kulturspezifisches Objekt, mit dem die Umwandlung von Typen geregelt wird. Wenn <paramref name="culture" /> den Wert <see langword="null" /> hat, wird die <see langword="CultureInfo" /> des aktuellen Threads verwendet.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <param name="securityAttributes">Informationen, die zum Autorisieren der Erstellung von <paramref name="typeName" /> verwendet werden.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs. Parameter geben den Namen des Typs an und wie er gesucht und erstellt werden kann.</summary>
        <returns>Eine Instanz des durch <paramref name="typeName" /> angegebenen Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine Hilfsmethode, die kombiniert <xref:System.AppDomain.CreateInstance%2A> und <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Finden Sie unter <xref:System.Reflection.AssemblyName> für das Format von `assemblyName`. Finden Sie unter den <xref:System.Type.FullName%2A?displayProperty=nameWithType> -Eigenschaft für das Format der `typeName`.  
  
> [!NOTE]
>  Wenn Sie einen früh gebundener Aufruf einer Methode vornehmen `M` eines Objekts vom Typ `T1` , von zurückgegeben wurde <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, und dass die Methode einen früh gebundener Aufruf an eine Methode eines Objekts vom Typ macht `T2` in einer Assembly `C` außer der aktuelle Assembly oder auf die Assembly mit `T1`, Assembly `C` in der aktuellen Anwendungsdomäne geladen wird. Dieser Ladevorgang wird ausgeführt, selbst wenn die früh gebundene aufrufen, um `T1.M()` wurde versucht, im Hauptteil einer <xref:System.Reflection.Emit.DynamicMethod>, oder in anderen dynamisch generiertem Code. Wenn die aktuelle Domäne die Standarddomäne, die Assembly ist `C` kann nicht entladen werden, bis der Prozess beendet. Wenn die aktuelle Domäne später, beim Laden der Assembly versucht `C`, kann der Ladevorgang fehlschlagen.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der `ignoreCase` Parameter.  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> oder <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender Konstruktor gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyName" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für die Möglichkeit, Vorgänge auf alle Typmember aufzurufen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue Instanz eines angegebenen Typs, der in der angegebenen Assemblydatei definiert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name einschließlich des Pfads einer Datei, die eine Assembly enthält, in der der angeforderte Typ definiert ist. Die Assembly wird mit der <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />-Methode geladen.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs, der in der angegebenen Assemblydatei definiert ist.</summary>
        <returns>Ein Objekt, das ein Wrapper für die neue Instanz ist, oder <see langword="null" />, wenn <paramref name="typeName" /> nicht gefunden wurde. Der Rückgabewert muss für den Zugriff auf das eigentliche Objekt entwrappt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardkonstruktor für `typeName` aufgerufen wird.  
  
 Weitere Informationen finden Sie unter der Methode <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 Wenn die <xref:System.AppDomain.CreateInstanceFrom%2A> Methode dient zum Erstellen einer Instanz in eine Ziel-Anwendungsdomäne, als die Anwendungsdomäne, von dem der Aufruf erfolgt, die Assembly geladen wird, in der Zielanwendungsdomäne. Wenn die Instanz in der aufrufenden Anwendungsdomäne nicht eingeschlossen ist, kann jedoch mithilfe der entpackten Instanz auf bestimmte Weise die Assembly in der aufrufenden Anwendungsdomäne geladen werden zu führen. Z. B. nach dem die Instanz nicht eingeschlossen ist, die Typinformationen angefordert werden kann, um seine Methoden aufrufen spät gebunden. Wenn die Assembly in der aufrufenden Anwendungsdomäne geladen wird, können Ausnahmen auftreten.  
  
-   Wenn eine andere Version derselben Assembly bereits in der aufrufenden Anwendungsdomäne geladen wurde oder wenn der Ladepfad, von der aufrufenden Anwendungsdomäne unterscheidet, von der Zielanwendungsdomäne Ausnahmen wie <xref:System.MissingMethodException> auftreten können.  
  
-   Wenn die aufrufenden Anwendungsdomäne früh gebundene Aufrufe den Instanztyp <xref:System.InvalidCastException> ausgelöst werden kann, bei dem Versuch, das die Instanz umgewandelt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> -methodenüberladung, um eine Instanz eines Objekts in einer Zielanwendungsdomäne erstellen und seine Methoden aufrufen.  
  
 Das Beispiel definiert die `MarshallableExample` -Klasse, die über Anwendungsdomänengrenzen hinweg gemarshallt werden kann. Im Beispiel wird einen Pfad zu der gerade ausgeführten Assembly erstellt, erstellt eine Zielanwendungsdomäne und verwendet die <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> -methodenüberladung, um die Beispielassembly in der Zielanwendungsdomäne laden und erstellen Sie eine Instanz des `MarshallableExample`.  
  
> [!NOTE]
>  Der Pfad ist absolut in diesem Beispiel, aber ein relativer Pfad würde auch funktionieren, da die <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> Methode wird verwendet, um die Assembly zu laden.  
  
 Nach dem Entpacken der Objekthandle aus und wird in diesem Beispiel drei Möglichkeiten, um ein Objekt in einer Zielanwendungsdomäne zu verwenden:  
  
-   Das Aufrufen einer Methode mit der dynamischen Bindung, die mithilfe von Reflektion. Dies erfordert die Typinformationen, wodurch die Assembly in der Anwendungsdomäne des Aufrufers geladen werden. (In diesem Beispiel ist es bereits geladen.)  
  
-   Wandeln das Objekt, das eine Schnittstelle bekannt, dass der Aufrufer und aufgerufenen. Wenn die Schnittstelle in der aufrufenden Assembly oder in einer dritten Assembly verwiesen wird, vom Aufrufer und aufgerufenen definiert ist, wird die aufgerufene Assembly nicht in der Anwendungsdomäne des Aufrufers geladen.  
  
-   Verwenden das Objekt direkt bei der Typ an den Aufrufer bekannt ist. Die Assembly muss in der Anwendungsdomäne des Aufrufers geladen werden.  
  
 Eine weitere Möglichkeit zum Vermeiden des Ladens von der aufgerufenen Assembly in die Anwendungsdomäne des Aufrufers wird für den Aufrufer für die Ableitung der <xref:System.MarshalByRefObject> Klasse und eine Methode definieren, die in der Zielanwendungsdomäne ausgeführt werden können. Diese Methode kann Reflektion verwenden, überprüfen Sie eine Zielassembly, da die Zielassembly bereits in der Zielanwendungsdomäne geladen wird. Siehe das Beispiel für die <xref:System.AppDomain.DynamicDirectory%2A> Eigenschaft.  
  
 [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cpp/example.cpp#1)]
 [!code-csharp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cs/example.cs#1)]
 [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> wurde in <paramref name="assemblyFile" /> nicht gefunden.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein parameterloser öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine ausreichende Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyFile" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.NullReferenceException">Diese Instanz ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name einschließlich des Pfads einer Datei, die eine Assembly enthält, in der der angeforderte Typ definiert ist. Die Assembly wird mit der <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />-Methode geladen.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs, der in der angegebenen Assemblydatei definiert ist.</summary>
        <returns>Ein Objekt, das ein Wrapper für die neue Instanz ist, oder <see langword="null" />, wenn <paramref name="typeName" /> nicht gefunden wurde. Der Rückgabewert muss für den Zugriff auf das eigentliche Objekt entwrappt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardkonstruktor für `typeName` aufgerufen wird.  
  
 Weitere Informationen zu dieser Methode finden Sie unter den <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> Methode.  
  
 Wenn die <xref:System.AppDomain.CreateInstanceFrom%2A> Methode dient zum Erstellen einer Instanz in eine Ziel-Anwendungsdomäne, als die Anwendungsdomäne, von dem der Aufruf erfolgt, die Assembly geladen wird, in der Zielanwendungsdomäne. Wenn die Instanz in der aufrufenden Anwendungsdomäne nicht eingeschlossen ist, kann jedoch mithilfe der entpackten Instanz auf bestimmte Weise die Assembly in der aufrufenden Anwendungsdomäne geladen werden zu führen. Z. B. nach dem die Instanz nicht eingeschlossen ist, die Typinformationen angefordert werden kann, um seine Methoden aufrufen spät gebunden. Wenn die Assembly in der aufrufenden Anwendungsdomäne geladen wird, können Ausnahmen auftreten.  
  
-   Wenn eine andere Version derselben Assembly bereits in der aufrufenden Anwendungsdomäne geladen wurde oder wenn der Ladepfad, von der aufrufenden Anwendungsdomäne unterscheidet, von der Zielanwendungsdomäne Ausnahmen wie <xref:System.MissingMethodException> auftreten können.  
  
-   Wenn die aufrufenden Anwendungsdomäne früh gebundene Aufrufe den Instanztyp <xref:System.InvalidCastException> ausgelöst werden kann, bei dem Versuch, das die Instanz umgewandelt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> wurde in <paramref name="assemblyFile" /> nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine ausreichende Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyFile" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.NullReferenceException">Diese Instanz ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name einschließlich des Pfads einer Datei, die eine Assembly enthält, in der der angeforderte Typ definiert ist. Die Assembly wird mit der <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />-Methode geladen.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <param name="ignoreCase">Ein boolescher Wert, der angibt, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll.</param>
        <param name="bindingAttr">Eine Kombination von 0 oder mehr Bitflags, die die Suche nach dem <paramref name="typeName" />-Konstruktor beeinflussen. Wenn <paramref name="bindingAttr" /> 0 ist, wird eine Suche nach öffentlichen Konstruktoren mit Beachtung der Groß-/Kleinschreibung durchgeführt.</param>
        <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see cref="T:System.Reflection.MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn <paramref name="binder" /> den Wert null aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Die an den Konstruktor zu übergebenden Argumente. Dieses Array von Argumenten muss hinsichtlich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmen. Wenn der Standardkonstruktor gewünscht wird, muss <paramref name="args" /> ein leeres Array oder NULL sein.</param>
        <param name="culture">Kulturabhängige Informationen, die die Umwandlung von <paramref name="args" /> in die für den <paramref name="typeName" />-Konstruktor deklarierten formalen Typen bestimmen. Wenn <paramref name="culture" /> den Wert <see langword="null" /> hat, wird die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs, der in der angegebenen Assemblydatei definiert ist.</summary>
        <returns>Ein Objekt, das ein Wrapper für die neue Instanz ist, oder <see langword="null" />, wenn <paramref name="typeName" /> nicht gefunden wurde. Der Rückgabewert muss für den Zugriff auf das eigentliche Objekt entwrappt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter der Methode <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 Wenn die <xref:System.AppDomain.CreateInstanceFrom%2A> Methode dient zum Erstellen einer Instanz in eine Ziel-Anwendungsdomäne, als die Anwendungsdomäne, von dem der Aufruf erfolgt, die Assembly geladen wird, in der Zielanwendungsdomäne. Wenn die Instanz in der aufrufenden Anwendungsdomäne nicht eingeschlossen ist, kann jedoch mithilfe der entpackten Instanz auf bestimmte Weise die Assembly in der aufrufenden Anwendungsdomäne geladen werden zu führen. Z. B. nach dem die Instanz nicht eingeschlossen ist, die Typinformationen angefordert werden kann, um seine Methoden aufrufen spät gebunden. Wenn die Assembly in der aufrufenden Anwendungsdomäne geladen wird, können Ausnahmen auftreten.  
  
-   Wenn eine andere Version derselben Assembly bereits in der aufrufenden Anwendungsdomäne geladen wurde oder wenn der Ladepfad, von der aufrufenden Anwendungsdomäne unterscheidet, von der Zielanwendungsdomäne Ausnahmen wie <xref:System.MissingMethodException> auftreten können.  
  
-   Wenn die aufrufenden Anwendungsdomäne früh gebundene Aufrufe den Instanztyp <xref:System.InvalidCastException> ausgelöst werden kann, bei dem Versuch, das die Instanz umgewandelt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> wurde in <paramref name="assemblyFile" /> nicht gefunden.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine ausreichende Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
- oder -  
 <paramref name="assemblyFile" /> wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.NullReferenceException">Diese Instanz ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name einschließlich des Pfads einer Datei, die eine Assembly enthält, in der der angeforderte Typ definiert ist. Die Assembly wird mit der <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />-Methode geladen.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <param name="ignoreCase">Ein boolescher Wert, der angibt, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll.</param>
        <param name="bindingAttr">Eine Kombination von 0 oder mehr Bitflags, die die Suche nach dem <paramref name="typeName" />-Konstruktor beeinflussen. Wenn <paramref name="bindingAttr" /> 0 ist, wird eine Suche nach öffentlichen Konstruktoren mit Beachtung der Groß-/Kleinschreibung durchgeführt.</param>
        <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see cref="T:System.Reflection.MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn <paramref name="binder" /> den Wert null aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Die an den Konstruktor zu übergebenden Argumente. Dieses Array von Argumenten muss hinsichtlich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmen. Wenn der Standardkonstruktor gewünscht wird, muss <paramref name="args" /> ein leeres Array oder NULL sein.</param>
        <param name="culture">Kulturabhängige Informationen, die die Umwandlung von <paramref name="args" /> in die für den <paramref name="typeName" />-Konstruktor deklarierten formalen Typen bestimmen. Wenn <paramref name="culture" /> den Wert <see langword="null" /> hat, wird die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <param name="securityAttributes">Informationen, die zum Autorisieren der Erstellung von <paramref name="typeName" /> verwendet werden.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs, der in der angegebenen Assemblydatei definiert ist.</summary>
        <returns>Ein Objekt, das ein Wrapper für die neue Instanz ist, oder <see langword="null" />, wenn <paramref name="typeName" /> nicht gefunden wurde. Der Rückgabewert muss für den Zugriff auf das eigentliche Objekt entwrappt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu dieser Methode finden Sie unter den <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> Methode.  
  
 Wenn die <xref:System.AppDomain.CreateInstanceFrom%2A> Methode dient zum Erstellen einer Instanz in eine Ziel-Anwendungsdomäne, als die Anwendungsdomäne, von dem der Aufruf erfolgt, die Assembly geladen wird, in der Zielanwendungsdomäne. Wenn die Instanz in der aufrufenden Anwendungsdomäne nicht eingeschlossen ist, kann jedoch mithilfe der entpackten Instanz auf bestimmte Weise die Assembly in der aufrufenden Anwendungsdomäne geladen werden zu führen. Z. B. nach dem die Instanz nicht eingeschlossen ist, die Typinformationen angefordert werden kann, um seine Methoden aufrufen spät gebunden. Wenn die Assembly in der aufrufenden Anwendungsdomäne geladen wird, können Ausnahmen auftreten.  
  
-   Wenn eine andere Version derselben Assembly bereits in der aufrufenden Anwendungsdomäne geladen wurde oder wenn der Ladepfad, von der aufrufenden Anwendungsdomäne unterscheidet, von der Zielanwendungsdomäne Ausnahmen wie <xref:System.MissingMethodException> auftreten können.  
  
-   Wenn die aufrufenden Anwendungsdomäne früh gebundene Aufrufe den Instanztyp <xref:System.InvalidCastException> ausgelöst werden kann, bei dem Versuch, das die Instanz umgewandelt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.  
  
- oder -  
 <paramref name="securityAttributes" /> ist nicht <see langword="null" />. Wenn die Legacy-CAS-Richtlinie nicht aktiviert ist, sollte <paramref name="securityAttributes" /> den Wert <see langword="null" /> aufweisen.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> wurde in <paramref name="assemblyFile" /> nicht gefunden.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine ausreichende Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyFile" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.NullReferenceException">Diese Instanz ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Bereitstellen von Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFromAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue Instanz eines angegebenen Typs, der in der angegebenen Assemblydatei definiert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Dateiname und der Pfad der Assembly, in der der angeforderte Typ definiert ist.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs, der in der angegebenen Assemblydatei definiert ist.</summary>
        <returns>Das angeforderte Objekt oder <see langword="null" />, wenn <paramref name="typeName" /> nicht gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine Hilfsmethode, die kombiniert <xref:System.AppDomain.CreateInstanceFrom%2A> und <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Diese Methode ruft den Standardkonstruktor für `typeName`.  
  
 Weitere Informationen finden Sie unter der Methode <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein parameterloser öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine ausreichende Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyName" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Dateiname und der Pfad der Assembly, in der der angeforderte Typ definiert ist.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly (siehe <see cref="P:System.Type.FullName" />-Eigenschaft).</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs, der in der angegebenen Assemblydatei definiert ist.</summary>
        <returns>Das angeforderte Objekt oder <see langword="null" />, wenn <paramref name="typeName" /> nicht gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine Hilfsmethode, die kombiniert <xref:System.AppDomain.CreateInstanceFrom%2A> und <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Diese Methode ruft den Standardkonstruktor für `typeName`.  
  
 Weitere Informationen zu dieser Methode finden Sie unter den <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein parameterloser öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine ausreichende Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyName" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Dateiname und der Pfad der Assembly, in der der angeforderte Typ definiert ist.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <param name="ignoreCase">Ein boolescher Wert, der angibt, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll.</param>
        <param name="bindingAttr">Eine Kombination von 0 oder mehr Bitflags, die die Suche nach dem <paramref name="typeName" />-Konstruktor beeinflussen. Wenn <paramref name="bindingAttr" /> 0 ist, wird eine Suche nach öffentlichen Konstruktoren mit Beachtung der Groß-/Kleinschreibung durchgeführt.</param>
        <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see cref="T:System.Reflection.MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn <paramref name="binder" /> den Wert null aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Die an den Konstruktor zu übergebenden Argumente. Dieses Array von Argumenten muss hinsichtlich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmen. Wenn der Standardkonstruktor gewünscht wird, muss <paramref name="args" /> ein leeres Array oder NULL sein.</param>
        <param name="culture">Kulturabhängige Informationen, die die Umwandlung von <paramref name="args" /> in die für den <paramref name="typeName" />-Konstruktor deklarierten formalen Typen bestimmen. Wenn <paramref name="culture" /> den Wert <see langword="null" /> hat, wird die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <summary>Erstellt eine neue Instanz des angegebenen, in der angegebenen Assemblydatei definierten Typs, die angibt, ob die Groß-/Kleinschreibung des Typnamens ignoriert wird, außerdem die Bindungsattribute und den Binder, mit denen der zu erstellende Typ ausgewählt wird, die Argumente des Konstruktors, die Kultur und die Aktivierungsattribute.</summary>
        <returns>Das angeforderte Objekt oder <see langword="null" />, wenn <paramref name="typeName" /> nicht gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine Hilfsmethode, die kombiniert <xref:System.AppDomain.CreateInstanceFrom%2A> und <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Weitere Informationen zu dieser Methode finden Sie unter den <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine ausreichende Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
- oder -  
 <paramref name="assemblyName" /> wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFromAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Dateiname und der Pfad der Assembly, in der der angeforderte Typ definiert ist.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <param name="ignoreCase">Ein boolescher Wert, der angibt, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll.</param>
        <param name="bindingAttr">Eine Kombination von 0 oder mehr Bitflags, die die Suche nach dem <paramref name="typeName" />-Konstruktor beeinflussen. Wenn <paramref name="bindingAttr" /> 0 ist, wird eine Suche nach öffentlichen Konstruktoren mit Beachtung der Groß-/Kleinschreibung durchgeführt.</param>
        <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see cref="T:System.Reflection.MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn <paramref name="binder" /> den Wert null aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Die an den Konstruktor zu übergebenden Argumente. Dieses Array von Argumenten muss hinsichtlich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmen. Wenn der Standardkonstruktor gewünscht wird, muss <paramref name="args" /> ein leeres Array oder NULL sein.</param>
        <param name="culture">Kulturabhängige Informationen, die die Umwandlung von <paramref name="args" /> in die für den <paramref name="typeName" />-Konstruktor deklarierten formalen Typen bestimmen. Wenn <paramref name="culture" /> den Wert <see langword="null" /> hat, wird die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <param name="securityAttributes">Informationen, die zum Autorisieren der Erstellung von <paramref name="typeName" /> verwendet werden.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs, der in der angegebenen Assemblydatei definiert ist.</summary>
        <returns>Das angeforderte Objekt oder <see langword="null" />, wenn <paramref name="typeName" /> nicht gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine Hilfsmethode, die kombiniert <xref:System.AppDomain.CreateInstanceFrom%2A> und <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Weitere Informationen zu dieser Methode finden Sie unter den <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine ausreichende Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyName" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.CurrentDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDomain As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property AppDomain ^ CurrentDomain { AppDomain ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDomain : AppDomain" Usage="System.AppDomain.CurrentDomain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuelle Anwendungsdomäne für den aktuellen <see cref="T:System.Threading.Thread" /> ab.</summary>
        <value>Die aktuelle Anwendungsdomäne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird eine neue Anwendungsdomäne erstellt. Die <xref:System.AppDomain.CurrentDomain%2A> Eigenschaft wird zum Abrufen einer <xref:System.AppDomain> Objekt, das die aktuelle Anwendungsdomäne darstellt. Die <xref:System.AppDomain.FriendlyName%2A> Eigenschaft enthält den Namen des die aktuelle Anwendungsdomäne, die dann in der Befehlszeile angezeigt werden.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiert eine dynamische Assembly in der aktuellen Anwendungsdomäne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
      </Parameters>
      <Docs>
        <param name="name">Die eindeutige Identität der dynamischen Assembly.</param>
        <param name="access">Der Zugriffsmodus für die dynamische Assembly.</param>
        <summary>Definiert eine dynamische Assembly mit dem angegebenen Namen und Zugriffsmodus.</summary>
        <returns>Eine dynamische Assembly mit dem angegebenen Namen und Zugriffsmodus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte nur verwendet werden, um eine dynamische Assembly in der aktuellen Anwendungsdomäne zu definieren. Weitere Informationen finden Sie unter den <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
> [!NOTE]
>  Bei der Entwicklung von Code, der dynamische Assemblys ausgibt, wird empfohlen, dass Sie eine Überladung der verwenden die <xref:System.AppDomain.DefineDynamicAssembly%2A> -Methode, Beweise und Berechtigungen angeben, die Beweise, die die dynamische Assembly, und enthalten soll <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Einschließlich <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in die `refusedPermissions` Parameter wird sichergestellt, dass die MSIL nicht überprüft wird. Eine Einschränkung dieser Technik ist, dass dadurch auch <xref:System.Security.SecurityException> ausgelöst wird, wenn Sie mit Code verwendet, die volle Vertrauenswürdigkeit erforderlich.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.AppDomain.DefineDynamicAssembly%2A> Methode und <xref:System.AppDomain.AssemblyResolve> Ereignis.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen angeben. Informationen dazu, wie Sie den vollqualifizierten Assemblynamen abzurufen, finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> beginnt mit einem Leerzeichen oder enthält einen Schrägstrich oder umgekehrten Schrägstrich.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">Die eindeutige Identität der dynamischen Assembly.</param>
        <param name="access">Der Zugriffsmodus für die dynamische Assembly.</param>
        <param name="assemblyAttributes">Eine aufzählbare Liste von Attributen, die auf die Assembly angewendet werden sollen, oder <see langword="null" />, wenn keine Attribute vorhanden sind.</param>
        <summary>Definiert eine dynamische Assembly mit dem angegebenen Namen, Zugriffsmodus und benutzerdefinierten Attributen.</summary>
        <returns>Eine dynamische Assembly mit dem angegebenen Namen und Funktionen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese methodenüberladung, um die Attribute angeben, die funktionieren nicht richtig, es sei denn, sie angewendet werden, wenn eine dynamische Assembly erstellt wird. Z. B. Sicherheitsattribute wie z. B. <xref:System.Security.SecurityTransparentAttribute> und <xref:System.Security.SecurityCriticalAttribute> funktionieren nicht ordnungsgemäß, wenn sie hinzugefügt werden, nachdem eine dynamische Assembly erstellt wurde.  
  
 Diese Methode sollte nur zum Definieren einer dynamischen Assembly in der aktuellen Anwendungsdomäne verwendet werden. Weitere Informationen zu dieser Einschränkung finden Sie unter den <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
 Diese methodenüberladung wird eingeführt, der [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie eine dynamische Assembly erstellt, die die <xref:System.Security.SecurityTransparentAttribute>. Das Attribut muss angegeben werden, als ein Element eines Arrays von <xref:System.Reflection.Emit.CustomAttributeBuilder> Objekte.  
  
 Der erste Schritt beim Erstellen der <xref:System.Reflection.Emit.CustomAttributeBuilder> besteht darin, einen Konstruktor für das Attribut zu erhalten. Der Konstruktor enthält keine Parameter, sodass die <xref:System.Type.GetConstructor%2A> -Methode aufgerufen wird und ein leeres Array vom <xref:System.Type> -Objekten zur Darstellung der Typen der Parameter. Der zweite Schritt ist das resultierende übergeben <xref:System.Reflection.ConstructorInfo> Objekt an den Konstruktor für die <xref:System.Reflection.Emit.CustomAttributeBuilder> -Klasse, zusammen mit der ein leeres Array vom Typ <xref:System.Object> auf die Argumente darstellen.  
  
 Die resultierende <xref:System.Reflection.Emit.CustomAttributeBuilder> übergeben, die <xref:System.AppDomain.DefineDynamicAssembly%2A> -Methode, wie das einzige Element eines Arrays.  
  
 Im Beispielcode definiert ein Modul und ein Typ in die neue dynamische Assembly, und zeigt dann die Attribute der Assembly.  
  
 [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cpp/source.cpp#1)]
 [!code-csharp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cs/source.cs#1)]
 [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> beginnt mit Leerraum, oder sie enthält einen Schrägstrich bzw. einen umgekehrten Schrägstrich.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">Die eindeutige Identität der dynamischen Assembly.</param>
        <param name="access">Der Modus, in dem auf die dynamische Assembly zugegriffen wird.</param>
        <param name="evidence">Der für die dynamische Assembly angegebene Beweis. Der Beweis wird ohne Änderungen als endgültiger Satz von Beweisen für die Richtlinienauflösung verwendet.</param>
        <summary>Definiert eine dynamische Assembly mit dem angegebenen Namen, Zugriffsmodus und Beweis.</summary>
        <returns>Eine dynamische Assembly mit dem angegebenen Namen und Funktionen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur vollständig vertrauenswürdige Aufrufer können angeben, deren `evidence` beim Definieren einer dynamischen <xref:System.Reflection.Assembly>. Die Common Language Runtime ordnet die <xref:System.Security.Policy.Evidence> durch die Sicherheitsrichtlinien, um zu bestimmen, die gewährten Berechtigungen. Teilweise vertrauenswürdige Aufrufer müssen ein NULL-Wert angeben `evidence`. Wenn `evidence` ist `null`, die Runtime kopiert die Berechtigungssätze, d. h. die aktuelle GRANT- und deny-Mengen von des Aufrufers <xref:System.Reflection.Assembly> an den dynamischen <xref:System.Reflection.Assembly> definiert wird, und kennzeichnet die Richtlinie als aufgelöst.  
  
 Wenn die dynamische <xref:System.Reflection.Assembly> ist auf dem Datenträger gespeichert, nachfolgende lädt erhalten gewährt, die basierend auf Richtlinien, die die Position zugeordnet, in denen die <xref:System.Reflection.Assembly> wurde gespeichert.  
  
 Diese Methode sollte nur verwendet werden, um eine dynamische Assembly in der aktuellen Anwendungsdomäne zu definieren. Weitere Informationen finden Sie unter den <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
> [!NOTE]
>  Bei der Entwicklung von Code, der dynamische Assemblys ausgibt, wird empfohlen, dass Sie eine Überladung der verwenden die <xref:System.AppDomain.DefineDynamicAssembly%2A> -Methode, Beweise und Berechtigungen angeben, die Beweise, die die dynamische Assembly, und enthalten soll <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Einschließlich <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in die `refusedPermissions` Parameter wird sichergestellt, dass die MSIL nicht überprüft wird. Eine Einschränkung dieser Technik ist, dass dadurch auch <xref:System.Security.SecurityException> ausgelöst wird, wenn Sie mit Code verwendet, die volle Vertrauenswürdigkeit erforderlich.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.AppDomain.DefineDynamicAssembly%2A> Methode und die <xref:System.AppDomain.AssemblyResolve> Ereignis.  
  
 Im Codebeispiel wird zunächst versucht, zum Erstellen einer Instanz von `MyDynamicType` durch Aufrufen der <xref:System.AppDomain.CreateInstance%2A> -Methode mit einem ungültigen Assemblynamen, und die resultierende Ausnahme abgefangen.  
  
 Im Codebeispiel fügt dann einen Ereignishandler für die <xref:System.AppDomain.AssemblyResolve> Ereignis und ein weiteres Mal versucht, die zum Erstellen einer Instanz von`MyDynamicType`. Während des Aufrufs von <xref:System.AppDomain.CreateInstance%2A>, <xref:System.AppDomain.AssemblyResolve> Ereignis wird ausgelöst, für die ungültige Assembly. Der Ereignishandler erstellt eine dynamische Assembly, die einen Typ namens enthält `MyDynamicType`, gibt den Typ einen parameterlosen Konstruktor und die neue dynamische Assembly zurück. Der Aufruf von <xref:System.AppDomain.CreateInstance%2A> dann erfolgreich abgeschlossen, und der Konstruktor für `MyDynamicType` eine Nachricht in der Konsole angezeigt.  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> beginnt mit einem Leerzeichen oder enthält einen Schrägstrich oder umgekehrten Schrägstrich.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Die eindeutige Identität der dynamischen Assembly.</param>
        <param name="access">Der Modus, in dem auf die dynamische Assembly zugegriffen wird.</param>
        <param name="dir">Der Name des Verzeichnisses, in dem die Assembly gespeichert wird. Wenn <paramref name="dir" /><see langword="null" /> ist, wird das aktuelle Verzeichnis als Standardverzeichnis verwendet.</param>
        <summary>Definiert eine dynamische Assembly mit dem angegebenen Namen, Zugriffsmodus und Speicherverzeichnis.</summary>
        <returns>Eine dynamische Assembly mit dem angegebenen Namen und Funktionen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte nur verwendet werden, um eine dynamische Assembly in der aktuellen Anwendungsdomäne zu definieren. Weitere Informationen finden Sie unter den <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
> [!NOTE]
>  Bei der Entwicklung von Code, der dynamische Assemblys ausgibt, wird empfohlen, dass Sie eine Überladung der verwenden die <xref:System.AppDomain.DefineDynamicAssembly%2A> -Methode, Beweise und Berechtigungen angeben, die Beweise, die die dynamische Assembly, und enthalten soll <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Einschließlich <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in die `refusedPermissions` Parameter wird sichergestellt, dass die MSIL nicht überprüft wird. Eine Einschränkung dieser Technik ist, dass dadurch auch <xref:System.Security.SecurityException> ausgelöst wird, wenn Sie mit Code verwendet, die volle Vertrauenswürdigkeit erforderlich.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.AppDomain.DefineDynamicAssembly%2A> Methode und <xref:System.AppDomain.AssemblyResolve> Ereignis.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen angeben. Informationen dazu, wie Sie den vollqualifizierten Assemblynamen abzurufen, finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> beginnt mit einem Leerzeichen oder enthält einen Schrägstrich oder umgekehrten Schrägstrich.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; * System.Security.SecurityContextSource -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="name">Die eindeutige Identität der dynamischen Assembly.</param>
        <param name="access">Der Zugriffsmodus für die dynamische Assembly.</param>
        <param name="assemblyAttributes">Eine aufzählbare Liste von Attributen, die auf die Assembly angewendet werden sollen, oder <see langword="null" />, wenn keine Attribute vorhanden sind.</param>
        <param name="securityContextSource">Die Quelle des Sicherheitskontexts.</param>
        <summary>Definiert eine dynamische Assembly mit dem angegebenen Namen, Zugriffsmodus und benutzerdefinierten Attributen und verwendet die angegebene Quelle für den Sicherheitskontext.</summary>
        <returns>Eine dynamische Assembly mit dem angegebenen Namen und Funktionen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese methodenüberladung, um die Attribute angeben, die funktionieren nicht richtig, es sei denn, sie angewendet werden, wenn eine dynamische Assembly erstellt wird. Z. B. Sicherheitsattribute wie z. B. <xref:System.Security.SecurityTransparentAttribute> und <xref:System.Security.SecurityCriticalAttribute> funktionieren nicht ordnungsgemäß, wenn sie hinzugefügt werden, nachdem eine dynamische Assembly erstellt wurde.  
  
 Diese Methode sollte nur zum Definieren einer dynamischen Assembly in der aktuellen Anwendungsdomäne verwendet werden. Weitere Informationen zu dieser Einschränkung finden Sie unter den <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> beginnt mit Leerraum, oder sie enthält einen Schrägstrich bzw. einen umgekehrten Schrägstrich.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert von <paramref name="securityContextSource" /> war keiner der Enumerationswerte.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of DefineDynamicAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">Die eindeutige Identität der dynamischen Assembly.</param>
        <param name="access">Der Modus, in dem auf die dynamische Assembly zugegriffen wird.</param>
        <param name="dir">Der Name des Verzeichnisses, in dem die Assembly gespeichert wird. Wenn <paramref name="dir" /><see langword="null" /> ist, wird das aktuelle Verzeichnis als Standardverzeichnis verwendet.</param>
        <param name="evidence">Der für die dynamische Assembly angegebene Beweis. Der Beweis wird ohne Änderungen als endgültiger Satz von Beweisen für die Richtlinienauflösung verwendet.</param>
        <summary>Definiert eine dynamische Assembly mit dem angegebenen Namen, Zugriffsmodus, Speicherverzeichnis und Beweis.</summary>
        <returns>Eine dynamische Assembly mit dem angegebenen Namen und Funktionen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur vollständig vertrauenswürdige Aufrufer können angeben, deren `evidence` beim Definieren einer dynamischen <xref:System.Reflection.Assembly>. Die Common Language Runtime ordnet die <xref:System.Security.Policy.Evidence> durch die Sicherheitsrichtlinien, um zu bestimmen, die gewährten Berechtigungen. Teilweise vertrauenswürdige Aufrufer müssen ein NULL-Wert angeben `evidence`. Wenn `evidence` ist `null`, die Runtime kopiert die Berechtigungssätze, d. h. die aktuelle GRANT- und deny-Mengen von des Aufrufers <xref:System.Reflection.Assembly> an den dynamischen <xref:System.Reflection.Assembly> definiert wird, und kennzeichnet die Richtlinie als aufgelöst.  
  
 Wenn die dynamische <xref:System.Reflection.Assembly> ist auf dem Datenträger gespeichert, nachfolgende lädt erhalten gewährt, die basierend auf Richtlinien, die die Position zugeordnet, in denen die <xref:System.Reflection.Assembly> wurde gespeichert.  
  
 Diese Methode sollte nur verwendet werden, um eine dynamische Assembly in der aktuellen Anwendungsdomäne zu definieren. Weitere Informationen finden Sie unter den <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
> [!NOTE]
>  Bei der Entwicklung von Code, der dynamische Assemblys ausgibt, wird empfohlen, dass Sie eine Überladung der verwenden die <xref:System.AppDomain.DefineDynamicAssembly%2A> -Methode, Beweise und Berechtigungen angeben, die Beweise, die die dynamische Assembly, und enthalten soll <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Einschließlich <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in die `refusedPermissions` Parameter wird sichergestellt, dass die MSIL nicht überprüft wird. Eine Einschränkung dieser Technik ist, dass dadurch auch <xref:System.Security.SecurityException> ausgelöst wird, wenn Sie mit Code verwendet, die volle Vertrauenswürdigkeit erforderlich.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.AppDomain.DefineDynamicAssembly%2A> Methode und <xref:System.AppDomain.AssemblyResolve> Ereignis.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen angeben. Informationen dazu, wie Sie den vollqualifizierten Assemblynamen abzurufen, finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> beginnt mit einem Leerzeichen oder enthält einen Schrägstrich oder umgekehrten Schrägstrich.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Die eindeutige Identität der dynamischen Assembly.</param>
        <param name="access">Der Modus, in dem auf die dynamische Assembly zugegriffen wird.</param>
        <param name="requiredPermissions">Die erforderliche Berechtigungsanforderung.</param>
        <param name="optionalPermissions">Die optionale Berechtigungsanforderung.</param>
        <param name="refusedPermissions">Die verweigerte Berechtigungsanforderung.</param>
        <summary>Definiert eine dynamische Assembly mit dem angegebenem Namen, Zugriffsmodus und den angegebenen Berechtigungsanforderungen.</summary>
        <returns>Eine dynamische Assembly mit dem angegebenen Namen und Funktionen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die berechtigungsanforderungen für angegebene `requiredPermissions`, `optionalPermissions`, und `refusedPermissions` werden nicht verwendet werden, es sei denn, die dynamische Assembly gespeichert und wieder in den Arbeitsspeicher geladen wurde. Berechtigungsanforderungen für eine flüchtige Assembly angeben, die noch nicht gespeichert ist, auf die Festplatte, und verwenden Sie eine Überladung von der <xref:System.AppDomain.DefineDynamicAssembly%2A> -Methode, Beweise und die angeforderten Berechtigungen, und geben eine <xref:System.Security.Policy.Evidence> Objekt.  
  
> [!NOTE]
>  Bei der Entwicklung von Code, der dynamische Assemblys ausgibt, wird empfohlen, dass Sie eine Überladung der verwenden die <xref:System.AppDomain.DefineDynamicAssembly%2A> -Methode, Beweise und Berechtigungen angeben, die Beweise, die die dynamische Assembly, und enthalten soll <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Einschließlich <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in die `refusedPermissions` Parameter wird sichergestellt, dass die MSIL nicht überprüft wird. Eine Einschränkung dieser Technik ist, dass dadurch auch <xref:System.Security.SecurityException> ausgelöst wird, wenn Sie mit Code verwendet, die volle Vertrauenswürdigkeit erforderlich.  
  
 Diese Methode sollte nur verwendet werden, um eine dynamische Assembly in der aktuellen Anwendungsdomäne zu definieren. Weitere Informationen finden Sie unter den <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.AppDomain.DefineDynamicAssembly%2A> Methode und <xref:System.AppDomain.AssemblyResolve> Ereignis.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen angeben. Informationen dazu, wie Sie den vollqualifizierten Assemblynamen abzurufen, finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> beginnt mit einem Leerzeichen oder enthält einen Schrägstrich oder umgekehrten Schrägstrich.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, isSynchronized As Boolean, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">Die eindeutige Identität der dynamischen Assembly.</param>
        <param name="access">Der Modus, in dem auf die dynamische Assembly zugegriffen wird.</param>
        <param name="dir">Der Name des Verzeichnisses, in dem die dynamische Assembly gespeichert wird. Wenn <paramref name="dir" /> den Wert <see langword="null" /> hat, wird das aktuelle Verzeichnis verwendet.</param>
        <param name="isSynchronized">
          <see langword="true" />, wenn das Erstellen von Modulen, Typen und Membern der dynamischen Assembly synchronisiert werden soll, andernfalls <see langword="false" />.</param>
        <param name="assemblyAttributes">Eine aufzählbare Liste von Attributen, die auf die Assembly angewendet werden sollen, oder <see langword="null" />, wenn keine Attribute vorhanden sind.</param>
        <summary>Definiert eine dynamische Assembly mit dem angegebenen Namen, Zugriffsmodus, Speicherverzeichnis und der Synchronisierungsoption.</summary>
        <returns>Eine dynamische Assembly mit dem angegebenen Namen und Funktionen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese methodenüberladung, um die Attribute angeben, die funktionieren nicht richtig, es sei denn, sie angewendet werden, wenn eine dynamische Assembly erstellt wird. Z. B. Sicherheitsattribute wie z. B. <xref:System.Security.SecurityTransparentAttribute> und <xref:System.Security.SecurityCriticalAttribute> funktionieren nicht ordnungsgemäß, wenn sie hinzugefügt werden, nachdem eine dynamische Assembly erstellt wurde.  
  
 Wenn `isSynchronized` ist `true`, die folgenden Methoden der resultierenden <xref:System.Reflection.Emit.AssemblyBuilder> synchronisiert werden: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, und <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Wenn zwei dieser Methoden in verschiedenen Threads aufgerufen werden, wird einer blockiert, bis die andere abgeschlossen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> beginnt mit Leerraum, oder sie enthält einen Schrägstrich bzw. einen umgekehrten Schrägstrich.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Die eindeutige Identität der dynamischen Assembly.</param>
        <param name="access">Der Modus, in dem auf die dynamische Assembly zugegriffen wird.</param>
        <param name="evidence">Der für die dynamische Assembly angegebene Beweis. Der Beweis wird ohne Änderungen als endgültiger Satz von Beweisen für die Richtlinienauflösung verwendet.</param>
        <param name="requiredPermissions">Die erforderliche Berechtigungsanforderung.</param>
        <param name="optionalPermissions">Die optionale Berechtigungsanforderung.</param>
        <param name="refusedPermissions">Die verweigerte Berechtigungsanforderung.</param>
        <summary>Definiert eine dynamische Assembly mit dem angegebenen Namen, Zugriffsmodus, Beweis und den angegebenen Berechtigungsanforderungen.</summary>
        <returns>Eine dynamische Assembly mit dem angegebenen Namen und Funktionen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die berechtigungsanforderungen für angegebene `requiredPermissions`, `optionalPermissions`, und `refusedPermissions` werden nur verwendet, wenn `evidence` ebenfalls angegeben wird, oder wenn die dynamische Assembly gespeichert und wieder in den Arbeitsspeicher geladen.  
  
> [!NOTE]
>  Bei der Entwicklung von Code, der dynamische Assemblys ausgibt, wird empfohlen, die Sie einschließen <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Einschließlich <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in die `refusedPermissions` Parameter wird sichergestellt, dass die MSIL nicht überprüft wird. Eine Einschränkung dieser Technik ist, dass dadurch auch <xref:System.Security.SecurityException> ausgelöst wird, wenn Sie mit Code verwendet, die volle Vertrauenswürdigkeit erforderlich.  
  
 Nur vollständig vertrauenswürdige Aufrufer können angeben, deren `evidence` beim Definieren einer dynamischen <xref:System.Reflection.Assembly>. Die Common Language Runtime ordnet die <xref:System.Security.Policy.Evidence> durch die Sicherheitsrichtlinien, um zu bestimmen, die gewährten Berechtigungen. Teilweise vertrauenswürdige Aufrufer müssen ein NULL-Wert angeben `evidence`. Wenn `evidence` ist `null`, die Runtime kopiert die Berechtigungssätze, d. h. die aktuelle GRANT- und deny-Mengen von des Aufrufers <xref:System.Reflection.Assembly> an den dynamischen <xref:System.Reflection.Assembly> definiert wird, und kennzeichnet die Richtlinie als aufgelöst.  
  
 Wenn die dynamische <xref:System.Reflection.Assembly> ist auf dem Datenträger gespeichert, nachfolgende lädt erhalten gewährt, die basierend auf Richtlinien, die die Position zugeordnet, in denen die <xref:System.Reflection.Assembly> wurde gespeichert.  
  
 Diese Methode sollte nur verwendet werden, um eine dynamische Assembly in der aktuellen Anwendungsdomäne zu definieren. Weitere Informationen finden Sie unter den <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.AppDomain.DefineDynamicAssembly%2A> Methode und <xref:System.AppDomain.AssemblyResolve> Ereignis.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen angeben. Informationen dazu, wie Sie den vollqualifizierten Assemblynamen abzurufen, finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> beginnt mit einem Leerzeichen oder enthält einen Schrägstrich oder umgekehrten Schrägstrich.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Die eindeutige Identität der dynamischen Assembly.</param>
        <param name="access">Der Modus, in dem auf die dynamische Assembly zugegriffen wird.</param>
        <param name="dir">Der Name des Verzeichnisses, in dem die Assembly gespeichert wird. Wenn <paramref name="dir" /><see langword="null" /> ist, wird das aktuelle Verzeichnis als Standardverzeichnis verwendet.</param>
        <param name="requiredPermissions">Die erforderliche Berechtigungsanforderung.</param>
        <param name="optionalPermissions">Die optionale Berechtigungsanforderung.</param>
        <param name="refusedPermissions">Die verweigerte Berechtigungsanforderung.</param>
        <summary>Definiert eine dynamische Assembly mit dem angegebenen Namen, Zugriffsmodus, Speicherverzeichnis und den angegebenen Berechtigungsanforderungen.</summary>
        <returns>Eine dynamische Assembly mit dem angegebenen Namen und Funktionen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die berechtigungsanforderungen für angegebene `requiredPermissions`, `optionalPermissions`, und `refusedPermissions` werden nicht verwendet werden, es sei denn, die dynamische Assembly gespeichert und wieder in den Arbeitsspeicher geladen wurde. Berechtigungsanforderungen für eine flüchtige Assembly angeben, die noch nicht gespeichert ist, auf die Festplatte, und verwenden Sie eine Überladung von der <xref:System.AppDomain.DefineDynamicAssembly%2A> -Methode, Beweise und die angeforderten Berechtigungen, und geben eine <xref:System.Security.Policy.Evidence> Objekt.  
  
> [!NOTE]
>  Bei der Entwicklung von Code, der dynamische Assemblys ausgibt, wird empfohlen, dass Sie eine Überladung der verwenden die <xref:System.AppDomain.DefineDynamicAssembly%2A> -Methode, Beweise und Berechtigungen angeben, die Beweise, die die dynamische Assembly, und enthalten soll <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Einschließlich <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in die `refusedPermissions` Parameter wird sichergestellt, dass die MSIL nicht überprüft wird. Eine Einschränkung dieser Technik ist, dass dadurch auch <xref:System.Security.SecurityException> ausgelöst wird, wenn Sie mit Code verwendet, die volle Vertrauenswürdigkeit erforderlich.  
  
 Diese Methode sollte nur verwendet werden, um eine dynamische Assembly in der aktuellen Anwendungsdomäne zu definieren. Weitere Informationen finden Sie unter den <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.AppDomain.DefineDynamicAssembly%2A> Methode und <xref:System.AppDomain.AssemblyResolve> Ereignis.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen angeben. Informationen dazu, wie Sie den vollqualifizierten Assemblynamen abzurufen, finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> beginnt mit einem Leerzeichen oder enthält einen Schrägstrich oder umgekehrten Schrägstrich.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  Please see http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Die eindeutige Identität der dynamischen Assembly.</param>
        <param name="access">Der Modus, in dem auf die dynamische Assembly zugegriffen wird.</param>
        <param name="dir">Der Name des Verzeichnisses, in dem die Assembly gespeichert wird. Wenn <paramref name="dir" /><see langword="null" /> ist, wird das aktuelle Verzeichnis als Standardverzeichnis verwendet.</param>
        <param name="evidence">Der für die dynamische Assembly angegebene Beweis. Der Beweis wird ohne Änderungen als endgültiger Satz von Beweisen für die Richtlinienauflösung verwendet.</param>
        <param name="requiredPermissions">Die erforderliche Berechtigungsanforderung.</param>
        <param name="optionalPermissions">Die optionale Berechtigungsanforderung.</param>
        <param name="refusedPermissions">Die verweigerte Berechtigungsanforderung.</param>
        <summary>Definiert eine dynamische Assembly mit dem angegebenen Namen, Zugriffsmodus, Speicherverzeichnis, Beweis und den angegebenen Berechtigungsanforderungen.</summary>
        <returns>Eine dynamische Assembly mit dem angegebenen Namen und Funktionen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die berechtigungsanforderungen für angegebene `requiredPermissions`, `optionalPermissions`, und `refusedPermissions` werden nur verwendet, wenn `evidence` ebenfalls angegeben wird, oder wenn die dynamische Assembly gespeichert und wieder in den Arbeitsspeicher geladen.  
  
> [!NOTE]
>  Bei der Entwicklung von Code, der dynamische Assemblys ausgibt, wird empfohlen, die Sie einschließen <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Einschließlich <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in die `refusedPermissions` Parameter wird sichergestellt, dass die MSIL nicht überprüft wird. Eine Einschränkung dieser Technik ist, dass dadurch auch <xref:System.Security.SecurityException> ausgelöst wird, wenn Sie mit Code verwendet, die volle Vertrauenswürdigkeit erforderlich.  
  
 Nur vollständig vertrauenswürdige Aufrufer können angeben, deren `evidence` beim Definieren einer dynamischen <xref:System.Reflection.Assembly>. Die Common Language Runtime ordnet die <xref:System.Security.Policy.Evidence> durch die Sicherheitsrichtlinien, um zu bestimmen, die gewährten Berechtigungen. Teilweise vertrauenswürdige Aufrufer müssen ein NULL-Wert angeben `evidence`. Wenn `evidence` ist `null`, die Runtime kopiert die Berechtigungssätze, d. h. die aktuelle GRANT- und deny-Mengen von des Aufrufers <xref:System.Reflection.Assembly> an den dynamischen <xref:System.Reflection.Assembly> definiert wird, und kennzeichnet die Richtlinie als aufgelöst.  
  
 Wenn die dynamische <xref:System.Reflection.Assembly> ist auf dem Datenträger gespeichert, nachfolgende lädt erhalten gewährt, die basierend auf Richtlinien, die die Position zugeordnet, in denen die <xref:System.Reflection.Assembly> wurde gespeichert.  
  
 Diese Methode sollte nur verwendet werden, um eine dynamische Assembly in der aktuellen Anwendungsdomäne zu definieren. Weitere Informationen finden Sie unter den <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.AppDomain.DefineDynamicAssembly%2A> Methode und <xref:System.AppDomain.AssemblyResolve> Ereignis.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen angeben. Informationen dazu, wie Sie den vollqualifizierten Assemblynamen abzurufen, finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> beginnt mit einem Leerzeichen oder enthält einen Schrägstrich oder umgekehrten Schrägstrich.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Die eindeutige Identität der dynamischen Assembly.</param>
        <param name="access">Der Modus, in dem auf die dynamische Assembly zugegriffen wird.</param>
        <param name="dir">Der Name des Verzeichnisses, in dem die dynamische Assembly gespeichert wird. Wenn <paramref name="dir" /><see langword="null" /> ist, wird das aktuelle Verzeichnis als Standardverzeichnis verwendet.</param>
        <param name="evidence">Der für die dynamische Assembly angegebene Beweis. Der Beweis wird ohne Änderungen als endgültiger Satz von Beweisen für die Richtlinienauflösung verwendet.</param>
        <param name="requiredPermissions">Die erforderliche Berechtigungsanforderung.</param>
        <param name="optionalPermissions">Die optionale Berechtigungsanforderung.</param>
        <param name="refusedPermissions">Die verweigerte Berechtigungsanforderung.</param>
        <param name="isSynchronized">
          <see langword="true" />, wenn das Erstellen von Modulen, Typen und Membern der dynamischen Assembly synchronisiert werden soll, andernfalls <see langword="false" />.</param>
        <summary>Definiert eine dynamische Assembly mit dem angegebenen Namen, Zugriffsmodus, Speicherverzeichnis, Beweis sowie der angegebenen Synchronisierungsoption und den angegebenen Berechtigungsanforderungen.</summary>
        <returns>Eine dynamische Assembly mit dem angegebenen Namen und Funktionen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die berechtigungsanforderungen für angegebene `requiredPermissions`, `optionalPermissions`, und `refusedPermissions` werden nur verwendet, wenn `evidence` ebenfalls angegeben wird, oder wenn die dynamische Assembly gespeichert und wieder in den Arbeitsspeicher geladen.  
  
> [!NOTE]
>  Bei der Entwicklung von Code, der dynamische Assemblys ausgibt, wird empfohlen, die Sie einschließen <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Einschließlich <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in die `refusedPermissions` Parameter wird sichergestellt, dass die MSIL nicht überprüft wird. Eine Einschränkung dieser Technik ist, dass dadurch auch <xref:System.Security.SecurityException> ausgelöst wird, wenn Sie mit Code verwendet, die volle Vertrauenswürdigkeit erforderlich.  
  
 Nur voll vertrauenswürdige Aufrufer ihre Beweise, beim Definieren einer dynamischen angeben können <xref:System.Reflection.Assembly>. Die Common Language Runtime ordnet die <xref:System.Security.Policy.Evidence> durch die Sicherheitsrichtlinien, um zu bestimmen, die gewährten Berechtigungen. Teilweise vertrauenswürdige Aufrufer angeben müssen `null` für die `evidence` Parameter. Wenn `evidence` ist `null`, die Runtime kopiert die Berechtigungssätze, d. h. die aktuelle GRANT- und deny-Mengen von des Aufrufers <xref:System.Reflection.Assembly> an den dynamischen <xref:System.Reflection.Assembly> definiert wird, und kennzeichnet die Richtlinie als aufgelöst.  
  
 Wenn die dynamische <xref:System.Reflection.Assembly> ist auf dem Datenträger gespeichert, nachfolgende lädt erhalten gewährt, die basierend auf Richtlinien, die die Position zugeordnet, in denen die <xref:System.Reflection.Assembly> wurde gespeichert.  
  
 Wenn `isSynchronized` ist `true`, die folgenden Methoden der resultierenden <xref:System.Reflection.Emit.AssemblyBuilder> synchronisiert werden: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, und <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Wenn zwei dieser Methoden in verschiedenen Threads aufgerufen werden, wird einer blockiert, bis die andere abgeschlossen ist.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.AppDomain.DefineDynamicAssembly%2A> Methode und <xref:System.AppDomain.AssemblyResolve> Ereignis.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen angeben. Informationen dazu, wie Sie den vollqualifizierten Assemblynamen abzurufen, finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> beginnt mit einem Leerzeichen oder enthält einen Schrägstrich oder umgekehrten Schrägstrich.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">Die eindeutige Identität der dynamischen Assembly.</param>
        <param name="access">Der Modus, in dem auf die dynamische Assembly zugegriffen wird.</param>
        <param name="dir">Der Name des Verzeichnisses, in dem die dynamische Assembly gespeichert wird. Wenn <paramref name="dir" /> den Wert <see langword="null" /> hat, wird das aktuelle Verzeichnis verwendet.</param>
        <param name="evidence">Der für die dynamische Assembly angegebene Beweis. Der Beweis wird ohne Änderungen als endgültiger Satz von Beweisen für die Richtlinienauflösung verwendet.</param>
        <param name="requiredPermissions">Die erforderliche Berechtigungsanforderung.</param>
        <param name="optionalPermissions">Die optionale Berechtigungsanforderung.</param>
        <param name="refusedPermissions">Die verweigerte Berechtigungsanforderung.</param>
        <param name="isSynchronized">
          <see langword="true" />, wenn das Erstellen von Modulen, Typen und Membern der dynamischen Assembly synchronisiert werden soll, andernfalls <see langword="false" />.</param>
        <param name="assemblyAttributes">Eine aufzählbare Liste von Attributen, die auf die Assembly angewendet werden sollen, oder <see langword="null" />, wenn keine Attribute vorhanden sind.</param>
        <summary>Definiert eine dynamische Assembly mit dem angegebenen Namen, Zugriffsmodus, Speicherverzeichnis, Beweis sowie der angegebenen Synchronisierungsoption und den angegebenen Berechtigungsanforderungen und benutzerdefinierten Attributen.</summary>
        <returns>Eine dynamische Assembly mit dem angegebenen Namen und Funktionen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese methodenüberladung, um die Attribute angeben, die funktionieren nicht richtig, es sei denn, sie angewendet werden, wenn eine dynamische Assembly erstellt wird. Z. B. Sicherheitsattribute wie z. B. <xref:System.Security.SecurityTransparentAttribute> und <xref:System.Security.SecurityCriticalAttribute> funktionieren nicht ordnungsgemäß, wenn sie hinzugefügt werden, nachdem eine dynamische Assembly erstellt wurde.  
  
 Die berechtigungsanforderungen für angegebene die `requiredPermissions`, `optionalPermissions`, und `refusedPermissions` Parameter werden verwendet, nur dann, wenn die `evidence` Parameter ebenfalls angegeben wird, oder wenn die dynamische Assembly gespeichert und wieder in den Arbeitsspeicher geladen.  
  
> [!NOTE]
>  Wenn Sie Code, die dynamische Assemblys ausgibt entwickeln, empfohlen, dass Sie die <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> -flag in der `refusedPermissions` Parameter. Die Einbeziehung dieses Flags stellt sicher, dass die Microsoft intermediate Language (MSIL) überprüft wird. Diese Methode erkennt die unbeabsichtigte Generierung von nicht überprüfbarem Code, die andernfalls nur sehr schwer entdeckt wird. Eine Einschränkung dieser Technik ist, dass dadurch auch <xref:System.Security.SecurityException> ausgelöst wird, wenn sie mit Code verwendet wird, die volle Vertrauenswürdigkeit erforderlich.  
  
 Nur voll vertrauenswürdige Aufrufer Beweise, beim Definieren einer dynamischen angeben können <xref:System.Reflection.Assembly>. Die Common Language Runtime ordnet die <xref:System.Security.Policy.Evidence> durch die Sicherheitsrichtlinien, um zu bestimmen, die gewährten Berechtigungen. Teilweise vertrauenswürdige Aufrufer angeben müssen `null` für die `evidence` Parameter. Wenn `evidence` ist `null`, die Runtime die Berechtigungssätze (das ist, den aktuellen Berechtigungssatz und verweigerten Berechtigungen) aus der Assembly des Aufrufers kopiert, auf die dynamische Assembly, die definiert wird, und kennzeichnet die Richtlinie als aufgelöst.  
  
 Wenn die dynamische Assembly, auf dem Datenträger, nachfolgende gespeichert wird lädt erhalten gewährt, die basierend auf Richtlinien, die die Position zugeordnet sind, in dem die dynamische Assembly gespeichert wurde.  
  
 Wenn `isSynchronized` ist `true`, die folgenden Methoden der resultierenden <xref:System.Reflection.Emit.AssemblyBuilder> synchronisiert werden: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, und <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Wenn zwei dieser Methoden in verschiedenen Threads aufgerufen werden, wird einer blockiert, bis die andere abgeschlossen ist.  
  
 Diese methodenüberladung wird eingeführt, der [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> ist <see langword="null" />.  
  
- oder -  
Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> beginnt mit Leerraum, oder sie enthält einen Schrägstrich bzw. einen umgekehrten Schrägstrich.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DoCallBack (callBackDelegate As CrossAppDomainDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DoCallBack(CrossAppDomainDelegate ^ callBackDelegate);" />
      <MemberSignature Language="F#" Value="abstract member DoCallBack : CrossAppDomainDelegate -&gt; unit&#xA;override this.DoCallBack : CrossAppDomainDelegate -&gt; unit" Usage="appDomain.DoCallBack callBackDelegate" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DoCallBack(System.CrossAppDomainDelegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" />
      </Parameters>
      <Docs>
        <param name="callBackDelegate">Ein Delegat, der eine aufzurufende Methode angibt.</param>
        <summary>Führt den Code in einer anderen Anwendungsdomäne aus, die durch den angegebenen Delegaten bezeichnet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `callBackDelegate` Geben Sie eine Marshal-by-Value, können <xref:System.MarshalByRefObject>, oder <xref:System.ContextBoundObject>.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die Verwendung eines statisches <xref:System.AppDomain.DoCallBack%2A> Methode.  
  
 [!code-cpp[AppDomain_DoCallBack#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_static.cpp#1)]
 [!code-csharp[AppDomain_DoCallBack#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_static.cs#1)]
 [!code-vb[AppDomain_DoCallBack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_static.vb#1)]  
  
 Im folgende Beispiel veranschaulicht die Verwendung der <xref:System.AppDomain.DoCallBack%2A> Methode als Wert.  
  
 [!code-cpp[AppDomain_DoCallBack#2](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byval.cpp#2)]
 [!code-csharp[AppDomain_DoCallBack#2](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byval.cs#2)]
 [!code-vb[AppDomain_DoCallBack#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byval.vb#2)]  
  
 Im folgende Beispiel veranschaulicht die Verwendung der <xref:System.AppDomain.DoCallBack%2A> Methode als Verweis.  
  
 [!code-cpp[AppDomain_DoCallBack#3](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byref.cpp#3)]
 [!code-csharp[AppDomain_DoCallBack#3](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byref.cs#3)]
 [!code-vb[AppDomain_DoCallBack#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byref.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBackDelegate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DomainManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainManager As AppDomainManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainManager ^ DomainManager { AppDomainManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainManager : AppDomainManager" Usage="System.AppDomain.DomainManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Domänen-Manager ab, der beim Initialisieren der Anwendungsdomäne vom Host bereitgestellt wurde.</summary>
        <value>Ein Objekt, das den Domänen-Manager darstellt, der beim Initialisieren der Anwendungsdomäne vom Host bereitgestellt wurde, oder <see langword="null" />, wenn kein Domänen-Manager bereitgestellt wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein nicht verwalteter Host der common Language Runtime (CLR) bieten einen Domänen-Manager. Der Domänen-Manager beim Initialisieren der neuen Anwendungsdomäne teilnehmen kann, und geben Sie anderen Managern, wie z. B. eine <xref:System.Security.HostSecurityManager>, die die Vorgänge der Anwendungsdomäne Teil.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.DomainUnload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DomainUnload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ DomainUnload;" />
      <MemberSignature Language="F#" Value="member this.DomainUnload : EventHandler " Usage="member this.DomainUnload : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.DomainUnload</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn eine <see cref="T:System.AppDomain" /> gerade entladen werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.EventHandler> Delegat für dieses Ereignis beliebige Abschlussaufgaben durchführen kann, bevor die Anwendungsdomäne entladen wird.  
  
 Jede Anwendungsdomäne, die zum Ausführen der Verarbeitung, wenn es entladen wird, sollten einen Ereignishandler für dieses Ereignis registrieren. Gemeinsamen Ereignishandler sollte nicht verwendet werden, da die <xref:System.EventHandler> Delegat gibt nicht an, die Domäne, die entladen wird.  
  
> [!NOTE]
>  Dieses Ereignis wird in der Standardanwendungsdomäne niemals ausgelöst.  
  
 Nehmen Sie keine Annahmen über den Thread, die, dem auf das Ereignis ausgelöst wird. Das Ereignis kann ausgelöst werden, in einem anderen Thread als dem, der aufgerufen der <xref:System.AppDomain.Unload%2A> Methode.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DynamicDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicDirectory : string" Usage="System.AppDomain.DynamicDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.DynamicDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Verzeichnis ab, das der Assemblyresolver für die Suche nach dynamisch erstellten Assemblys verwendet.</summary>
        <value>Das Verzeichnis, das der Assemblyresolver für die Suche nach dynamisch erstellten Assemblys verwendet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um das dynamische Verzeichnis festzulegen, weisen Sie einen Basis Verzeichnispfad für die <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> Eigenschaft der <xref:System.AppDomainSetup> -Objekt, das zum Erstellen der neuen Anwendungsdomäne verwendet werden. Der Pfad des Basisverzeichnisses, Sie der Eigenschaft weisen, wird geändert, indem zusätzlich ein Unterverzeichnis, deren einfacher Name ist, den Hashcode, der die Zeichenfolge, die Sie zuweisen, die <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> -Eigenschaft, sodass das Format des Basisverzeichnisses ist *Originalpfad* \\ *Hashcode*. Das dynamische Verzeichnis ist ein Unterverzeichnis von diesem Verzeichnis. Der einfache Name ist der Wert des der <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> -Eigenschaft, sodass dessen Format *Originalpfad*\\*Hashcode*\\*Anwendungsname*.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Anwendungsdomäne mit einem Verzeichnis für dynamische Assemblys gibt eine dynamische Assembly und speichert sie in das dynamische Verzeichnis, und lädt die Assembly in der neuen Anwendungsdomäne und anschließend wird verwendet.  
  
 Das Beispiel erstellt eine <xref:System.AppDomainSetup> -Objekt und legt seine <xref:System.AppDomainSetup.ApplicationName%2A> Eigenschaft "Example" und die zugehörige <xref:System.AppDomainSetup.DynamicBase%2A> Eigenschaft auf "C:\DynamicAssemblyDir". Das Beispiel zeigt, klicken Sie dann die <xref:System.AppDomainSetup.DynamicBase%2A> -Eigenschaft, um anzugeben, dass es sich bei der Hashcode, der den Namen der Anwendung als Unterverzeichnis des Pfades angefügt wurde, der ursprünglich zugeordnet wurde.  
  
> [!NOTE]
>  Das Basisverzeichnis in diesem Beispiel soll werden außerhalb des Suchpfads für die exemplarische Anwendung befindet. Achten Sie darauf, dass Sie das Beispiel in einem anderen Speicherort zu kompilieren. Löschen Sie das Basisverzeichnis und allen seinen Unterverzeichnisse jedes Mal, wenn Sie das Beispiel ausführen.  
  
 Das Beispiel erstellt eine neue Anwendungsdomäne mit der <xref:System.AppDomainSetup> Objekt. Im Beispiel wird die <xref:System.AppDomain.DynamicDirectory%2A> Eigenschaft, um den Namen des Verzeichnisses abzurufen, um das Verzeichnis erstellen zu können. (Im Beispiel kann ganz einfach das Verzeichnis im Voraus erstellen durch Verketten der ursprüngliche Pfad, der den Hashcode, der den Namen der Anwendung und den Namen der Anwendung.)  
  
 Das Beispiel enthält eine `GenerateDynamicAssembly` -Methode, die eine Assembly Namens gibt `DynamicHelloWorld.dll` und speichert sie in der neuen Anwendungsdomäne dynamische-Verzeichnis. Die dynamische Assembly enthält einen Typ, `HelloWorld`, die eine statische Methode hat (`Shared` Methode in Visual Basic) mit dem Namen `HelloFromAD`. Das Aufrufen dieser Methode zeigt den Namen der Anwendungsdomäne.  
  
 Die `Example` Klasse leitet sich von <xref:System.MarshalByRefObject>, damit das Beispiel eine Instanz der Klasse in der neuen Anwendungsdomäne und rufen erstellen kann der `Test` Methode. Die `Test` Methode lädt die dynamische Assembly anhand des Anzeigenamens und ruft die statische `HelloFromAD` Methode.  
  
 Sie können anzeigen, dass das dynamische Verzeichnis nach der Prüfpfade durchsucht wird, durch das Schreiben von Code für eine Assembly mit dem Namen `DynamicHelloWorld.dll` und im gleichen Verzeichnis wie in diesem Beispiel kompilieren. Die Assembly muss eine Klasse namens verfügen `HelloWorld` mit einer statischen Methode, die mit dem Namen `HelloFromAD`. Diese Methode muss nicht die gleiche Funktionalität wie das im Beispiel; Sie können einfach eine Zeichenfolge in der Konsole anzeigen. Die Assembly benötigen auch eine <xref:System.Reflection.AssemblyVersionAttribute> -Attribut, das die Version auf 1.0.0.0 festlegt. Wenn Sie das Beispiel ausführen, befindet die Assembly, die Sie im aktuellen Verzeichnis kompiliert, bevor das dynamische Verzeichnis durchsucht wird.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Pfadinformationen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.AppDomain.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Security.Policy.Evidence" /> ab, der dieser Anwendungsdomäne zugeordnet ist.</summary>
        <value>Der dieser Anwendungsdomäne zugeordnete Beweis.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt die Assembly in der angegebenen Datei aus.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string -&gt; int&#xA;override this.ExecuteAssembly : string -&gt; int" Usage="appDomain.ExecuteAssembly assemblyFile" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name der Datei mit der auszuführenden Assembly.</param>
        <summary>Führt die Assembly in der angegebenen Datei aus.</summary>
        <returns>Der vom Einstiegspunkt der Assembly zurückgegebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Assembly beginnt in der Einstiegspunkt in .NET Framework-Header angegeben.  
  
 Diese Methode erstellt einen neuen Prozess oder eine Anwendungsdomäne nicht, und es wird die Einstiegspunktmethode nicht auf einem neuen Thread ausgeführt.  
  
 Diese Methode lädt Assemblys, die mit der <xref:System.Reflection.Assembly.LoadFile%2A> Methode. Sie können auch ausführen, Assemblys mit der <xref:System.AppDomain.ExecuteAssemblyByName%2A> -Methode, die Laden von Assemblys mit der <xref:System.Reflection.Assembly.Load%2A> Methode.  
  
 Zum Erstellen der <xref:System.AppDomain> zum Laden und ausführen, verwenden Sie die <xref:System.AppDomain.CreateDomain%2A> Methode.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die Verwendung einer der Überladungen der <xref:System.AppDomain.ExecuteAssembly%2A> in zwei verschiedenen Domänen.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyFile" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.MissingMethodException">Die angegebene Assembly verfügt über keinen Einstiegspunkt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder Verzeichnis und für den Zugriff auf die Informationen im Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">für das Lesen von eines URIS, der nicht mit "file://" beginnt.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Um eine Konsolenanwendung auszuführen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name der Datei mit der auszuführenden Assembly.</param>
        <param name="assemblySecurity">Beweis für das Laden der Assembly.</param>
        <summary>Führt die Assembly in der angegebenen Datei unter Verwendung der angegebenen Beweise aus.</summary>
        <returns>Der vom Einstiegspunkt der Assembly zurückgegebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Assembly beginnt in der Einstiegspunkt in .NET Framework-Header angegeben.  
  
 Die <xref:System.AppDomain.ExecuteAssembly%2A> Methode erstellt keinen, einen neuen Prozess oder eine Anwendungsdomäne, und es wird die Einstiegspunktmethode nicht auf einem neuen Thread ausgeführt.  
  
 Diese Methode lädt Assemblys, die mit der <xref:System.Reflection.Assembly.LoadFile%2A> Methode. Sie können auch ausführen, Assemblys mit der <xref:System.AppDomain.ExecuteAssemblyByName%2A> -Methode, die Laden von Assemblys mit der <xref:System.Reflection.Assembly.Load%2A> Methode.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die Verwendung einer der Überladungen der <xref:System.AppDomain.ExecuteAssembly%2A> in zwei verschiedenen Domänen.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyFile" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.MissingMethodException">Die angegebene Assembly verfügt über keinen Einstiegspunkt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder Verzeichnis und für den Zugriff auf die Informationen im Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">für das Lesen von eines URIS, der nicht mit "file://" beginnt.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Um eine Konsolenanwendung auszuführen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name der Datei mit der auszuführenden Assembly.</param>
        <param name="args">Die Argumente für den Einstiegspunkt der Assembly.</param>
        <summary>Führt die Assembly in der angegebenen Datei unter Verwendung der angegebenen Argumente aus.</summary>
        <returns>Der vom Einstiegspunkt der Assembly zurückgegebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Assembly beginnt in der Einstiegspunkt in .NET Framework-Header angegeben.  
  
 Diese Methode erstellt einen neuen Prozess oder eine Anwendungsdomäne nicht, und es wird die Einstiegspunktmethode nicht auf einem neuen Thread ausgeführt.  
  
 Diese Methode lädt Assemblys, die mit der <xref:System.Reflection.Assembly.LoadFile%2A> Methode. Sie können auch ausführen, Assemblys mit der <xref:System.AppDomain.ExecuteAssemblyByName%2A> -Methode, die Laden von Assemblys mit der <xref:System.Reflection.Assembly.Load%2A> Methode.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die Verwendung einer der Überladungen der <xref:System.AppDomain.ExecuteAssembly%2A> in zwei verschiedenen Domänen.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
- oder -  
 <paramref name="assemblyFile" /> wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.MissingMethodException">Die angegebene Assembly verfügt über keinen Einstiegspunkt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder Verzeichnis und für den Zugriff auf die Informationen im Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">für das Lesen von eines URIS, der nicht mit "file://" beginnt.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Um eine Konsolenanwendung auszuführen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name der Datei mit der auszuführenden Assembly.</param>
        <param name="assemblySecurity">Der angegebene Beweis für die Assembly.</param>
        <param name="args">Die Argumente für den Einstiegspunkt der Assembly.</param>
        <summary>Führt die Assembly in der angegebenen Datei unter Verwendung der angegebenen Beweise und Argumente aus.</summary>
        <returns>Der vom Einstiegspunkt der Assembly zurückgegebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Assembly beginnt in der Einstiegspunkt in .NET Framework-Header angegeben.  
  
 Diese Methode erstellt einen neuen Prozess oder eine Anwendungsdomäne nicht, und es wird die Einstiegspunktmethode nicht auf einem neuen Thread ausgeführt.  
  
 Diese Methode lädt Assemblys, die mit der <xref:System.Reflection.Assembly.LoadFile%2A> Methode. Sie können auch ausführen, Assemblys mit der <xref:System.AppDomain.ExecuteAssemblyByName%2A> -Methode, die Laden von Assemblys mit der <xref:System.Reflection.Assembly.Load%2A> Methode.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die Verwendung einer der Überladungen der <xref:System.AppDomain.ExecuteAssembly%2A> in zwei verschiedenen Domänen.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyFile" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> ist nicht <see langword="null" />. Wenn die Legacy-CAS-Richtlinie nicht aktiviert ist, sollte <paramref name="assemblySecurity" /> dem Wert <see langword="null" /> entsprechen.</exception>
        <exception cref="T:System.MissingMethodException">Die angegebene Assembly verfügt über keinen Einstiegspunkt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder Verzeichnis und für den Zugriff auf die Informationen im Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">für das Lesen von eines URIS, der nicht mit "file://" beginnt.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Um eine Konsolenanwendung auszuführen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name der Datei mit der auszuführenden Assembly.</param>
        <param name="args">Die Argumente für den Einstiegspunkt der Assembly.</param>
        <param name="hashValue">Stellt den Wert des errechneten Hashcodes dar.</param>
        <param name="hashAlgorithm">Stellt den vom Assemblymanifest verwendeten Hashalgorithmus dar.</param>
        <summary>Führt die Assembly in der angegebenen Datei unter Verwendung der angegebenen Argumente, des Hashwerts und Hashalgorithmus aus.</summary>
        <returns>Der vom Einstiegspunkt der Assembly zurückgegebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Assembly beginnt in der Einstiegspunkt in .NET Framework-Header angegeben.  
  
 Diese Methode erstellt einen neuen Prozess oder eine Anwendungsdomäne nicht, und es wird die Einstiegspunktmethode nicht auf einem neuen Thread ausgeführt.  
  
 Diese Methode lädt Assemblys, die mit der <xref:System.Reflection.Assembly.LoadFile%2A> Methode. Sie können auch ausführen, Assemblys mit der <xref:System.AppDomain.ExecuteAssemblyByName%2A> -Methode, die Laden von Assemblys mit der <xref:System.Reflection.Assembly.Load%2A> Methode.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die Verwendung einer der Überladungen der <xref:System.AppDomain.ExecuteAssembly%2A> in zwei verschiedenen Domänen.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
- oder -  
 <paramref name="assemblyFile" /> wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.MissingMethodException">Die angegebene Assembly verfügt über keinen Einstiegspunkt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder Verzeichnis und für den Zugriff auf die Informationen im Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">für das Lesen von eines URIS, der nicht mit "file://" beginnt.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Um eine Konsolenanwendung auszuführen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name der Datei mit der auszuführenden Assembly.</param>
        <param name="assemblySecurity">Der angegebene Beweis für die Assembly.</param>
        <param name="args">Die Argumente für den Einstiegspunkt der Assembly.</param>
        <param name="hashValue">Stellt den Wert des errechneten Hashcodes dar.</param>
        <param name="hashAlgorithm">Stellt den vom Assemblymanifest verwendeten Hashalgorithmus dar.</param>
        <summary>Führt die Assembly in der angegebenen Datei unter Verwendung der angegebenen Beweise, Argumente, des Hashwerts und Hashalgorithmus aus.</summary>
        <returns>Der vom Einstiegspunkt der Assembly zurückgegebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Assembly beginnt in der Einstiegspunkt in .NET Framework-Header angegeben.  
  
 Diese Methode erstellt einen neuen Prozess oder eine Anwendungsdomäne nicht, und es wird die Einstiegspunktmethode nicht auf einem neuen Thread ausgeführt.  
  
 Diese Methode lädt Assemblys, die mit der <xref:System.Reflection.Assembly.LoadFile%2A> Methode. Sie können auch ausführen, Assemblys mit der <xref:System.AppDomain.ExecuteAssemblyByName%2A> -Methode, die Laden von Assemblys mit der <xref:System.Reflection.Assembly.Load%2A> Methode.  
  
   
  
## Examples  
 Folgende Beispiel veranschaulicht die Verwendung einer der Überladungen der <xref:System.AppDomain.ExecuteAssembly%2A> in zwei verschiedenen Domänen.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyFile" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> ist nicht <see langword="null" />. Wenn die Legacy-CAS-Richtlinie nicht aktiviert ist, sollte <paramref name="assemblySecurity" /> dem Wert <see langword="null" /> entsprechen.</exception>
        <exception cref="T:System.MissingMethodException">Die angegebene Assembly verfügt über keinen Einstiegspunkt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder Verzeichnis und für den Zugriff auf die Informationen im Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">für das Lesen von eines URIS, der nicht mit "file://" beginnt.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Um eine Konsolenanwendung auszuführen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssemblyByName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt eine Assembly aus.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string -&gt; int" Usage="appDomain.ExecuteAssemblyByName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Führt eine Assembly unter Angabe ihres Anzeigenamens aus.</summary>
        <returns>Der vom Einstiegspunkt der Assembly zurückgegebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.AppDomain.ExecuteAssemblyByName%2A> Methode bietet ähnliche Funktionen wie die <xref:System.AppDomain.ExecuteAssembly%2A> -Methode, gibt jedoch die Assembly anhand des Anzeigenamens oder <xref:System.Reflection.AssemblyName> statt über den Dateispeicherort. Aus diesem Grund <xref:System.AppDomain.ExecuteAssemblyByName%2A> lädt Assemblys, mit der <xref:System.Reflection.Assembly.Load%2A> Methode und nicht mit der <xref:System.Reflection.Assembly.LoadFile%2A> Methode.  
  
 Die Assembly beginnt in der Einstiegspunkt in .NET Framework-Header angegeben.  
  
 Diese Methode erstellt einen neuen Prozess oder eine Anwendungsdomäne nicht, und es wird die Einstiegspunktmethode nicht auf einem neuen Thread ausgeführt.  
  
 Zum Erstellen der <xref:System.AppDomain> zum Laden und ausführen, verwenden Sie die <xref:System.AppDomain.CreateDomain%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die durch <paramref name="assemblyName" /> angegebene Assembly wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException">Die durch <paramref name="assemblyName" /> angegebene Assembly ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyName" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Die durch <paramref name="assemblyName" /> angegebene Assembly wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.MissingMethodException">Die angegebene Assembly verfügt über keinen Einstiegspunkt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder eines Verzeichnisses, für den Zugriff auf die Informationen im Pfad selbst und für einen Anzeigenamen in einen Pfad umleiten. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf eine Website, wenn Sie ein Anzeigenamen an eine URL umgeleitet wird.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Um eine Konsolenanwendung auszuführen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Ein <see cref="T:System.Reflection.AssemblyName" />-Objekt, das den Namen der Assembly darstellt.</param>
        <param name="args">Befehlszeilenargumente, die beim Starten des Prozesses übergeben werden sollen.</param>
        <summary>Führt bei Angabe eines <see cref="T:System.Reflection.AssemblyName" /> die Assembly mit den angegebenen Argumenten aus.</summary>
        <returns>Der vom Einstiegspunkt der Assembly zurückgegebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.AppDomain.ExecuteAssemblyByName%2A> Methode bietet ähnliche Funktionen wie die <xref:System.AppDomain.ExecuteAssembly%2A> -Methode, gibt jedoch die Assembly anhand des Anzeigenamens oder <xref:System.Reflection.AssemblyName> statt über den Dateispeicherort. Aus diesem Grund <xref:System.AppDomain.ExecuteAssemblyByName%2A> lädt Assemblys, mit der <xref:System.Reflection.Assembly.Load%2A> Methode und nicht mit der <xref:System.Reflection.Assembly.LoadFile%2A> Methode.  
  
 Die Assembly beginnt in der Einstiegspunkt in .NET Framework-Header angegeben.  
  
 Diese Methode erstellt einen neuen Prozess oder eine Anwendungsdomäne nicht, und es wird die Einstiegspunktmethode nicht auf einem neuen Thread ausgeführt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Die durch <paramref name="assemblyName" /> angegebene Assembly wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException">Die durch <paramref name="assemblyName" /> angegebene Assembly wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException">Die durch <paramref name="assemblyName" /> angegebene Assembly ist keine gültige Assembly.  
  
- oder -  
 <paramref name="assemblyName" /> wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.MissingMethodException">Die angegebene Assembly verfügt über keinen Einstiegspunkt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder eines Verzeichnisses, für den Zugriff auf die Informationen im Pfad selbst und für einen Anzeigenamen in einen Pfad umleiten. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf eine Website, wenn Sie ein Anzeigenamen an eine URL umgeleitet wird.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Um eine Konsolenanwendung auszuführen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Beweis für das Laden der Assembly.</param>
        <summary>Führt eine Assembly unter Angabe ihres Anzeigenamens mit dem angegebenen Beweis aus.</summary>
        <returns>Der vom Einstiegspunkt der Assembly zurückgegebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.AppDomain.ExecuteAssemblyByName%2A> Methode bietet ähnliche Funktionen wie die <xref:System.AppDomain.ExecuteAssembly%2A> -Methode, gibt jedoch die Assembly anhand des Anzeigenamens oder <xref:System.Reflection.AssemblyName> statt über den Dateispeicherort. Aus diesem Grund <xref:System.AppDomain.ExecuteAssemblyByName%2A> lädt Assemblys, mit der <xref:System.Reflection.Assembly.Load%2A> Methode und nicht mit der <xref:System.Reflection.Assembly.LoadFile%2A> Methode.  
  
 Die Assembly beginnt in der Einstiegspunkt in .NET Framework-Header angegeben.  
  
 Die <xref:System.AppDomain.ExecuteAssemblyByName%2A> Methode erstellt keinen, einen neuen Prozess oder eine Anwendungsdomäne, und es wird die Einstiegspunktmethode nicht auf einem neuen Thread ausgeführt.  
  
> [!NOTE]
>  Bei Verwendung der <xref:System.AppDomain.ExecuteAssemblyByName%2A> -Methode mit einer <xref:System.Security.Policy.Evidence> Parameter Beweise werden zusammengeführt. Beweise, die als Argument an die <xref:System.AppDomain.ExecuteAssemblyByName%2A> Methode ersetzen vom Ladeprogramm bereitgestellte Beweise.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die durch <paramref name="assemblyName" /> angegebene Assembly wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException">Die durch <paramref name="assemblyName" /> angegebene Assembly wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException">Die durch <paramref name="assemblyName" /> angegebene Assembly ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyName" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.MissingMethodException">Die angegebene Assembly verfügt über keinen Einstiegspunkt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder eines Verzeichnisses, für den Zugriff auf die Informationen im Pfad selbst und für einen Anzeigenamen in einen Pfad umleiten. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf eine Website, wenn Sie ein Anzeigenamen an eine URL umgeleitet wird.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Um eine Konsolenanwendung auszuführen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="args">Befehlszeilenargumente, die beim Starten des Prozesses übergeben werden sollen.</param>
        <summary>Führt die Assembly unter Angabe ihres Anzeigenamens mit den angegebenen Argumenten aus.</summary>
        <returns>Der vom Einstiegspunkt der Assembly zurückgegebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.AppDomain.ExecuteAssemblyByName%2A> Methode bietet ähnliche Funktionen wie die <xref:System.AppDomain.ExecuteAssembly%2A> -Methode, gibt jedoch die Assembly anhand des Anzeigenamens oder <xref:System.Reflection.AssemblyName> statt über den Dateispeicherort. Aus diesem Grund <xref:System.AppDomain.ExecuteAssemblyByName%2A> lädt Assemblys, mit der <xref:System.Reflection.Assembly.Load%2A> Methode und nicht mit der <xref:System.Reflection.Assembly.LoadFile%2A> Methode.  
  
 Die Assembly beginnt in der Einstiegspunkt in .NET Framework-Header angegeben.  
  
 Diese Methode erstellt einen neuen Prozess oder eine Anwendungsdomäne nicht, und es wird die Einstiegspunktmethode nicht auf einem neuen Thread ausgeführt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die durch <paramref name="assemblyName" /> angegebene Assembly wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException">Die durch <paramref name="assemblyName" /> angegebene Assembly wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException">Die durch <paramref name="assemblyName" /> angegebene Assembly ist keine gültige Assembly.  
  
- oder -  
 <paramref name="assemblyName" /> wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.MissingMethodException">Die angegebene Assembly verfügt über keinen Einstiegspunkt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder eines Verzeichnisses, für den Zugriff auf die Informationen im Pfad selbst und für einen Anzeigenamen in einen Pfad umleiten. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf eine Website, wenn Sie ein Anzeigenamen an eine URL umgeleitet wird.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Um eine Konsolenanwendung auszuführen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Ein <see cref="T:System.Reflection.AssemblyName" />-Objekt, das den Namen der Assembly darstellt.</param>
        <param name="assemblySecurity">Beweis für das Laden der Assembly.</param>
        <param name="args">Befehlszeilenargumente, die beim Starten des Prozesses übergeben werden sollen.</param>
        <summary>Führt bei Angabe eines <see cref="T:System.Reflection.AssemblyName" /> die Assembly mit dem angegebenen Beweis und den angegebenen Argumenten aus.</summary>
        <returns>Der vom Einstiegspunkt der Assembly zurückgegebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.AppDomain.ExecuteAssemblyByName%2A> Methode bietet ähnliche Funktionen wie die <xref:System.AppDomain.ExecuteAssembly%2A> -Methode, gibt jedoch die Assembly anhand des Anzeigenamens oder <xref:System.Reflection.AssemblyName> statt über den Dateispeicherort. Aus diesem Grund <xref:System.AppDomain.ExecuteAssemblyByName%2A> lädt Assemblys, mit der <xref:System.Reflection.Assembly.Load%2A> Methode und nicht mit der <xref:System.Reflection.Assembly.LoadFile%2A> Methode.  
  
 Die Assembly beginnt in der Einstiegspunkt in .NET Framework-Header angegeben.  
  
 Diese Methode erstellt einen neuen Prozess oder eine Anwendungsdomäne nicht, und es wird die Einstiegspunktmethode nicht auf einem neuen Thread ausgeführt.  
  
> [!NOTE]
>  Bei Verwendung der <xref:System.AppDomain.ExecuteAssemblyByName%2A> -Methode mit einer <xref:System.Security.Policy.Evidence> Parameter Beweise werden zusammengeführt. Beweise, die als Argument an die <xref:System.AppDomain.ExecuteAssemblyByName%2A> Methode ersetzen vom Ladeprogramm bereitgestellte Beweise.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Die durch <paramref name="assemblyName" /> angegebene Assembly wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException">Die durch <paramref name="assemblyName" /> angegebene Assembly wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException">Die durch <paramref name="assemblyName" /> angegebene Assembly ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyName" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> ist nicht <see langword="null" />. Wenn die Legacy-CAS-Richtlinie nicht aktiviert ist, sollte <paramref name="assemblySecurity" /> dem Wert <see langword="null" /> entsprechen.</exception>
        <exception cref="T:System.MissingMethodException">Die angegebene Assembly verfügt über keinen Einstiegspunkt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder eines Verzeichnisses, für den Zugriff auf die Informationen im Pfad selbst und für einen Anzeigenamen in einen Pfad umleiten. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf eine Website, wenn Sie ein Anzeigenamen an eine URL umgeleitet wird.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Um eine Konsolenanwendung auszuführen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Beweis für das Laden der Assembly.</param>
        <param name="args">Befehlszeilenargumente, die beim Starten des Prozesses übergeben werden sollen.</param>
        <summary>Führt die Assembly unter Angabe ihres Anzeigenamens mit dem angegebenen Beweis und den angegebenen Argumenten aus.</summary>
        <returns>Der vom Einstiegspunkt der Assembly zurückgegebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.AppDomain.ExecuteAssemblyByName%2A> Methode bietet ähnliche Funktionen wie die <xref:System.AppDomain.ExecuteAssembly%2A> -Methode, gibt jedoch die Assembly anhand des Anzeigenamens oder <xref:System.Reflection.AssemblyName> statt über den Dateispeicherort. Aus diesem Grund <xref:System.AppDomain.ExecuteAssemblyByName%2A> lädt Assemblys, mit der <xref:System.Reflection.Assembly.Load%2A> Methode und nicht mit der <xref:System.Reflection.Assembly.LoadFile%2A> Methode.  
  
 Die Assembly beginnt in der Einstiegspunkt in .NET Framework-Header angegeben.  
  
 Diese Methode erstellt einen neuen Prozess oder eine Anwendungsdomäne nicht, und es wird die Einstiegspunktmethode nicht auf einem neuen Thread ausgeführt.  
  
> [!NOTE]
>  Bei Verwendung der <xref:System.AppDomain.ExecuteAssemblyByName%2A> -Methode mit einer <xref:System.Security.Policy.Evidence> Parameter Beweise werden zusammengeführt. Beweise, die als Argument an die <xref:System.AppDomain.ExecuteAssemblyByName%2A> Methode ersetzen vom Ladeprogramm bereitgestellte Beweise.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die durch <paramref name="assemblyName" /> angegebene Assembly wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException">Die durch <paramref name="assemblyName" /> angegebene Assembly wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException">Die durch <paramref name="assemblyName" /> angegebene Assembly ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyName" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> ist nicht <see langword="null" />. Wenn die Legacy-CAS-Richtlinie nicht aktiviert ist, sollte <paramref name="assemblySecurity" /> dem Wert <see langword="null" /> entsprechen.</exception>
        <exception cref="T:System.MissingMethodException">Die angegebene Assembly verfügt über keinen Einstiegspunkt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder eines Verzeichnisses, für den Zugriff auf die Informationen im Pfad selbst und für einen Anzeigenamen in einen Pfad umleiten. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf eine Website, wenn Sie ein Anzeigenamen an eine URL umgeleitet wird.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">Um eine Konsolenanwendung auszuführen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="FirstChanceException">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.FirstChanceException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FirstChanceException As EventHandler(Of FirstChanceExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Runtime::ExceptionServices::FirstChanceExceptionEventArgs ^&gt; ^ FirstChanceException;" />
      <MemberSignature Language="F#" Value="member this.FirstChanceException : EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " Usage="member this.FirstChanceException : System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Ausnahme in verwaltetem Code ausgelöst wird, bevor die Laufzeit in der Aufrufliste nach einem Ausnahmehandler in der Anwendungsdomäne sucht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis ist nur eine Benachrichtigung. Behandlung dieses Ereignisses nicht die Ausnahme behandeln oder Auswirkungen auf nachfolgende Ausnahmebehandlung in keiner Weise. Nachdem das Ereignis ausgelöst wurde, und Ereignishandler aufgerufen wurden, beginnt die common Language Runtime (CLR), suchen Sie nach einem Handler für die Ausnahme. <xref:System.AppDomain.FirstChanceException> Stellt die Anwendungsdomäne mit der ersten Möglichkeit, eine verwaltete Ausnahme zu untersuchen.  
  
 Das Ereignis kann pro Anwendungsdomäne behandelt werden. Wenn ein Thread über mehrere Anwendungsdomänen während der Ausführung von eines Aufrufs erfolgreich ist, wird das Ereignis in jeder Anwendungsdomäne ausgelöst, die einen Ereignishandler registriert wurden, bevor die CLR beginnt die Suche nach einer übereinstimmenden Ausnahmehandler in dieser Anwendungsdomäne. Nachdem das Ereignis behandelt wurde, erfolgt eine Suche für ein passender Ausnahmehandler in dieser Anwendungsdomäne. Wenn keiner gefunden wird, wird das Ereignis in der nächsten Anwendungsdomäne ausgelöst.  
  
 Sie müssen alle Ausnahmen, die im Ereignis-Handler für auftreten behandeln die <xref:System.AppDomain.FirstChanceException> Ereignis. Andernfalls <xref:System.AppDomain.FirstChanceException> ist rekursiv ausgelöst wird. Dies kann zu einem Stapelüberlauf und Beenden der Anwendung führen. Es wird empfohlen, dass Sie Ereignishandler für dieses Ereignis als eingeschränkte Ausführungsbereiche (CERs), implementieren, um zu verhindern, dass Ausnahmen wie z. B. Out-of-Memory- oder Stapelüberlauf infrastrukturbezogenen Auswirkungen auf den virtuellen Computer, während die Benachrichtigung für die Ausnahme ist verarbeitet werden.  
  
 Dieses Ereignis wird nicht ausgelöst, für Ausnahmen, die eine Beschädigung des Prozessstatus, z.B. zugriffsverletzungen, angeben, wenn der Ereignishandler sicherheitskritisch ist und für die <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> Attribut.  
  
 Die common Language Runtime hält Threadabbrüche, während dieser Benachrichtigungsereignis behandelt wird.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Reihe von Anwendungsdomänen, die mit dem Namen `AD0` über `AD3`, mit einem `Worker` Objekt in jeder Anwendungsdomäne. Jede `Worker` enthält einen Verweis auf die `Worker` Objekt in der nächsten Anwendungsdomäne, mit Ausnahme der `Worker` in der letzten Anwendungsdomäne. Die <xref:System.AppDomain.FirstChanceException> Ereignis erfolgt in allen Anwendungsdomänen außer `AD1`.  
  
> [!NOTE]
>  Zusätzlich zu diesem Beispiel, das Benachrichtigungen über Ausnahmefehler der ersten Chance in mehreren Anwendungsdomänen veranschaulicht wird, finden Sie einfache Anwendungsfälle in [wie: erste-Chance-Ausnahme-Benachrichtigungen empfangen](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md).  
  
 Wenn die Anwendungsdomänen erstellt wurden, ruft die Standardanwendungsdomäne die `TestException` Methode für die ersten Anwendungsdomäne. Jede `Worker` -Objekt ruft die `TestException` -Methode für die nächsten Anwendungsdomäne, bis die letzte `Worker` löst eine Ausnahme, die verarbeitet oder nicht behandelt wird. Daher alle Anwendungsdomänen, der aktuelle Thread durchläuft und `TestException` an den Stapel in jeder Anwendungsdomäne hinzugefügt wird.  
  
 Wenn die letzte `Worker` Objekt verarbeitet die Ausnahme, die <xref:System.AppDomain.FirstChanceException> Ereignis wird nur in der letzten Anwendungsdomäne ausgelöst. Die anderen Anwendungsdomänen bekommen nicht die Gelegenheit zur Behandlung von Ausnahmen, damit das Ereignis nicht ausgelöst wird.  
  
 Bei der letzten `Worker` Objekt behandelt nicht die Ausnahme, die <xref:System.AppDomain.FirstChanceException> Ereignis wird ausgelöst, in jeder Anwendungsdomäne, die einen Ereignishandler. Nach Abschluss der einzelnen Ereignishandler wird der Stapel entladen, bis die Ausnahme, die von der Standardanwendungsdomäne abgefangen wird fortgesetzt.  
  
> [!NOTE]
>  Ändern, um anzuzeigen, wie die Anzeige der Stapel wächst durch das das Ereignis ausgelöst wird, das näher und Annäherung an die Standardanwendungsdomäne, `e.Exception.Message` zu `e.Exception` in die `FirstChanceHandler` -Ereignishandler. Beachten Sie, dass bei `TestException` heißt über Anwendungsdomänen hinweg, es wird zweimal angezeigt: einmal für den Proxy und einmal für den Stub.  
  
 [!code-csharp[System.AppDomain.FirstChanceException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/cs/example.cs#1)]
 [!code-vb[System.AppDomain.FirstChanceException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="T:System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs" />
        <altmember cref="E:System.AppDomain.UnhandledException" />
        <related type="Article" href="https://msdn.microsoft.com/library/66f002b8-a97d-4a6e-a503-2cec01689113">Gewusst wie: Empfangen von Ausnahmebenachrichtigungen (erste Chance)</related>
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FriendlyName : string" Usage="System.AppDomain.FriendlyName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.FriendlyName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den angezeigten Namen dieser Anwendungsdomäne ab.</summary>
        <value>Der angezeigte Name dieser Anwendungsdomäne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der angezeigte Name der Standardanwendungsdomäne ist der Dateiname der ausführbaren Prozessdatei an. Ist z. B. wenn die ausführbare Datei verwendet, um den Prozess starten `"c:\MyAppDirectory\MyAssembly.exe"`, ist der Anzeigename, der die Standardanwendungsdomäne `"MyAssembly.exe"`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.AppDomain.FriendlyName%2A> Eigenschaft, um den Anzeigenamen des die aktuelle Anwendungsdomäne abzurufen. Für die Standardanwendungsdomäne ist der Anzeigename den Namen der ausführbaren Datei der Anwendung. Das Codebeispiel zeigt auch zusätzliche Informationen zur Anwendungsdomäne.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblies : unit -&gt; System.Reflection.Assembly[]&#xA;override this.GetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.GetAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die Assemblys ab, die in den Ausführungskontext dieser Anwendungsdomäne geladen wurden.</summary>
        <returns>Ein Array von Assemblys in dieser Anwendungsdomäne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.AppDomain.GetAssemblies%2A> Methode, um eine Liste aller Assemblys abzurufen, die in die Anwendungsdomäne geladen wurden. Anschließend werden die Assemblys in der Konsole angezeigt.  
  
 Um dieses Codebeispiel ausführen zu können, müssen Sie zum Erstellen einer Assembly mit dem Namen `CustomLibrary.dll`, oder ändern Sie den Assemblynamen, die an die <xref:System.AppDomain.GetAssemblies%2A> Methode.  
  
 [!code-cpp[ADGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetAssemblies/CPP/adgetassemblies.cpp#1)]
 [!code-csharp[ADGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetAssemblies/CS/adgetassemblies.cs#1)]
 [!code-vb[ADGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetAssemblies/VB/adgetassemblies.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetCurrentThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentThreadId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentThreadId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentThreadId : unit -&gt; int" Usage="System.AppDomain.GetCurrentThreadId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den aktuellen Threadbezeichner ab.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die als Bezeichner das aktuellen Threads verwendet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> -Eigenschaft, die stabil ist, auch wenn .NET Framework von einer Umgebung gehostet wird, die Fibers (also: schlanken Threads) unterstützt.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Diese Methode aufgerufen wird. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <altmember cref="T:System.Int32" />
        <altmember cref="P:System.Threading.Thread.ManagedThreadId" />
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetData(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetData : string -&gt; obj&#xA;override this.GetData : string -&gt; obj" Usage="appDomain.GetData name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetData(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name einer vordefinierten Anwendungsdomäneneigenschaft oder der Name einer von Ihnen definierten Anwendungsdomäneneigenschaft.</param>
        <summary>Ruft den in der aktuellen Anwendungsdomäne gespeicherten Wert für den angegebenen Namen ab.</summary>
        <returns>Der Wert der <paramref name="name" />-Eigenschaft oder <see langword="null" />, wenn die Eigenschaft nicht vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode können Sie den Wert eines Eintrags in einem internen Cache von Name-Daten-Paare abzurufen, die Eigenschaften dieser Instanz von beschreiben <xref:System.AppDomain>. Beachten Sie, dass der Vergleich `name` durch den Namen des Schlüssel-Wert-Paaren wird Groß-/Kleinschreibung beachtet.  
  
 Der Cache enthält automatisch die vordefinierten Systemdaten-Einträge, die eingefügt werden, wenn die Anwendungsdomäne erstellt wird. Sie können überprüfen, deren Werte mit den <xref:System.AppDomain.GetData%2A> -Methode oder einer entsprechenden <xref:System.AppDomainSetup> Eigenschaften.  
  
 Sie einfügen oder ändern Sie Ihre eigenen benutzerdefinierten Name-Daten-Paare, mit der <xref:System.AppDomain.SetData%2A> Methode und überprüfen Sie ihre Werte mit den <xref:System.AppDomain.GetData%2A> Methode.  
  
 Die folgende Tabelle beschreibt die `name` jedes vordefinierten Eintrag im Dateisystem und der entsprechenden <xref:System.AppDomainSetup> Eigenschaft.  
  
|Wert von 'Name'|Eigenschaft|  
|---------------------|--------------|  
|"ANWENDUNGSBASISVERZEICHNIS"|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>|  
|"APP_CONFIG_FILE"|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=nameWithType>|  
|"APP_LAUNCH_URL"|(keine Eigenschaft)<br /><br /> "APP_LAUNCH_URL" stellt dar, die durch den Benutzer vor allen umleitungen, die ursprünglich angeforderte URL. Es steht nur, wenn die Anwendung mit einem Browser wie Internet Explorer gestartet wurde. Geben Sie diesen Wert nicht von allen Browsern.|  
|"APP_NAME"|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>|  
|"BINPATH_PROBE_ONLY"|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=nameWithType>|  
|"CACHE_BASE"|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>|  
|"CODE_DOWNLOAD_DISABLED"|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>|  
|"DEV_PATH"|(keine Eigenschaft)|  
|"DISALLOW_APP"|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_BASE_PROBING"|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_REDIRECTS"|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=nameWithType>|  
|"DYNAMIC_BASE"|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>|  
|"FORCE_CACHE_INSTALL"|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>|  
|"LICENSE_FILE" oder eine anwendungsspezifische Zeichenfolge|<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=nameWithType>|  
|"LOADER_OPTIMIZATION"|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=nameWithType>|  
|"LOCATION_URI"|(keine Eigenschaft)|  
|"PRIVATE_BINPATH"|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>|  
|"REGEX_DEFAULT_MATCH_TIMEOUT"|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=nameWithType><br /><br /> "REGEX_DEFAULT_MATCH_TIMEOUT" ist kein Eintrag System, und der Wert kann festgelegt werden, durch den Aufruf der <xref:System.AppDomain.SetData%2A> Methode.|  
|"SHADOW_COPY_DIRS"|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>|  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine neue Anwendungsdomäne erstellt, legt einen Wert vom System bereitgestellten für die Domäne fest und fügt einen neuen Wert-Paar für die Domäne. Das Beispiel dann veranschaulicht, wie die <xref:System.AppDomain.GetData%2A> Methode, um die Daten aus diesen Wert-Paare abgerufen und in der Konsole angezeigt werden.  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Informationen in den Pfad selbst, wenn die Eigenschaft auf einen Pfad bezieht. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="M:System.AppDomain.SetData(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="appDomain.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den Typ der aktuellen Instanz ab.</summary>
        <returns>Der Typ der aktuellen Instanz.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.AppDomain.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Ganzzahl ab, die die Anwendungsdomäne innerhalb des Prozesses eindeutig identifiziert.</summary>
        <value>Eine Ganzzahl, die die Anwendungsdomäne identifiziert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird eine zweite Anwendungsdomäne erstellt und zeigt Informationen über die Standarddomäne und der neuen Domäne.  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InitializeLifetimeService();" />
      <MemberSignature Language="F#" Value="override this.InitializeLifetimeService : unit -&gt; obj" Usage="appDomain.InitializeLifetimeService " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.InitializeLifetimeService</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt zu einer unendlichen Lebensdauer der <see cref="T:System.AppDomain" />, indem das Erstellen eines Lease verhindert wird.</summary>
        <returns>Immer <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCompatibilitySwitchSet (value As String) As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; IsCompatibilitySwitchSet(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsCompatibilitySwitchSet : string -&gt; Nullable&lt;bool&gt;" Usage="appDomain.IsCompatibilitySwitchSet value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Der zu überprüfende Kompatibilitätsschalter.</param>
        <summary>Ruft einen booleschen Wert, der NULL-Werte zulässt, ab, der angibt, ob alle Kompatibilitätsschalter festgelegt werden und ob in diesem Fall der angegebene Kompatibilitätsschalter festgelegt wird.</summary>
        <returns>Ein NULL-Verweis (<see langword="Nothing" /> in Visual Basic), wenn keine Kompatibilitätsschalter festgelegt werden, andernfalls ein boolescher Wert, der angibt, ob der durch <paramref name="value" /> angegebene Kompatibilitätsschalter festgelegt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überprüft, ob der angegebene Kompatibilitätsschalter für die aktuelle Anwendungsdomäne festgelegt wurde. Kompatibilitätsoptionen in der Regel ein Verhalten wiederhergestellt werden (z. B. wie Zeichenfolgen sortiert werden), das zwischen Versionen von .NET Framework geändert wurde.  Sie werden festgelegt, durch den Aufruf der <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType> Methode vor dem Erstellen einer Anwendungsdomäne.  
  
 Die folgende Tabelle enthält Beispiele für Kompatibilitätsschalter, die festgelegt werden können, um das Verhalten früherer Versionen von .NET Framework wiederherzustellen.  
  
|Schalter|Bedeutung|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|Codezugriffssicherheit (CAS) für die [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] in dieser Anwendungsdomäne aktiviert ist. Finden Sie unter [ &lt;NetFx40_LegacySecurityPolicy&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).|  
|"NetFx40_Legacy20SortingBehavior"|Standardwerte für die zum Sortieren von Zeichenfolgen die [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] in dieser Anwendungsdomäne aktiviert sind. Ihr Erfolg erfordert sort00001000.dll installiert werden. Finden Sie unter [ &lt;CompatSortNLSVersion&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).|  
|"NetFx40_Legacy40SortingBehavior"|Standardwerte für die zum Sortieren von Zeichenfolgen die [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]und Unicode 5.0 in dieser Anwendungsdomäne aktiviert sind. Ihr Erfolg erfordert sort00060101.dll installiert werden.|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> Formatieren von Verhalten für die [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] in dieser Anwendungsdomäne aktiviert ist.  Finden Sie unter [ &lt;TimeSpan_LegacyFormatMode&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) und im Abschnitt "Wiederherstellen von Legacy TimeSpan Formatting" die <xref:System.TimeSpan> Thema.|  
|"UseRandomizedStringHashAlgorithm"|Die Common Language Runtime berechnet Hashcodes für Zeichenfolgen auf einer pro Anwendungsdomäne, anstatt einen einzelnen Hashalgorithmus, der einen konsistenten Hashcode über Anwendungsdomänen hinweg erzeugt. Finden Sie unter [ &lt;UseRandomizedStringHashAlgorithm&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsDefaultAppDomain" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDefaultAppDomain () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDefaultAppDomain();" />
      <MemberSignature Language="F#" Value="member this.IsDefaultAppDomain : unit -&gt; bool" Usage="appDomain.IsDefaultAppDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob die Anwendungsdomäne die Standardanwendungsdomäne für den Prozess ist.</summary>
        <returns>
          <see langword="true" />, wenn das aktuelle <see cref="T:System.AppDomain" />-Objekt die Standardanwendungsdomäne für den Prozess darstellt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder verwalteter Prozess verfügt über eine Standarddomäne für die Anwendung. Die Ausführung beginnt in der Standarddomäne.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine zweite Anwendungsdomäne erstellt und zeigt Informationen über die Standarddomäne und der neuen Domäne.  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsFinalizingForUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFinalizingForUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFinalizingForUnload();" />
      <MemberSignature Language="F#" Value="member this.IsFinalizingForUnload : unit -&gt; bool" Usage="appDomain.IsFinalizingForUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt an, ob diese Anwendungsdomäne entladen wird und ob die darin enthaltenen Objekte durch die Common Language Runtime finalisiert werden.</summary>
        <returns>
          <see langword="true" />, wenn die Anwendungsdomäne entladen wird und die Common Language Runtime mit dem Aufrufen von Finalizers begonnen hat, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Methode "Abschluss" für ein Objekt bietet Sie notwendige Bereinigungen ausführen, bevor das Objekt mit Garbage Collection durchgeführt wird. Nach der Finalisierung wird das Objekt zugegriffen werden kann, jedoch in einem ungültigen Zustand und kann daher nicht verwendet werden. Schließlich werden die Garbagecollection abgeschlossen ist und das Objekt freigegeben.  
  
 Eines Objekts Finalization-Methode wird aufgerufen, in einem der folgenden Situationen: während der Garbagecollection, wenn die common Language Runtime beendet wird oder wenn die Anwendungsdomäne mit dem Objekt entladen wird. Die <xref:System.AppDomain.IsFinalizingForUnload%2A> Methodenrückgabe `true` nur im letzten Fall; es werden keine zurückgegeben `true` Wenn Beendigung aus routinemäßigen Garbagecollection oder Herunterfahren der CLR führt.  
  
> [!NOTE]
>  Verwenden Sie zum bestimmen, ob die Beendigung aufgrund Herunterfahren der CLR ist die <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType> Eigenschaft. Es gibt `true` Wenn Finalization durch eine Anwendungsdomäne entladen wird, oder durch die CLR heruntergefahren wird.  
  
 Während der Ausführung in der Finalisierungsmethode Entladen der Domäne, empfiehlt es sich um ein anderes Objekt zugreifen, das, die von einem statischen Feld verwiesen wird, und verfügt über eine Methode für die Beendigung. Allerdings kann nicht zuverlässig möchten, weil das verwendete Objekt möglicherweise bereits beendet wurde.  
  
> [!NOTE]
>  Eine Ausnahme von dieser Regel wird die <xref:System.Console> -Klasse, die enthält statische Felder, die Streamobjekte verweisen, aber ist implementiert, besonders, sodass Sie immer noch beim Herunterfahren der Anwendungsdomäne entladen oder das System die Systemkonsole schreiben können.  
  
 Verwenden Sie diese Methode in ein Objekt der Finalization-Methode, um festzustellen, ob die Anwendungsdomäne mit dem Objekt entladen wird. Wenn dies der Fall ist, können nicht Sie zuverlässig jedes beliebige Objekt zugreifen, verfügt über eine Beendigung-Methode, und verweist auf ein statisches Feld.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Environment.HasShutdownStarted" />
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.AppDomain.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob in die aktuelle Anwendungsdomäne geladene Assemblys mit vollständiger Vertrauenswürdigkeit ausgeführt werden.</summary>
        <value>
          <see langword="true" />, wenn in die aktuelle Anwendungsdomäne geladene Assemblys mit voller Vertrauenswürdigkeit ausgeführt werden, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt immer `true` für die Standardanwendungsdomäne einer Anwendung, die auf dem Desktop ausgeführt wird. Gibt `false` für eine Sandbox-Anwendungsdomäne, die mithilfe der <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> Methode zu überladen, es sei denn, die Berechtigungen, die die Anwendungsdomäne gewährt werden, auf volle Vertrauenswürdigkeit entsprechen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.AppDomain.IsFullyTrusted%2A> Eigenschaft und die <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> Eigenschaft mit vollständig vertrauenswürdigen als auch teilweise vertrauenswürdigen Anwendungsdomänen. Die vollständig vertrauenswürdige Anwendungsdomäne ist die Standardanwendungsdomäne für die Anwendung. Die teilweise vertrauenswürdige Anwendungsdomäne wird erstellt, mit der <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> -methodenüberladung.  
  
 Im Beispiel wird eine `Worker` abgeleitete Klasse <xref:System.MarshalByRefObject>, sodass es über Anwendungsdomänengrenzen hinweg gemarshallt werden kann. Das Beispiel erstellt eine `Worker` Objekt in der Standardanwendungsdomäne. Es ruft dann die `TestIsFullyTrusted` -Methode zum Anzeigen des Eigenschaftswert für die Anwendungsdomäne und für zwei Assemblys, die in die Anwendungsdomäne geladen werden: "mscorlib", die Teil von .NET Framework und die Beispielassembly ist. Die Anwendungsdomäne vollständig vertrauenswürdig ist, damit beide Assemblys vollständig vertrauenswürdig sind.  
  
 Im Beispiel erstellen Sie eine weitere `Worker` -Objekt in einer Sandbox-Anwendungsdomäne und erneut auf Aufrufe der `TestIsFullyTrusted` Methode. "Mscorlib" wird auch in einer teilweise vertrauenswürdigen Anwendungsdomäne immer vertraut, aber die Beispielassembly ist teilweise vertrauenswürdig.  
  
 [!code-csharp[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/cs/example.cs#1)]
 [!code-vb[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsHomogenous" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHomogenous As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHomogenous { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHomogenous : bool" Usage="System.AppDomain.IsHomogenous" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die aktuelle Anwendungsdomäne einen Satz von Berechtigungen aufweist, der allen in die Anwendungsdomäne geladenen Assemblys gewährt wird.</summary>
        <value>
          <see langword="true" />, wenn die aktuelle Anwendungsdomäne einen homogenen Satz von Berechtigungen aufweist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt `true` für Sandbox-Anwendungsdomänen, die mithilfe von erstellt wurden die <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> -methodenüberladung. Sandbox-Anwendungsdomänen haben einen homogenen Satz von Berechtigungen. d. h. erhält der gleiche Satz von Berechtigungen auf alle teilweise vertrauenswürdigen Assemblys, die in die Anwendungsdomäne geladen werden. Eine Sandbox-Anwendungsdomäne hat optional eine Liste von Assemblys mit starkem Namen, die von dieser Berechtigung festgelegt und stattdessen mit voller Vertrauenswürdigkeit ausgeführt. ausgenommen sind.  
  
 Voll vertrauenswürdiger Code kann mithilfe der <xref:System.AppDomain.PermissionSet%2A> -Eigenschaft bestimmt den homogenen Berechtigungssatz einer Sandbox-Anwendungsdomäne.  
  
 Außerdem gibt diese Eigenschaft `true` für die Standardanwendungsdomäne einer Desktopanwendung, da dieser Anwendungsdomäne alle Assemblys volles Vertrauen gewährt.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomain.PermissionSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lädt eine <see cref="T:System.Reflection.Assembly" /> in diese Anwendungsdomäne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Ein Array vom Typ <see langword="byte" />, das ein COFF-Image mit einer ausgegebenen Assembly ist.</param>
        <summary>Lädt die <see cref="T:System.Reflection.Assembly" /> mit einem COFF-Image (Common Object File Format), das eine angegebene <see cref="T:System.Reflection.Assembly" /> enthält.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], entspricht die Vertrauensebene einer Assembly, die geladen wird, mithilfe dieser Methode die Vertrauensebene der Anwendungsdomäne.  
  
 Diese Methode sollte nur für das Laden einer Assembly in die aktuelle Anwendungsdomäne verwendet werden. Diese Methode wird zur Vereinfachung bereitgestellt, für die Interoperabilität mit Aufrufern, die die statische aufrufen können <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> Methode. Verwenden Sie zum Laden von Assemblys in anderen Anwendungsdomänen eine Methode ein, z. B. <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Informationen, die für alle Überladungen dieser Methode gemein sind, finden Sie unter den <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die Verwendung eine unformatierte Assembly laden.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen angeben. Informationen dazu, wie Sie den vollqualifizierten Assemblynamen abzurufen, finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="rawAssembly" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder Verzeichnis und für den Zugriff auf die Informationen im Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Ein Objekt, das die zu ladende Assembly beschreibt.</param>
        <summary>Lädt eine <see cref="T:System.Reflection.Assembly" /> bei Angabe ihres <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte nur für das Laden einer Assembly in die aktuelle Anwendungsdomäne verwendet werden. Diese Methode wird zur Vereinfachung bereitgestellt, für die Interoperabilität mit Aufrufern, die die statische aufrufen können <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> Methode. Verwenden Sie zum Laden von Assemblys in anderen Anwendungsdomänen eine Methode ein, z. B. <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Wenn bereits eine Version der angeforderten Assembly geladen wurde, gibt diese Methode die geladene Assembly, selbst wenn eine andere Version angefordert wird.  
  
 Einen partiellen Assemblynamen für die Angabe `assemblyRef` wird nicht empfohlen. (Ein Teil des Namens lässt eine oder mehrere der Kultur, Version oder Token des öffentlichen Schlüssels. Für Überladungen, die eine Zeichenfolge anstelle von einer <xref:System.Reflection.AssemblyName> Objekt "MyAssembly, Version = 1.0.0.0" ist ein Beispiel für einen Teil des Namens und "MyAssembly, Version = 1.0.0.0, Culture = Neutral, PublicKeyToken = 18ab3442da84b47" ist ein Beispiel eines vollständigen Namens.) Mithilfe von partiellen Namen verfügt über eine negative Auswirkung auf die Leistung aus. Darüber hinaus ein partiellen Assemblynamen kann laden eine Assembly aus dem globalen Assemblycache nur dann, wenn eine genaue Kopie der Assembly in das Anwendungsbasisverzeichnis (<xref:System.AppDomain.BaseDirectory%2A> oder <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>).  
  
 Wenn die aktuelle <xref:System.AppDomain> Objekt darstellt, die Anwendungsdomäne `A`, und die <xref:System.AppDomain.Load%2A> Methode wird aufgerufen, von der Anwendungsdomäne `B`, die Assembly wird in beide Anwendungsdomänen geladen. Beispielsweise der folgende code lädt `MyAssembly` in die neue Anwendungsdomäne `ChildDomain` und auch in der Anwendungsdomäne, in dem der Code ausgeführt wird:  
  
 [!code-cpp[System.AppDomain.Load#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.load/cpp/source.cpp#1)]
 [!code-csharp[System.AppDomain.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.load/cs/source.cs#1)]
 [!code-vb[System.AppDomain.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.load/vb/source.vb#1)]  
  
 Die Assembly wird in beiden Domänen geladen, da <xref:System.Reflection.Assembly> nicht von abgeleitet <xref:System.MarshalByRefObject>, und aus diesem Grund ist der Rückgabewert von der <xref:System.AppDomain.Load%2A> Methode nicht gemarshallt werden kann. Stattdessen versucht die common Language Runtime die Assembly in der aufrufenden Anwendungsdomäne geladen. Die Assemblys, die in den zwei Anwendungsdomänen geladen werden möglicherweise anders, wenn die Path-Einstellungen für die zwei Anwendungsdomänen unterscheiden.  
  
> [!NOTE]
>  Wenn beide die <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> Eigenschaft und die <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> Eigenschaft festgelegt werden, der erste Versuch zum Laden der Assembly verwendet den Anzeigenamen (einschließlich Version, Kultur und So weiter, vom der <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> Eigenschaft). Wenn die Datei nicht gefunden wird, die <xref:System.Reflection.AssemblyName.CodeBase%2A> Eigenschaft wird verwendet, um für die Assembly zu suchen. Wenn die Assembly gefunden wird, mithilfe von <xref:System.Reflection.AssemblyName.CodeBase%2A>, der Anzeigenamen der Assembly abgeglichen wird. Wenn die Übereinstimmung fehlschlägt, eine <xref:System.IO.FileLoadException> ausgelöst.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyRef" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder Verzeichnis und für den Zugriff auf die Informationen im Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="abstract member Load : string -&gt; System.Reflection.Assembly&#xA;override this.Load : string -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyString" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Lädt eine <see cref="T:System.Reflection.Assembly" /> bei Angabe ihres Anzeigenamens.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte nur für das Laden einer Assembly in die aktuelle Anwendungsdomäne verwendet werden. Diese Methode wird zur Vereinfachung bereitgestellt, für die Interoperabilität mit Aufrufern, die die statische aufrufen können <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> Methode. Verwenden Sie zum Laden von Assemblys in anderen Anwendungsdomänen eine Methode ein, z. B. <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Informationen, die für alle Überladungen dieser Methode gemein sind, finden Sie unter den <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> ist gleich <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyString" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder Verzeichnis und für den Zugriff auf die Informationen im Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Ein Array vom Typ <see langword="byte" />, das ein COFF-Image mit einer ausgegebenen Assembly ist.</param>
        <param name="rawSymbolStore">Ein Array vom Typ <see langword="byte" />, das die Rohdatenbytes enthält, die die Symbole für die Assembly darstellen.</param>
        <summary>Lädt die <see cref="T:System.Reflection.Assembly" /> mit einem COFF-Image (Common Object File Format), das eine angegebene <see cref="T:System.Reflection.Assembly" /> enthält. Die Rohdatenbytes, die die Symbole für die <see cref="T:System.Reflection.Assembly" /> darstellen, werden ebenfalls geladen.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], entspricht die Vertrauensebene einer Assembly, die geladen wird, mithilfe dieser Methode die Vertrauensebene der Anwendungsdomäne.  
  
 Diese Methode sollte nur für das Laden einer Assembly in die aktuelle Anwendungsdomäne verwendet werden. Diese Methode wird zur Vereinfachung bereitgestellt, für die Interoperabilität mit Aufrufern, die die statische aufrufen können <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> Methode. Verwenden Sie zum Laden von Assemblys in anderen Anwendungsdomänen eine Methode ein, z. B. <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Informationen, die für alle Überladungen dieser Methode gemein sind, finden Sie unter den <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die Verwendung eine unformatierte Assembly laden.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen angeben. Informationen dazu, wie Sie den vollqualifizierten Assemblynamen abzurufen, finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="rawAssembly" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Net.WebPermission">für das Lesen von eines URIS, der nicht mit "file://" beginnt.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder Verzeichnis und für den Zugriff auf die Informationen im Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Ein Objekt, das die zu ladende Assembly beschreibt.</param>
        <param name="assemblySecurity">Beweis für das Laden der Assembly.</param>
        <summary>Lädt eine <see cref="T:System.Reflection.Assembly" /> bei Angabe ihres <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte nur für das Laden einer Assembly in die aktuelle Anwendungsdomäne verwendet werden. Diese Methode wird zur Vereinfachung bereitgestellt, für die Interoperabilität mit Aufrufern, die die statische aufrufen können <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> Methode. Verwenden Sie zum Laden von Assemblys in anderen Anwendungsdomänen eine Methode ein, z. B. <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Informationen, die für alle Überladungen dieser Methode gemein sind, finden Sie unter den <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> ist gleich <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyRef" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder Verzeichnis und für den Zugriff auf die Informationen im Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Net.WebPermission">für das Lesen von eines Pfads, der nicht in der Form "file://" oder "\\\UNC\dir\\" oder "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Beweis für das Laden der Assembly.</param>
        <summary>Lädt eine <see cref="T:System.Reflection.Assembly" /> bei Angabe ihres Anzeigenamens.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte nur für das Laden einer Assembly in die aktuelle Anwendungsdomäne verwendet werden. Diese Methode wird zur Vereinfachung bereitgestellt, für die Interoperabilität mit Aufrufern, die die statische aufrufen können <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> Methode. Verwenden Sie zum Laden von Assemblys in anderen Anwendungsdomänen eine Methode ein, z. B. <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Informationen, die für alle Überladungen dieser Methode gemein sind, finden Sie unter den <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> ist gleich <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyString" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assemblys mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder Verzeichnis und für den Zugriff auf die Informationen im Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">für das Lesen von eines Pfads, der nicht in der Form "file://" oder "\\\UNC\dir\\" oder "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Ein Array vom Typ <see langword="byte" />, das ein COFF-Image mit einer ausgegebenen Assembly ist.</param>
        <param name="rawSymbolStore">Ein Array vom Typ <see langword="byte" />, das die Rohdatenbytes enthält, die die Symbole für die Assembly darstellen.</param>
        <param name="securityEvidence">Beweis für das Laden der Assembly.</param>
        <summary>Lädt die <see cref="T:System.Reflection.Assembly" /> mit einem COFF-Image (Common Object File Format), das eine angegebene <see cref="T:System.Reflection.Assembly" /> enthält. Die Rohdatenbytes, die die Symbole für die <see cref="T:System.Reflection.Assembly" /> darstellen, werden ebenfalls geladen.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], entspricht die Vertrauensebene einer Assembly, die geladen wird, mithilfe dieser Methode die Vertrauensebene der Anwendungsdomäne.  
  
 Diese Methode sollte nur für das Laden einer Assembly in die aktuelle Anwendungsdomäne verwendet werden. Diese Methode wird zur Vereinfachung bereitgestellt, für die Interoperabilität mit Aufrufern, die die statische aufrufen können <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> Methode. Verwenden Sie zum Laden von Assemblys in anderen Anwendungsdomänen eine Methode ein, z. B. <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Informationen, die für alle Überladungen dieser Methode gemein sind, finden Sie unter den <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die Verwendung eine unformatierte Assembly laden.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen angeben. Informationen dazu, wie Sie den vollqualifizierten Assemblynamen abzurufen, finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> ist keine gültige Assembly.  
  
- oder -  
Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="rawAssembly" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> ist nicht <see langword="null" />. Wenn die Legacy-CAS-Richtlinie nicht aktiviert ist, sollte <paramref name="securityEvidence" /> dem Wert <see langword="null" /> entsprechen.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Bereitstellen von Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder Verzeichnis und für den Zugriff auf die Informationen im Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">für das Lesen von eines Pfads, der nicht in der Form "file://" oder "\\\UNC\dir\\" oder "c:\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringIsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MonitoringIsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MonitoringIsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringIsEnabled : bool with get, set" Usage="System.AppDomain.MonitoringIsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob CPU- und Speicherüberwachung von Anwendungsdomänen für den aktuellen Prozess aktiviert ist, oder legt ihn fest. Wenn die Überwachung für einen Prozess aktiviert wurde, kann sie nicht deaktiviert werden.</summary>
        <value>
          <see langword="true" />, wenn die Überwachung aktiviert ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies `static` Eigenschaft (`Shared` Eigenschaft in Visual Basic) steuert die CPU- und speicherüberwachung von alle Anwendungsdomänen im Prozess.  
  
 Wenn Sie versuchen, diese Eigenschaft auf festgelegt `false`, <xref:System.ArgumentException> Ausnahme ausgelöst wird, selbst wenn der aktuelle Wert der Eigenschaft ist `false`.  
  
 Nachdem die Überwachung aktiviert ist, können Sie mithilfe der <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, und <xref:System.AppDomain.MonitoringTotalProcessorTime%2A> Instanzeigenschaften Überwachen der Nutzung von CPU und Arbeitsspeicher von einzelnen Anwendungsdomänen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der aktuelle Prozess hat versucht, dieser Eigenschaft den Wert <see langword="false" /> zuzuweisen.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">Überwachung von Anwendungsdomänenressourcen</related>
        <related type="Article" href="https://msdn.microsoft.com/library/02119ab6-1e91-448e-97ad-e7b2e5c4bbbd">&lt;AppdomainResourceMonitoring&gt; Element</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringSurvivedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringSurvivedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl von Bytes ab, die nach der letzten Auflistung noch vorhanden sind und auf die bekanntermaßen von der aktuellen Anwendungsdomäne verwiesen wird.</summary>
        <value>Die Anzahl der noch vorhandenen Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Statistiken werden mit jeder Garbagecollection aktualisiert. Allerdings sind sie mit Sicherheit erst nach einer vollständigen blockierenden Auflistung präzise sein. Tritt auf, d. h. eine Auflistung, die alle Generationen umfasst, und Beenden der Anwendung während der Auflistung, an. Z. B. die <xref:System.GC.Collect?displayProperty=nameWithType> -methodenüberladung, führt eine vollständige blockierende Auflistung. (Gleichzeitigen Auflistung erfolgt im Hintergrund und die Anwendung nicht blockiert.)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" />-Eigenschaft ist auf <see langword="false" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">Überwachung von Anwendungsdomänenressourcen</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MonitoringSurvivedProcessMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long MonitoringSurvivedProcessMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedProcessMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die gesamten Bytes ab, die nach der letzten Auflistung für alle Anwendungsdomänen im Prozess noch vorhanden sind.</summary>
        <value>Die Gesamtzahl der noch vorhandenen Bytes für den Prozess.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nachdem eine vollständige blockierende Auflistung verwaltet dieser Wert gibt die Anzahl der Bytes im Moment auf aufrechterhalten Heaps an. In der Nähe der Anzahl von gemeldet wird die <xref:System.GC.GetTotalMemory%2A> Methode. Nach einer kurzlebigen Auflistung stellt diese Zahl die Anzahl der Bytes aktuell weiterzuleitenden in kurzlebigen Generationen live.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" />-Eigenschaft ist auf <see langword="false" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">Überwachung von Anwendungsdomänenressourcen</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalAllocatedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringTotalAllocatedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalAllocatedMemorySize : int64" Usage="System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gesamtgröße in Bytes aller Speicherbelegungen ab, die von der Anwendungsdomäne seit der Erstellung vorgenommen wurden, ohne Subtraktion des freigegebenen Speichers.</summary>
        <value>Die Gesamtgröße aller Speicherbelegungen.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Die <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" />-Eigenschaft ist auf <see langword="false" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">Überwachung von Anwendungsdomänenressourcen</related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MonitoringTotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalProcessorTime : TimeSpan" Usage="System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die gesamte Prozessorzeit ab, die von allen Threads bei der Ausführung in der aktuellen Anwendungsdomäne seit Prozessstart genutzt wurde.</summary>
        <value>Gesamte Prozessorzeit für die aktuelle Anwendungsdomäne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Gesamtzeit, die gemeldet wird für eine Anwendungsdomäne enthält, die Zeit, die für jeden Thread im Prozess, in dieser Anwendungsdomäne ausgeführt wird.  
  
 Ein Thread, der nicht verwalteten Code aufruft, ist immer noch eine Anwendungsdomäne zugeordnet, und die CPU-Zeit für die Ausführung, die der nicht verwaltete Code für die Anwendungsdomäne gemeldet wird, in dem der Aufruf erfolgt ist.  
  
 Wenn ein Thread blockiert ist, oder im Ruhezustand, belegt er keine Prozessorzeit.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" />-Eigenschaft ist auf <see langword="false" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315">Überwachung von Anwendungsdomänenressourcen</related>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.AppDomain.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Berechtigungssatz einer Sandbox-Anwendungsdomäne ab.</summary>
        <value>Der Berechtigungssatz der Sandbox-Anwendungsdomäne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sandbox-Anwendungsdomänen, die mithilfe der <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> methodenüberladung einen homogenen Satz von Berechtigungen aufweisen, also der gleiche Satz von Berechtigungen erteilt alle teilweise vertrauenswürdigen Assemblys, die in die Anwendungsdomäne geladen werden. Eine Sandbox-Anwendungsdomäne hat optional eine Liste von Assemblys mit starkem Namen, die von dieser Berechtigung festgelegt und stattdessen mit voller Vertrauenswürdigkeit ausgeführt. ausgenommen sind.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="P:System.AppDomain.IsHomogenous" />
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ProcessExit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProcessExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ProcessExit;" />
      <MemberSignature Language="F#" Value="member this.ProcessExit : EventHandler " Usage="member this.ProcessExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ProcessExit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der übergeordnete Prozess der Standardanwendungsdomäne beendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.EventHandler> für dieses Ereignis Abschlussaufgaben z. B. das Schließen von Dateien durchführen, kann Freigeben von Speicher und so weiter, bevor der Prozess beendet.  
  
 Ab .NET Framework, Version 2.0 wird dieses Ereignis wird in jeder Anwendungsdomäne ausgelöst, der einen Ereignishandler registriert.  
  
> [!NOTE]
>  Die gesamte Ausführungszeit aller <xref:System.AppDomain.ProcessExit> -Ereignishandler ist, genau wie die gesamte Ausführungszeit aller Finalizer beim Beenden des Prozesses beschränkt ist. Der Standardwert ist zwei Sekunden. Ein nicht verwalteter Host kann diesen Zeitpunkt der Ausführung ändern, durch den Aufruf der [ICLRPolicyManager:: SetTimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md) -Methode mit dem [OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md) Enumerationswert.  
  
 In der .NET Framework-Versionen 1.0 und 1.1 wird dieses Ereignis wird nur in der Standardanwendungsdomäne ausgelöst, und nur dann, wenn ein Ereignishandler in der Standardanwendungsdomäne registriert ist.  
  
 Um einen Ereignishandler für dieses Ereignis zu registrieren, benötigen Sie die erforderlichen Berechtigungen, oder ein <xref:System.Security.SecurityException> ausgelöst.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReflectionOnlyAssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyAssemblyResolve : ResolveEventHandler " Usage="member this.ReflectionOnlyAssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die Auflösung einer Assembly in dem auf Reflektion beschränkten Kontext fehlschlägt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In den ReflectionOnly Kontext verwenden werden Abhängigkeiten nicht automatisch aufgelöst. Sie müssen vorab geladen werden oder durch den Handler für dieses Ereignis zurückgegeben werden. Dieses Ereignis wird ausgelöst, wenn eine Assembly abhängig ist, die nicht bereits in den ReflectionOnly-Kontext geladen wurde. Die fehlende Abhängigkeit wird angegeben, indem die <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> Eigenschaft. Die <xref:System.ResolveEventHandler> für dieses Ereignis muss eine Assembly zurückgeben, das die Abhängigkeit erfüllt. Die Assembly, die zurückgegeben wird, muss in den ReflectionOnly-Kontext geladen werden.  
  
> [!IMPORTANT]
>  Dieses Ereignis wird ausgelöst, nur für die fehlenden Abhängigkeiten der Assembly, die Sie in den ReflectionOnly Kontext laden (z. B. durch Verwendung der <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> Methode). Es wird nicht ausgelöst, wenn die Assembly, die Sie laden nicht gefunden werden kann.  
  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> Eigenschaft gibt die Assembly, die das Laden der Assembly angefordert, die nicht aufgelöst werden konnte. Die Identität der anfordernden Assembly zu kennen ist möglicherweise nützlich, identifizieren die richtige Version der Abhängigkeit, wenn mehr als eine Version verfügbar ist. Weitere Informationen finden Sie unter <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Bei diesem Ereignis die <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> Eigenschaft gibt den Assemblynamen aus, bevor die Richtlinie angewendet wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ReflectionOnlyGetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function ReflectionOnlyGetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Assembly ^&gt; ^ ReflectionOnlyGetAssemblies();" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyGetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.ReflectionOnlyGetAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Assemblys zurück, die in den auf Reflektion beschränkten Kontext der Anwendungsdomäne geladen wurden.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.Assembly" />-Objekten, die Assemblys darstellen, die in den auf Reflektion beschränkten Kontext geladen wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt die Assemblys, die in den ReflectionOnly-Kontext geladen wurden. Rufen Sie die Assemblys, die geladen wurden, für die Ausführung mit der <xref:System.AppDomain.GetAssemblies%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird lädt die System.dll-Assembly, in den Ausführungskontext, und klicken Sie dann in den ReflectionOnly-Kontext. Die <xref:System.AppDomain.GetAssemblies%2A> und <xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A> Methoden werden verwendet, um die in den jeweiligen Kontext geladenen Assemblys anzuzeigen.  
  
 [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CPP/reflectiononly.cpp#1)]
 [!code-csharp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CS/reflectiononly.cs#1)]
 [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/VB/reflectiononly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Es wurde versucht, eine Operation für eine entladene Anwendungsdomäne auszuführen.</exception>
        <altmember cref="M:System.AppDomain.GetAssemblies" />
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.RelativeSearchPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RelativeSearchPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RelativeSearchPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RelativeSearchPath : string" Usage="System.AppDomain.RelativeSearchPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.RelativeSearchPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Pfad unterhalb des Basisverzeichnisses ab, in dem der Assemblyresolver nach privaten Assemblys suchen soll.</summary>
        <value>Der Pfad unterhalb des Basisverzeichnisses, in dem der Assemblyresolver nach privaten Assemblys suchen soll.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Private Assemblys werden in der gleichen Verzeichnisstruktur wie die Anwendung bereitgestellt. Wenn der Pfad, wird angegeben die <xref:System.AppDomain.RelativeSearchPath%2A> Eigenschaft ist nicht unter <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>, wird Sie ignoriert.  
  
 Diese Eigenschaft gibt den Wert festgelegt, mit <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Pfadinformationen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.PrivateBinPath" />
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ResourceResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResourceResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ ResourceResolve;" />
      <MemberSignature Language="F#" Value="member this.ResourceResolve : ResolveEventHandler " Usage="member this.ResourceResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ResourceResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die Auflösung einer Ressource fehlschlägt, weil die Ressource keine gültige verknüpfte oder eingebettete Ressource in der Assembly ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ResolveEventHandler> für dieses Ereignis versuchen kann, suchen Sie die Assembly, die mit der Ressource und zurückgeben.  
  
> [!IMPORTANT]
>  Dieses Ereignis wird nicht ausgelöst, wenn die Auflösung fehlschlägt, weil keine Datei für eine gültige verknüpfte Ressource gefunden werden kann. Es wird ausgelöst, wenn ein Manifestressource-Stream wurde nicht gefunden, aber es wird nicht ausgelöst, wenn ein einzelne Ressource-Schlüssel nicht gefunden werden kann.  
  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> Eigenschaft enthält die Assembly, die die Ressource angefordert. Weitere Informationen finden Sie unter <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Um einen Ereignishandler für dieses Ereignis zu registrieren, benötigen Sie die erforderlichen Berechtigungen, oder ein <xref:System.Security.SecurityException> ausgelöst.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAppDomainPolicy (domainPolicy As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAppDomainPolicy(System::Security::Policy::PolicyLevel ^ domainPolicy);" />
      <MemberSignature Language="F#" Value="member this.SetAppDomainPolicy : System.Security.Policy.PolicyLevel -&gt; unit" Usage="appDomain.SetAppDomainPolicy domainPolicy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="domainPolicy">Die Sicherheitsrichtlinienebene.</param>
        <summary>Legt die Sicherheitsrichtlinienebene für diese Anwendungsdomäne fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode aufrufen, bevor Sie eine Assembly in geladen ist die <xref:System.AppDomain> in der Reihenfolge für die Sicherheitsrichtlinie so Auswirkungen haben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.AppDomain.SetAppDomainPolicy%2A> Methode zum Festlegen der Sicherheitsrichtlinie auf Hostebene einer Anwendungsdomäne.  
  
 [!code-cpp[ADSetAppDomainPolicy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetAppDomainPolicy/CPP/adsetappdomainpolicy.cpp#1)]
 [!code-csharp[ADSetAppDomainPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetAppDomainPolicy/CS/adsetappdomainpolicy.cs#1)]
 [!code-vb[ADSetAppDomainPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetAppDomainPolicy/VB/adsetappdomainpolicy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domainPolicy" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">Die Sicherheitsrichtlinienebene wurde bereits festgelegt.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetCachePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCachePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetCachePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetCachePath : string -&gt; unit&#xA;override this.SetCachePath : string -&gt; unit" Usage="appDomain.SetCachePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetCachePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der vollqualifizierte Pfad des Speicherortes der Schattenkopie.</param>
        <summary>Legt den angegebenen Verzeichnispfad als Speicherort für gespiegelte Assemblys fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Cachepfad wird ignoriert, wenn die <xref:System.AppDomainSetup.ApplicationName%2A> Eigenschaft nicht festgelegt. Siehe <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>-Eigenschaft.  
  
 Weitere Informationen zum Erstellen von Schattenkopien finden Sie unter [Schattenkopien von Assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Erstellen von Schattenkopien von Assemblys</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Weist einer Anwendungsdomäneneigenschaft einen Wert zu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetData(System::String ^ name, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="abstract member SetData : string * obj -&gt; unit&#xA;override this.SetData : string * obj -&gt; unit" Usage="appDomain.SetData (name, data)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetData(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Der Name einer zu erstellenden oder zu ändernden benutzerdefinierten Anwendungsdomäneneigenschaft.</param>
        <param name="data">Der Wert der Eigenschaft.</param>
        <summary>Weist der angegebenen Anwendungsdomäneneigenschaft den angegebenen Wert zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Einfügen eines Eintrags oder ändern Sie den Wert eines Eintrags in einem internen Cache von Name-Daten-Paaren, die Eigenschaften dieser Instanz von beschreiben <xref:System.AppDomain>.  
  
 Der Cache enthält automatisch die vordefinierten Systemdaten-Einträge, die eingefügt werden, wenn die Anwendungsdomäne erstellt wird. Sie können nicht einfügen oder bearbeiten Sie die Systemeinträge mit dieser Methode. Ein Methodenaufruf, der versucht, einen Eintrag im Dateisystem zu ändern, hat keine Auswirkung. die Methode löst keine Ausnahme aus. Sie können überprüfen, die Werte der Systemeinträge mit den <xref:System.AppDomain.GetData%2A> -Methode oder einer entsprechenden <xref:System.AppDomainSetup> Eigenschaften beschrieben, <xref:System.AppDomain.GetData%2A>.  
  
 Sie können diese Methode, um das standardmäßige Timeoutintervall für Ihre Evaluierung von Muster für reguläre Ausdrücke von Supply "REGEX_DEFAULT_MATCH_TIMEOUT" den Wert festzulegen als Wert des Aufrufen der `name` Argument und ein <xref:System.TimeSpan> Wert, der den Timeoutwert darstellt. Intervall, als Wert für die `data` Argument. Sie können auch einfügen, oder ändern Sie Ihre eigenen benutzerdefinierten Name-Daten-Paare mit dieser Methode, und überprüfen Sie ihre Werte mit den <xref:System.AppDomain.GetData%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29> Methode, um einen neuen Wert-Paar zu erstellen. Anschließend wird die <xref:System.AppDomain.GetData%2A> Methode zum Abrufen des Werts, und in der Konsole angezeigt.  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.AppDomain.GetData(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object, permission As IPermission)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetData(System::String ^ name, System::Object ^ data, System::Security::IPermission ^ permission);" />
      <MemberSignature Language="F#" Value="member this.SetData : string * obj * System.Security.IPermission -&gt; unit" Usage="appDomain.SetData (name, data, permission)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="permission" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="name">Der Name einer zu erstellenden oder zu ändernden benutzerdefinierten Anwendungsdomäneneigenschaft.</param>
        <param name="data">Der Wert der Eigenschaft.</param>
        <param name="permission">Die vom Aufrufer beim Abrufen der Eigenschaft verlangte Berechtigung.</param>
        <summary>Weist der angegebenen Anwendungsdomäneneigenschaft den angegebenen Wert mit einer angegebenen Berechtigung zu, die der Aufrufer beim Abrufen der Eigenschaft besitzen muss.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Einfügen oder ändern Ihre eigenen benutzerdefinierten Einträge in einem internen Cache von Namen/Daten-Paare, die Eigenschaften der Anwendungsdomäne beschreiben. Wenn Sie einen Eintrag einfügen, können Sie angeben, eine berechtigungsforderung zum erzwingen, wenn der Eintrag abgerufen wird. Darüber hinaus können Sie diese Methode, um das standardmäßige Timeoutintervall für Ihre Evaluierung von Muster für reguläre Ausdrücke von Supply "REGEX_DEFAULT_MATCH_TIMEOUT" den Wert festlegen aufrufen, als Wert für die `name` Argument und ein <xref:System.TimeSpan> Wert, der darstellt der Timeout-Intervall als Wert für die `data` Argument.  
  
 Diese Methode können Sie eine systemdefinierte Eigenschaftenzeichenfolge eine sicherheitsforderung zuweisen.  
  
 Der Cache enthält automatisch die vordefinierten Systemdaten-Einträge, die eingefügt werden, wenn die Anwendungsdomäne erstellt wird. Sie können nicht einfügen oder bearbeiten Sie die Systemeinträge mit dieser Methode. Ein Methodenaufruf, der versucht, einen Eintrag im Dateisystem zu ändern, hat keine Auswirkung. die Methode löst keine Ausnahme aus. Sie können überprüfen, die Werte der Systemeinträge mit den <xref:System.AppDomain.GetData%2A> Methode oder die entsprechende <xref:System.AppDomainSetup> im Abschnitt "Hinweise" beschriebenen Eigenschaften die <xref:System.AppDomain.GetData%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="name" /> gibt eine systemdefinierte Eigenschaftenzeichenfolge an, und <paramref name="permission" /> ist nicht <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetDynamicBase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDynamicBase (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDynamicBase(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetDynamicBase : string -&gt; unit" Usage="appDomain.SetDynamicBase path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der vollqualifizierte Pfad des Basisverzeichnisses, in dem Unterverzeichnisse für die Speicherung dynamischer Assemblys erstellt werden.</param>
        <summary>Legt den angegebenen Verzeichnispfad als das Basisverzeichnis fest, in dem Unterverzeichnisse für die Speicherung und den Zugriff auf dynamisch generierte Dateien erstellt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode legt die <xref:System.AppDomainSetup.DynamicBase%2A> Eigenschaft des internen <xref:System.AppDomainSetup> dieser Instanz zugeordnet.  
  
   
  
## Examples  
 Diese Methode ist mittlerweile veraltet und sollte nicht für Neuentwicklungen verwendet werden. Das folgende Beispiel zeigt, wie Sie die nicht veraltete Alternative, mit der <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> Eigenschaft. Eine Erläuterung der in diesem Beispiel wird, finden Sie unter den <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> Eigenschaft oder das <xref:System.AppDomain.DynamicDirectory%2A> Eigenschaft.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="P:System.AppDomainSetup.DynamicBase" />
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPrincipalPolicy (policy As PrincipalPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPrincipalPolicy(System::Security::Principal::PrincipalPolicy policy);" />
      <MemberSignature Language="F#" Value="member this.SetPrincipalPolicy : System.Security.Principal.PrincipalPolicy -&gt; unit" Usage="appDomain.SetPrincipalPolicy policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">Einer der <see cref="T:System.Security.Principal.PrincipalPolicy" />-Werte, die den Typ des Prinzipalobjekts angeben, das an Threads angefügt werden soll.</param>
        <summary>Gibt an, wie Haupt- und Identitätsobjekte an einen Thread angefügt werden sollen, wenn während der Ausführung in dieser Anwendungsdomäne versucht wird, den Thread an einen Prinzipal zu binden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Festlegen dieses Werts werden nur wirksam, wenn Sie diese vor der Verwendung von Festlegen der <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> Eigenschaft. Wenn Sie festlegen, z. B. <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> zu einer bestimmten Prinzipal (z. B. einen generischen Prinzipal), und klicken Sie dann verwenden die <xref:System.AppDomain.SetPrincipalPolicy%2A> Methode zum Festlegen der <xref:System.Security.Principal.PrincipalPolicy> zu <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>, der aktuelle Prinzipal bleibt der generischen Prinzipal.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Auswirkung auf die Threads der Verwendung der <xref:System.AppDomain.SetPrincipalPolicy%2A> Methode, die Dienstprinzipalnamen der Anwendungsdomäne ändern. Außerdem wird gezeigt, die Auswirkungen der Verwendung der <xref:System.AppDomain.SetThreadPrincipal%2A> Methode, um den Prinzipal zu ändern, die für das Anfügen an Threads in der Anwendungsdomäne verfügbar ist.  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Fähigkeit zum Bearbeiten des Hauptobjekts. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyFiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetShadowCopyFiles();" />
      <MemberSignature Language="F#" Value="member this.SetShadowCopyFiles : unit -&gt; unit" Usage="appDomain.SetShadowCopyFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aktiviert die Schattenkopiefunktion.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zum Erstellen von Schattenkopien, finden Sie unter [Schattenkopien von Assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
   
  
## Examples  
 Diese Methode ist mittlerweile veraltet und sollte nicht für Neuentwicklungen verwendet werden.  
  
 [!code-cpp[adproperties#1](~/samples/snippets/cpp/VS_Snippets_CLR/adproperties/CPP/adproperties.cpp#1)]
 [!code-csharp[adproperties#1](~/samples/snippets/csharp/VS_Snippets_CLR/adproperties/CS/adproperties.cs#1)]
 [!code-vb[adproperties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/adproperties/VB/adproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Erstellen von Schattenkopien von Assemblys</related>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyPath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetShadowCopyPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetShadowCopyPath : string -&gt; unit&#xA;override this.SetShadowCopyPath : string -&gt; unit" Usage="appDomain.SetShadowCopyPath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetShadowCopyPath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Eine Liste von Verzeichnisnamen, die durch ein Semikolon voneinander getrennt sind.</param>
        <summary>Legt den angegebenen Verzeichnispfad als Speicherort für zu spiegelnde Assemblys fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig enthält eine Schattenkopie alle Assemblys, die bei der Suche gefunden. Die <xref:System.AppDomain.SetShadowCopyPath%2A> Methode beschränkt die Schattenkopie, auf die Assemblys in den Verzeichnissen, die anhand des `path`.  
  
 Die <xref:System.AppDomain.SetShadowCopyPath%2A> Methode gibt keine zusätzliche Verzeichnisse an, nach Assemblys durchsucht werden. Schattenkopien werden Assemblys müssen bereits in den Suchpfad, z. B. unter befinden <xref:System.AppDomain.BaseDirectory%2A>. Die <xref:System.AppDomain.SetShadowCopyPath%2A> Methode gibt an, welche Suchpfade Schattenkopien möglich sind.  
  
 Diese Methode legt die <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> Eigenschaft des internen <xref:System.AppDomainSetup> dieser Instanz zugeordnet.  
  
 Weitere Informationen zum Erstellen von Schattenkopien, finden Sie unter [Schattenkopien von Assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
   
  
## Examples  
 Diese Methode ist mittlerweile veraltet und sollte nicht für Neuentwicklungen verwendet werden.  
  
 [!code-cpp[ADShadowCopy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADShadowCopy/CPP/adshadowcopy.cpp#1)]
 [!code-csharp[ADShadowCopy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADShadowCopy/CS/adshadowcopy.cs#1)]
 [!code-vb[ADShadowCopy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADShadowCopy/VB/adshadowcopy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Erstellen von Schattenkopien von Assemblys</related>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetThreadPrincipal (principal As IPrincipal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetThreadPrincipal(System::Security::Principal::IPrincipal ^ principal);" />
      <MemberSignature Language="F#" Value="member this.SetThreadPrincipal : System.Security.Principal.IPrincipal -&gt; unit" Usage="appDomain.SetThreadPrincipal principal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <param name="principal">Das Prinzipalobjekt, das an Threads angefügt werden soll.</param>
        <summary>Legt das Standardprinzipalobjekt fest, das an Threads angefügt wird, wenn bei der Ausführung in dieser Anwendungsdomäne versucht wird, diese an einen Prinzipal zu binden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt die Auswirkungen der Verwendung der <xref:System.AppDomain.SetThreadPrincipal%2A> Methode, um den Prinzipal zu ändern, ist verfügbar für das Anfügen an Threads, die in der Anwendungsdomäne ausgeführt werden. Außerdem wird gezeigt, die Auswirkungen auf die Threads der Verwendung der <xref:System.AppDomain.SetPrincipalPolicy%2A> Methode, die Dienstprinzipalnamen der Anwendungsdomäne ändern.  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="principal" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">Der Principal des Threads wurde bereits festgelegt.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Fähigkeit zum Bearbeiten des Hauptobjekts. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.SetupInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SetupInformation As AppDomainSetup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainSetup ^ SetupInformation { AppDomainSetup ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SetupInformation : AppDomainSetup" Usage="System.AppDomain.SetupInformation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Konfigurationsinformationen der Anwendungsdomäne für diese Instanz ab.</summary>
        <value>Die Initialisierungsinformationen für die Anwendungsdomäne.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShadowCopyFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShadowCopyFiles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : bool" Usage="System.AppDomain.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob die Anwendungsdomäne für das Erstellen von Dateischattenkopien konfiguriert ist.</summary>
        <value>
          <see langword="true" />, wenn in der Anwendungsdomäne Dateischattenkopien erstellt werden, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> und [Schattenkopien von Assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md">Erstellen von Schattenkopien von Assemblys</related>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AppDomain.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = _AppDomain::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Für zukünftige Verwendung reserviert. Muss IID_NULL sein.</param>
        <param name="rgszNames">Das übergebene Array von zuzuordnenden Namen.</param>
        <param name="cNames">Die Anzahl der zuzuordnenden Namen.</param>
        <param name="lcid">Der Gebietsschemakontext, in dem die Namen interpretiert werden sollen.</param>
        <param name="rgDispId">Das vom Aufrufer zugewiesene Array, das die IDs entsprechend den Namen empfängt.</param>
        <summary>Ordnet eine Reihe von Namen einer entsprechenden Reihe von Dispatchbezeichnern zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen von nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetIDsOfNames`, finden Sie unter der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AppDomain.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = _AppDomain::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Die zurückzugebenden Typinformationen.</param>
        <param name="lcid">Der Gebietsschemabezeichner für die Typinformationen.</param>
        <param name="ppTInfo">Empfängt einen Zeiger auf das angeforderte Objekt mit den Typinformationen.</param>
        <summary>Ruft die Typinformationen für ein Objekt ab, die dann zum Abrufen der Typinformationen für eine Schnittstelle verwendet werden können.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen von nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetTypeInfo`, finden Sie unter der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AppDomain.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = _AppDomain::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Zeigt auf einen Speicherort, der die Anzahl der Schnittstellen mit Typinformationen empfängt, die vom Objekt bereitgestellt werden.</param>
        <summary>Ruft die Anzahl der Schnittstellen mit Typinformationen ab, die von einem Objekt bereitgestellt werden (0 oder 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen von nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetTypeInfoCount`, finden Sie unter der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AppDomain.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = _AppDomain::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Bezeichnet den Member.</param>
        <param name="riid">Für zukünftige Verwendung reserviert. Muss IID_NULL sein.</param>
        <param name="lcid">Der Gebietsschemakontext, in dem Argumente interpretiert werden sollen.</param>
        <param name="wFlags">Flags, die den Kontext des Aufrufs beschreiben.</param>
        <param name="pDispParams">Ein Zeiger auf eine Struktur, die ein Array von Argumenten und ein Array von Argument-DISPIDs für benannte Argumente sowie Zähler für die Anzahl der Elemente in jedem Array enthält.</param>
        <param name="pVarResult">Ein Verweis auf den Speicherort, an dem das Ergebnis gespeichert werden soll.</param>
        <param name="pExcepInfo">Ein Zeiger auf eine Struktur mit Ausnahmeinformationen.</param>
        <param name="puArgErr">Der Index des ersten Arguments mit einem Fehler.</param>
        <summary>Stellt den Zugriff auf von einem Objekt verfügbar gemachte Eigenschaften und Methoden bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen von nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::Invoke`, finden Sie unter der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="appDomain.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine Zeichenfolgendarstellung ab, die den angezeigten Namen der Anwendungsdomäne und aller Kontextrichtlinien einschließt.</summary>
        <returns>Eine durch Verketten der literalen Zeichenfolge "Name:", dem angezeigten Namen der Anwendungsdomäne und entweder Zeichenfolgendarstellungen der Kontextrichtlinien oder der Zeichenfolge "Keine Kontextrichtlinien vorhanden" gebildete Zeichenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel zeigt den Rückgabewert der <xref:System.AppDomain.ToString%2A> Methode.  
  
 [!code-cpp[ADToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADToString/CPP/adtostring.cpp#1)]
 [!code-csharp[ADToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADToString/CS/adtostring.cs#1)]
 [!code-vb[ADToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADToString/VB/adtostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Die durch die aktuelle <see cref="T:System.AppDomain" /> dargestellte Anwendungsdomäne wurde entladen.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.TypeResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TypeResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ TypeResolve;" />
      <MemberSignature Language="F#" Value="member this.TypeResolve : ResolveEventHandler " Usage="member this.TypeResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.TypeResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die Auflösung eines Typs fehlschlägt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.AppDomain.TypeResolve> Ereignis tritt auf, wenn die common Language Runtime nicht kann, um die Assembly zu bestimmen, die den angeforderten Typ erstellen können. Dies kann auftreten, wenn der Typ in einer dynamischen Assembly definiert ist, oder der Typ nicht in einer dynamischen Assembly definiert ist, aber die Runtime weiß nicht, welche Assembly in der Typ definiert ist. Die zweite Situation kann auftreten, wenn <xref:System.Type.GetType%2A?displayProperty=nameWithType> mit einem Typnamen, die nicht qualifiziert ist mit dem Assemblynamen aufgerufen wird.  
  
 Die <xref:System.ResolveEventHandler> für dieses Ereignis versuchen kann, um zu suchen und erstellen Sie den Typ.  
  
 Allerdings die <xref:System.AppDomain.TypeResolve> Ereignis nicht ausgeführt, wenn die Runtime weiß, es ist nicht möglich, die ein Typ in bestimmte Assemblys gefunden. Dieses Ereignis beispielsweise nicht ausgeführt, wenn der Typ in eine statische Assembly nicht gefunden wird, da die Runtime weiß, dass Typen statische Assemblys dynamisch hinzugefügt werden können.  
  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> Eigenschaft enthält die Assembly, die den Typ angefordert hat. Weitere Informationen finden Sie unter <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Um einen Ereignishandler für dieses Ereignis zu registrieren, benötigen Sie die erforderlichen Berechtigungen, oder ein <xref:System.Security.SecurityException> ausgelöst.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.AppDomain.TypeResolve> Ereignis.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen angeben. Informationen dazu, wie Sie den vollqualifizierten Assemblynamen abzurufen, finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_TypeResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_TypeResolve/CPP/typeresolve.cpp#1)]
 [!code-csharp[AppDomain_TypeResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_TypeResolve/CS/typeresolve.cs#1)]
 [!code-vb[AppDomain_TypeResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_TypeResolve/VB/typeresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledException As UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event UnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : UnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.UnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.UnhandledException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Ausnahme nicht abgefangen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis stellt eine Benachrichtigung nicht abgefangenen Ausnahmen bereit. Sie können die Anwendung zum Protokollieren von Informationen zur Ausnahme vor dem Standardhandler System die Ausnahme, die dem Benutzer meldet und die Anwendung beendet. Wenn genügend Informationen über den Zustand der Anwendung verfügbar ist, können andere Aktionen durchgeführt werden, z. B. Speichern von Daten aus dem Programm für eine spätere Wiederherstellung. Vorsicht ist empfehlenswert, da Daten aus dem Programm beschädigt werden können, wenn Ausnahmen nicht behandelt werden.  
  
> [!NOTE]
>  In der .NET Framework-Versionen 1.0 und 1.1 werden Beenden der Anwendung und Debuggen von Optionen für den Benutzer gemeldet, bevor dieses Ereignis ausgelöst wird, anstatt erst nach.  
  
 Dieses Ereignis kann in jeder Anwendungsdomäne behandelt werden. Das Ereignis wird jedoch nicht unbedingt in der Anwendungsdomäne ausgelöst, in dem die Ausnahme aufgetreten ist. Nur wenn der gesamte Stapel des Threads entladen wurde ohne Suchen nach einem entsprechenden Ausnahmehandler, daher ist der erste Ort, der das Ereignis ausgelöst werden kann in der Anwendungsdomäne, von dem der Thread stammt, wird eine Ausnahme nicht behandelt.  
  
> [!NOTE]
>  Tritt auf, dieses Ereignis nur für die Standardanwendungsdomäne, die vom System erstellt wird, wenn eine Anwendung gestartet wird, in der .NET Framework-Versionen 1.0 und 1.1. Wenn eine Anwendung zusätzliche Anwendungsdomänen erstellt, hat die gibt dabei einen Delegaten für dieses Ereignis in diesen Anwendungsdomänen keine Auswirkungen.  
  
 Wenn die <xref:System.AppDomain.UnhandledException> Ereignis in der Standardanwendungsdomäne behandelt werden, es wird dann gibt es für alle in jedem Thread aus, unabhängig davon, welche die Anwendungsdomäne den Schritte im Thread nicht behandelte Ausnahme ausgelöst. Wenn der Thread in einer Anwendungsdomäne gestartet wird, die einen Ereignishandler für <xref:System.AppDomain.UnhandledException>, das Ereignis wird ausgelöst, in dieser Anwendungsdomäne. Wenn dieser Anwendungsdomäne nicht die Standardanwendungsdomäne ist, und es auch ein Ereignishandler in der Standardanwendungsdomäne gibt, wird das Ereignis in beide Anwendungsdomänen ausgelöst.  
  
 Beispielsweise angenommen, ein Thread startet in Anwendungsdomäne "AD1", ruft eine Methode in der Anwendungsdomäne "AD2", und dort Ruft eine Methode in der Anwendungsdomäne "AD3", die, in dem eine Ausnahme ausgelöst. Der ersten Anwendungsdomäne, in dem die <xref:System.AppDomain.UnhandledException> -Ereignis ausgelöst werden kann, ist "AD1". Wenn dieser Anwendungsdomäne nicht die Standardanwendungsdomäne ist, kann das Ereignis auch in der Standardanwendungsdomäne ausgelöst werden.  
  
> [!NOTE]
>  Die common Language Runtime anhält, Threadabbrüche und Ereignishandler für die <xref:System.AppDomain.UnhandledException> Ereignis ausgeführt werden.  
  
 Wenn der Ereignishandler verfügt über eine <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> Attribut mit den geeigneten Flags, wird der Ereignishandler als einen eingeschränkten Ausführungsbereich behandelt.  
  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], dieses Ereignis wird nicht ausgelöst, für die Ausnahmen, die den Status des Prozesses beschädigt werden, wie z. B. Stapelüberläufe oder zugriffsverletzungen, es sei denn, der Ereignishandler sicherheitskritisch ist und verfügt über die <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> Attribut.  
  
 In der .NET Framework-Versionen 1.0 und 1.1 eine nicht behandelte Ausnahme, die in einem anderen Thread als dem Hauptanwendungsthread auftritt, wird von der Laufzeit abgefangen und verursacht deshalb keine beenden die Anwendung. Daher ist es möglich, dass die <xref:System.AppDomain.UnhandledException> Ereignis ausgelöst wurde ohne die Anwendung beendet. Ab .NET Framework, Version 2.0, wurde diese Sicherheitsnetz für nicht behandelte Ausnahmen in Threads, die untergeordnete entfernt werden, da es sich bei der kumulative Effekt einer automatischen Fehler enthielt eine Verringerung der Leistung, beschädigte Daten und Abstürze, die schwer zu wurden, das Debuggen. Weitere Informationen einschließlich einer Liste von Fällen, in dem die Common Language Runtime nicht beendet wird, finden Sie unter [Ausnahmen in verwalteten Threads](~/docs/standard/threading/exceptions-in-managed-threads.md).  
  
 Um einen Ereignishandler für dieses Ereignis zu registrieren, benötigen Sie die erforderlichen Berechtigungen, oder ein <xref:System.Security.SecurityException> ausgelöst.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
## <a name="other-events-for-unhandled-exceptions"></a>Andere Ereignisse für nicht behandelte Ausnahmen  
 Für bestimmte Anwendungsmodelle der <xref:System.AppDomain.UnhandledException> Ereignis kann mit anderen Ereignissen getrennt werden, wenn die nicht behandelte Ausnahme im Thread hauptanwendung auftritt.  
  
 Nicht behandelte Ausnahmen in die Hauptassembly der Anwendung Thread Ursache, in Anwendungen, die Windows Forms verwendet, die <xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType> Ereignis ausgelöst wurde. Wenn dieses Ereignis behandelt wird, ist das Standardverhalten, dass es sich bei die Anwendung nicht in die nicht behandelte Ausnahme beendet wird, auch wenn die Anwendung in einem unbekannten Zustand gelassen wird. In diesem Fall die <xref:System.AppDomain.UnhandledException> Ereignis wird nicht ausgelöst. Dieses Verhalten kann geändert werden, mithilfe der Anwendungskonfigurationsdatei oder mit der <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType> Methode zum Ändern des websitemodus, <xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType> vor der <xref:System.Windows.Forms.Application.ThreadException> Ereignishandler verknüpft ist. Dies gilt nur für den Thread der hauptanwendung. Die <xref:System.AppDomain.UnhandledException> Ereignis wird ausgelöst, für nicht behandelte Ausnahmen in anderen Threads.  
  
 Ab Microsoft Visual Studio 2005 stellt das Anwendungsframework für die Visual Basic ein anderes Ereignis für unbehandelte Ausnahmen in Thread der hauptanwendung bereit. Finden Sie unter den <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType> Ereignis. Dieses Ereignis verfügt über ein Ereignisobjekt für die Argumente mit den gleichen Namen wie das Ereignisargumentobjekt, der von verwendeten <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>, jedoch mit unterschiedlichen Eigenschaften. Insbesondere diese Ereignisargumentobjekt ein <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> -Eigenschaft, die der Anwendung ermöglicht, weiterhin ausgeführt wird, die nicht behandelte Ausnahme wird ignoriert (und verlässt Sie die Anwendung in einem unbekannten Zustand). In diesem Fall die <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> Ereignis wird nicht ausgelöst.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.AppDomain.UnhandledException> Ereignis. Definiert einen Ereignishandler `MyHandler`, die aufgerufen wird, wenn eine nicht behandelte Ausnahme, in der Standardanwendungsdomäne ausgelöst wird. Klicken Sie dann zwei Ausnahmen ausgelöst. Die erste erfolgt durch eine **Try/Catch-** Block. Die zweite wird nicht behandelt, und ruft die `MyHandle` Routine, bevor die Anwendung beendet wird.  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Unload(System.AppDomain)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unload (domain As AppDomain)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unload(AppDomain ^ domain);" />
      <MemberSignature Language="F#" Value="static member Unload : AppDomain -&gt; unit" Usage="System.AppDomain.Unload domain" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <param name="domain">Eine zu entladende Anwendungsdomäne.</param>
        <summary>Entlädt die angegebene Anwendungsdomäne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .NET Framework, Version 2.0 ist ein Thread für das Entladen von Anwendungsdomänen. Dies verbessert die Zuverlässigkeit, insbesondere bei .NET Framework gehostet wird. Wenn ein Thread ruft <xref:System.AppDomain.Unload%2A>, die Zieldomäne ist für das Entladen markiert. Der dedizierte Thread versucht, die Domäne zu entladen, und alle Threads in der Domäne werden abgebrochen. Wenn ein Thread nicht, z. B. abgebrochen werden, da sie nicht verwalteten Code ausgeführt wird oder weil es ausgeführt wird ein `finally` Block nach einiger Zeit eine <xref:System.CannotUnloadAppDomainException> wird ausgelöst, in dem Thread, der ursprünglich aufgerufen <xref:System.AppDomain.Unload%2A>. Nach Beendigung des Threads, die letztendlich nicht abgebrochen werden konnte, wird die Zieldomäne nicht entladen. Also im .NET Framework, Version 2.0 `domain` nicht notwendigerweise zu entladen, da es möglicherweise nicht möglich, die Ausführung von Threads zu beenden.  
  
> [!NOTE]
>  In einigen Fällen Aufrufen <xref:System.AppDomain.Unload%2A> bewirkt, dass eine sofortige <xref:System.CannotUnloadAppDomainException>, z. B. Wenn sie in einem Finalizer aufgerufen wird.  
  
 Threads in `domain` werden beendet, mit der <xref:System.Threading.Thread.Abort%2A> -Methode, die löst eine <xref:System.Threading.ThreadAbortException> im Thread. Obwohl der Thread sofort beendet werden soll, es ausführen fortsetzen, unvorhersehbar Zeit in einer `finally` Klausel.  
  
## <a name="version-compatibility"></a>Versionskompatibilität  
 In .NET Framework, Version 1.0 und 1.1, wenn der Thread aufruft <xref:System.AppDomain.Unload%2A> läuft in `domain`, einem anderen Thread zum Ausführen des Entladevorgangs gestartet wird. Wenn `domain` kann nicht entladen werden kann, eine <xref:System.CannotUnloadAppDomainException> wird ausgelöst, in diesem Thread, nicht in der ursprüngliche Thread, der aufgerufen <xref:System.AppDomain.Unload%2A>. Jedoch, wenn der Thread aufruft <xref:System.AppDomain.Unload%2A> ausgeführt wird, außerhalb `domain`, dass der Thread die Ausnahme empfängt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie eine Anwendungsdomäne entladen wird.  
  
 [!code-cpp[ADUnload#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADUnload/CPP/adunload.cpp#1)]
 [!code-csharp[ADUnload#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADUnload/CS/adunload.cs#1)]
 [!code-vb[ADUnload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADUnload/VB/adunload.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.CannotUnloadAppDomainException">
          <paramref name="domain" /> konnte nicht entladen werden.</exception>
        <exception cref="T:System.Exception">Während des Entladeprozesses ist ein Fehler aufgetreten.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Um einen Ereignishandler für dieses Ereignis hinzuzufügen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
  </Members>
</Type>