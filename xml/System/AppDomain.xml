<Type Name="AppDomain" FullName="System.AppDomain">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c3ab234edad8a65f7b4b6688da32990c9642f79d" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30731664" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.AppDomain" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomain&#xA;Inherits MarshalByRefObject&#xA;Implements _AppDomain, IEvidenceFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomain sealed : MarshalByRefObject, _AppDomain, System::Security::IEvidenceFactory" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Anwendungsdomäne dar. Dies ist eine isolierte Umgebung, in der Programme ausgeführt werden. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Anwendungsdomänen, die durch Werte dargestellt werden <xref:System.AppDomain> Objekte bieten Isolation, entladen und Sicherheit Grenzen für die Ausführung von verwaltetem Code.  
  
-   Verwenden Sie Anwendungsdomänen, um Aufgaben zu isolieren, die einen Prozess beenden kann. Wenn der Status des der <xref:System.AppDomain> , die eine Aufgabe ausgeführt wird instabil ist, wird die <xref:System.AppDomain> können ohne Auswirkungen auf den Prozess entladen werden. Dies ist wichtig, wenn ein Prozess für lange Zeiträume ohne Neustart ausgeführt werden muss. Sie können auch Anwendungsdomänen verwenden, um Aufgaben zu isolieren, die keine Daten gemeinsam verwenden sollten.  
  
-   Wenn eine Assembly in die Standardanwendungsdomäne geladen wird, es nicht aus dem Arbeitsspeicher entladen während der Prozess ausgeführt wird. Wenn Sie eine zweite Anwendungsdomäne zum Laden und Ausführen der Assemblys zu öffnen, ist jedoch die Assembly entladen, wenn diese Anwendungsdomäne entladen wird. Verwenden Sie dieses Verfahren, um den Arbeitssatz von lang andauernden Prozessen zu minimieren, die gelegentlich große DLLs verwenden.  
  
 Mehrere Anwendungsdomänen können in einem einzelnen Prozess ausführen. Es ist jedoch keine eindeutige Korrelation zwischen Anwendungsdomänen und Threads. Mehrere Threads können zu einer einzelnen Anwendungsdomäne gehören, und zwar ein bestimmter Thread nicht auf eine einzelne Anwendungsdomäne, einem bestimmten Zeitpunkt beschränkt ist ein Thread ausgeführt wird, in einer einzelnen Anwendungsdomäne.  
  
 Anwendungsdomänen werden erstellt, mit der <xref:System.AppDomain.CreateDomain%2A> Methode. <xref:System.AppDomain> -Instanzen werden verwendet, um das Laden und Ausführen von Assemblys (<xref:System.Reflection.Assembly>). Wenn ein <xref:System.AppDomain> ist nicht mehr verwendet, kann Sie entladen werden.  
  
 Die <xref:System.AppDomain> Klasse implementiert einen Satz von Ereignissen, mit denen Anwendungen reagieren, wenn eine Assembly geladen wird, wenn eine Anwendungsdomäne entladen werden, oder wenn eine nicht behandelte Ausnahme ausgelöst wird.  
  
 Weitere Informationen zur Verwendung von Anwendungsdomänen finden Sie unter [Anwendungsdomänen](~/docs/framework/app-domains/application-domains.md).  
  
 Diese Klasse implementiert die <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, und <xref:System.Security.IEvidenceFactory> Schnittstellen.  
  
 Erstellen Sie nie einen remotefähige Wrapper für ein <xref:System.AppDomain> Objekt. Auf diese Weise konnte einen remote-Verweis auf dieses veröffentlicht <xref:System.AppDomain>, Verfügbarmachen von Methoden wie z. B. <xref:System.AppDomain.CreateInstance%2A> mit remote Access und Zerstören von effektiv Codezugriffssicherheit für diesen <xref:System.AppDomain>. Herstellen einer Verbindung mit dem Remote-böswillige Clients <xref:System.AppDomain> konnte erhalten Zugriff auf alle Ressourcen der <xref:System.AppDomain> selbst hat Zugriff auf. Erstellen nicht remotefähige Wrapper für jeden Typ, der erweitert <xref:System.MarshalByRefObject> und, implementiert die Methoden, die von böswilligen Clients verwendet werden können, um das Sicherheitssystem zu umgehen.  
  
> [!CAUTION]
>  Der Standardwert für die <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType> Eigenschaft ist `false`. Diese Einstellung ist für Dienste unsicher. Um zu verhindern, dass Dienste teilweise vertrauenswürdigen Code herunterladen, legen Sie diese Eigenschaft auf `true`.  
  
   
  
## Examples  
 In diesem Beispiel wird gezeigt, wie zum Erstellen eines neuen <xref:System.AppDomain>, instanziieren Sie einen Typ in, neue <xref:System.AppDomain>, und die Kommunikation mit dem Objekt dieses Typs. Darüber hinaus wird in diesem Beispiel wird gezeigt, wie Entladen der <xref:System.AppDomain> verursacht das Objekt, das Garbage Collection bereinigt werden.  
  
 [!code-cpp[AppDomainX#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainX/cpp/AppDomainX.cpp#1)]
 [!code-csharp[AppDomainX#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainX/cs/AppDomainX.cs#1)]
 [!code-vb[AppDomainX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainX/VB/AppDomainX.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ActivationContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationContext As ActivationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ActivationContext ^ ActivationContext { ActivationContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Aktivierungskontext für die aktuelle Anwendungsdomäne ab.</summary>
        <value>Ein Objekt, das den Aktivierungskontext für die aktuelle Anwendungsdomäne darstellt, oder <see langword="null" />, wenn die Domäne keinen Aktivierungskontext besitzt.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.AppendPrivatePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendPrivatePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AppendPrivatePath(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.AppendPrivatePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Name des Verzeichnisses, das an den privaten Pfad angefügt werden soll.</param>
        <summary>Fügt den angegebenen Verzeichnisnamen an die Liste der privaten Pfade an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Verwendung dieser Eigenschaft wird nicht empfohlen, da es die Überprüfungspfad für Assemblys ändern kann, nachdem sie bereits geladen wurden. Verwenden Sie stattdessen die <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>-Eigenschaft.  
  
 Den privaten Pfad oder die relativen Suchpfads, ist der Pfad relativ zum des Basisverzeichnisses, in dem der Assemblyresolver nach privaten Assemblys sucht.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationIdentity As ApplicationIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ApplicationIdentity ^ ApplicationIdentity { ApplicationIdentity ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Identität der Anwendung in der Anwendungsdomäne ab.</summary>
        <value>Ein Objekt, das die Anwendung in der Anwendungsdomäne identifiziert.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft Informationen ab, die die einer Anwendung gewährten Berechtigungen beschreiben und ob die Anwendung eine Vertrauensebene besitzt, die eine Ausführung zulässt.</summary>
        <value>Ein Objekt, das Informationen über Berechtigungen und Vertrauenswürdigkeit für die Anwendung in der Anwendungsdomäne kapselt.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ApplyPolicy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyPolicy (assemblyName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyPolicy(System::String ^ assemblyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Assemblyanzeigename in der von der <see cref="P:System.Reflection.Assembly.FullName" />-Eigenschaft bereitgestellten Form.</param>
        <summary>Gibt den Assemblyanzeigenamen nach dem Anwenden der Richtlinien zurück.</summary>
        <returns>Eine Zeichenfolge, die den Assemblyanzeigenamen nach dem Anwenden der Richtlinien enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.AppDomain.ApplyPolicy%2A> Methode akzeptiert einen Anzeigenamen und gibt den Anzeigenamen nach der Richtlinie. Dies ist hilfreich, wenn Sie mithilfe der Richtlinie, eine Assembly geladen werden, weil Reflection-only-Kontext keine Richtlinien angewendet werden müssen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyLoad As AssemblyLoadEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event AssemblyLoadEventHandler ^ AssemblyLoad;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyLoad</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt beim Laden einer Assembly ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.AssemblyLoadEventHandler> Delegat für dieses Ereignis gibt an, welche Assembly geladen wurde.  
  
 Um einen Ereignishandler für dieses Ereignis zu registrieren, benötigen Sie die erforderlichen Berechtigungen, oder ein <xref:System.Security.SecurityException> ausgelöst wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.AppDomain.AssemblyLoad> Ereignis.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen bereitstellen. Informationen zur Vorgehensweise zum Abrufen der vollqualifizierte Assemblyname finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_AssemblyLoad#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CPP/assemblyload.cpp#1)]
 [!code-csharp[AppDomain_AssemblyLoad#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CS/assemblyload.cs#1)]
 [!code-vb[AppDomain_AssemblyLoad#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_AssemblyLoad/VB/assemblyload.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ AssemblyResolve;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die Auflösung einer Assembly fehlschlägt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es liegt in der Verantwortung des der <xref:System.ResolveEventHandler> für dieses Ereignis, um die Assembly zurück, die von angegeben wird die <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> Eigenschaft oder null zurück, wenn die Assembly nicht erkannt wird. Die Assembly muss in einem Ausführungskontext geladen werden; Wenn sie in den reflektionsbezogenen Kontext geladen wurde, schlägt fehl, die Last, die dieses Ereignis ausgelöst werden soll, verursacht hat.  
  
 Anleitungen zur Verwendung dieses Ereignisses finden Sie unter [auflösen beim Laden von Assemblys](~/docs/framework/app-domains/resolve-assembly-loads.md).  
  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]die <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> Eigenschaft gibt die Assembly, die das Laden der Assembly angefordert, die nicht aufgelöst werden konnte. Beispielsweise kann das Ladeprogramm möglicherweise nicht um eine Abhängigkeit von der anfordernden Assembly geladen werden, weil die anfordernde Assembly und die dazugehörige Abhängigkeit nicht in der Überprüfungspfad enthalten sind. Die Identität der anfordernden Assembly zu kennen möglicherweise nützlich, in Abhängigkeit der suchen oder um zu identifizieren, die richtige Version sein, wenn mehr als eine Version der Abhängigkeit verfügbar ist. Weitere Informationen finden Sie unter <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
> [!IMPORTANT]
>  Beginnend mit der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]die <xref:System.ResolveEventHandler> Ereignis wird für alle Assemblys, einschließlich Ressourcenassemblys. In früheren Versionen wurde das Ereignis nicht für Ressourcenassemblys ausgelöst. Wenn das Betriebssystem lokalisiert wird, der Handler kann mehrfach aufgerufen werden: einmal für jede Kultur in der Kette fallback.  
  
 Bei diesem Ereignis die <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> Eigenschaft gibt den Assemblynamen aus, bevor die Richtlinie angewendet wird.  
  
> [!IMPORTANT]
>  Wenn mehr als ein Ereignishandler für dieses Ereignis registriert ist, die Handlersarecalled Ereignis in der Reihenfolge, bis ein Ereignishandler einen Wert zurückgibt, die nicht `null`. Nachfolgende Ereignishandler werden ignoriert.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.AppDomain.AssemblyResolve> Ereignis.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen bereitstellen. Informationen zur Vorgehensweise zum Abrufen der vollqualifizierte Assemblyname finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AssemblyResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyResolve/CPP/assemblyresolve.cpp#1)]
 [!code-csharp[AssemblyResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyResolve/CS/assemblyresolve.cs#1)]
 [!code-vb[AssemblyResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyResolve/VB/assemblyresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.BaseDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Basisverzeichnis ab, das der Assemblyresolver für die Suche nach Assemblys verwendet.</summary>
        <value>Das Basisverzeichnis, das der Assemblyresolver für die Suche nach Assemblys verwendet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft entspricht der <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> Eigenschaft. Sie können auch abgerufen werden mithilfe der <xref:System.AppDomain.GetData%2A> Methode mit der Zeichenfolge "APPBASE".  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine neue Anwendungsdomäne, die ein Basisverzeichnis, mit der bei der Suche nach Assemblys in die Domäne laden angeben. Anschließend wird die <xref:System.AppDomain.BaseDirectory%2A> Eigenschaft, um den Pfad des Basisverzeichnisses, für die Anzeige auf der Konsole zu erhalten.  
  
 [!code-cpp[ADSetup#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetup/CPP/adsetup.cpp#1)]
 [!code-csharp[ADSetup#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetup/CS/adsetup.cs#1)]
 [!code-vb[ADSetup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetup/VB/adsetup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Informationen in den Pfad selbst, sofern der Pfad ist in der Form "file://" oder \\\UNC\dir oder "" c: "\\". Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="P:System.AppDomainSetup.ApplicationBase" />
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearPrivatePath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearPrivatePath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearPrivatePath();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearPrivatePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt den Pfad, der den Speicherort von privaten Assemblys angibt, auf die leere Zeichenfolge ("") zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der private Pfad ist ein Pfad relativ zum des Basisverzeichnisses, mit dem die common Language Runtime zum Suchen von privaten Assemblys gesucht.  
  
 Weitere Informationen finden Sie unter <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.AppDomain.ClearPrivatePath%2A> -Methode entfernt alle Einträge aus der Liste der privaten Pfade zu suchen, wenn Assemblys geladen werden.  
  
 Diese Methode ist mittlerweile veraltet und sollte nicht für Neuentwicklungen verwendet werden.  
  
 [!code-cpp[ADClearPrivatePath#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADClearPrivatePath/CPP/adclearprivatepath.cpp#1)]
 [!code-csharp[ADClearPrivatePath#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADClearPrivatePath/CS/adclearprivatepath.cs#1)]
 [!code-vb[ADClearPrivatePath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADClearPrivatePath/VB/adclearprivatepath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearShadowCopyPath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearShadowCopyPath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearShadowCopyPath();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearShadowCopyPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die Liste der Verzeichnisse mit gespiegelten Assemblys auf die leere Zeichenfolge ("") zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Pfad der Schatten kopieren ist eine Liste der Verzeichnisse, in dem Schatten Assemblys kopiert, gespeichert sind.  
  
 Weitere Informationen finden Sie unter <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> und [von Schattenkopien von Assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue Instanz eines angegebenen COM-Typs.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Name einer Datei, die eine Assembly enthält, in der der angeforderte Typ definiert ist.</param>
        <param name="typeName">Der Name des angeforderten Typs.</param>
        <summary>Erstellt eine neue Instanz eines angegebenen COM-Typs. Parameter geben den Namen einer Datei mit einer Assembly an, die den Typ und den Typnamen enthält.</summary>
        <returns>Ein Objekt, das ein Wrapper für die neue Instanz ist, die durch <paramref name="typeName" /> angegeben wird. Der Rückgabewert muss für den Zugriff auf das eigentliche Objekt entwrappt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um Objekte Remote zu erstellen, ohne den Typ lokal laden zu müssen.  
  
 Der Rückgabewert muss Zugriff auf das eigentliche Objekt entwrappt werden.  
  
 Ein <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> Attribut mit einem Wert von `true` muss entweder explizit oder standardmäßig angewendet werden, die COM-Typ für diese Methode zum Erstellen einer Instanz dieses Typs; anderenfalls <xref:System.TypeLoadException> ausgelöst wird.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht.  
  
 [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CPP/createcominstancefrom.cpp#1)]
 [!code-csharp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CS/createcominstancefrom.cs#1)]
 [!code-vb[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/VB/createcominstancefrom.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> oder <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Der Typ kann nicht geladen werden.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein öffentlicher parameterloser Konstruktor gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" /> ist eine abstrakte Klasse.  
  
 - oder -   
  
 Dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> ist eine leere Zeichenfolge ("").</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.NullReferenceException">Das COM-Objekt, auf das verwiesen wird, ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyFile As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name einer Datei, die eine Assembly enthält, in der der angeforderte Typ definiert ist.</param>
        <param name="typeName">Der Name des angeforderten Typs.</param>
        <param name="hashValue">Stellt den Wert des errechneten Hashcodes dar.</param>
        <param name="hashAlgorithm">Stellt den vom Assemblymanifest verwendeten Hashalgorithmus dar.</param>
        <summary>Erstellt eine neue Instanz eines angegebenen COM-Typs. Parameter geben den Namen einer Datei mit einer Assembly an, die den Typ und den Typnamen enthält.</summary>
        <returns>Ein Objekt, das ein Wrapper für die neue Instanz ist, die durch <paramref name="typeName" /> angegeben wird. Der Rückgabewert muss für den Zugriff auf das eigentliche Objekt entwrappt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um Objekte Remote zu erstellen, ohne den Typ lokal laden zu müssen.  
  
 Der Rückgabewert muss Zugriff auf das eigentliche Objekt entwrappt werden.  
  
 Ein <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> Attribut mit einem Wert von `true` muss entweder explizit oder standardmäßig angewendet werden, die COM-Typ für diese Methode zum Erstellen einer Instanz dieses Typs; anderenfalls <xref:System.TypeLoadException> ausgelöst wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> oder <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Der Typ kann nicht geladen werden.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein öffentlicher parameterloser Konstruktor gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" /> ist eine abstrakte Klasse.  
  
 - oder -   
  
 Dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> ist die leere Zeichenfolge ("").</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.NullReferenceException">Das COM-Objekt, auf das verwiesen wird, ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDomain">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue Anwendungsdomäne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Der angezeigte Name der Domäne.</param>
        <summary>Erstellt eine neue Anwendungsdomäne mit dem angegebenen Namen.</summary>
        <returns>Die neu erstellte Anwendungsdomäne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `friendlyName` -Parameters sollte für die Domäne in einer Weise zu identifizieren, die aussagekräftige Bezeichnung. Diese Zeichenfolge sollte für die Anzeige in Benutzeroberflächen geeignet sein.  
  
 Diese methodenüberladung verwendet die <xref:System.AppDomainSetup> Informationen von der Standardanwendungsdomäne.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt im allgemeinen Vorgehensweise: erstellen eine Domäne mithilfe eines der <xref:System.AppDomain.CreateDomain%2A> Überladungen.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Bereitstellen von Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="P:System.AppDomain.FriendlyName" />
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Der angezeigte Name der Domäne. Dieser aussagekräftige Name zur Kennzeichnung der Domäne kann auf Benutzeroberflächen angezeigt werden. Weitere Informationen finden Sie unter <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Ein Beweis für die Identität des Codes, der in der Anwendungsdomäne ausgeführt wird. Übergeben Sie <see langword="null" />, um den Beweis der aktuellen Anwendungsdomäne zu verwenden.</param>
        <summary>Erstellt eine neue Anwendungsdomäne mit dem angegebenen Namen und den bereitgestellten Beweisen.</summary>
        <returns>Die neu erstellte Anwendungsdomäne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese methodenüberladung verwendet die <xref:System.AppDomainSetup> Informationen von der Standardanwendungsdomäne.  
  
 Wenn `securityInfo` ist nicht angegeben wird, wird der Beweis der aktuellen Anwendungsdomäne verwendet.  
  
> [!IMPORTANT]
>  Verwenden Sie die Überladung dieser Methode nicht zum Erstellen von Sandbox-Anwendungsdomänen. Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], den Nachweis, den für angegebene `securityInfo` wirkt sich nicht mehr auf des Berechtigungssatzes der Anwendungsdomäne. Verwenden der <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> methodenüberladung zum Erstellen von Sandbox-Anwendungsdomänen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt im allgemeinen Vorgehensweise: erstellen eine Domäne mithilfe eines der <xref:System.AppDomain.CreateDomain%2A> Überladungen.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Bereitstellen von Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Der angezeigte Name der Domäne. Dieser aussagekräftige Name zur Kennzeichnung der Domäne kann auf Benutzeroberflächen angezeigt werden. Weitere Informationen finden Sie unter <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Ein Beweis für die Identität des Codes, der in der Anwendungsdomäne ausgeführt wird. Übergeben Sie <see langword="null" />, um den Beweis der aktuellen Anwendungsdomäne zu verwenden.</param>
        <param name="info">Ein Objekt, das Initialisierungsinformationen für die Anwendungsdomäne enthält.</param>
        <summary>Erstellt eine neue Anwendungsdomäne mit dem angegebenen Namen, den angegebenen Beweisen und Anwendungsdomänen-Setupinformationen.</summary>
        <returns>Die neu erstellte Anwendungsdomäne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `info` ist nicht angegeben wird, Überladung dieser Methode verwendet die <xref:System.AppDomainSetup> Informationen von der Standardanwendungsdomäne.  
  
 Wenn `securityInfo` ist nicht angegeben wird, wird der Beweis der aktuellen Anwendungsdomäne verwendet.  
  
> [!IMPORTANT]
>  Verwenden Sie die Überladung dieser Methode nicht zum Erstellen von Sandbox-Anwendungsdomänen. Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], den Nachweis, den für angegebene `securityInfo` wirkt sich nicht mehr auf des Berechtigungssatzes der Anwendungsdomäne. Verwenden der <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> methodenüberladung zum Erstellen von Sandbox-Anwendungsdomänen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt im allgemeinen Vorgehensweise: erstellen eine Domäne mithilfe eines der <xref:System.AppDomain.CreateDomain%2A> Überladungen.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Bereitstellen von Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, params System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup, grantSet As PermissionSet, ParamArray fullTrustAssemblies As StrongName()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info, System::Security::PermissionSet ^ grantSet, ... cli::array &lt;System::Security::Policy::StrongName ^&gt; ^ fullTrustAssemblies);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="friendlyName">Der angezeigte Name der Domäne. Dieser aussagekräftige Name zur Kennzeichnung der Domäne kann auf Benutzeroberflächen angezeigt werden. Weitere Informationen finden Sie in der Beschreibung von <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Ein Beweis für die Identität des Codes, der in der Anwendungsdomäne ausgeführt wird. Übergeben Sie <see langword="null" />, um den Beweis der aktuellen Anwendungsdomäne zu verwenden.</param>
        <param name="info">Ein Objekt, das Initialisierungsinformationen für die Anwendungsdomäne enthält.</param>
        <param name="grantSet">Ein Standardberechtigungssatz, der allen Assemblys gewährt wird, die in die neue Anwendungsdomäne geladen werden und über keine speziellen Berechtigungen verfügen.</param>
        <param name="fullTrustAssemblies">Ein Array von starken Namen, die Assemblys darstellen und in der neuen Anwendungsdomäne als vollständig vertrauenswürdig betrachtet werden sollen.</param>
        <summary>Erstellt eine neue Anwendungsdomäne mit angegebenem Namen, Beweis, Anwendungsdomänen-Setupinformationen, Standardberechtigungssatz und Array vollständig vertrauenswürdiger Assemblys.</summary>
        <returns>Die neu erstellte Anwendungsdomäne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Müssen Sie festlegen der <xref:System.AppDomainSetup.ApplicationBase%2A> Eigenschaft von der <xref:System.AppDomainSetup> -Objekt, das Sie, für die angeben `info`. Andernfalls wird eine Ausnahme ausgelöst.  
  
 Wenn `securityInfo` ist nicht angegeben wird, wird der Beweis der aktuellen Anwendungsdomäne verwendet.  
  
 Die bereitgestellten Informationen `grantSet` und `fullTrustAssemblies` dient zum Erstellen einer <xref:System.Security.Policy.ApplicationTrust> Objekt für die neue Anwendungsdomäne.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Die Anwendungsdomäne ist <see langword="null" />.  
  
 - oder -   
  
 Die <see cref="P:System.AppDomainSetup.ApplicationBase" />-Eigenschaft ist nicht für das <see cref="T:System.AppDomainSetup" />-Objekt festgelegt, das für <paramref name="info" /> bereitgestellt ist.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Fähigkeit, eine Anwendungsdomäne zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Der angezeigte Name der Domäne. Dieser aussagekräftige Name zur Kennzeichnung der Domäne kann auf Benutzeroberflächen angezeigt werden. Weitere Informationen finden Sie unter <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Ein Beweis für die Identität des Codes, der in der Anwendungsdomäne ausgeführt wird. Übergeben Sie <see langword="null" />, um den Beweis der aktuellen Anwendungsdomäne zu verwenden.</param>
        <param name="appBasePath">Das Basisverzeichnis, das der Assemblyresolver für die Suche nach Assemblys verwendet. Weitere Informationen finden Sie unter <see cref="P:System.AppDomain.BaseDirectory" />.</param>
        <param name="appRelativeSearchPath">Der Pfad, in dem der Assemblyresolver nach privaten Assemblys suchen soll, mit einer relativen Angabe zum Basisverzeichnis. Weitere Informationen finden Sie unter <see cref="P:System.AppDomain.RelativeSearchPath" />.</param>
        <param name="shadowCopyFiles">Wenn <see langword="true" />, wird eine Spiegelung einer Assembly in diese Anwendungsdomäne geladen.</param>
        <summary>Erstellt eine neue Anwendungsdomäne mit dem angegebenen Namen unter Verwendung der Beweise, des Anwendungsbasispfads, des relativen Suchpfads und eines Parameters, der angibt, ob eine Schattenkopie einer Assembly in die Anwendungsdomäne geladen werden soll.</summary>
        <returns>Die neu erstellte Anwendungsdomäne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `securityInfo` ist nicht angegeben wird, wird der Beweis der aktuellen Anwendungsdomäne verwendet.  
  
 Weitere Informationen zum Erstellen von Schattenkopien finden Sie unter <xref:System.AppDomain.ShadowCopyFiles%2A> und [von Schattenkopien von Assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
> [!IMPORTANT]
>  Verwenden Sie die Überladung dieser Methode nicht zum Erstellen von Sandbox-Anwendungsdomänen. Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], den Nachweis, den für angegebene `securityInfo` wirkt sich nicht mehr auf des Berechtigungssatzes der Anwendungsdomäne. Verwenden der <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> methodenüberladung zum Erstellen von Sandbox-Anwendungsdomänen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt im allgemeinen Vorgehensweise: erstellen eine Domäne mithilfe eines der <xref:System.AppDomain.CreateDomain%2A> Überladungen.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Bereitstellen von Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean, adInit As AppDomainInitializer, adInitArgs As String()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer ^ adInit, cli::array &lt;System::String ^&gt; ^ adInitArgs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" />
        <Parameter Name="adInitArgs" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Der angezeigte Name der Domäne. Dieser aussagekräftige Name zur Kennzeichnung der Domäne kann auf Benutzeroberflächen angezeigt werden. Weitere Informationen finden Sie unter <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Ein Beweis für die Identität des Codes, der in der Anwendungsdomäne ausgeführt wird. Übergeben Sie <see langword="null" />, um den Beweis der aktuellen Anwendungsdomäne zu verwenden.</param>
        <param name="appBasePath">Das Basisverzeichnis, das der Assemblyresolver für die Suche nach Assemblys verwendet. Weitere Informationen finden Sie unter <see cref="P:System.AppDomain.BaseDirectory" />.</param>
        <param name="appRelativeSearchPath">Der Pfad, in dem der Assemblyresolver nach privaten Assemblys suchen soll, mit einer relativen Angabe zum Basisverzeichnis. Weitere Informationen finden Sie unter <see cref="P:System.AppDomain.RelativeSearchPath" />.</param>
        <param name="shadowCopyFiles">
          <see langword="true" />, um eine Schattenkopie einer Assembly in die Anwendungsdomäne zu laden.</param>
        <param name="adInit">Ein <see cref="T:System.AppDomainInitializer" />-Delegat, der eine Rückrufmethode darstellt, die beim Initialisieren des neuen <see cref="T:System.AppDomain" />-Objekts aufgerufen werden soll.</param>
        <param name="adInitArgs">Ein Array von Zeichenfolgenargumenten, das an die durch <c>adInit</c> dargestellte Rückrufmethode übergeben werden soll, wenn das neue <see cref="T:System.AppDomain" />-Objekt initialisiert wird.</param>
        <summary>Erstellt eine neue Anwendungsdomäne mit dem angegebenen Namen unter Verwendung der Beweise, des Anwendungsbasispfads, des relativen Suchpfads und eines Parameters, der angibt, ob eine Schattenkopie einer Assembly in die Anwendungsdomäne geladen werden soll. Gibt eine Rückrufmethode an, die beim Initialisieren der Anwendungsdomäne aufgerufen wird, und ein Array von Zeichenfolgenargumenten, die an die Rückrufmethode übergeben werden sollen.</summary>
        <returns>Die neu erstellte Anwendungsdomäne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die dargestellte Methode `adInit` im Kontext der neu erstellte Anwendungsdomäne ausgeführt wird.  
  
 Wenn `securityInfo` ist nicht angegeben wird, wird der Beweis der aktuellen Anwendungsdomäne verwendet.  
  
 Weitere Informationen zum Erstellen von Schattenkopien finden Sie unter <xref:System.AppDomain.ShadowCopyFiles%2A> und [von Schattenkopien von Assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
> [!IMPORTANT]
>  Verwenden Sie die Überladung dieser Methode nicht zum Erstellen von Sandbox-Anwendungsdomänen. Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], den Nachweis, den für angegebene `securityInfo` wirkt sich nicht mehr auf des Berechtigungssatzes der Anwendungsdomäne. Verwenden der <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> methodenüberladung zum Erstellen von Sandbox-Anwendungsdomänen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="friendlyName" /> ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Bereitstellen von Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue Instanz eines angegebenen Typs, der in einer angegebenen Assembly definiert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs, der in der angegebenen Assembly definiert ist.</summary>
        <returns>Ein Objekt, das ein Wrapper für die neue Instanz ist, die durch <paramref name="typeName" /> angegeben wird. Der Rückgabewert muss für den Zugriff auf das eigentliche Objekt entwrappt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft den Standardkonstruktor für `typeName`.  
  
 Finden Sie unter <xref:System.Reflection.AssemblyName> für das Format von `assemblyName`.  
  
 Ein Versuch, aufzurufen <xref:System.AppDomain.CreateInstance%2A> auf ein Ziel führt die Anwendungsdomäne, die nicht die aktuelle Anwendungsdomäne ist in der Assembly in der Ziel-Anwendungsdomäne geladen. Da ein <xref:System.Reflection.Assembly> ist nicht <xref:System.MarshalByRefObject>, wenn diese Methode versucht, Zurückgeben der <xref:System.Reflection.Assembly> für die geladene Assembly in der aktuellen Anwendungsdomäne, versucht die common Language Runtime die Assembly in die aktuelle Anwendungsdomäne geladen und die Last möglicherweise fehl. Die Assembly, die in der aktuellen Anwendungsdomäne geladen ist möglicherweise aus der Assembly unterscheiden, die zuerst geladen wurde, wenn die pfadeinstellungen für die zwei Anwendungsdomänen unterscheiden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> oder <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyName" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.NullReferenceException">Diese Instanz ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder eines Verzeichnisses und für den Zugriff auf die Informationen in den Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Fähigkeit zum Aufrufen von nicht verwalteten Codes beim Erstellen einer Instanz eines Delegaten. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
 Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs, der in der angegebenen Assembly definiert ist. Ein Parameter gibt ein Array von Aktivierungsattributen an.</summary>
        <returns>Ein Objekt, das ein Wrapper für die neue Instanz ist, die durch <paramref name="typeName" /> angegeben wird. Der Rückgabewert muss für den Zugriff auf das eigentliche Objekt entwrappt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft den Standardkonstruktor für `typeName`.  
  
 Finden Sie unter <xref:System.Reflection.AssemblyName> für das Format von `assemblyName`.  
  
 Ein Versuch, aufzurufen <xref:System.AppDomain.CreateInstance%2A> auf ein Ziel führt die Anwendungsdomäne, die nicht die aktuelle Anwendungsdomäne ist in der Assembly in der Ziel-Anwendungsdomäne geladen. Da ein <xref:System.Reflection.Assembly> ist nicht <xref:System.MarshalByRefObject>, wenn diese Methode versucht, Zurückgeben der <xref:System.Reflection.Assembly> für die geladene Assembly in der aktuellen Anwendungsdomäne, versucht die common Language Runtime die Assembly in die aktuelle Anwendungsdomäne geladen und die Last möglicherweise fehl. Die Assembly, die in der aktuellen Anwendungsdomäne geladen ist möglicherweise aus der Assembly unterscheiden, die zuerst geladen wurde, wenn die pfadeinstellungen für die zwei Anwendungsdomänen unterscheiden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> oder <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyName" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.NullReferenceException">Diese Instanz ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Fähigkeit zum Aufrufen von nicht verwalteten Codes beim Erstellen einer Instanz eines Delegaten. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für die Fähigkeit zum Aufrufen von Vorgängen für alle Typmember. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <param name="ignoreCase">Ein boolescher Wert, der angibt, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll.</param>
        <param name="bindingAttr">Eine Kombination von 0 (null) oder mehr Bitflags, die die Suche nach dem <c>typeName</c>-Konstruktor beeinflussen. Wenn <c>bindingAttr</c> 0 (null) ist, wird eine Suche nach öffentlichen Konstruktoren unter Beachtung der Groß-/Kleinschreibung durchgeführt.</param>
        <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see cref="T:System.Reflection.MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn <c>binder</c> den Wert NULL aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Die an den Konstruktor zu übergebenden Argumente. Dieses Array von Argumenten muss hinsichtlich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmen. Wenn der Standardkonstruktor bevorzugt wird, muss <c>args</c> ein leeres Array oder NULL sein.</param>
        <param name="culture">Kulturabhängige Informationen, die die Koersion von <c>args</c> in die für den <c>typeName</c>-Konstruktor deklarierten formalen Typen bestimmen. Wenn <c>culture</c><see langword="null" /> ist, wird die <see cref="T:System.Globalization.CultureInfo" /> für den aktuellen Thread verwendet.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
 Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs, der in der angegebenen Assembly definiert ist. Parameter geben einen Binder, Bindungsflags, Konstruktorargumente, kulturspezifische Informationen zum Interpretieren von Argumenten und optionale Aktivierungsattribute an.</summary>
        <returns>Ein Objekt, das ein Wrapper für die neue Instanz ist, die durch <paramref name="typeName" /> angegeben wird. Der Rückgabewert muss für den Zugriff auf das eigentliche Objekt entwrappt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Finden Sie unter <xref:System.Reflection.AssemblyName> für das Format von `assemblyName`.  
  
 Ein Versuch, aufzurufen <xref:System.AppDomain.CreateInstance%2A> auf ein Ziel führt die Anwendungsdomäne, die nicht die aktuelle Anwendungsdomäne ist in der Assembly in der Ziel-Anwendungsdomäne geladen. Da ein <xref:System.Reflection.Assembly> ist nicht <xref:System.MarshalByRefObject>, wenn diese Methode versucht, Zurückgeben der <xref:System.Reflection.Assembly> für die geladene Assembly in der aktuellen Anwendungsdomäne, versucht die common Language Runtime die Assembly in die aktuelle Anwendungsdomäne geladen und die Last möglicherweise fehl. Die Assembly, die in der aktuellen Anwendungsdomäne geladen ist möglicherweise aus der Assembly unterscheiden, die zuerst geladen wurde, wenn die pfadeinstellungen für die zwei Anwendungsdomänen unterscheiden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> oder <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
 - oder -   
  
 <paramref name="assemblyName" /> wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender Konstruktor gefunden.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.NullReferenceException">Diese Instanz ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Fähigkeit zum Aufrufen von nicht verwalteten Codes beim Erstellen einer Instanz eines Delegaten. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für die Fähigkeit zum Aufrufen von Vorgängen für alle Typmember. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <param name="ignoreCase">Ein boolescher Wert, der angibt, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll.</param>
        <param name="bindingAttr">Eine Kombination von 0 (null) oder mehr Bitflags, die die Suche nach dem <c>typeName</c>-Konstruktor beeinflussen. Wenn <c>bindingAttr</c> 0 (null) ist, wird eine Suche nach öffentlichen Konstruktoren unter Beachtung der Groß-/Kleinschreibung durchgeführt.</param>
        <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see cref="T:System.Reflection.MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn <c>binder</c> den Wert NULL aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Die an den Konstruktor zu übergebenden Argumente. Dieses Array von Argumenten muss hinsichtlich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmen. Wenn der Standardkonstruktor bevorzugt wird, muss <c>args</c> ein leeres Array oder NULL sein.</param>
        <param name="culture">Kulturabhängige Informationen, die die Koersion von <c>args</c> in die für den <c>typeName</c>-Konstruktor deklarierten formalen Typen bestimmen. Wenn <c>culture</c><see langword="null" /> ist, wird die <see cref="T:System.Globalization.CultureInfo" /> für den aktuellen Thread verwendet.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
 Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <param name="securityAttributes">Informationen, die zum Autorisieren der Erstellung von <c>typeName</c> verwendet werden.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs, der in der angegebenen Assembly definiert ist. Parameter geben einen Binder, Bindungsflags, Konstruktorargumente, kulturspezifische Informationen zum Interpretieren von Argumenten, Aktivierungsattribute und die Autorisierung zum Erstellen des Typs an.</summary>
        <returns>Ein Objekt, das ein Wrapper für die neue Instanz ist, die durch <paramref name="typeName" /> angegeben wird. Der Rückgabewert muss für den Zugriff auf das eigentliche Objekt entwrappt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Finden Sie unter <xref:System.Reflection.AssemblyName> für das Format von `assemblyName`.  
  
 Ein Versuch, aufzurufen <xref:System.AppDomain.CreateInstance%2A> auf ein Ziel führt die Anwendungsdomäne, die nicht die aktuelle Anwendungsdomäne ist in der Assembly in der Ziel-Anwendungsdomäne geladen. Da ein <xref:System.Reflection.Assembly> ist nicht <xref:System.MarshalByRefObject>, wenn diese Methode versucht, Zurückgeben der <xref:System.Reflection.Assembly> für die geladene Assembly in der aktuellen Anwendungsdomäne, versucht die common Language Runtime die Assembly in die aktuelle Anwendungsdomäne geladen und die Last möglicherweise fehl. Die Assembly, die in der aktuellen Anwendungsdomäne geladen ist möglicherweise aus der Assembly unterscheiden, die zuerst geladen wurde, wenn die pfadeinstellungen für die zwei Anwendungsdomänen unterscheiden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> oder <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyName" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender Konstruktor gefunden.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.  
  
 - oder -   
  
 <paramref name="securityAttributes" /> ist nicht <see langword="null" />. Wenn die Legacy-CAS-Richtlinie nicht aktiviert ist, sollte <paramref name="securityAttributes" /><see langword="null." /> sein.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.NullReferenceException">Diese Instanz ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Bereitstellen von Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für die Fähigkeit zum Aufrufen von Vorgängen für alle Typmember. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue Instanz eines angegebenen Typs.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs. Parameter geben die Assembly, in der der Typ definiert ist, und den Namen des Typs an.</summary>
        <returns>Eine Instanz des durch <paramref name="typeName" /> angegebenen Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine bequeme Methode, die kombiniert <xref:System.AppDomain.CreateInstance%2A> und <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Diese Methode ruft den Standardkonstruktor für `typeName`.  
  
 Finden Sie unter <xref:System.Reflection.AssemblyName> für das Format von `assemblyName`. Finden Sie unter der <xref:System.Type.FullName%2A?displayProperty=nameWithType> -Eigenschaft für das Format der `typeName`.  
  
> [!NOTE]
>  Einen früh gebundener Aufruf an eine Methode ausführen `M` eines Objekts vom Typ `T1` der zurückgegeben wurde, indem <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, und dass die Methode einen früh gebundener Aufruf an eine Methode eines Objekts vom Typ macht `T2` in einer Assembly `C` außer der aktuelle Assembly oder die Assembly mit `T1`, Assembly `C` wird in der aktuellen Anwendungsdomäne geladen. Dieser Ladevorgang wird ausgeführt, selbst wenn die früh gebundenen Aufruf von `T1.M()` wurde versucht, im Text einer <xref:System.Reflection.Emit.DynamicMethod>, oder in anderen dynamisch generierten Code. Wenn die aktuelle Domäne die Standarddomäne, die Assembly ist `C` kann nicht entladen werden, bis der Prozess beendet wird. Wenn die aktuelle Domäne später, beim Laden der Assembly versucht `C`, kann der Ladevorgang fehlschlagen.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die einfachste Möglichkeit zum Ausführen von Code in einer anderen Anwendungsdomäne. Im Beispiel definiert eine Klasse namens `Worker` von erbt <xref:System.MarshalByRefObject>. Die `Worker` Klasse definiert eine Methode, die den Namen der Anwendungsdomäne anzeigt, in der er ausgeführt wird. Das Beispiel erstellt Instanzen von `Worker` in der Standardanwendungsdomäne und in eine neue Anwendungsdomäne.  
  
> [!NOTE]
>  Die Assembly mit `Worker` muss in beide Anwendungsdomänen geladen werden, aber andere Assemblys, die nur in der neuen Anwendungsdomäne geladen werden können.  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> oder <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyName" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält oder wenn Sie einen Typ aus einem Modul als der Manifestdatei erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
 Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs. Parameter geben die Assembly an, in der der Typ definiert ist, und den Namen des Typs und ein Array von Aktivierungsattributen.</summary>
        <returns>Eine Instanz des durch <paramref name="typeName" /> angegebenen Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine bequeme Methode, die kombiniert <xref:System.AppDomain.CreateInstance%2A> und <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Diese Methode ruft den Standardkonstruktor für `typeName`.  
  
 Finden Sie unter <xref:System.Reflection.AssemblyName> für das Format von `assemblyName`. Finden Sie unter der <xref:System.Type.FullName%2A?displayProperty=nameWithType> -Eigenschaft für das Format der `typeName`.  
  
> [!NOTE]
>  Einen früh gebundener Aufruf an eine Methode ausführen `M` eines Objekts vom Typ `T1` der zurückgegeben wurde, indem <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, und dass die Methode einen früh gebundener Aufruf an eine Methode eines Objekts vom Typ macht `T2` in einer Assembly `C` außer der aktuelle Assembly oder die Assembly mit `T1`, Assembly `C` wird in der aktuellen Anwendungsdomäne geladen. Dieser Ladevorgang wird ausgeführt, selbst wenn die früh gebundenen Aufruf von `T1.M()` wurde versucht, im Text einer <xref:System.Reflection.Emit.DynamicMethod>, oder in anderen dynamisch generierten Code. Wenn die aktuelle Domäne die Standarddomäne, die Assembly ist `C` kann nicht entladen werden, bis der Prozess beendet wird. Wenn die aktuelle Domäne später, beim Laden der Assembly versucht `C`, kann der Ladevorgang fehlschlagen.  
  
   
  
## Examples  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> oder <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyName" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Fähigkeit zum Aufrufen von nicht verwalteten Codes beim Erstellen einer Instanz eines Delegaten. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für die Fähigkeit zum Aufrufen von Vorgängen für alle Typmember. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <param name="ignoreCase">Ein boolescher Wert, der angibt, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll.</param>
        <param name="bindingAttr">Eine Kombination von 0 (null) oder mehr Bitflags, die die Suche nach dem <c>typeName</c>-Konstruktor beeinflussen. Wenn <c>bindingAttr</c> 0 (null) ist, wird eine Suche nach öffentlichen Konstruktoren unter Beachtung der Groß-/Kleinschreibung durchgeführt.</param>
        <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see cref="T:System.Reflection.MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn <c>binder</c> den Wert NULL aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Die an den Konstruktor zu übergebenden Argumente. Dieses Array von Argumenten muss hinsichtlich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmen. Wenn der Standardkonstruktor bevorzugt wird, muss <c>args</c> ein leeres Array oder NULL sein.</param>
        <param name="culture">Ein kulturspezifisches Objekt, mit dem die Umwandlung von Typen geregelt wird. Wenn <c>culture</c><see langword="null" /> ist, wird die <see langword="CultureInfo" /> für den aktuellen Thread verwendet.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. In der Regel ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält. Dies gibt die zum Aktivieren eines Remoteobjekts erforderliche URL an.  
  
 Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <summary>Erstellt eine neue Instanz des angegebenen, in der angegebenen Assembly definierten Typs, die angibt, ob die Groß-/Kleinschreibung des Typnamens ignoriert wird, außerdem die Bindungsattribute und den Binder, mit denen der zu erstellende Typ ausgewählt wird, die Argumente des Konstruktors, die Kultur und die Aktivierungsattribute.</summary>
        <returns>Eine Instanz des durch <paramref name="typeName" /> angegebenen Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine bequeme Methode, die kombiniert <xref:System.AppDomain.CreateInstance%2A> und <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Finden Sie unter <xref:System.Reflection.AssemblyName> für das Format von `assemblyName`. Finden Sie unter der <xref:System.Type.FullName%2A?displayProperty=nameWithType> -Eigenschaft für das Format der `typeName`.  
  
> [!NOTE]
>  Einen früh gebundener Aufruf an eine Methode ausführen `M` eines Objekts vom Typ `T1` der zurückgegeben wurde, indem <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, und dass die Methode einen früh gebundener Aufruf an eine Methode eines Objekts vom Typ macht `T2` in einer Assembly `C` außer der aktuelle Assembly oder die Assembly mit `T1`, Assembly `C` wird in der aktuellen Anwendungsdomäne geladen. Dieser Ladevorgang wird ausgeführt, selbst wenn die früh gebundenen Aufruf von `T1.M()` wurde versucht, im Text einer <xref:System.Reflection.Emit.DynamicMethod>, oder in anderen dynamisch generierten Code. Wenn die aktuelle Domäne die Standarddomäne, die Assembly ist `C` kann nicht entladen werden, bis der Prozess beendet wird. Wenn die aktuelle Domäne später, beim Laden der Assembly versucht `C`, kann der Ladevorgang fehlschlagen.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die Verwendung von der `ignoreCase` Parameter.  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> oder <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender Konstruktor gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
 - oder -   
  
 <paramref name="assemblyName" /> wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Fähigkeit zum Aufrufen von nicht verwalteten Codes beim Erstellen einer Instanz eines Delegaten. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für die Fähigkeit zum Aufrufen von Vorgängen für alle Typmember. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <param name="ignoreCase">Ein boolescher Wert, der angibt, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll.</param>
        <param name="bindingAttr">Eine Kombination von 0 (null) oder mehr Bitflags, die die Suche nach dem <c>typeName</c>-Konstruktor beeinflussen. Wenn <c>bindingAttr</c> 0 (null) ist, wird eine Suche nach öffentlichen Konstruktoren unter Beachtung der Groß-/Kleinschreibung durchgeführt.</param>
        <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see cref="T:System.Reflection.MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn <c>binder</c> den Wert NULL aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Die an den Konstruktor zu übergebenden Argumente. Dieses Array von Argumenten muss hinsichtlich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmen. Wenn der Standardkonstruktor bevorzugt wird, muss <c>args</c> ein leeres Array oder NULL sein.</param>
        <param name="culture">Ein kulturspezifisches Objekt, mit dem die Umwandlung von Typen geregelt wird. Wenn <c>culture</c><see langword="null" /> ist, wird die <see langword="CultureInfo" /> für den aktuellen Thread verwendet.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
 Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <param name="securityAttributes">Informationen, die zum Autorisieren der Erstellung von <c>typeName</c> verwendet werden.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs. Parameter geben den Namen des Typs an und wie er gesucht und erstellt werden kann.</summary>
        <returns>Eine Instanz des durch <paramref name="typeName" /> angegebenen Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine bequeme Methode, die kombiniert <xref:System.AppDomain.CreateInstance%2A> und <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Finden Sie unter <xref:System.Reflection.AssemblyName> für das Format von `assemblyName`. Finden Sie unter der <xref:System.Type.FullName%2A?displayProperty=nameWithType> -Eigenschaft für das Format der `typeName`.  
  
> [!NOTE]
>  Einen früh gebundener Aufruf an eine Methode ausführen `M` eines Objekts vom Typ `T1` der zurückgegeben wurde, indem <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, und dass die Methode einen früh gebundener Aufruf an eine Methode eines Objekts vom Typ macht `T2` in einer Assembly `C` außer der aktuelle Assembly oder die Assembly mit `T1`, Assembly `C` wird in der aktuellen Anwendungsdomäne geladen. Dieser Ladevorgang wird ausgeführt, selbst wenn die früh gebundenen Aufruf von `T1.M()` wurde versucht, im Text einer <xref:System.Reflection.Emit.DynamicMethod>, oder in anderen dynamisch generierten Code. Wenn die aktuelle Domäne die Standarddomäne, die Assembly ist `C` kann nicht entladen werden, bis der Prozess beendet wird. Wenn die aktuelle Domäne später, beim Laden der Assembly versucht `C`, kann der Ladevorgang fehlschlagen.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die Verwendung von der `ignoreCase` Parameter.  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> oder <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender Konstruktor gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyName" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assembly mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für die Fähigkeit zum Aufrufen von Vorgängen für alle Typmember. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue Instanz eines angegebenen Typs, der in der angegebenen Assemblydatei definiert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name einschließlich des Pfads einer Datei, die eine Assembly enthält, in der der angeforderte Typ definiert ist. Die Assembly wird mit der <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />-Methode geladen.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs, der in der angegebenen Assemblydatei definiert ist.</summary>
        <returns>Ein Objekt, das ein Wrapper für die neue Instanz ist, oder <see langword="null" />, wenn <paramref name="typeName" /> nicht gefunden wurde. Der Rückgabewert muss für den Zugriff auf das eigentliche Objekt entwrappt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardkonstruktor für `typeName` aufgerufen wird.  
  
 Weitere Informationen finden Sie unter der Methode <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 Wenn die <xref:System.AppDomain.CreateInstanceFrom%2A> Methode dient zum Erstellen einer Instanz in einer Zielanwendungsdomäne als der Anwendungsdomäne, aus dem der Aufruf erfolgt, wird die Assembly in der Ziel-Anwendungsdomäne geladen. Jedoch, wenn die Instanz in der aufrufenden Anwendungsdomäne nicht eingeschlossen ist, kann die entwrappte Instanz auf bestimmte Weise die Assembly in der aufrufenden Anwendungsdomäne geladen werden soll verursachen. Beispielsweise nach dem die Instanz nicht eingeschlossen ist, die Typinformationen angefordert werden kann, um seine Methoden aufrufen spät gebunden. Wenn die Assembly in der aufrufenden Anwendungsdomäne geladen wird, können Ausnahmen auftreten.  
  
-   Wenn eine andere Version derselben Assembly bereits in der aufrufenden Anwendungsdomäne geladen wurde, oder wenn im Ladepfad der aufrufenden Anwendungsdomäne unterscheidet, von der Zielanwendungsdomäne Ausnahmen wie <xref:System.MissingMethodException> auftreten können.  
  
-   Wenn die aufrufenden Anwendungsdomäne früh gebundene Aufrufe den Instanztyp <xref:System.InvalidCastException> ausgelöst werden kann, bei dem Versuch der umgewandelt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> -methodenüberladung eine Instanz eines Objekts in eine Zielanwendungsdomäne erstellen und ihre Methoden aufrufen.  
  
 Im Beispiel definiert die `MarshallableExample` -Klasse, die über die Grenzen der Anwendungsdomäne hinweg gemarshallt werden kann. Im Beispiel wird einen Pfad zu der aktuell ausgeführten Assembly erstellt, erstellt eine Zielanwendungsdomäne und verwendet die <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> -methodenüberladung, um die Beispielassembly in der Zielanwendungsdomäne laden und erstellen Sie eine Instanz des `MarshallableExample`.  
  
> [!NOTE]
>  Der Pfad kann absolut in diesem Beispiel, aber ein relativer Pfad würde auch funktionieren, da die <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> Methode wird verwendet, um die Assembly zu laden.  
  
 Nach dem Entpacken der Objekthandle aus und wird in diesem Beispiel drei Möglichkeiten, ein Objekt in einer Zielanwendungsdomäne zu verwenden:  
  
-   Aufrufen einer Methode mit später Bindung, die über Reflektion ermöglicht. Dies erfordert Typinformationen, wodurch die Assembly in die Anwendungsdomäne des Aufrufers geladen werden soll. (In diesem Beispiel ist es bereits geladen.)  
  
-   Wandeln das Objekt, das eine Schnittstelle, die der Aufrufer und dem aufgerufenen bekannt. Wenn die Schnittstelle in der aufrufenden Assembly oder in einer dritten Assembly verwiesen wird, vom Aufrufer und dem aufgerufenen definiert ist, wird die aufgerufene Assembly nicht in die Anwendungsdomäne des Aufrufers geladen.  
  
-   Verwenden das Objekt direkt bei der Typ, an den Aufrufer bekannt ist. Die Assembly muss in die Anwendungsdomäne des Aufrufers geladen werden.  
  
 Eine andere Möglichkeit zur Vermeidung die aufgerufene Assembly in die Anwendungsdomäne des Aufrufers geladen wird, für den Aufrufer Ableitung der <xref:System.MarshalByRefObject> Klasse und eine Methode definieren, die in der Zielanwendungsdomäne ausgeführt werden können. Diese Methode kann Reflektion verwenden eine Zielassembly untersuchen, da die Zielassembly bereits in der Zielanwendungsdomäne geladen wird. Siehe das Beispiel für die <xref:System.AppDomain.DynamicDirectory%2A> Eigenschaft.  
  
 [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cpp/example.cpp#1)]
 [!code-csharp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cs/example.cs#1)]
 [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> wurde in <paramref name="assemblyFile" /> nicht gefunden.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein parameterloser öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine ausreichende Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyFile" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.NullReferenceException">Diese Instanz ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name einschließlich des Pfads einer Datei, die eine Assembly enthält, in der der angeforderte Typ definiert ist. Die Assembly wird mit der <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />-Methode geladen.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
 Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs, der in der angegebenen Assemblydatei definiert ist.</summary>
        <returns>Ein Objekt, das ein Wrapper für die neue Instanz ist, oder <see langword="null" />, wenn <paramref name="typeName" /> nicht gefunden wurde. Der Rückgabewert muss für den Zugriff auf das eigentliche Objekt entwrappt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardkonstruktor für `typeName` aufgerufen wird.  
  
 Weitere Informationen zu dieser Methode finden Sie unter der <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> Methode.  
  
 Wenn die <xref:System.AppDomain.CreateInstanceFrom%2A> Methode dient zum Erstellen einer Instanz in einer Zielanwendungsdomäne als der Anwendungsdomäne, aus dem der Aufruf erfolgt, wird die Assembly in der Ziel-Anwendungsdomäne geladen. Jedoch, wenn die Instanz in der aufrufenden Anwendungsdomäne nicht eingeschlossen ist, kann die entwrappte Instanz auf bestimmte Weise die Assembly in der aufrufenden Anwendungsdomäne geladen werden soll verursachen. Beispielsweise nach dem die Instanz nicht eingeschlossen ist, die Typinformationen angefordert werden kann, um seine Methoden aufrufen spät gebunden. Wenn die Assembly in der aufrufenden Anwendungsdomäne geladen wird, können Ausnahmen auftreten.  
  
-   Wenn eine andere Version derselben Assembly bereits in der aufrufenden Anwendungsdomäne geladen wurde, oder wenn im Ladepfad der aufrufenden Anwendungsdomäne unterscheidet, von der Zielanwendungsdomäne Ausnahmen wie <xref:System.MissingMethodException> auftreten können.  
  
-   Wenn die aufrufenden Anwendungsdomäne früh gebundene Aufrufe den Instanztyp <xref:System.InvalidCastException> ausgelöst werden kann, bei dem Versuch der umgewandelt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> wurde in <paramref name="assemblyFile" /> nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine ausreichende Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyFile" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.NullReferenceException">Diese Instanz ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name einschließlich des Pfads einer Datei, die eine Assembly enthält, in der der angeforderte Typ definiert ist. Die Assembly wird mit der <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />-Methode geladen.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <param name="ignoreCase">Ein boolescher Wert, der angibt, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll.</param>
        <param name="bindingAttr">Eine Kombination von 0 (null) oder mehr Bitflags, die die Suche nach dem <c>typeName</c>-Konstruktor beeinflussen. Wenn <c>bindingAttr</c> 0 (null) ist, wird eine Suche nach öffentlichen Konstruktoren unter Beachtung der Groß-/Kleinschreibung durchgeführt.</param>
        <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see cref="T:System.Reflection.MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn <c>binder</c> den Wert NULL aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Die an den Konstruktor zu übergebenden Argumente. Dieses Array von Argumenten muss hinsichtlich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmen. Wenn der Standardkonstruktor bevorzugt wird, muss <c>args</c> ein leeres Array oder NULL sein.</param>
        <param name="culture">Kulturabhängige Informationen, die die Koersion von <c>args</c> in die für den <c>typeName</c>-Konstruktor deklarierten formalen Typen bestimmen. Wenn <c>culture</c><see langword="null" /> ist, wird die <see cref="T:System.Globalization.CultureInfo" /> für den aktuellen Thread verwendet.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
 Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs, der in der angegebenen Assemblydatei definiert ist.</summary>
        <returns>Ein Objekt, das ein Wrapper für die neue Instanz ist, oder <see langword="null" />, wenn <paramref name="typeName" /> nicht gefunden wurde. Der Rückgabewert muss für den Zugriff auf das eigentliche Objekt entwrappt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter der Methode <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 Wenn die <xref:System.AppDomain.CreateInstanceFrom%2A> Methode dient zum Erstellen einer Instanz in einer Zielanwendungsdomäne als der Anwendungsdomäne, aus dem der Aufruf erfolgt, wird die Assembly in der Ziel-Anwendungsdomäne geladen. Jedoch, wenn die Instanz in der aufrufenden Anwendungsdomäne nicht eingeschlossen ist, kann die entwrappte Instanz auf bestimmte Weise die Assembly in der aufrufenden Anwendungsdomäne geladen werden soll verursachen. Beispielsweise nach dem die Instanz nicht eingeschlossen ist, die Typinformationen angefordert werden kann, um seine Methoden aufrufen spät gebunden. Wenn die Assembly in der aufrufenden Anwendungsdomäne geladen wird, können Ausnahmen auftreten.  
  
-   Wenn eine andere Version derselben Assembly bereits in der aufrufenden Anwendungsdomäne geladen wurde, oder wenn im Ladepfad der aufrufenden Anwendungsdomäne unterscheidet, von der Zielanwendungsdomäne Ausnahmen wie <xref:System.MissingMethodException> auftreten können.  
  
-   Wenn die aufrufenden Anwendungsdomäne früh gebundene Aufrufe den Instanztyp <xref:System.InvalidCastException> ausgelöst werden kann, bei dem Versuch der umgewandelt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> wurde in <paramref name="assemblyFile" /> nicht gefunden.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine ausreichende Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
 - oder -   
  
 <paramref name="assemblyFile" /> wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.NullReferenceException">Diese Instanz ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name einschließlich des Pfads einer Datei, die eine Assembly enthält, in der der angeforderte Typ definiert ist. Die Assembly wird mit der <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />-Methode geladen.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <param name="ignoreCase">Ein boolescher Wert, der angibt, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll.</param>
        <param name="bindingAttr">Eine Kombination von 0 (null) oder mehr Bitflags, die die Suche nach dem <c>typeName</c>-Konstruktor beeinflussen. Wenn <c>bindingAttr</c> 0 (null) ist, wird eine Suche nach öffentlichen Konstruktoren unter Beachtung der Groß-/Kleinschreibung durchgeführt.</param>
        <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see cref="T:System.Reflection.MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn <c>binder</c> den Wert NULL aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Die an den Konstruktor zu übergebenden Argumente. Dieses Array von Argumenten muss hinsichtlich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmen. Wenn der Standardkonstruktor bevorzugt wird, muss <c>args</c> ein leeres Array oder NULL sein.</param>
        <param name="culture">Kulturabhängige Informationen, die die Koersion von <c>args</c> in die für den <c>typeName</c>-Konstruktor deklarierten formalen Typen bestimmen. Wenn <c>culture</c><see langword="null" /> ist, wird die <see cref="T:System.Globalization.CultureInfo" /> für den aktuellen Thread verwendet.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
 Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <param name="securityAttributes">Informationen, die zum Autorisieren der Erstellung von <c>typeName</c> verwendet werden.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs, der in der angegebenen Assemblydatei definiert ist.</summary>
        <returns>Ein Objekt, das ein Wrapper für die neue Instanz ist, oder <see langword="null" />, wenn <paramref name="typeName" /> nicht gefunden wurde. Der Rückgabewert muss für den Zugriff auf das eigentliche Objekt entwrappt werden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu dieser Methode finden Sie unter der <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> Methode.  
  
 Wenn die <xref:System.AppDomain.CreateInstanceFrom%2A> Methode dient zum Erstellen einer Instanz in einer Zielanwendungsdomäne als der Anwendungsdomäne, aus dem der Aufruf erfolgt, wird die Assembly in der Ziel-Anwendungsdomäne geladen. Jedoch, wenn die Instanz in der aufrufenden Anwendungsdomäne nicht eingeschlossen ist, kann die entwrappte Instanz auf bestimmte Weise die Assembly in der aufrufenden Anwendungsdomäne geladen werden soll verursachen. Beispielsweise nach dem die Instanz nicht eingeschlossen ist, die Typinformationen angefordert werden kann, um seine Methoden aufrufen spät gebunden. Wenn die Assembly in der aufrufenden Anwendungsdomäne geladen wird, können Ausnahmen auftreten.  
  
-   Wenn eine andere Version derselben Assembly bereits in der aufrufenden Anwendungsdomäne geladen wurde, oder wenn im Ladepfad der aufrufenden Anwendungsdomäne unterscheidet, von der Zielanwendungsdomäne Ausnahmen wie <xref:System.MissingMethodException> auftreten können.  
  
-   Wenn die aufrufenden Anwendungsdomäne früh gebundene Aufrufe den Instanztyp <xref:System.InvalidCastException> ausgelöst werden kann, bei dem Versuch der umgewandelt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.  
  
 - oder -   
  
 <paramref name="securityAttributes" /> ist nicht <see langword="null" />. Wenn die Legacy-CAS-Richtlinie nicht aktiviert ist, sollte <paramref name="securityAttributes" /> den Wert <see langword="null" /> aufweisen.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> wurde in <paramref name="assemblyFile" /> nicht gefunden.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine ausreichende Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyFile" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.NullReferenceException">Diese Instanz ist <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Bereitstellen von Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFromAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine neue Instanz eines angegebenen Typs, der in der angegebenen Assemblydatei definiert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Dateiname und der Pfad der Assembly, in der der angeforderte Typ definiert ist.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs, der in der angegebenen Assemblydatei definiert ist.</summary>
        <returns>Das angeforderte Objekt oder <see langword="null" />, wenn <paramref name="typeName" /> nicht gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine bequeme Methode, die kombiniert <xref:System.AppDomain.CreateInstanceFrom%2A> und <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Diese Methode ruft den Standardkonstruktor für `typeName`.  
  
 Weitere Informationen finden Sie unter der Methode <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein parameterloser öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine ausreichende Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyName" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Dateiname und der Pfad der Assembly, in der der angeforderte Typ definiert ist.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly (siehe <see cref="P:System.Type.FullName" />-Eigenschaft).</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
 Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs, der in der angegebenen Assemblydatei definiert ist.</summary>
        <returns>Das angeforderte Objekt oder <see langword="null" />, wenn <paramref name="typeName" /> nicht gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine bequeme Methode, die kombiniert <xref:System.AppDomain.CreateInstanceFrom%2A> und <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Diese Methode ruft den Standardkonstruktor für `typeName`.  
  
 Weitere Informationen zu dieser Methode finden Sie unter der <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein parameterloser öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine ausreichende Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyName" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Dateiname und der Pfad der Assembly, in der der angeforderte Typ definiert ist.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <param name="ignoreCase">Ein boolescher Wert, der angibt, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll.</param>
        <param name="bindingAttr">Eine Kombination von 0 (null) oder mehr Bitflags, die die Suche nach dem <c>typeName</c>-Konstruktor beeinflussen. Wenn <c>bindingAttr</c> 0 (null) ist, wird eine Suche nach öffentlichen Konstruktoren unter Beachtung der Groß-/Kleinschreibung durchgeführt.</param>
        <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see cref="T:System.Reflection.MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn <c>binder</c> den Wert NULL aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Die an den Konstruktor zu übergebenden Argumente. Dieses Array von Argumenten muss hinsichtlich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmen. Wenn der Standardkonstruktor bevorzugt wird, muss <c>args</c> ein leeres Array oder NULL sein.</param>
        <param name="culture">Kulturabhängige Informationen, die die Koersion von <c>args</c> in die für den <c>typeName</c>-Konstruktor deklarierten formalen Typen bestimmen. Wenn <c>culture</c><see langword="null" /> ist, wird die <see cref="T:System.Globalization.CultureInfo" /> für den aktuellen Thread verwendet.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
 Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <summary>Erstellt eine neue Instanz des angegebenen, in der angegebenen Assemblydatei definierten Typs, die angibt, ob die Groß-/Kleinschreibung des Typnamens ignoriert wird, außerdem die Bindungsattribute und den Binder, mit denen der zu erstellende Typ ausgewählt wird, die Argumente des Konstruktors, die Kultur und die Aktivierungsattribute.</summary>
        <returns>Das angeforderte Objekt oder <see langword="null" />, wenn <paramref name="typeName" /> nicht gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine bequeme Methode, die kombiniert <xref:System.AppDomain.CreateInstanceFrom%2A> und <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Weitere Informationen zu dieser Methode finden Sie unter der <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine ausreichende Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
 - oder -   
  
 <paramref name="assemblyName" /> wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Dateiname und der Pfad der Assembly, in der der angeforderte Typ definiert ist.</param>
        <param name="typeName">Der vollqualifizierte Name des angeforderten Typs einschließlich des Namespace, jedoch ohne die Assembly, wie er von der <see cref="P:System.Type.FullName" />-Eigenschaft zurückgegeben wird.</param>
        <param name="ignoreCase">Ein boolescher Wert, der angibt, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll.</param>
        <param name="bindingAttr">Eine Kombination von 0 (null) oder mehr Bitflags, die die Suche nach dem <c>typeName</c>-Konstruktor beeinflussen. Wenn <c>bindingAttr</c> 0 (null) ist, wird eine Suche nach öffentlichen Konstruktoren unter Beachtung der Groß-/Kleinschreibung durchgeführt.</param>
        <param name="binder">Ein Objekt, das die Bindung, die Umwandlung von Argumenttypen, das Aufrufen von Membern und das Abrufen von <see cref="T:System.Reflection.MemberInfo" />-Objekten über Reflektion ermöglicht. Wenn <c>binder</c> den Wert NULL aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Die an den Konstruktor zu übergebenden Argumente. Dieses Array von Argumenten muss hinsichtlich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmen. Wenn der Standardkonstruktor bevorzugt wird, muss <c>args</c> ein leeres Array oder NULL sein.</param>
        <param name="culture">Kulturabhängige Informationen, die die Koersion von <c>args</c> in die für den <c>typeName</c>-Konstruktor deklarierten formalen Typen bestimmen. Wenn <c>culture</c><see langword="null" /> ist, wird die <see cref="T:System.Globalization.CultureInfo" /> für den aktuellen Thread verwendet.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
 Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <param name="securityAttributes">Informationen, die zum Autorisieren der Erstellung von <c>typeName</c> verwendet werden.</param>
        <summary>Erstellt eine neue Instanz des angegebenen Typs, der in der angegebenen Assemblydatei definiert ist.</summary>
        <returns>Das angeforderte Objekt oder <see langword="null" />, wenn <paramref name="typeName" /> nicht gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies ist eine bequeme Methode, die kombiniert <xref:System.AppDomain.CreateInstanceFrom%2A> und <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Weitere Informationen zu dieser Methode finden Sie unter der <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ist <see langword="null" />.  
  
 - oder -   
  
 <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typeName" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine ausreichende Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyName" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">die Möglichkeit zum Lesen der Datei, die das Assemblymanifest enthält. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.CurrentDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDomain As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property AppDomain ^ CurrentDomain { AppDomain ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die aktuelle Anwendungsdomäne für den aktuellen <see cref="T:System.Threading.Thread" /> ab.</summary>
        <value>Die aktuelle Anwendungsdomäne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel erstellt eine neue Anwendungsdomäne. Die <xref:System.AppDomain.CurrentDomain%2A> Eigenschaft wird zum Abrufen einer <xref:System.AppDomain> Objekt, das die aktuelle Anwendungsdomäne darstellt. Die <xref:System.AppDomain.FriendlyName%2A> Eigenschaft enthält den Namen der aktuellen Anwendungsdomäne, die dann in der Befehlszeile angezeigt werden.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiert eine dynamische Assembly in der aktuellen Anwendungsdomäne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
      </Parameters>
      <Docs>
        <param name="name">Die eindeutige Identität der dynamischen Assembly.</param>
        <param name="access">Der Zugriffsmodus für die dynamische Assembly.</param>
        <summary>Definiert eine dynamische Assembly mit dem angegebenen Namen und Zugriffsmodus.</summary>
        <returns>Eine dynamische Assembly mit dem angegebenen Namen und Zugriffsmodus.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte nur verwendet werden, um eine dynamische Assembly in der aktuellen Anwendungsdomäne zu definieren. Weitere Informationen finden Sie unter der <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
> [!NOTE]
>  Während der Entwicklung des Codes, der dynamische Assemblys ausgibt, wird empfohlen, dass Sie eine Überladung der verwenden die <xref:System.AppDomain.DefineDynamicAssembly%2A> Methode, die Beweise und Berechtigungen angibt. Geben Sie den Beweis, Sie möchten die dynamische Assembly, und <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Einschließlich <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in der `refusedPermissions` stellt sicher, dass die MSIL nicht überprüft wird. Eine Einschränkung des diese Technik ist, dass dadurch auch <xref:System.Security.SecurityException> ausgelöst werden, wenn mit Code verwendet, die volle Vertrauenswürdigkeit erforderlich.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.AppDomain.DefineDynamicAssembly%2A> Methode und <xref:System.AppDomain.AssemblyResolve> Ereignis.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen bereitstellen. Informationen zur Vorgehensweise zum Abrufen der vollqualifizierte Assemblyname finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> beginnt mit einem Leerzeichen oder enthält einen Schrägstrich oder umgekehrten Schrägstrich.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">Die eindeutige Identität der dynamischen Assembly.</param>
        <param name="access">Der Zugriffsmodus für die dynamische Assembly.</param>
        <param name="assemblyAttributes">Eine aufzählbare Liste von Attributen, die auf die Assembly angewendet werden sollen, oder <see langword="null" />, wenn keine Attribute vorhanden sind.</param>
        <summary>Definiert eine dynamische Assembly mit dem angegebenen Namen, Zugriffsmodus und benutzerdefinierten Attributen.</summary>
        <returns>Eine dynamische Assembly mit dem angegebenen Namen und Funktionen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese methodenüberladung, um Attribute angeben, die funktionieren nicht ordnungsgemäß, es sei denn, sie angewendet werden, wenn eine dynamische Assembly erstellt wird. Beispielsweise Sicherheitsattribute wie z. B. <xref:System.Security.SecurityTransparentAttribute> und <xref:System.Security.SecurityCriticalAttribute> funktionieren nicht ordnungsgemäß, wenn sie hinzugefügt werden, nachdem eine dynamische Assembly erstellt wurde.  
  
 Diese Methode sollte verwendet werden, nur um eine dynamische Assembly in der aktuellen Anwendungsdomäne zu definieren. Weitere Informationen zu dieser Einschränkung finden Sie unter der <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
 Diese methodenüberladung wird eingeführt, der [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie eine dynamische Assembly erstellen, verfügt die <xref:System.Security.SecurityTransparentAttribute>. Das Attribut muss angegeben werden, als ein Element eines Arrays von <xref:System.Reflection.Emit.CustomAttributeBuilder> Objekte.  
  
 Der erste Schritt beim Erstellen der <xref:System.Reflection.Emit.CustomAttributeBuilder> besteht darin, einen Konstruktor für das Attribut abzurufen. Der Konstruktor hat keine Parameter, damit die <xref:System.Type.GetConstructor%2A> -Methode aufgerufen wird und ein leeres Array vom <xref:System.Type> -Objekten, die Typen der Parameter darstellen. Der zweite Schritt ist das resultierende übergeben <xref:System.Reflection.ConstructorInfo> Objekt an den Konstruktor für die <xref:System.Reflection.Emit.CustomAttributeBuilder> -Klasse, zusammen mit der ein leeres Array vom Typ <xref:System.Object> auf die Argumente darstellen.  
  
 Das resultierende <xref:System.Reflection.Emit.CustomAttributeBuilder> übergeben, die <xref:System.AppDomain.DefineDynamicAssembly%2A> Methode als das einzige Element eines Arrays.  
  
 Der Beispielcode definiert ein Modul und ein Typ in die neue dynamische Assembly und zeigt dann die Attribute der Assembly.  
  
 [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cpp/source.cpp#1)]
 [!code-csharp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cs/source.cs#1)]
 [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> beginnt mit Leerraum, oder sie enthält einen Schrägstrich bzw. einen umgekehrten Schrägstrich.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">Die eindeutige Identität der dynamischen Assembly.</param>
        <param name="access">Der Modus, in dem auf die dynamische Assembly zugegriffen wird.</param>
        <param name="evidence">Der für die dynamische Assembly angegebene Beweis. Der Beweis wird ohne Änderungen als endgültiger Satz von Beweisen für die Richtlinienauflösung verwendet.</param>
        <summary>Definiert eine dynamische Assembly mit dem angegebenen Namen, Zugriffsmodus und Beweis.</summary>
        <returns>Eine dynamische Assembly mit dem angegebenen Namen und Funktionen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur voll vertrauenswürdige Aufrufer angeben können ihre `evidence` beim Definieren einer dynamischen <xref:System.Reflection.Assembly>. Die Common Language Runtime ordnet die <xref:System.Security.Policy.Evidence> durch die Sicherheitsrichtlinie, um die gewährten Berechtigungen zu bestimmen. Teilweise vertrauenswürdige Aufrufer müssen ein NULL-Wert angeben `evidence`. Wenn `evidence` ist `null`, die Laufzeit übernimmt die Berechtigungssätze, d. h. der aktuellen GRANT- und deny-Mengen aus des Aufrufers <xref:System.Reflection.Assembly> in der dynamischen <xref:System.Reflection.Assembly> definiert wird, und kennzeichnet die Richtlinie als aufgelöst.  
  
 Wenn die dynamische <xref:System.Reflection.Assembly> ist auf einem Datenträger gespeichert, nachfolgende lädt erhalten gewährt anhand von Richtlinien, die den Speicherort zugeordnet, in dem die <xref:System.Reflection.Assembly> gespeichert wurde.  
  
 Diese Methode sollte nur verwendet werden, um eine dynamische Assembly in der aktuellen Anwendungsdomäne zu definieren. Weitere Informationen finden Sie unter der <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
> [!NOTE]
>  Während der Entwicklung des Codes, der dynamische Assemblys ausgibt, wird empfohlen, dass Sie eine Überladung der verwenden die <xref:System.AppDomain.DefineDynamicAssembly%2A> Methode, die Beweise und Berechtigungen angibt. Geben Sie den Beweis, Sie möchten die dynamische Assembly, und <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Einschließlich <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in der `refusedPermissions` stellt sicher, dass die MSIL nicht überprüft wird. Eine Einschränkung des diese Technik ist, dass dadurch auch <xref:System.Security.SecurityException> ausgelöst werden, wenn mit Code verwendet, die volle Vertrauenswürdigkeit erforderlich.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.AppDomain.DefineDynamicAssembly%2A> Methode und die <xref:System.AppDomain.AssemblyResolve> Ereignis.  
  
 Im Codebeispiel wird zunächst versucht, zum Erstellen einer Instanz des `MyDynamicType` durch Aufrufen der <xref:System.AppDomain.CreateInstance%2A> Methode mit einem ungültigen Assemblynamen, und die resultierende Ausnahme abgefangen.  
  
 Das Codebeispiel fügt dann einen Ereignishandler für das <xref:System.AppDomain.AssemblyResolve> Ereignis und erneut versucht, die zum Erstellen einer Instanz von`MyDynamicType`. Während des Aufrufs <xref:System.AppDomain.CreateInstance%2A>die <xref:System.AppDomain.AssemblyResolve> Ereignis wird ausgelöst, für die ungültige Assembly. Der Ereignishandler erstellt eine dynamische Assembly, die einen Typ mit dem Namen enthält `MyDynamicType`, gibt den Typ einen parameterlosen Konstruktor und die neue dynamische Assembly zurück. Der Aufruf von <xref:System.AppDomain.CreateInstance%2A> dann erfolgreich abgeschlossen, und der Konstruktor für `MyDynamicType` wird eine Meldung in der Konsole angezeigt.  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> beginnt mit einem Leerzeichen oder enthält einen Schrägstrich oder umgekehrten Schrägstrich.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assembly mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Die eindeutige Identität der dynamischen Assembly.</param>
        <param name="access">Der Modus, in dem auf die dynamische Assembly zugegriffen wird.</param>
        <param name="dir">Der Name des Verzeichnisses, in dem die Assembly gespeichert wird. Wenn <c>dir</c><see langword="null" /> ist, wird das aktuelle Verzeichnis als Standardverzeichnis verwendet.</param>
        <summary>Definiert eine dynamische Assembly mit dem angegebenen Namen, Zugriffsmodus und Speicherverzeichnis.</summary>
        <returns>Eine dynamische Assembly mit dem angegebenen Namen und Funktionen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte nur verwendet werden, um eine dynamische Assembly in der aktuellen Anwendungsdomäne zu definieren. Weitere Informationen finden Sie unter der <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
> [!NOTE]
>  Während der Entwicklung des Codes, der dynamische Assemblys ausgibt, wird empfohlen, dass Sie eine Überladung der verwenden die <xref:System.AppDomain.DefineDynamicAssembly%2A> Methode, die Beweise und Berechtigungen angibt. Geben Sie den Beweis, Sie möchten die dynamische Assembly, und <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Einschließlich <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in der `refusedPermissions` stellt sicher, dass die MSIL nicht überprüft wird. Eine Einschränkung des diese Technik ist, dass dadurch auch <xref:System.Security.SecurityException> ausgelöst werden, wenn mit Code verwendet, die volle Vertrauenswürdigkeit erforderlich.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.AppDomain.DefineDynamicAssembly%2A> Methode und <xref:System.AppDomain.AssemblyResolve> Ereignis.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen bereitstellen. Informationen zur Vorgehensweise zum Abrufen der vollqualifizierte Assemblyname finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> beginnt mit einem Leerzeichen oder enthält einen Schrägstrich oder umgekehrten Schrägstrich.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes, System::Security::SecurityContextSource securityContextSource);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="name">Die eindeutige Identität der dynamischen Assembly.</param>
        <param name="access">Der Zugriffsmodus für die dynamische Assembly.</param>
        <param name="assemblyAttributes">Eine aufzählbare Liste von Attributen, die auf die Assembly angewendet werden sollen, oder <see langword="null" />, wenn keine Attribute vorhanden sind.</param>
        <param name="securityContextSource">Die Quelle des Sicherheitskontexts.</param>
        <summary>Definiert eine dynamische Assembly mit dem angegebenen Namen, Zugriffsmodus und benutzerdefinierten Attributen und verwendet die angegebene Quelle für den Sicherheitskontext.</summary>
        <returns>Eine dynamische Assembly mit dem angegebenen Namen und Funktionen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese methodenüberladung, um Attribute angeben, die funktionieren nicht ordnungsgemäß, es sei denn, sie angewendet werden, wenn eine dynamische Assembly erstellt wird. Beispielsweise Sicherheitsattribute wie z. B. <xref:System.Security.SecurityTransparentAttribute> und <xref:System.Security.SecurityCriticalAttribute> funktionieren nicht ordnungsgemäß, wenn sie hinzugefügt werden, nachdem eine dynamische Assembly erstellt wurde.  
  
 Diese Methode sollte verwendet werden, nur um eine dynamische Assembly in der aktuellen Anwendungsdomäne zu definieren. Weitere Informationen zu dieser Einschränkung finden Sie unter der <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> beginnt mit Leerraum, oder sie enthält einen Schrägstrich bzw. einen umgekehrten Schrägstrich.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert von <paramref name="securityContextSource" /> war keiner der Enumerationswerte.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">Die eindeutige Identität der dynamischen Assembly.</param>
        <param name="access">Der Modus, in dem auf die dynamische Assembly zugegriffen wird.</param>
        <param name="dir">Der Name des Verzeichnisses, in dem die Assembly gespeichert wird. Wenn <c>dir</c><see langword="null" /> ist, wird das aktuelle Verzeichnis als Standardverzeichnis verwendet.</param>
        <param name="evidence">Der für die dynamische Assembly angegebene Beweis. Der Beweis wird ohne Änderungen als endgültiger Satz von Beweisen für die Richtlinienauflösung verwendet.</param>
        <summary>Definiert eine dynamische Assembly mit dem angegebenen Namen, Zugriffsmodus, Speicherverzeichnis und Beweis.</summary>
        <returns>Eine dynamische Assembly mit dem angegebenen Namen und Funktionen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nur voll vertrauenswürdige Aufrufer angeben können ihre `evidence` beim Definieren einer dynamischen <xref:System.Reflection.Assembly>. Die Common Language Runtime ordnet die <xref:System.Security.Policy.Evidence> durch die Sicherheitsrichtlinie, um die gewährten Berechtigungen zu bestimmen. Teilweise vertrauenswürdige Aufrufer müssen ein NULL-Wert angeben `evidence`. Wenn `evidence` ist `null`, die Laufzeit übernimmt die Berechtigungssätze, d. h. der aktuellen GRANT- und deny-Mengen aus des Aufrufers <xref:System.Reflection.Assembly> in der dynamischen <xref:System.Reflection.Assembly> definiert wird, und kennzeichnet die Richtlinie als aufgelöst.  
  
 Wenn die dynamische <xref:System.Reflection.Assembly> ist auf einem Datenträger gespeichert, nachfolgende lädt erhalten gewährt anhand von Richtlinien, die den Speicherort zugeordnet, in dem die <xref:System.Reflection.Assembly> gespeichert wurde.  
  
 Diese Methode sollte nur verwendet werden, um eine dynamische Assembly in der aktuellen Anwendungsdomäne zu definieren. Weitere Informationen finden Sie unter der <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
> [!NOTE]
>  Während der Entwicklung des Codes, der dynamische Assemblys ausgibt, wird empfohlen, dass Sie eine Überladung der verwenden die <xref:System.AppDomain.DefineDynamicAssembly%2A> Methode, die Beweise und Berechtigungen angibt. Geben Sie den Beweis, Sie möchten die dynamische Assembly, und <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Einschließlich <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in der `refusedPermissions` stellt sicher, dass die MSIL nicht überprüft wird. Eine Einschränkung des diese Technik ist, dass dadurch auch <xref:System.Security.SecurityException> ausgelöst werden, wenn mit Code verwendet, die volle Vertrauenswürdigkeit erforderlich.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.AppDomain.DefineDynamicAssembly%2A> Methode und <xref:System.AppDomain.AssemblyResolve> Ereignis.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen bereitstellen. Informationen zur Vorgehensweise zum Abrufen der vollqualifizierte Assemblyname finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> beginnt mit einem Leerzeichen oder enthält einen Schrägstrich oder umgekehrten Schrägstrich.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assembly mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Die eindeutige Identität der dynamischen Assembly.</param>
        <param name="access">Der Modus, in dem auf die dynamische Assembly zugegriffen wird.</param>
        <param name="requiredPermissions">Die erforderliche Berechtigungsanforderung.</param>
        <param name="optionalPermissions">Die optionale Berechtigungsanforderung.</param>
        <param name="refusedPermissions">Die verweigerte Berechtigungsanforderung.</param>
        <summary>Definiert eine dynamische Assembly mit dem angegebenem Namen, Zugriffsmodus und den angegebenen Berechtigungsanforderungen.</summary>
        <returns>Eine dynamische Assembly mit dem angegebenen Namen und Funktionen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die berechtigungsanforderungen für angegebene `requiredPermissions`, `optionalPermissions`, und `refusedPermissions` werden nicht verwendet werden, es sei denn, die dynamische Assembly gespeichert und wieder in den Arbeitsspeicher geladen wurde. Anforderungen für die Berechtigungen für eine flüchtige Assembly angeben, die nie gespeichert wird, auf den Datenträger, verwenden Sie eine Überladung der der <xref:System.AppDomain.DefineDynamicAssembly%2A> -Methode, die Beweise gibt an, als auch die angeforderten Berechtigungen aus, und geben ein <xref:System.Security.Policy.Evidence> Objekt.  
  
> [!NOTE]
>  Während der Entwicklung des Codes, der dynamische Assemblys ausgibt, wird empfohlen, dass Sie eine Überladung der verwenden die <xref:System.AppDomain.DefineDynamicAssembly%2A> Methode, die Beweise und Berechtigungen angibt. Geben Sie den Beweis, Sie möchten die dynamische Assembly, und <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Einschließlich <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in der `refusedPermissions` stellt sicher, dass die MSIL nicht überprüft wird. Eine Einschränkung des diese Technik ist, dass dadurch auch <xref:System.Security.SecurityException> ausgelöst werden, wenn mit Code verwendet, die volle Vertrauenswürdigkeit erforderlich.  
  
 Diese Methode sollte nur verwendet werden, um eine dynamische Assembly in der aktuellen Anwendungsdomäne zu definieren. Weitere Informationen finden Sie unter der <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.AppDomain.DefineDynamicAssembly%2A> Methode und <xref:System.AppDomain.AssemblyResolve> Ereignis.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen bereitstellen. Informationen zur Vorgehensweise zum Abrufen der vollqualifizierte Assemblyname finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> beginnt mit einem Leerzeichen oder enthält einen Schrägstrich oder umgekehrten Schrägstrich.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, isSynchronized As Boolean, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">Die eindeutige Identität der dynamischen Assembly.</param>
        <param name="access">Der Modus, in dem auf die dynamische Assembly zugegriffen wird.</param>
        <param name="dir">Der Name des Verzeichnisses, in dem die dynamische Assembly gespeichert wird. Wenn <c>dir</c> den Wert <see langword="null" /> hat, wird das aktuelle Verzeichnis verwendet.</param>
        <param name="isSynchronized">
          <see langword="true" />, wenn das Erstellen von Modulen, Typen und Membern der dynamischen Assembly synchronisiert werden soll, andernfalls <see langword="false" />.</param>
        <param name="assemblyAttributes">Eine aufzählbare Liste von Attributen, die auf die Assembly angewendet werden sollen, oder <see langword="null" />, wenn keine Attribute vorhanden sind.</param>
        <summary>Definiert eine dynamische Assembly mit dem angegebenen Namen, Zugriffsmodus, Speicherverzeichnis und der Synchronisierungsoption.</summary>
        <returns>Eine dynamische Assembly mit dem angegebenen Namen und Funktionen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese methodenüberladung, um Attribute angeben, die funktionieren nicht ordnungsgemäß, es sei denn, sie angewendet werden, wenn eine dynamische Assembly erstellt wird. Beispielsweise Sicherheitsattribute wie z. B. <xref:System.Security.SecurityTransparentAttribute> und <xref:System.Security.SecurityCriticalAttribute> funktionieren nicht ordnungsgemäß, wenn sie hinzugefügt werden, nachdem eine dynamische Assembly erstellt wurde.  
  
 Wenn `isSynchronized` ist `true`, die folgenden Methoden der resultierenden <xref:System.Reflection.Emit.AssemblyBuilder> synchronisiert werden sollen: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, und <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Wenn zwei dieser Kontaktmethoden in verschiedenen Threads aufgerufen werden, wird eine blockieren, bis der andere abgeschlossen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> beginnt mit Leerraum, oder sie enthält einen Schrägstrich bzw. einen umgekehrten Schrägstrich.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Die eindeutige Identität der dynamischen Assembly.</param>
        <param name="access">Der Modus, in dem auf die dynamische Assembly zugegriffen wird.</param>
        <param name="evidence">Der für die dynamische Assembly angegebene Beweis. Der Beweis wird ohne Änderungen als endgültiger Satz von Beweisen für die Richtlinienauflösung verwendet.</param>
        <param name="requiredPermissions">Die erforderliche Berechtigungsanforderung.</param>
        <param name="optionalPermissions">Die optionale Berechtigungsanforderung.</param>
        <param name="refusedPermissions">Die verweigerte Berechtigungsanforderung.</param>
        <summary>Definiert eine dynamische Assembly mit dem angegebenen Namen, Zugriffsmodus, Beweis und den angegebenen Berechtigungsanforderungen.</summary>
        <returns>Eine dynamische Assembly mit dem angegebenen Namen und Funktionen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die berechtigungsanforderungen für angegebene `requiredPermissions`, `optionalPermissions`, und `refusedPermissions` werden nur verwendet, wenn `evidence` ebenfalls angegeben wird, oder wenn die dynamische Assembly gespeichert und wieder in den Arbeitsspeicher geladen.  
  
> [!NOTE]
>  Während der Entwicklung des Codes, der dynamische Assemblys ausgibt, wird empfohlen, dass Sie enthalten <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Einschließlich <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in der `refusedPermissions` stellt sicher, dass die MSIL nicht überprüft wird. Eine Einschränkung des diese Technik ist, dass dadurch auch <xref:System.Security.SecurityException> ausgelöst werden, wenn mit Code verwendet, die volle Vertrauenswürdigkeit erforderlich.  
  
 Nur voll vertrauenswürdige Aufrufer angeben können ihre `evidence` beim Definieren einer dynamischen <xref:System.Reflection.Assembly>. Die Common Language Runtime ordnet die <xref:System.Security.Policy.Evidence> durch die Sicherheitsrichtlinie, um die gewährten Berechtigungen zu bestimmen. Teilweise vertrauenswürdige Aufrufer müssen ein NULL-Wert angeben `evidence`. Wenn `evidence` ist `null`, die Laufzeit übernimmt die Berechtigungssätze, d. h. der aktuellen GRANT- und deny-Mengen aus des Aufrufers <xref:System.Reflection.Assembly> in der dynamischen <xref:System.Reflection.Assembly> definiert wird, und kennzeichnet die Richtlinie als aufgelöst.  
  
 Wenn die dynamische <xref:System.Reflection.Assembly> ist auf einem Datenträger gespeichert, nachfolgende lädt erhalten gewährt anhand von Richtlinien, die den Speicherort zugeordnet, in dem die <xref:System.Reflection.Assembly> gespeichert wurde.  
  
 Diese Methode sollte nur verwendet werden, um eine dynamische Assembly in der aktuellen Anwendungsdomäne zu definieren. Weitere Informationen finden Sie unter der <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.AppDomain.DefineDynamicAssembly%2A> Methode und <xref:System.AppDomain.AssemblyResolve> Ereignis.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen bereitstellen. Informationen zur Vorgehensweise zum Abrufen der vollqualifizierte Assemblyname finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> beginnt mit einem Leerzeichen oder enthält einen Schrägstrich oder umgekehrten Schrägstrich.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assembly mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Die eindeutige Identität der dynamischen Assembly.</param>
        <param name="access">Der Modus, in dem auf die dynamische Assembly zugegriffen wird.</param>
        <param name="dir">Der Name des Verzeichnisses, in dem die Assembly gespeichert wird. Wenn <c>dir</c><see langword="null" /> ist, wird das aktuelle Verzeichnis als Standardverzeichnis verwendet.</param>
        <param name="requiredPermissions">Die erforderliche Berechtigungsanforderung.</param>
        <param name="optionalPermissions">Die optionale Berechtigungsanforderung.</param>
        <param name="refusedPermissions">Die verweigerte Berechtigungsanforderung.</param>
        <summary>Definiert eine dynamische Assembly mit dem angegebenen Namen, Zugriffsmodus, Speicherverzeichnis und den angegebenen Berechtigungsanforderungen.</summary>
        <returns>Eine dynamische Assembly mit dem angegebenen Namen und Funktionen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die berechtigungsanforderungen für angegebene `requiredPermissions`, `optionalPermissions`, und `refusedPermissions` werden nicht verwendet werden, es sei denn, die dynamische Assembly gespeichert und wieder in den Arbeitsspeicher geladen wurde. Anforderungen für die Berechtigungen für eine flüchtige Assembly angeben, die nie gespeichert wird, auf den Datenträger, verwenden Sie eine Überladung der der <xref:System.AppDomain.DefineDynamicAssembly%2A> -Methode, die Beweise gibt an, als auch die angeforderten Berechtigungen aus, und geben ein <xref:System.Security.Policy.Evidence> Objekt.  
  
> [!NOTE]
>  Während der Entwicklung des Codes, der dynamische Assemblys ausgibt, wird empfohlen, dass Sie eine Überladung der verwenden die <xref:System.AppDomain.DefineDynamicAssembly%2A> Methode, die Beweise und Berechtigungen angibt. Geben Sie den Beweis, Sie möchten die dynamische Assembly, und <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Einschließlich <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in der `refusedPermissions` stellt sicher, dass die MSIL nicht überprüft wird. Eine Einschränkung des diese Technik ist, dass dadurch auch <xref:System.Security.SecurityException> ausgelöst werden, wenn mit Code verwendet, die volle Vertrauenswürdigkeit erforderlich.  
  
 Diese Methode sollte nur verwendet werden, um eine dynamische Assembly in der aktuellen Anwendungsdomäne zu definieren. Weitere Informationen finden Sie unter der <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.AppDomain.DefineDynamicAssembly%2A> Methode und <xref:System.AppDomain.AssemblyResolve> Ereignis.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen bereitstellen. Informationen zur Vorgehensweise zum Abrufen der vollqualifizierte Assemblyname finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> beginnt mit einem Leerzeichen oder enthält einen Schrägstrich oder umgekehrten Schrägstrich.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Die eindeutige Identität der dynamischen Assembly.</param>
        <param name="access">Der Modus, in dem auf die dynamische Assembly zugegriffen wird.</param>
        <param name="dir">Der Name des Verzeichnisses, in dem die Assembly gespeichert wird. Wenn <c>dir</c><see langword="null" /> ist, wird das aktuelle Verzeichnis als Standardverzeichnis verwendet.</param>
        <param name="evidence">Der für die dynamische Assembly angegebene Beweis. Der Beweis wird ohne Änderungen als endgültiger Satz von Beweisen für die Richtlinienauflösung verwendet.</param>
        <param name="requiredPermissions">Die erforderliche Berechtigungsanforderung.</param>
        <param name="optionalPermissions">Die optionale Berechtigungsanforderung.</param>
        <param name="refusedPermissions">Die verweigerte Berechtigungsanforderung.</param>
        <summary>Definiert eine dynamische Assembly mit dem angegebenen Namen, Zugriffsmodus, Speicherverzeichnis, Beweis und den angegebenen Berechtigungsanforderungen.</summary>
        <returns>Eine dynamische Assembly mit dem angegebenen Namen und Funktionen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die berechtigungsanforderungen für angegebene `requiredPermissions`, `optionalPermissions`, und `refusedPermissions` werden nur verwendet, wenn `evidence` ebenfalls angegeben wird, oder wenn die dynamische Assembly gespeichert und wieder in den Arbeitsspeicher geladen.  
  
> [!NOTE]
>  Während der Entwicklung des Codes, der dynamische Assemblys ausgibt, wird empfohlen, dass Sie enthalten <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Einschließlich <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in der `refusedPermissions` stellt sicher, dass die MSIL nicht überprüft wird. Eine Einschränkung des diese Technik ist, dass dadurch auch <xref:System.Security.SecurityException> ausgelöst werden, wenn mit Code verwendet, die volle Vertrauenswürdigkeit erforderlich.  
  
 Nur voll vertrauenswürdige Aufrufer angeben können ihre `evidence` beim Definieren einer dynamischen <xref:System.Reflection.Assembly>. Die Common Language Runtime ordnet die <xref:System.Security.Policy.Evidence> durch die Sicherheitsrichtlinie, um die gewährten Berechtigungen zu bestimmen. Teilweise vertrauenswürdige Aufrufer müssen ein NULL-Wert angeben `evidence`. Wenn `evidence` ist `null`, die Laufzeit übernimmt die Berechtigungssätze, d. h. der aktuellen GRANT- und deny-Mengen aus des Aufrufers <xref:System.Reflection.Assembly> in der dynamischen <xref:System.Reflection.Assembly> definiert wird, und kennzeichnet die Richtlinie als aufgelöst.  
  
 Wenn die dynamische <xref:System.Reflection.Assembly> ist auf einem Datenträger gespeichert, nachfolgende lädt erhalten gewährt anhand von Richtlinien, die den Speicherort zugeordnet, in dem die <xref:System.Reflection.Assembly> gespeichert wurde.  
  
 Diese Methode sollte nur verwendet werden, um eine dynamische Assembly in der aktuellen Anwendungsdomäne zu definieren. Weitere Informationen finden Sie unter der <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.AppDomain.DefineDynamicAssembly%2A> Methode und <xref:System.AppDomain.AssemblyResolve> Ereignis.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen bereitstellen. Informationen zur Vorgehensweise zum Abrufen der vollqualifizierte Assemblyname finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> beginnt mit einem Leerzeichen oder enthält einen Schrägstrich oder umgekehrten Schrägstrich.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assembly mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Die eindeutige Identität der dynamischen Assembly.</param>
        <param name="access">Der Modus, in dem auf die dynamische Assembly zugegriffen wird.</param>
        <param name="dir">Der Name des Verzeichnisses, in dem die dynamische Assembly gespeichert wird. Wenn <c>dir</c><see langword="null" /> ist, wird das aktuelle Verzeichnis als Standardverzeichnis verwendet.</param>
        <param name="evidence">Der für die dynamische Assembly angegebene Beweis. Der Beweis wird ohne Änderungen als endgültiger Satz von Beweisen für die Richtlinienauflösung verwendet.</param>
        <param name="requiredPermissions">Die erforderliche Berechtigungsanforderung.</param>
        <param name="optionalPermissions">Die optionale Berechtigungsanforderung.</param>
        <param name="refusedPermissions">Die verweigerte Berechtigungsanforderung.</param>
        <param name="isSynchronized">
          <see langword="true" />, wenn das Erstellen von Modulen, Typen und Membern der dynamischen Assembly synchronisiert werden soll, andernfalls <see langword="false" />.</param>
        <summary>Definiert eine dynamische Assembly mit dem angegebenen Namen, Zugriffsmodus, Speicherverzeichnis, Beweis sowie der angegebenen Synchronisierungsoption und den angegebenen Berechtigungsanforderungen.</summary>
        <returns>Eine dynamische Assembly mit dem angegebenen Namen und Funktionen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die berechtigungsanforderungen für angegebene `requiredPermissions`, `optionalPermissions`, und `refusedPermissions` werden nur verwendet, wenn `evidence` ebenfalls angegeben wird, oder wenn die dynamische Assembly gespeichert und wieder in den Arbeitsspeicher geladen.  
  
> [!NOTE]
>  Während der Entwicklung des Codes, der dynamische Assemblys ausgibt, wird empfohlen, dass Sie enthalten <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`. Einschließlich <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in der `refusedPermissions` stellt sicher, dass die MSIL nicht überprüft wird. Eine Einschränkung des diese Technik ist, dass dadurch auch <xref:System.Security.SecurityException> ausgelöst werden, wenn mit Code verwendet, die volle Vertrauenswürdigkeit erforderlich.  
  
 Nur voll vertrauenswürdige Aufrufer ihre Beweise, beim Definieren einer dynamischen angeben können <xref:System.Reflection.Assembly>. Die Common Language Runtime ordnet die <xref:System.Security.Policy.Evidence> durch die Sicherheitsrichtlinie, um die gewährten Berechtigungen zu bestimmen. Teilweise vertrauenswürdige Aufrufer angeben müssen `null` für die `evidence` Parameter. Wenn `evidence` ist `null`, die Laufzeit übernimmt die Berechtigungssätze, d. h. der aktuellen GRANT- und deny-Mengen aus des Aufrufers <xref:System.Reflection.Assembly> in der dynamischen <xref:System.Reflection.Assembly> definiert wird, und kennzeichnet die Richtlinie als aufgelöst.  
  
 Wenn die dynamische <xref:System.Reflection.Assembly> ist auf einem Datenträger gespeichert, nachfolgende lädt erhalten gewährt anhand von Richtlinien, die den Speicherort zugeordnet, in dem die <xref:System.Reflection.Assembly> gespeichert wurde.  
  
 Wenn `isSynchronized` ist `true`, die folgenden Methoden der resultierenden <xref:System.Reflection.Emit.AssemblyBuilder> synchronisiert werden sollen: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, und <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Wenn zwei dieser Kontaktmethoden in verschiedenen Threads aufgerufen werden, wird einer blockiert, bis zum Abschluss der anderen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.AppDomain.DefineDynamicAssembly%2A> Methode und <xref:System.AppDomain.AssemblyResolve> Ereignis.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen bereitstellen. Informationen zur Vorgehensweise zum Abrufen der vollqualifizierte Assemblyname finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> beginnt mit einem Leerzeichen oder enthält einen Schrägstrich oder umgekehrten Schrägstrich.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assembly mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">Die eindeutige Identität der dynamischen Assembly.</param>
        <param name="access">Der Modus, in dem auf die dynamische Assembly zugegriffen wird.</param>
        <param name="dir">Der Name des Verzeichnisses, in dem die dynamische Assembly gespeichert wird. Wenn <c>dir</c> den Wert <see langword="null" /> hat, wird das aktuelle Verzeichnis verwendet.</param>
        <param name="evidence">Der für die dynamische Assembly angegebene Beweis. Der Beweis wird ohne Änderungen als endgültiger Satz von Beweisen für die Richtlinienauflösung verwendet.</param>
        <param name="requiredPermissions">Die erforderliche Berechtigungsanforderung.</param>
        <param name="optionalPermissions">Die optionale Berechtigungsanforderung.</param>
        <param name="refusedPermissions">Die verweigerte Berechtigungsanforderung.</param>
        <param name="isSynchronized">
          <see langword="true" />, wenn das Erstellen von Modulen, Typen und Membern der dynamischen Assembly synchronisiert werden soll, andernfalls <see langword="false" />.</param>
        <param name="assemblyAttributes">Eine aufzählbare Liste von Attributen, die auf die Assembly angewendet werden sollen, oder <see langword="null" />, wenn keine Attribute vorhanden sind.</param>
        <summary>Definiert eine dynamische Assembly mit dem angegebenen Namen, Zugriffsmodus, Speicherverzeichnis, Beweis sowie der angegebenen Synchronisierungsoption und den angegebenen Berechtigungsanforderungen und benutzerdefinierten Attributen.</summary>
        <returns>Eine dynamische Assembly mit dem angegebenen Namen und Funktionen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese methodenüberladung, um Attribute angeben, die funktionieren nicht ordnungsgemäß, es sei denn, sie angewendet werden, wenn eine dynamische Assembly erstellt wird. Beispielsweise Sicherheitsattribute wie z. B. <xref:System.Security.SecurityTransparentAttribute> und <xref:System.Security.SecurityCriticalAttribute> funktionieren nicht ordnungsgemäß, wenn sie hinzugefügt werden, nachdem eine dynamische Assembly erstellt wurde.  
  
 Die berechtigungsanforderungen für angegebene der `requiredPermissions`, `optionalPermissions`, und `refusedPermissions` Parameter werden nur verwendet, wenn die `evidence` Parameter ebenfalls angegeben wird, oder wenn die dynamische Assembly gespeichert und wieder in den Arbeitsspeicher geladen.  
  
> [!NOTE]
>  Bei der Entwicklung von Code, der dynamische Assemblys ausgibt, wird empfohlen, dass Sie enthalten die <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> -flag in der `refusedPermissions` Parameter. Die Angabe dieses Flags wird sichergestellt, dass die Microsoft intermediate Language (MSIL) überprüft werden. Diese Technik erkennt die unbeabsichtigte Generierung von nicht überprüfbaren Code, die andernfalls schwer zu erkennen ist. Eine Einschränkung des diese Technik ist, dass dadurch auch <xref:System.Security.SecurityException> ausgelöst werden, wenn er mit Code verwendet wird, die volle Vertrauenswürdigkeit erforderlich.  
  
 Nur voll vertrauenswürdige Aufrufer Beweise, beim Definieren einer dynamischen angeben können <xref:System.Reflection.Assembly>. Die Common Language Runtime ordnet die <xref:System.Security.Policy.Evidence> durch die Sicherheitsrichtlinie, um die gewährten Berechtigungen zu bestimmen. Teilweise vertrauenswürdige Aufrufer angeben müssen `null` für die `evidence` Parameter. Wenn `evidence` ist `null`, die Common Language Runtime die Berechtigungssätze (das ist die Gewährung für die aktuelle und verweigerten Berechtigungen) aus der aufrufenden Assembly kopiert, auf die dynamische Assembly, die definiert wird, und die Richtlinie als gelöst markiert.  
  
 Wenn die dynamische Assembly, auf den Datenträger, nachfolgende gespeichert ist lädt erhalten gewährt anhand von Richtlinien, die den Speicherort zugeordnet sind, in dem die dynamische Assembly gespeichert wurde.  
  
 Wenn `isSynchronized` ist `true`, die folgenden Methoden der resultierenden <xref:System.Reflection.Emit.AssemblyBuilder> synchronisiert werden sollen: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, und <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Wenn zwei dieser Kontaktmethoden in verschiedenen Threads aufgerufen werden, wird eine blockieren, bis der andere abgeschlossen ist.  
  
 Diese methodenüberladung wird eingeführt, der [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> ist <see langword="null" />.  
  
 - oder -   
  
 Die <see langword="Name" />-Eigenschaft von <paramref name="name" /> beginnt mit Leerraum, oder sie enthält einen Schrägstrich bzw. einen umgekehrten Schrägstrich.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assembly mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DoCallBack (callBackDelegate As CrossAppDomainDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DoCallBack(CrossAppDomainDelegate ^ callBackDelegate);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DoCallBack(System.CrossAppDomainDelegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" />
      </Parameters>
      <Docs>
        <param name="callBackDelegate">Ein Delegat, der eine aufzurufende Methode angibt.</param>
        <summary>Führt den Code in einer anderen Anwendungsdomäne aus, die durch den angegebenen Delegaten bezeichnet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `callBackDelegate` kann eine Marshal-by-Value, geben Sie <xref:System.MarshalByRefObject>, oder <xref:System.ContextBoundObject>.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die Verwendung eines statisches <xref:System.AppDomain.DoCallBack%2A> Methode.  
  
 [!code-cpp[AppDomain_DoCallBack#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_static.cpp#1)]
 [!code-csharp[AppDomain_DoCallBack#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_static.cs#1)]
 [!code-vb[AppDomain_DoCallBack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_static.vb#1)]  
  
 Im folgende Beispiel veranschaulicht die Verwendung der <xref:System.AppDomain.DoCallBack%2A> Methode nach Wert.  
  
 [!code-cpp[AppDomain_DoCallBack#2](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byval.cpp#2)]
 [!code-csharp[AppDomain_DoCallBack#2](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byval.cs#2)]
 [!code-vb[AppDomain_DoCallBack#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byval.vb#2)]  
  
 Im folgende Beispiel veranschaulicht die Verwendung der <xref:System.AppDomain.DoCallBack%2A> Methode als Verweis.  
  
 [!code-cpp[AppDomain_DoCallBack#3](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byref.cpp#3)]
 [!code-csharp[AppDomain_DoCallBack#3](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byref.cs#3)]
 [!code-vb[AppDomain_DoCallBack#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byref.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="callBackDelegate" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DomainManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainManager As AppDomainManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainManager ^ DomainManager { AppDomainManager ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Domänen-Manager ab, der beim Initialisieren der Anwendungsdomäne vom Host bereitgestellt wurde.</summary>
        <value>Ein Objekt, das den Domänen-Manager darstellt, der beim Initialisieren der Anwendungsdomäne vom Host bereitgestellt wurde, oder <see langword="null" />, wenn kein Domänen-Manager bereitgestellt wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein nicht verwalteter Host der common Language Runtime (CLR) bieten einen Domänen-Manager. Domain-Manager beim Initialisieren der neuen Anwendungsdomäne teilnehmen kann, und geben Sie anderen-Managern, wie z. B. eine <xref:System.Security.HostSecurityManager>, die die Vorgänge der Anwendungsdomäne Teil.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.DomainUnload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DomainUnload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ DomainUnload;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.DomainUnload</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn eine <see cref="T:System.AppDomain" /> gerade entladen werden soll.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.EventHandler> Delegat für dieses Ereignis beliebige Abschlussaufgaben durchführen kann, bevor die Anwendungsdomäne entladen wird.  
  
 Jede Anwendungsdomäne, die Verarbeitung, wenn es entladen wird durchführen muss, sollten einen Ereignishandler für dieses Ereignis registrieren. Ein freigegebenen Ereignishandler sollte nicht verwendet werden, da die <xref:System.EventHandler> Delegat gibt nicht an der Domäne, die entladen wird.  
  
> [!NOTE]
>  Dieses Ereignis wird in die Standardanwendungsdomäne niemals ausgelöst.  
  
 Nehmen Sie keine Annahmen über den Thread aus, dem auf das Ereignis ausgelöst wird. Das Ereignis kann ausgelöst werden, in einem anderen Thread als dem aufgerufen, die <xref:System.AppDomain.Unload%2A> Methode.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DynamicDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicDirectory { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.DynamicDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Verzeichnis ab, das der Assemblyresolver für die Suche nach dynamisch erstellten Assemblys verwendet.</summary>
        <value>Das Verzeichnis, das der Assemblyresolver für die Suche nach dynamisch erstellten Assemblys verwendet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um das dynamische Verzeichnis festzulegen, weisen Sie einen Basis Verzeichnispfad für die <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> Eigenschaft von der <xref:System.AppDomainSetup> -Objekt, das zum Erstellen der neuen Anwendungsdomäne verwendet werden. Pfad des Basisverzeichnisses, Sie der Eigenschaft weisen, wird geändert, indem das Hinzufügen eines Unterverzeichnisses, dessen einfacher Name der Hashcode der Zeichenfolge, die Sie zum Zuweisen ist, der <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> -Eigenschaft, damit das Format des Basisverzeichnisses ist *ursprünglichen Pfad* \\ *Hashcode*. Das dynamische Verzeichnis ist ein Unterverzeichnis des diesem Basisverzeichnis. Der einfache Name ist der Wert der <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> -Eigenschaft, damit dessen Format *ursprünglichen Pfad*\\*Hashcode*\\*Anwendungsname*.  
  
   
  
## Examples  
 Im folgende Beispiel wird eine Anwendungsdomäne mit einem Verzeichnis für dynamische Assemblys erstellt, gibt eine dynamische Assembly und speichert ihn in das dynamische Verzeichnis und klicken Sie dann lädt die Assembly in der neuen Anwendungsdomäne und verwendet.  
  
 Das Beispiel erstellt eine <xref:System.AppDomainSetup> -Objekt und stellt seine <xref:System.AppDomainSetup.ApplicationName%2A> "Beispiel"-Eigenschaft und die zugehörige <xref:System.AppDomainSetup.DynamicBase%2A> -Eigenschaft auf "C:\DynamicAssemblyDir". Klicken Sie dann das Beispiel zeigt die <xref:System.AppDomainSetup.DynamicBase%2A> -Eigenschaft, um anzuzeigen, die der Hashcode, der den Namen der Anwendung als Unterverzeichnis des Pfads angefügt wurde, die ursprünglich zugeordnet wurde.  
  
> [!NOTE]
>  Das Basisverzeichnis in diesem Beispiel werden außerhalb der Überprüfungspfad für die exemplarische Anwendung dient. Achten Sie darauf, dass Sie das Beispiel in einem anderen Speicherort zu kompilieren. Löschen Sie das Basisverzeichnis und alle Unterverzeichnisse jedes Mal, wenn Sie das Beispiel ausführen.  
  
 Das Beispiel erstellt eine neue Anwendungsdomäne mit dem <xref:System.AppDomainSetup> Objekt. Im Beispiel wird die <xref:System.AppDomain.DynamicDirectory%2A> Eigenschaft zum Abrufen der Name des Verzeichnisses, um das Verzeichnis erstellen zu können. (Im Beispiel kann genauso einfach erstellen des Verzeichnisses im Vorfeld durch Verketten der ursprüngliche Pfad, der den Hashcode, der den Namen der Anwendung und den Namen der Anwendung.)  
  
 Das Beispiel besteht aus einem `GenerateDynamicAssembly` Methode, die eine Assembly mit dem Namen ausgibt `DynamicHelloWorld.dll` und speichert sie in der neuen Anwendungsdomäne dynamische Verzeichnis. Die dynamische Assembly enthält einen Typ `HelloWorld`, besitzt eine statische Methode (`Shared` Methode in Visual Basic) mit dem Namen `HelloFromAD`. Beim Aufrufen dieser Methode zeigt den Namen der Anwendungsdomäne.  
  
 Die `Example` Klasse abgeleitet <xref:System.MarshalByRefObject>, damit das Beispiel eine Instanz der Klasse in der neuen Anwendungsdomäne und der Aufruf erstellen, kann seine `Test` Methode. Die `Test` Methode lädt die dynamische Assembly mit ihrem Anzeigenamen und ruft die statische `HelloFromAD` Methode.  
  
 Sie können anzeigen, dass das dynamische Verzeichnis nach der normalen Prüfpfade durchsucht wird, durch Schreiben von Code für eine Assembly mit dem Namen `DynamicHelloWorld.dll` und im gleichen Verzeichnis wie dieses Beispiel kompilieren. Die Assembly muss eine Klasse mit dem Namen verfügen `HelloWorld` mit einer statischen Methode mit dem Namen `HelloFromAD`. Diese Methode muss es sich nicht in die gleiche Funktionalität wie das im Beispiel; Es kann einfach eine Zeichenfolge in der Konsole angezeigt werden. Die Assembly benötigen auch eine <xref:System.Reflection.AssemblyVersionAttribute> -Attribut, das die Version auf 1.0.0.0 festlegt. Wenn Sie das Beispiel ausführen, ist die Assembly, die im aktuellen Verzeichnis kompiliert gefunden, bevor das dynamische Verzeichnis durchsucht wird.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Pfadinformationen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den <see cref="T:System.Security.Policy.Evidence" /> ab, der dieser Anwendungsdomäne zugeordnet ist.</summary>
        <value>Der dieser Anwendungsdomäne zugeordnete Beweis.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assembly mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt die Assembly in der angegebenen Datei aus.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name der Datei mit der auszuführenden Assembly.</param>
        <summary>Führt die Assembly in der angegebenen Datei aus.</summary>
        <returns>Der vom Einstiegspunkt der Assembly zurückgegebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Assembly beginnt in der Einstiegspunkt in .NET Framework-Header angegeben.  
  
 Diese Methode erstellt einen neuen Prozess oder eine Anwendungsdomäne nicht, und die Einstiegspunktmethode nicht in einem neuen Thread ausgeführt.  
  
 Diese Methode lädt Assemblys, die mithilfe der <xref:System.Reflection.Assembly.LoadFile%2A> Methode. Sie können Assemblys auch mit Ausführen der <xref:System.AppDomain.ExecuteAssemblyByName%2A> -Methode, die Assemblys mit lädt die <xref:System.Reflection.Assembly.Load%2A> Methode.  
  
 Zum Erstellen der <xref:System.AppDomain> zum Laden und ausführen, verwenden Sie die <xref:System.AppDomain.CreateDomain%2A> Methode.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die Verwendung einer der Überladungen der <xref:System.AppDomain.ExecuteAssembly%2A> in zwei verschiedenen Domänen.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyFile" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.MissingMethodException">Die angegebene Assembly verfügt über keinen Einstiegspunkt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder eines Verzeichnisses und für den Zugriff auf die Informationen in den Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">zum Lesen von eines URIS, der nicht mit "file://" beginnt.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">eine Konsolenanwendung ausführen zu können. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name der Datei mit der auszuführenden Assembly.</param>
        <param name="assemblySecurity">Beweis für das Laden der Assembly.</param>
        <summary>Führt die Assembly in der angegebenen Datei unter Verwendung der angegebenen Beweise aus.</summary>
        <returns>Der vom Einstiegspunkt der Assembly zurückgegebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Assembly beginnt in der Einstiegspunkt in .NET Framework-Header angegeben.  
  
 Die <xref:System.AppDomain.ExecuteAssembly%2A> Methode erstellt einen neuen Prozess oder die Anwendungsdomäne und die Einstiegspunktmethode nicht in einem neuen Thread ausgeführt.  
  
 Diese Methode lädt Assemblys, die mithilfe der <xref:System.Reflection.Assembly.LoadFile%2A> Methode. Sie können Assemblys auch mit Ausführen der <xref:System.AppDomain.ExecuteAssemblyByName%2A> -Methode, die Assemblys mit lädt die <xref:System.Reflection.Assembly.Load%2A> Methode.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die Verwendung einer der Überladungen der <xref:System.AppDomain.ExecuteAssembly%2A> in zwei verschiedenen Domänen.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyFile" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.MissingMethodException">Die angegebene Assembly verfügt über keinen Einstiegspunkt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assembly mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder eines Verzeichnisses und für den Zugriff auf die Informationen in den Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">zum Lesen von eines URIS, der nicht mit "file://" beginnt.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">eine Konsolenanwendung ausführen zu können. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name der Datei mit der auszuführenden Assembly.</param>
        <param name="args">Die Argumente für den Einstiegspunkt der Assembly.</param>
        <summary>Führt die Assembly in der angegebenen Datei unter Verwendung der angegebenen Argumente aus.</summary>
        <returns>Der vom Einstiegspunkt der Assembly zurückgegebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Assembly beginnt in der Einstiegspunkt in .NET Framework-Header angegeben.  
  
 Diese Methode erstellt einen neuen Prozess oder eine Anwendungsdomäne nicht, und die Einstiegspunktmethode nicht in einem neuen Thread ausgeführt.  
  
 Diese Methode lädt Assemblys, die mithilfe der <xref:System.Reflection.Assembly.LoadFile%2A> Methode. Sie können Assemblys auch mit Ausführen der <xref:System.AppDomain.ExecuteAssemblyByName%2A> -Methode, die Assemblys mit lädt die <xref:System.Reflection.Assembly.Load%2A> Methode.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die Verwendung einer der Überladungen der <xref:System.AppDomain.ExecuteAssembly%2A> in zwei verschiedenen Domänen.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
 - oder -   
  
 <paramref name="assemblyFile" /> wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.MissingMethodException">Die angegebene Assembly verfügt über keinen Einstiegspunkt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder eines Verzeichnisses und für den Zugriff auf die Informationen in den Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">zum Lesen von eines URIS, der nicht mit "file://" beginnt.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">eine Konsolenanwendung ausführen zu können. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name der Datei mit der auszuführenden Assembly.</param>
        <param name="assemblySecurity">Der angegebene Beweis für die Assembly.</param>
        <param name="args">Die Argumente für den Einstiegspunkt der Assembly.</param>
        <summary>Führt die Assembly in der angegebenen Datei unter Verwendung der angegebenen Beweise und Argumente aus.</summary>
        <returns>Der vom Einstiegspunkt der Assembly zurückgegebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Assembly beginnt in der Einstiegspunkt in .NET Framework-Header angegeben.  
  
 Diese Methode erstellt einen neuen Prozess oder eine Anwendungsdomäne nicht, und die Einstiegspunktmethode nicht in einem neuen Thread ausgeführt.  
  
 Diese Methode lädt Assemblys, die mithilfe der <xref:System.Reflection.Assembly.LoadFile%2A> Methode. Sie können Assemblys auch mit Ausführen der <xref:System.AppDomain.ExecuteAssemblyByName%2A> -Methode, die Assemblys mit lädt die <xref:System.Reflection.Assembly.Load%2A> Methode.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die Verwendung einer der Überladungen der <xref:System.AppDomain.ExecuteAssembly%2A> in zwei verschiedenen Domänen.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyFile" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> ist nicht <see langword="null" />. Wenn die Legacy-CAS-Richtlinie nicht aktiviert ist, sollte <paramref name="assemblySecurity" /> dem Wert <see langword="null" /> entsprechen.</exception>
        <exception cref="T:System.MissingMethodException">Die angegebene Assembly verfügt über keinen Einstiegspunkt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assembly mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder eines Verzeichnisses und für den Zugriff auf die Informationen in den Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">zum Lesen von eines URIS, der nicht mit "file://" beginnt.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">eine Konsolenanwendung ausführen zu können. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name der Datei mit der auszuführenden Assembly.</param>
        <param name="args">Die Argumente für den Einstiegspunkt der Assembly.</param>
        <param name="hashValue">Stellt den Wert des errechneten Hashcodes dar.</param>
        <param name="hashAlgorithm">Stellt den vom Assemblymanifest verwendeten Hashalgorithmus dar.</param>
        <summary>Führt die Assembly in der angegebenen Datei unter Verwendung der angegebenen Argumente, des Hashwerts und Hashalgorithmus aus.</summary>
        <returns>Der vom Einstiegspunkt der Assembly zurückgegebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Assembly beginnt in der Einstiegspunkt in .NET Framework-Header angegeben.  
  
 Diese Methode erstellt einen neuen Prozess oder eine Anwendungsdomäne nicht, und die Einstiegspunktmethode nicht in einem neuen Thread ausgeführt.  
  
 Diese Methode lädt Assemblys, die mithilfe der <xref:System.Reflection.Assembly.LoadFile%2A> Methode. Sie können Assemblys auch mit Ausführen der <xref:System.AppDomain.ExecuteAssemblyByName%2A> -Methode, die Assemblys mit lädt die <xref:System.Reflection.Assembly.Load%2A> Methode.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die Verwendung einer der Überladungen der <xref:System.AppDomain.ExecuteAssembly%2A> in zwei verschiedenen Domänen.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
 - oder -   
  
 <paramref name="assemblyFile" /> wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.MissingMethodException">Die angegebene Assembly verfügt über keinen Einstiegspunkt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder eines Verzeichnisses und für den Zugriff auf die Informationen in den Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">zum Lesen von eines URIS, der nicht mit "file://" beginnt.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">eine Konsolenanwendung ausführen zu können. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name der Datei mit der auszuführenden Assembly.</param>
        <param name="assemblySecurity">Der angegebene Beweis für die Assembly.</param>
        <param name="args">Die Argumente für den Einstiegspunkt der Assembly.</param>
        <param name="hashValue">Stellt den Wert des errechneten Hashcodes dar.</param>
        <param name="hashAlgorithm">Stellt den vom Assemblymanifest verwendeten Hashalgorithmus dar.</param>
        <summary>Führt die Assembly in der angegebenen Datei unter Verwendung der angegebenen Beweise, Argumente, des Hashwerts und Hashalgorithmus aus.</summary>
        <returns>Der vom Einstiegspunkt der Assembly zurückgegebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Assembly beginnt in der Einstiegspunkt in .NET Framework-Header angegeben.  
  
 Diese Methode erstellt einen neuen Prozess oder eine Anwendungsdomäne nicht, und die Einstiegspunktmethode nicht in einem neuen Thread ausgeführt.  
  
 Diese Methode lädt Assemblys, die mithilfe der <xref:System.Reflection.Assembly.LoadFile%2A> Methode. Sie können Assemblys auch mit Ausführen der <xref:System.AppDomain.ExecuteAssemblyByName%2A> -Methode, die Assemblys mit lädt die <xref:System.Reflection.Assembly.Load%2A> Methode.  
  
   
  
## Examples  
 Folgende Beispiel veranschaulicht die Verwendung einer der Überladungen der <xref:System.AppDomain.ExecuteAssembly%2A> in zwei verschiedenen Domänen.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyFile" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyFile" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> ist nicht <see langword="null" />. Wenn die Legacy-CAS-Richtlinie nicht aktiviert ist, sollte <paramref name="assemblySecurity" /> dem Wert <see langword="null" /> entsprechen.</exception>
        <exception cref="T:System.MissingMethodException">Die angegebene Assembly verfügt über keinen Einstiegspunkt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assembly mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder eines Verzeichnisses und für den Zugriff auf die Informationen in den Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">zum Lesen von eines URIS, der nicht mit "file://" beginnt.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">eine Konsolenanwendung ausführen zu können. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssemblyByName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Führt eine Assembly aus.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Führt eine Assembly unter Angabe ihres Anzeigenamens aus.</summary>
        <returns>Der vom Einstiegspunkt der Assembly zurückgegebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.AppDomain.ExecuteAssemblyByName%2A> Methode verfügt über ähnliche Funktionen, die <xref:System.AppDomain.ExecuteAssembly%2A> -Methode, gibt jedoch die Assembly über den Anzeigenamen oder <xref:System.Reflection.AssemblyName> statt über den Dateispeicherort. Aus diesem Grund <xref:System.AppDomain.ExecuteAssemblyByName%2A> lädt Assemblys mit der <xref:System.Reflection.Assembly.Load%2A> Methode und nicht mit der <xref:System.Reflection.Assembly.LoadFile%2A> Methode.  
  
 Die Assembly beginnt in der Einstiegspunkt in .NET Framework-Header angegeben.  
  
 Diese Methode erstellt einen neuen Prozess oder eine Anwendungsdomäne nicht, und die Einstiegspunktmethode nicht in einem neuen Thread ausgeführt.  
  
 Zum Erstellen der <xref:System.AppDomain> zum Laden und ausführen, verwenden Sie die <xref:System.AppDomain.CreateDomain%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die durch <paramref name="assemblyName" /> angegebene Assembly wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException">Die durch <paramref name="assemblyName" /> angegebene Assembly ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyName" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Die durch <paramref name="assemblyName" /> angegebene Assembly wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.MissingMethodException">Die angegebene Assembly verfügt über keinen Einstiegspunkt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder das Verzeichnis, für den Zugriff auf die Informationen in den Pfad selbst und für die Umleitung von einem Pfad eines Anzeigenamen ein. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf eine Website, wenn Sie ein Anzeigenamen an eine URL umgeleitet wird.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">eine Konsolenanwendung ausführen zu können. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Ein <see cref="T:System.Reflection.AssemblyName" />-Objekt, das den Namen der Assembly darstellt.</param>
        <param name="args">Befehlszeilenargumente, die beim Starten des Prozesses übergeben werden sollen.</param>
        <summary>Führt bei Angabe eines <see cref="T:System.Reflection.AssemblyName" /> die Assembly mit den angegebenen Argumenten aus.</summary>
        <returns>Der vom Einstiegspunkt der Assembly zurückgegebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.AppDomain.ExecuteAssemblyByName%2A> Methode verfügt über ähnliche Funktionen, die <xref:System.AppDomain.ExecuteAssembly%2A> -Methode, gibt jedoch die Assembly über den Anzeigenamen oder <xref:System.Reflection.AssemblyName> statt über den Dateispeicherort. Aus diesem Grund <xref:System.AppDomain.ExecuteAssemblyByName%2A> lädt Assemblys mit der <xref:System.Reflection.Assembly.Load%2A> Methode und nicht mit der <xref:System.Reflection.Assembly.LoadFile%2A> Methode.  
  
 Die Assembly beginnt in der Einstiegspunkt in .NET Framework-Header angegeben.  
  
 Diese Methode erstellt einen neuen Prozess oder eine Anwendungsdomäne nicht, und die Einstiegspunktmethode nicht in einem neuen Thread ausgeführt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Die durch <paramref name="assemblyName" /> angegebene Assembly wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException">Die durch <paramref name="assemblyName" /> angegebene Assembly wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException">Die durch <paramref name="assemblyName" /> angegebene Assembly ist keine gültige Assembly.  
  
 - oder -   
  
 <paramref name="assemblyName" /> wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.MissingMethodException">Die angegebene Assembly verfügt über keinen Einstiegspunkt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder das Verzeichnis, für den Zugriff auf die Informationen in den Pfad selbst und für die Umleitung von einem Pfad eines Anzeigenamen ein. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf eine Website, wenn Sie ein Anzeigenamen an eine URL umgeleitet wird.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">eine Konsolenanwendung ausführen zu können. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Beweis für das Laden der Assembly.</param>
        <summary>Führt eine Assembly unter Angabe ihres Anzeigenamens mit dem angegebenen Beweis aus.</summary>
        <returns>Der vom Einstiegspunkt der Assembly zurückgegebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.AppDomain.ExecuteAssemblyByName%2A> Methode verfügt über ähnliche Funktionen, die <xref:System.AppDomain.ExecuteAssembly%2A> -Methode, gibt jedoch die Assembly über den Anzeigenamen oder <xref:System.Reflection.AssemblyName> statt über den Dateispeicherort. Aus diesem Grund <xref:System.AppDomain.ExecuteAssemblyByName%2A> lädt Assemblys mit der <xref:System.Reflection.Assembly.Load%2A> Methode und nicht mit der <xref:System.Reflection.Assembly.LoadFile%2A> Methode.  
  
 Die Assembly beginnt in der Einstiegspunkt in .NET Framework-Header angegeben.  
  
 Die <xref:System.AppDomain.ExecuteAssemblyByName%2A> Methode erstellt einen neuen Prozess oder die Anwendungsdomäne und die Einstiegspunktmethode nicht in einem neuen Thread ausgeführt.  
  
> [!NOTE]
>  Bei Verwendung der <xref:System.AppDomain.ExecuteAssemblyByName%2A> Methode mit einer <xref:System.Security.Policy.Evidence> Parameter Beweise werden zusammengeführt. Beweise, die als Argument an die <xref:System.AppDomain.ExecuteAssemblyByName%2A> Methode ablösen vom Ladeprogramm bereitgestellte Beweise.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die durch <paramref name="assemblyName" /> angegebene Assembly wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException">Die durch <paramref name="assemblyName" /> angegebene Assembly wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException">Die durch <paramref name="assemblyName" /> angegebene Assembly ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyName" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.MissingMethodException">Die angegebene Assembly verfügt über keinen Einstiegspunkt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder das Verzeichnis, für den Zugriff auf die Informationen in den Pfad selbst und für die Umleitung von einem Pfad eines Anzeigenamen ein. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assembly mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf eine Website, wenn Sie ein Anzeigenamen an eine URL umgeleitet wird.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">eine Konsolenanwendung ausführen zu können. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="args">Befehlszeilenargumente, die beim Starten des Prozesses übergeben werden sollen.</param>
        <summary>Führt die Assembly unter Angabe ihres Anzeigenamens mit den angegebenen Argumenten aus.</summary>
        <returns>Der vom Einstiegspunkt der Assembly zurückgegebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.AppDomain.ExecuteAssemblyByName%2A> Methode verfügt über ähnliche Funktionen, die <xref:System.AppDomain.ExecuteAssembly%2A> -Methode, gibt jedoch die Assembly über den Anzeigenamen oder <xref:System.Reflection.AssemblyName> statt über den Dateispeicherort. Aus diesem Grund <xref:System.AppDomain.ExecuteAssemblyByName%2A> lädt Assemblys mit der <xref:System.Reflection.Assembly.Load%2A> Methode und nicht mit der <xref:System.Reflection.Assembly.LoadFile%2A> Methode.  
  
 Die Assembly beginnt in der Einstiegspunkt in .NET Framework-Header angegeben.  
  
 Diese Methode erstellt einen neuen Prozess oder eine Anwendungsdomäne nicht, und die Einstiegspunktmethode nicht in einem neuen Thread ausgeführt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die durch <paramref name="assemblyName" /> angegebene Assembly wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException">Die durch <paramref name="assemblyName" /> angegebene Assembly wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException">Die durch <paramref name="assemblyName" /> angegebene Assembly ist keine gültige Assembly.  
  
 - oder -   
  
 <paramref name="assemblyName" /> wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.MissingMethodException">Die angegebene Assembly verfügt über keinen Einstiegspunkt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder das Verzeichnis, für den Zugriff auf die Informationen in den Pfad selbst und für die Umleitung von einem Pfad eines Anzeigenamen ein. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf eine Website, wenn Sie ein Anzeigenamen an eine URL umgeleitet wird.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">eine Konsolenanwendung ausführen zu können. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Ein <see cref="T:System.Reflection.AssemblyName" />-Objekt, das den Namen der Assembly darstellt.</param>
        <param name="assemblySecurity">Beweis für das Laden der Assembly.</param>
        <param name="args">Befehlszeilenargumente, die beim Starten des Prozesses übergeben werden sollen.</param>
        <summary>Führt bei Angabe eines <see cref="T:System.Reflection.AssemblyName" /> die Assembly mit dem angegebenen Beweis und den angegebenen Argumenten aus.</summary>
        <returns>Der vom Einstiegspunkt der Assembly zurückgegebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.AppDomain.ExecuteAssemblyByName%2A> Methode verfügt über ähnliche Funktionen, die <xref:System.AppDomain.ExecuteAssembly%2A> -Methode, gibt jedoch die Assembly über den Anzeigenamen oder <xref:System.Reflection.AssemblyName> statt über den Dateispeicherort. Aus diesem Grund <xref:System.AppDomain.ExecuteAssemblyByName%2A> lädt Assemblys mit der <xref:System.Reflection.Assembly.Load%2A> Methode und nicht mit der <xref:System.Reflection.Assembly.LoadFile%2A> Methode.  
  
 Die Assembly beginnt in der Einstiegspunkt in .NET Framework-Header angegeben.  
  
 Diese Methode erstellt einen neuen Prozess oder eine Anwendungsdomäne nicht, und die Einstiegspunktmethode nicht in einem neuen Thread ausgeführt.  
  
> [!NOTE]
>  Bei Verwendung der <xref:System.AppDomain.ExecuteAssemblyByName%2A> Methode mit einer <xref:System.Security.Policy.Evidence> Parameter Beweise werden zusammengeführt. Beweise, die als Argument an die <xref:System.AppDomain.ExecuteAssemblyByName%2A> Methode ablösen vom Ladeprogramm bereitgestellte Beweise.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Die durch <paramref name="assemblyName" /> angegebene Assembly wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException">Die durch <paramref name="assemblyName" /> angegebene Assembly wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException">Die durch <paramref name="assemblyName" /> angegebene Assembly ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyName" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> ist nicht <see langword="null" />. Wenn die Legacy-CAS-Richtlinie nicht aktiviert ist, sollte <paramref name="assemblySecurity" /> dem Wert <see langword="null" /> entsprechen.</exception>
        <exception cref="T:System.MissingMethodException">Die angegebene Assembly verfügt über keinen Einstiegspunkt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder das Verzeichnis, für den Zugriff auf die Informationen in den Pfad selbst und für die Umleitung von einem Pfad eines Anzeigenamen ein. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assembly mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf eine Website, wenn Sie ein Anzeigenamen an eine URL umgeleitet wird.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">eine Konsolenanwendung ausführen zu können. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Beweis für das Laden der Assembly.</param>
        <param name="args">Befehlszeilenargumente, die beim Starten des Prozesses übergeben werden sollen.</param>
        <summary>Führt die Assembly unter Angabe ihres Anzeigenamens mit dem angegebenen Beweis und den angegebenen Argumenten aus.</summary>
        <returns>Der vom Einstiegspunkt der Assembly zurückgegebene Wert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.AppDomain.ExecuteAssemblyByName%2A> Methode verfügt über ähnliche Funktionen, die <xref:System.AppDomain.ExecuteAssembly%2A> -Methode, gibt jedoch die Assembly über den Anzeigenamen oder <xref:System.Reflection.AssemblyName> statt über den Dateispeicherort. Aus diesem Grund <xref:System.AppDomain.ExecuteAssemblyByName%2A> lädt Assemblys mit der <xref:System.Reflection.Assembly.Load%2A> Methode und nicht mit der <xref:System.Reflection.Assembly.LoadFile%2A> Methode.  
  
 Die Assembly beginnt in der Einstiegspunkt in .NET Framework-Header angegeben.  
  
 Diese Methode erstellt einen neuen Prozess oder eine Anwendungsdomäne nicht, und die Einstiegspunktmethode nicht in einem neuen Thread ausgeführt.  
  
> [!NOTE]
>  Bei Verwendung der <xref:System.AppDomain.ExecuteAssemblyByName%2A> Methode mit einer <xref:System.Security.Policy.Evidence> Parameter Beweise werden zusammengeführt. Beweise, die als Argument an die <xref:System.AppDomain.ExecuteAssemblyByName%2A> Methode ablösen vom Ladeprogramm bereitgestellte Beweise.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die durch <paramref name="assemblyName" /> angegebene Assembly wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException">Die durch <paramref name="assemblyName" /> angegebene Assembly wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException">Die durch <paramref name="assemblyName" /> angegebene Assembly ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyName" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> ist nicht <see langword="null" />. Wenn die Legacy-CAS-Richtlinie nicht aktiviert ist, sollte <paramref name="assemblySecurity" /> dem Wert <see langword="null" /> entsprechen.</exception>
        <exception cref="T:System.MissingMethodException">Die angegebene Assembly verfügt über keinen Einstiegspunkt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder das Verzeichnis, für den Zugriff auf die Informationen in den Pfad selbst und für die Umleitung von einem Pfad eines Anzeigenamen ein. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assembly mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf eine Website, wenn Sie ein Anzeigenamen an eine URL umgeleitet wird.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">eine Konsolenanwendung ausführen zu können. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="FirstChanceException">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.FirstChanceException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FirstChanceException As EventHandler(Of FirstChanceExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Runtime::ExceptionServices::FirstChanceExceptionEventArgs ^&gt; ^ FirstChanceException;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Ausnahme in verwaltetem Code ausgelöst wird, bevor die Laufzeit in der Aufrufliste nach einem Ausnahmehandler in der Anwendungsdomäne sucht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis ist nur eine Benachrichtigung. Behandlung dieses Ereignisses nicht die Ausnahme behandeln oder nachfolgenden Ausnahmebehandlung in keiner Weise beeinflussen. Nachdem das Ereignis ausgelöst wurde, und Ereignishandler aufgerufen haben, beginnt die common Language Runtime (CLR), einen Handler für die Ausnahme gesucht werden soll. <xref:System.AppDomain.FirstChanceException> bietet die Anwendungsdomäne eine erste Möglichkeit, eine verwaltete Ausnahme zu untersuchen.  
  
 Das Ereignis kann pro Anwendungsdomäne behandelt werden. Wenn ein Thread über mehrere Anwendungsdomänen während der Ausführung eines Aufrufs erfolgreich ist, wird das Ereignis in jeder Anwendungsdomäne ausgelöst, die einen Ereignishandler registriert wurden, bevor die CLR beginnt die Suche nach einem entsprechenden Ausnahmehandler in der Anwendungsdomäne. Nachdem das Ereignis behandelt wurde, erfolgt eine Suche für ein passender Ausnahmehandler in der Anwendungsdomäne. Wenn keiner gefunden wird, wird das Ereignis in der nächsten Anwendungsdomäne ausgelöst.  
  
 Sie müssen alle Ausnahmen behandelt, die im Ereignis, Handler für auftreten das <xref:System.AppDomain.FirstChanceException> Ereignis. Andernfalls <xref:System.AppDomain.FirstChanceException> rekursiv ausgelöst wird. Dies kann zu einem Stapelüberlauf und Beendigung der Anwendung führen. Es wird empfohlen, dass Sie Ereignishandler für dieses Ereignis als eingeschränkte Ausführungsbereiche (CERs), implementieren, um zu verhindern, dass Ausnahmen infrastrukturbezogenen, z. B. Out-of-Memory oder Stapelüberlauf der virtuellen Computer beeinträchtigen, während die Ausnahme Benachrichtigung ist verarbeitet werden.  
  
 Dieses Ereignis wird nicht ausgelöst, für die Ausnahmen, die eine Beschädigung der Prozessstatus, z. B. zugriffsverletzungen angeben, wenn der Ereignishandler als sicherheitskritisch wird und für die <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> Attribut.  
  
 Die common Language Runtime hält Threadabbrüche während dieses Benachrichtigungsereignis behandelt wird.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Reihe von Anwendungsdomänen, die mit dem Namen `AD0` über `AD3`, mit einem `Worker` Objekt pro Anwendungsdomäne. Jede `Worker` Objekt enthält einen Verweis auf die `Worker` -Objekt in der nächsten Anwendungsdomäne, außer für die `Worker` in der letzten Anwendungsdomäne. Die <xref:System.AppDomain.FirstChanceException> Ereignis behandelt wird, in allen Anwendungsdomänen außer `AD1`.  
  
> [!NOTE]
>  Zusätzlich zu diesem Beispiel, in dem erste Chance ausnahmebenachrichtigungen in mehreren Anwendungsdomänen veranschaulicht wird, finden Sie in einfachen Anwendungsfällen [wie: erste Chance Ausnahmebenachrichtigungen empfangen](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md).  
  
 Wenn die Anwendungsdomänen erstellt wurden, ruft die Standardanwendungsdomäne die `TestException` Methode für die erste Anwendungsdomäne. Jede `Worker` -Objekt ruft die `TestException` Methode für die nächste Anwendungsdomäne, bis der letzte `Worker` löst eine Ausnahme, die entweder behandelt oder nicht behandelt wird. Folglich alle Anwendungsdomänen, der aktuelle Thread durchläuft und `TestException` wird dem Stapel in jeder Anwendungsdomäne hinzugefügt.  
  
 Wenn der letzte `Worker` Objekt verarbeitet die Ausnahme, die <xref:System.AppDomain.FirstChanceException> Ereignis wird nur in der letzten Anwendungsdomäne. Die anderen Anwendungsdomänen Gelegenheit nie zur Behandlung von Ausnahmen, damit das Ereignis nicht ausgelöst wird.  
  
 Bei der letzten `Worker` Objekt behandelt die Ausnahme nicht die <xref:System.AppDomain.FirstChanceException> Ereignis wird in jeder Anwendungsdomäne, die einen Ereignishandler aufweist. Nach Abschluss der einzelnen Ereignishandler wird der Stapel entladen, bis die Ausnahme durch die Standardanwendungsdomäne abgefangen wird fortgesetzt.  
  
> [!NOTE]
>  Um anzuzeigen, wie die Anzeige der Stapel vergrößert wird, wie das Ereignis, das näher ausgelöst wird und näher an die Standardanwendungsdomäne, ändern Sie `e.Exception.Message` auf `e.Exception` in der `FirstChanceHandler` -Ereignishandler. Beachten Sie, dass bei `TestException` heißt über Anwendungsdomänengrenzen hinweg, dann zweimal angezeigt: einmal für den Proxy und einmal für den Stub.  
  
 [!code-csharp[System.AppDomain.FirstChanceException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/cs/example.cs#1)]
 [!code-vb[System.AppDomain.FirstChanceException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="T:System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs" />
        <altmember cref="E:System.AppDomain.UnhandledException" />
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.FriendlyName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den angezeigten Namen dieser Anwendungsdomäne ab.</summary>
        <value>Der angezeigte Name dieser Anwendungsdomäne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Anzeigename für die Standardanwendungsdomäne ist der Dateiname der ausführbaren Prozessdatei an. Z. B. wenn die ausführbare Datei verwendet wird, zum Starten des Prozesses ist `"c:\MyAppDirectory\MyAssembly.exe"`, ist der Anzeigename, der die Standardanwendungsdomäne `"MyAssembly.exe"`.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.AppDomain.FriendlyName%2A> Eigenschaft, um den Anzeigenamen des die aktuelle Anwendungsdomäne. Für die Standardanwendungsdomäne ist der Anzeigename der Name der ausführbaren Datei der Anwendung. Das Codebeispiel zeigt auch zusätzliche Informationen zu der Anwendungsdomäne.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die Assemblys ab, die in den Ausführungskontext dieser Anwendungsdomäne geladen wurden.</summary>
        <returns>Ein Array von Assemblys in dieser Anwendungsdomäne.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird mit der <xref:System.AppDomain.GetAssemblies%2A> Methode, um eine Liste aller Assemblys abzurufen, die in die Anwendungsdomäne geladen wurden. Anschließend werden die Assemblys in der Konsole angezeigt.  
  
 Um dieses Codebeispiel ausführen zu können, müssen Sie zum Erstellen einer Assembly mit dem Namen `CustomLibrary.dll`, oder ändern Sie den Assemblynamen, die an die <xref:System.AppDomain.GetAssemblies%2A> Methode.  
  
 [!code-cpp[ADGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetAssemblies/CPP/adgetassemblies.cpp#1)]
 [!code-csharp[ADGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetAssemblies/CS/adgetassemblies.cs#1)]
 [!code-vb[ADGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetAssemblies/VB/adgetassemblies.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetCurrentThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentThreadId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentThreadId();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den aktuellen Threadbezeichner ab.</summary>
        <returns>Eine 32-Bit-Ganzzahl mit Vorzeichen, die als Bezeichner das aktuellen Threads verwendet wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> -Eigenschaft, die stabil ist, selbst wenn .NET Framework von einer Umgebung gehostet wird, die Fibers (also: schlanken Threads) unterstützt.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Diese Methode aufgerufen wird. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <altmember cref="T:System.Int32" />
        <altmember cref="P:System.Threading.Thread.ManagedThreadId" />
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetData(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetData(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Der Name einer vordefinierten Anwendungsdomäneneigenschaft oder der Name einer von Ihnen definierten Anwendungsdomäneneigenschaft.</param>
        <summary>Ruft den in der aktuellen Anwendungsdomäne gespeicherten Wert für den angegebenen Namen ab.</summary>
        <returns>Der Wert der <paramref name="name" />-Eigenschaft oder <see langword="null" />, wenn die Eigenschaft nicht vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Abrufen des Werts eines Eintrags in einem internen Cache von Name-Daten-Paaren, die Eigenschaften dieser Instanz von beschreiben <xref:System.AppDomain>. Beachten Sie, dass der Vergleich von `name` durch den Namen des Schlüssel-Wert-Paare wird Groß-/Kleinschreibung beachtet.  
  
 Der Cache enthält automatisch die vordefinierten Systemdaten-Einträge, die eingefügt werden, wenn die Anwendungsdomäne erstellt wird. Sie können prüfen, deren Werte mit den <xref:System.AppDomain.GetData%2A> Methode oder die entsprechende <xref:System.AppDomainSetup> Eigenschaften.  
  
 Sie einfügen oder ändern Sie Ihre eigenen benutzerdefinierten Name-Daten-Paare mit der <xref:System.AppDomain.SetData%2A> Methode, und überprüfen Sie deren Werte mit der <xref:System.AppDomain.GetData%2A> Methode.  
  
 Die folgende Tabelle beschreibt die `name` jedes vordefinierten Eintrag im Dateisystem und dem zugehörigen <xref:System.AppDomainSetup> Eigenschaft.  
  
|Wert des "Name"|Eigenschaft|  
|---------------------|--------------|  
|"APPBASE"|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>|  
|"APP_CONFIG_FILE"|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=nameWithType>|  
|"APP_LAUNCH_URL"|(keine Eigenschaft)<br /><br /> "APP_LAUNCH_URL" darstellt, die durch den Benutzer vor allen umleitungen, die ursprünglich angeforderte URL. Es steht nur, wenn die Anwendung mit einem Browser wie Internet Explorer gestartet wurde. Geben Sie diesen Wert nicht von allen Browsern.|  
|"APP_NAME"|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>|  
|"BINPATH_PROBE_ONLY"|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=nameWithType>|  
|"CACHE_BASE"|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>|  
|"CODE_DOWNLOAD_DISABLED"|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>|  
|"DEV_PATH"|(keine Eigenschaft)|  
|"DISALLOW_APP"|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_BASE_PROBING"|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_REDIRECTS"|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=nameWithType>|  
|"DYNAMIC_BASE"|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>|  
|"FORCE_CACHE_INSTALL"|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>|  
|"LICENSE_FILE" oder eine anwendungsspezifische Zeichenfolge|<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=nameWithType>|  
|"LOADER_OPTIMIZATION"|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=nameWithType>|  
|"LOCATION_URI"|(keine Eigenschaft)|  
|"PRIVATE_BINPATH"|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>|  
|"REGEX_DEFAULT_MATCH_TIMEOUT"|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=nameWithType><br /><br /> "REGEX_DEFAULT_MATCH_TIMEOUT" ist kein System Eintrag, und ihr Wert kann festgelegt werden, durch Aufrufen der <xref:System.AppDomain.SetData%2A> Methode.|  
|"SHADOW_COPY_DIRS"|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>|  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine neue Anwendungsdomäne, wird ein vom System bereitgestellte Wert für die Domäne und fügt einen neuen Wert-Paar für die Domäne. Im Beispiel wird dann veranschaulicht, wie die <xref:System.AppDomain.GetData%2A> Methode, um die Daten aus diesen Wert-Paare abzurufen und in der Konsole angezeigt werden.  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Informationen in den Pfad selbst, wenn die Eigenschaft auf einen Pfad bezieht. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="M:System.AppDomain.SetData(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den Typ der aktuellen Instanz ab.</summary>
        <returns>Der Typ der aktuellen Instanz.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Ganzzahl ab, die die Anwendungsdomäne innerhalb des Prozesses eindeutig identifiziert.</summary>
        <value>Eine Ganzzahl, die die Anwendungsdomäne identifiziert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird eine zweite Anwendungsdomäne erstellt, und zeigt Informationen über die Standarddomäne und der neuen Domäne.  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InitializeLifetimeService();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.InitializeLifetimeService</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Führt zu einer unendlichen Lebensdauer der <see cref="T:System.AppDomain" />, indem das Erstellen eines Lease verhindert wird.</summary>
        <returns>Immer <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCompatibilitySwitchSet (value As String) As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; IsCompatibilitySwitchSet(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Der zu überprüfende Kompatibilitätsschalter.</param>
        <summary>Ruft einen booleschen Wert, der NULL-Werte zulässt, ab, der angibt, ob alle Kompatibilitätsschalter festgelegt werden und ob in diesem Fall der angegebene Kompatibilitätsschalter festgelegt wird.</summary>
        <returns>Ein NULL-Verweis (<see langword="Nothing" /> in Visual Basic), wenn keine Kompatibilitätsschalter festgelegt werden, andernfalls ein boolescher Wert, der angibt, ob der durch <paramref name="value" /> angegebene Kompatibilitätsschalter festgelegt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überprüft, ob der angegebene Kompatibilitätsschalter für die aktuelle Anwendungsdomäne festgelegt wurde. Kompatibilitätsschalter wiederherstellen in der Regel ein Verhalten (z. B. wie Zeichenfolgen sortiert werden), die zwischen verschiedenen Versionen von .NET Framework geändert wurde.  Sie sind festgelegt werden, indem die <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType> Methode vor dem Erstellen einer Anwendungsdomäne.  
  
 Die folgende Tabelle enthält Beispiele für Kompatibilitätsschalter, die festgelegt werden können, um das Verhalten von früheren Versionen von .NET Framework wiederherzustellen.  
  
|Schalter|Bedeutung|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|Codezugriffssicherheit (CAS) für die [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] in dieser Anwendungsdomäne aktiviert ist. Finden Sie unter [ &lt;NetFx40_LegacySecurityPolicy&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).|  
|"NetFx40_Legacy20SortingBehavior"|Standardwerte für zum Sortieren von Zeichenfolgen die [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] in dieser Anwendungsdomäne aktiviert sind. Ihr Erfolg erfordert sort00001000.dll installiert werden. Finden Sie unter [ &lt;CompatSortNLSVersion&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).|  
|"NetFx40_Legacy40SortingBehavior"|Standardwerte für zum Sortieren von Zeichenfolgen die [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]und Unicode 5.0 in dieser Anwendungsdomäne aktiviert sind. Ihr Erfolg erfordert sort00060101.dll installiert werden.|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> Formatieren Sie das Verhalten für die [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] in dieser Anwendungsdomäne aktiviert ist.  Finden Sie unter [ &lt;TimeSpan_LegacyFormatMode&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) und im Abschnitt "Wiederherstellen Legacy TimeSpan Formatierung" die <xref:System.TimeSpan> Thema.|  
|"UseRandomizedStringHashAlgorithm"|Die Common Language Runtime berechnet Hashcodes für Zeichenfolgen auf einer pro Anwendungsdomäne anstelle eines einzelnen Hashalgorithmus, der über Anwendungsdomänen hinweg konsistenten Hashcode erzeugt. Finden Sie unter [ &lt;UseRandomizedStringHashAlgorithm&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsDefaultAppDomain" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDefaultAppDomain () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDefaultAppDomain();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob die Anwendungsdomäne die Standardanwendungsdomäne für den Prozess ist.</summary>
        <returns>
          <see langword="true" />, wenn das aktuelle <see cref="T:System.AppDomain" />-Objekt die Standardanwendungsdomäne für den Prozess darstellt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jeder verwaltete Prozess besitzt eine Standardanwendungsdomäne. Die Ausführung beginnt in der Standarddomäne.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine zweite Anwendungsdomäne erstellt, und zeigt Informationen über die Standarddomäne und der neuen Domäne.  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsFinalizingForUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFinalizingForUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFinalizingForUnload();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt an, ob diese Anwendungsdomäne entladen wird und ob die darin enthaltenen Objekte durch die Common Language Runtime finalisiert werden.</summary>
        <returns>
          <see langword="true" />, wenn die Anwendungsdomäne entladen wird und die Common Language Runtime mit dem Aufrufen von Finalizers begonnen hat, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Finalisierungsmethode für ein Objekt bietet die Möglichkeit, alle erforderlichen Bereinigungen ausführen, bevor das Objekt mit Garbage Collection durchgeführt wird. Nach seiner Finalisierung verfolgt ist das Objekt zugegriffen werden kann, aber in einem ungültigen Zustand befindet, und kann daher nicht verwendet werden. Schließlich wird Garbagecollection abgeschlossen ist, und gibt das Objekt frei.  
  
 Ein Objekt Finalisierung-Methode wird aufgerufen, in den folgenden Situationen: während der Garbagecollection, wenn die common Language Runtime beendet wird oder wenn die Anwendungsdomäne mit dem Objekt entladen wird. Die <xref:System.AppDomain.IsFinalizingForUnload%2A> -Methode zurückkehrt `true` nur im letzten Fall; sie gibt keine zurück `true` Wenn Finalisierung als von der Routine Garbagecollection oder CLR heruntergefahren wurde Ergebnis.  
  
> [!NOTE]
>  Um festzustellen, ob die Beendigung aufgrund von CLR heruntergefahren ist, verwenden die <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType> Eigenschaft. Es gibt `true` Wenn Finalisierung könnte durch eine Anwendungsdomäne entladen oder die CLR heruntergefahren wird.  
  
 Während der Ausführung in der Finalisierungsmethode während der Domäne zu entladen, empfiehlt es sich um ein anderes Objekt zugreifen, das von einem statischen Feld verwiesen wird, und verfügt über eine Methode zur Finalisierung verfolgt. Allerdings möglich Sie zuverlässig dies nicht, wenn das verwendete Objekt möglicherweise bereits freigegeben wurde.  
  
> [!NOTE]
>  Eine Ausnahme von dieser Regel wird die <xref:System.Console> -Klasse, die enthält statische Felder, die Streamobjekte verweisen, jedoch wird implementiert, speziell, damit Sie auch beim Herunterfahren der Anwendungsdomäne entladen oder das System immer an der Systemkonsole schreiben können.  
  
 Verwenden Sie diese Methode in einer Objektmethode seiner Finalisierung verfolgt, um zu bestimmen, ob die Anwendungsdomäne mit dem Objekt entladen wird. Wenn dies der Fall ist, können nicht Sie zuverlässig beliebige Objekte zugreifen, verfügt über eine Methode zur Finalisierung verfolgt und von einem statischen Feld verwiesen wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Environment.HasShutdownStarted" />
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob in die aktuelle Anwendungsdomäne geladene Assemblys mit vollständiger Vertrauenswürdigkeit ausgeführt werden.</summary>
        <value>
          <see langword="true" />, wenn in die aktuelle Anwendungsdomäne geladene Assemblys mit voller Vertrauenswürdigkeit ausgeführt werden, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt immer `true` für die Standardanwendungsdomäne einer Anwendung, die auf dem Desktop ausgeführt wird. Es gibt `false` für eine Sandbox-Anwendungsdomäne, das erstellt wurde die <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> Methode zu überladen, es sei denn, die Berechtigungen, die die Anwendungsdomäne gewährt werden, auf volle Vertrauenswürdigkeit entsprechen.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.AppDomain.IsFullyTrusted%2A> Eigenschaft und die <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> Eigenschaft mit vollständig vertrauenswürdigen als auch teilweise vertrauenswürdigen Anwendungsdomänen. Die vollständig vertrauenswürdige Anwendungsdomäne ist die Standardanwendungsdomäne für die Anwendung. Die teilweise vertrauenswürdige Anwendungsdomäne wird erstellt, mit der <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> -methodenüberladung.  
  
 Im Beispiel wird eine `Worker` von abgeleitete Klasse <xref:System.MarshalByRefObject>, sodass es über Anwendungsdomänengrenzen hinweg gemarshallt werden kann. Das Beispiel erstellt eine `Worker` Objekt in der Standardanwendungsdomäne. Er ruft dann die `TestIsFullyTrusted` -Methode zum Anzeigen des Eigenschaftswert für die Anwendungsdomäne und für zwei Assemblys, die in die Anwendungsdomäne geladen werden: "mscorlib", die Bestandteil von .NET Framework und die Beispielassembly ist. Die Anwendungsdomäne ist vollständig vertrauenswürdig sein, damit beide Assemblys vollständig vertrauenswürdig sind.  
  
 Das Beispiel erstellt eine andere `Worker` Objekt in einer Sandbox-Anwendungsdomäne und erneut Aufrufe der `TestIsFullyTrusted` Methode. "Mscorlib" ist auch in einer teilweise vertrauenswürdigen Anwendungsdomäne immer als vertrauenswürdig gilt, aber die Beispielassembly ist, teilweise vertrauenswürdig.  
  
 [!code-csharp[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/cs/example.cs#1)]
 [!code-vb[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsHomogenous" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHomogenous As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHomogenous { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die aktuelle Anwendungsdomäne einen Satz von Berechtigungen aufweist, der allen in die Anwendungsdomäne geladenen Assemblys gewährt wird.</summary>
        <value>
          <see langword="true" />, wenn die aktuelle Anwendungsdomäne einen homogenen Satz von Berechtigungen aufweist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt `true` für Sandbox-Anwendungsdomänen, die erstellt wurden die <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> -methodenüberladung. Sandbox-Anwendungsdomänen über einen homogenen Satz von Berechtigungen verfügen; d. h. erhält der gleiche Satz von Berechtigungen auf alle teilweise vertrauenswürdige Assemblys, die in die Anwendungsdomäne geladen werden. Eine Sandbox-Anwendungsdomäne hat optional eine Liste von Assemblys mit starkem Namen, die diese Berechtigung, und führen stattdessen mit voller Vertrauenswürdigkeit ausgeschlossen sind.  
  
 Vollständig vertrauenswürdige Code kann mithilfe der <xref:System.AppDomain.PermissionSet%2A> -Eigenschaft zum Bestimmen des homogenen Berechtigungssatzes einer Sandbox-Anwendungsdomäne.  
  
 Diese Eigenschaft gibt auch zurück `true` für die Standardanwendungsdomäne einer desktop-Anwendung, da diese Anwendungsdomäne auf alle Assemblys volle Vertrauenswürdigkeit gewährt.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomain.PermissionSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Lädt eine <see cref="T:System.Reflection.Assembly" /> in diese Anwendungsdomäne.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Ein Array vom Typ <see langword="byte" />, das ein COFF-Image mit einer ausgegebenen Assembly ist.</param>
        <summary>Lädt die <see cref="T:System.Reflection.Assembly" /> mit einem COFF-Image (Common Object File Format), das eine angegebene <see cref="T:System.Reflection.Assembly" /> enthält.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], die Vertrauensebene einer Assembly, die geladen wird, mit dieser Methode ist identisch mit der Vertrauensebene der Anwendungsdomäne.  
  
 Diese Methode sollte nur zum Laden einer Assembly in der aktuellen Anwendungsdomäne verwendet werden. Diese Methode wird als Annehmlichkeit bereitgestellt, für die Interoperabilität mit Aufrufern, die die statische aufrufen können <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> Methode. Verwenden Sie zum Laden von Assemblys in anderen Anwendungsdomänen eine Methode ein, z. B. <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Informationen, die für alle Überladungen dieser Methode gemein sind, finden Sie unter der <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die Verwendung eine unformatierte Assembly zu laden.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen bereitstellen. Informationen zur Vorgehensweise zum Abrufen der vollqualifizierte Assemblyname finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="rawAssembly" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder eines Verzeichnisses und für den Zugriff auf die Informationen in den Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Ein Objekt, das die zu ladende Assembly beschreibt.</param>
        <summary>Lädt eine <see cref="T:System.Reflection.Assembly" /> bei Angabe ihres <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte nur zum Laden einer Assembly in der aktuellen Anwendungsdomäne verwendet werden. Diese Methode wird als Annehmlichkeit bereitgestellt, für die Interoperabilität mit Aufrufern, die die statische aufrufen können <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> Methode. Verwenden Sie zum Laden von Assemblys in anderen Anwendungsdomänen eine Methode ein, z. B. <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Wenn bereits eine Version der angeforderten Assembly geladen wird, gibt diese Methode die geladene Assembly zurück, selbst wenn eine andere Version angefordert wird.  
  
 Einen partiellen Assemblynamen für die Angabe `assemblyRef` wird nicht empfohlen. (Ein Teilnamen lässt eine oder mehrere der Kultur, Version oder Token des öffentlichen Schlüssels. Für Überladungen, die eine Zeichenfolge anstelle von akzeptieren ein <xref:System.Reflection.AssemblyName> -Objekt, "MyAssembly, Version = 1.0.0.0" ist ein Beispiel eines unvollständigen Namens und "MyAssembly, Version = 1.0.0.0, Culture = Neutral, PublicKeyToken = 18ab3442da84b47" ist ein Beispiel für einen vollständigen Namen.) Namensteile mit verfügt über eine negative Auswirkung auf die Leistung aus. Darüber hinaus ein partiellen Assemblynamen kann laden eine Assembly aus dem globalen Assemblycache nur, wenn eine genaue Kopie der Assembly in das Anwendungsbasisverzeichnis (<xref:System.AppDomain.BaseDirectory%2A> oder <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>).  
  
 Wenn die aktuelle <xref:System.AppDomain> Objekt darstellt, die Anwendungsdomäne `A`, und die <xref:System.AppDomain.Load%2A> Methode wird von der Anwendungsdomäne aufgerufen `B`, die Assembly wird in beide Anwendungsdomänen geladen. Im folgenden Codebeispiel lädt `MyAssembly` in der neuen Anwendungsdomäne `ChildDomain` und auch in der Anwendungsdomäne, in dem der Code ausgeführt wird:  
  
 [!code-cpp[System.AppDomain.Load#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.load/cpp/source.cpp#1)]
 [!code-csharp[System.AppDomain.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.load/cs/source.cs#1)]
 [!code-vb[System.AppDomain.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.load/vb/source.vb#1)]  
  
 Die Assembly wird in beide Domänen geladen, da <xref:System.Reflection.Assembly> nicht ableiten <xref:System.MarshalByRefObject>, und daher ist der Rückgabewert von der <xref:System.AppDomain.Load%2A> Methode nicht gemarshallt werden kann. Stattdessen versucht die common Language Runtime die Assembly in der aufrufenden Anwendungsdomäne geladen. Die Assemblys, die in den zwei Anwendungsdomänen geladen sind möglicherweise anders, wenn die pfadeinstellungen für die zwei Anwendungsdomänen unterscheiden.  
  
> [!NOTE]
>  Wenn beide die <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> Eigenschaft und die <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> Eigenschaft festgelegt werden, der erste Versuch zum Laden der Assembly verwendet den Anzeigenamen (einschließlich der Version, Kultur und So weiter, wie vom die <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> Eigenschaft). Wenn die Datei nicht gefunden wird, die <xref:System.Reflection.AssemblyName.CodeBase%2A> Eigenschaft wird verwendet, um nach der Assembly zu suchen. Wenn die Assembly gefunden wird, mithilfe von <xref:System.Reflection.AssemblyName.CodeBase%2A>, der Anzeigenamen der Assembly abgeglichen wird. Wenn die Übereinstimmung fehlschlägt, eine <xref:System.IO.FileLoadException> ausgelöst wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyRef" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder eines Verzeichnisses und für den Zugriff auf die Informationen in den Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Lädt eine <see cref="T:System.Reflection.Assembly" /> bei Angabe ihres Anzeigenamens.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte nur zum Laden einer Assembly in der aktuellen Anwendungsdomäne verwendet werden. Diese Methode wird als Annehmlichkeit bereitgestellt, für die Interoperabilität mit Aufrufern, die die statische aufrufen können <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> Methode. Verwenden Sie zum Laden von Assemblys in anderen Anwendungsdomänen eine Methode ein, z. B. <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Informationen, die für alle Überladungen dieser Methode gemein sind, finden Sie unter der <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> ist gleich <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyString" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder eines Verzeichnisses und für den Zugriff auf die Informationen in den Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">für den Zugriff auf den Speicherort der Assembly zugreifen, wenn die Assembly nicht lokal ist.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Ein Array vom Typ <see langword="byte" />, das ein COFF-Image mit einer ausgegebenen Assembly ist.</param>
        <param name="rawSymbolStore">Ein Array vom Typ <see langword="byte" />, das die Rohdatenbytes enthält, die die Symbole für die Assembly darstellen.</param>
        <summary>Lädt die <see cref="T:System.Reflection.Assembly" /> mit einem COFF-Image (Common Object File Format), das eine angegebene <see cref="T:System.Reflection.Assembly" /> enthält. Die Rohdatenbytes, die die Symbole für die <see cref="T:System.Reflection.Assembly" /> darstellen, werden ebenfalls geladen.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], die Vertrauensebene einer Assembly, die geladen wird, mit dieser Methode ist identisch mit der Vertrauensebene der Anwendungsdomäne.  
  
 Diese Methode sollte nur zum Laden einer Assembly in der aktuellen Anwendungsdomäne verwendet werden. Diese Methode wird als Annehmlichkeit bereitgestellt, für die Interoperabilität mit Aufrufern, die die statische aufrufen können <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> Methode. Verwenden Sie zum Laden von Assemblys in anderen Anwendungsdomänen eine Methode ein, z. B. <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Informationen, die für alle Überladungen dieser Methode gemein sind, finden Sie unter der <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die Verwendung eine unformatierte Assembly zu laden.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen bereitstellen. Informationen zur Vorgehensweise zum Abrufen der vollqualifizierte Assemblyname finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="rawAssembly" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Net.WebPermission">zum Lesen von eines URIS, der nicht mit "file://" beginnt.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder eines Verzeichnisses und für den Zugriff auf die Informationen in den Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Ein Objekt, das die zu ladende Assembly beschreibt.</param>
        <param name="assemblySecurity">Beweis für das Laden der Assembly.</param>
        <summary>Lädt eine <see cref="T:System.Reflection.Assembly" /> bei Angabe ihres <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte nur zum Laden einer Assembly in der aktuellen Anwendungsdomäne verwendet werden. Diese Methode wird als Annehmlichkeit bereitgestellt, für die Interoperabilität mit Aufrufern, die die statische aufrufen können <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> Methode. Verwenden Sie zum Laden von Assemblys in anderen Anwendungsdomänen eine Methode ein, z. B. <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Informationen, die für alle Überladungen dieser Methode gemein sind, finden Sie unter der <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> ist gleich <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyRef" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder eines Verzeichnisses und für den Zugriff auf die Informationen in den Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assembly mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Net.WebPermission">zum Lesen von eines Pfads, die nicht in der Form "file://" oder "\\\UNC\dir\\" oder "" c: "\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Der Anzeigename der Assembly. Siehe <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Beweis für das Laden der Assembly.</param>
        <summary>Lädt eine <see cref="T:System.Reflection.Assembly" /> bei Angabe ihres Anzeigenamens.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sollte nur zum Laden einer Assembly in der aktuellen Anwendungsdomäne verwendet werden. Diese Methode wird als Annehmlichkeit bereitgestellt, für die Interoperabilität mit Aufrufern, die die statische aufrufen können <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> Methode. Verwenden Sie zum Laden von Assemblys in anderen Anwendungsdomänen eine Methode ein, z. B. <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Informationen, die für alle Überladungen dieser Methode gemein sind, finden Sie unter der <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> ist gleich <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="assemblyString" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Laden einer Assembly mit Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder eines Verzeichnisses und für den Zugriff auf die Informationen in den Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">zum Lesen von eines Pfads, die nicht in der Form "file://" oder "\\\UNC\dir\\" oder "" c: "\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Ein Array vom Typ <see langword="byte" />, das ein COFF-Image mit einer ausgegebenen Assembly ist.</param>
        <param name="rawSymbolStore">Ein Array vom Typ <see langword="byte" />, das die Rohdatenbytes enthält, die die Symbole für die Assembly darstellen.</param>
        <param name="securityEvidence">Beweis für das Laden der Assembly.</param>
        <summary>Lädt die <see cref="T:System.Reflection.Assembly" /> mit einem COFF-Image (Common Object File Format), das eine angegebene <see cref="T:System.Reflection.Assembly" /> enthält. Die Rohdatenbytes, die die Symbole für die <see cref="T:System.Reflection.Assembly" /> darstellen, werden ebenfalls geladen.</summary>
        <returns>Die geladene Assembly.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], die Vertrauensebene einer Assembly, die geladen wird, mit dieser Methode ist identisch mit der Vertrauensebene der Anwendungsdomäne.  
  
 Diese Methode sollte nur zum Laden einer Assembly in der aktuellen Anwendungsdomäne verwendet werden. Diese Methode wird als Annehmlichkeit bereitgestellt, für die Interoperabilität mit Aufrufern, die die statische aufrufen können <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> Methode. Verwenden Sie zum Laden von Assemblys in anderen Anwendungsdomänen eine Methode ein, z. B. <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Informationen, die für alle Überladungen dieser Methode gemein sind, finden Sie unter der <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> -methodenüberladung.  
  
   
  
## Examples  
 Im folgende Beispiel veranschaulicht die Verwendung eine unformatierte Assembly zu laden.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen bereitstellen. Informationen zur Vorgehensweise zum Abrufen der vollqualifizierte Assemblyname finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="rawAssembly" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> ist keine gültige Assembly.  
  
 - oder -   
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und <paramref name="rawAssembly" /> wurde mit einer höheren Version kompiliert.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> ist nicht <see langword="null" />. Wenn die Legacy-CAS-Richtlinie nicht aktiviert ist, sollte <paramref name="securityEvidence" /> dem Wert <see langword="null" /> entsprechen.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Bereitstellen von Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff zum Lesen aus einer Datei oder eines Verzeichnisses und für den Zugriff auf die Informationen in den Pfad selbst. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">zum Lesen von eines Pfads, die nicht in der Form "file://" oder "\\\UNC\dir\\" oder "" c: "\\".</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringIsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MonitoringIsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MonitoringIsEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob CPU- und Speicherüberwachung von Anwendungsdomänen für den aktuellen Prozess aktiviert ist, oder legt ihn fest. Wenn die Überwachung für einen Prozess aktiviert wurde, kann sie nicht deaktiviert werden.</summary>
        <value>
          <see langword="true" />, wenn die Überwachung aktiviert ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies `static` Eigenschaft (`Shared` Eigenschaft in Visual Basic) steuert die CPU- und speicherüberwachung alle Anwendungsdomänen im Prozess.  
  
 Wenn Sie versuchen, diese Eigenschaft festgelegt wird, um `false`, <xref:System.ArgumentException> Ausnahme wird ausgelöst, selbst wenn der aktuelle Wert der Eigenschaft ist `false`.  
  
 Nachdem die Überwachung aktiviert ist, können Sie die <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, und <xref:System.AppDomain.MonitoringTotalProcessorTime%2A> Instanzeigenschaften zum Überwachen der CPU- und Arbeitsspeicherressourcen Verwenden von einzelnen Anwendungsdomänen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der aktuelle Prozess hat versucht, dieser Eigenschaft den Wert <see langword="false" /> zuzuweisen.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringSurvivedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringSurvivedMemorySize { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl von Bytes ab, die nach der letzten Auflistung noch vorhanden sind und auf die bekanntermaßen von der aktuellen Anwendungsdomäne verwiesen wird.</summary>
        <value>Die Anzahl der noch vorhandenen Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Statistiken werden mit jeder Garbagecollection aktualisiert. Allerdings sind sie unbedingt genau nur nach der eine vollständige blockierende Garbage Collection; Tritt auf, d. h. eine Auflistung, die alle Generationen umfasst, und Beenden der Anwendung während der Auflistung, an. Z. B. die <xref:System.GC.Collect?displayProperty=nameWithType> methodenüberladung führt eine vollständige blockierende Garbage Collection. (Gleichzeitige Auflistung erfolgt im Hintergrund und die Anwendung nicht blockiert.)  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" />-Eigenschaft ist auf <see langword="false" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MonitoringSurvivedProcessMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long MonitoringSurvivedProcessMemorySize { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die gesamten Bytes ab, die nach der letzten Auflistung für alle Anwendungsdomänen im Prozess noch vorhanden sind.</summary>
        <value>Die Gesamtzahl der noch vorhandenen Bytes für den Prozess.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nach einer vollständigen blockierenden Auflistung verwaltet dieser Wert gibt die Anzahl der Bytes im Moment auf live aufrechterhalten Heaps. Es sollte in der Nähe der Anzahl von gemeldet werden die <xref:System.GC.GetTotalMemory%2A> Methode. Nach einer kurzlebigen Auflistung gespeichert dieser Wert gibt die Anzahl der Bytes zurzeit in kurzlebigen Generationen live.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" />-Eigenschaft ist auf <see langword="false" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalAllocatedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringTotalAllocatedMemorySize { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Gesamtgröße in Bytes aller Speicherbelegungen ab, die von der Anwendungsdomäne seit der Erstellung vorgenommen wurden, ohne Subtraktion des freigegebenen Speichers.</summary>
        <value>Die Gesamtgröße aller Speicherbelegungen.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Die <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" />-Eigenschaft ist auf <see langword="false" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MonitoringTotalProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die gesamte Prozessorzeit ab, die von allen Threads bei der Ausführung in der aktuellen Anwendungsdomäne seit Prozessstart genutzt wurde.</summary>
        <value>Gesamte Prozessorzeit für die aktuelle Anwendungsdomäne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Gesamtzeit, die gemeldet wird für eine Anwendungsdomäne umfasst die Ausführungszeit jeder Thread in den Prozess in der Anwendungsdomäne.  
  
 Ein Thread, der nicht verwalteten Code aufruft, ist noch eine Anwendungsdomäne zugeordnet, und der verstrichene Prozessorzeit, die der nicht verwalteten Code für die Anwendungsdomäne gemeldet wird, in dem der Aufruf erfolgte.  
  
 Wenn ein Thread blockiert ist, oder im Ruhezustand, belegt er keine Prozessorzeit.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" />-Eigenschaft ist auf <see langword="false" /> festgelegt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Berechtigungssatz einer Sandbox-Anwendungsdomäne ab.</summary>
        <value>Der Berechtigungssatz der Sandbox-Anwendungsdomäne.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sandbox-Anwendungsdomänen, die erstellt wurden die <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> methodenüberladung haben einen homogenen Satz von Berechtigungen, d. h. der gleiche Satz von Berechtigungen gewährt wird, um alle teilweise vertrauenswürdige Assemblys, die in die Anwendungsdomäne geladen werden. Eine Sandbox-Anwendungsdomäne hat optional eine Liste von Assemblys mit starkem Namen, die diese Berechtigung, und führen stattdessen mit voller Vertrauenswürdigkeit ausgeschlossen sind.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="P:System.AppDomain.IsHomogenous" />
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ProcessExit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProcessExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ProcessExit;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ProcessExit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn der übergeordnete Prozess der Standardanwendungsdomäne beendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.EventHandler> für dieses Ereignis Abschlussaufgaben, z. B. das Schließen von Dateien, ausführen kann Speicherplatz freigeben, bevor der Prozess beendet.  
  
 Ab .NET Framework, Version 2.0, wird dieses Ereignis in jeder Anwendungsdomäne ausgelöst, der einen Ereignishandler registriert.  
  
> [!NOTE]
>  Die Gesamtzeit der Ausführung aller <xref:System.AppDomain.ProcessExit> Ereignishandler ist eingeschränkt, ebenso wie die Gesamtausführungszeit aller Finalizer beim Beenden des Prozesses beschränkt ist. Der Standardwert ist zwei Sekunden. Ein nicht verwalteter Host kann diese Ausführungszeit ändern, durch Aufrufen der [ICLRPolicyManager:: SetTimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md) Methode mit der [OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md) -Enumerationswert.  
  
 In der .NET Framework-Versionen 1.0 und 1.1 bietet dieses Ereignis nur in der Standardanwendungsdomäne ausgelöst, und nur, wenn ein Ereignishandler in der Standardanwendungsdomäne registriert ist.  
  
 Um einen Ereignishandler für dieses Ereignis zu registrieren, benötigen Sie die erforderlichen Berechtigungen, oder ein <xref:System.Security.SecurityException> ausgelöst wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReflectionOnlyAssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ ReflectionOnlyAssemblyResolve;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die Auflösung einer Assembly in dem auf Reflektion beschränkten Kontext fehlschlägt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abhängigkeiten werden in den ReflectionOnly-Kontext nicht automatisch aufgelöst. Sie müssen vorab geladen oder durch den Handler für dieses Ereignis zurückgegeben werden. Dieses Ereignis wird ausgelöst, wenn eine Assembly eine Abhängigkeit verfügt, die nicht bereits in den reflektionsbezogenen Kontext geladen wird. Die fehlende Abhängigkeit wird angegeben, indem die <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> Eigenschaft. Die <xref:System.ResolveEventHandler> für dieses Ereignis muss eine Assembly zurückgeben, die die Abhängigkeit erfüllt. Die Assembly, die zurückgegeben wird, muss in den reflektionsbezogenen Kontext geladen.  
  
> [!IMPORTANT]
>  Dieses Ereignis wird nur für die fehlenden Abhängigkeiten der Assembly, die Sie in den reflektionsbezogenen Kontext geladen werden (z. B. mithilfe der <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> Methode). Es wird nicht ausgelöst, wenn die Assembly, die Sie laden nicht gefunden werden kann.  
  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]die <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> Eigenschaft gibt die Assembly, die das Laden der Assembly angefordert, die nicht aufgelöst werden konnte. Zu wissen, die Identität des anfordernden Assembly ist möglicherweise nützlich, identifizieren die richtige Version der Abhängigkeit, wenn mehrere Versionen verfügbar ist. Weitere Informationen finden Sie unter <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Bei diesem Ereignis die <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> Eigenschaft gibt den Assemblynamen aus, bevor die Richtlinie angewendet wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ReflectionOnlyGetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function ReflectionOnlyGetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Assembly ^&gt; ^ ReflectionOnlyGetAssemblies();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Assemblys zurück, die in den auf Reflektion beschränkten Kontext der Anwendungsdomäne geladen wurden.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.Assembly" />-Objekten, die Assemblys darstellen, die in den auf Reflektion beschränkten Kontext geladen wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt die Assemblys, die in den ReflectionOnly Kontext geladen wurden. Verwenden Sie zum Abrufen der Assemblys, die geladen wurden für die Ausführung der <xref:System.AppDomain.GetAssemblies%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Codebeispiel lädt die Assembly "System.dll" in den Ausführungskontext und dann in den ReflectionOnly Kontext. Die <xref:System.AppDomain.GetAssemblies%2A> und <xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A> Methoden werden verwendet, um die in den jeweiligen Kontext geladenen Assemblys anzuzeigen.  
  
 [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CPP/reflectiononly.cpp#1)]
 [!code-csharp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CS/reflectiononly.cs#1)]
 [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/VB/reflectiononly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Es wurde versucht, eine Operation für eine entladene Anwendungsdomäne auszuführen.</exception>
        <altmember cref="M:System.AppDomain.GetAssemblies" />
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.RelativeSearchPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RelativeSearchPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RelativeSearchPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.RelativeSearchPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Pfad unterhalb des Basisverzeichnisses ab, in dem der Assemblyresolver nach privaten Assemblys suchen soll.</summary>
        <value>Der Pfad unterhalb des Basisverzeichnisses, in dem der Assemblyresolver nach privaten Assemblys suchen soll.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Private Assemblys werden in der gleichen Verzeichnisstruktur, wie die Anwendung bereitgestellt. Wenn der Pfad, wird angegeben die <xref:System.AppDomain.RelativeSearchPath%2A> Eigenschaft ist nicht unter <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>, wird ignoriert.  
  
 Diese Eigenschaft gibt den Wert festgelegt, mit <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für den Zugriff auf die Pfadinformationen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
        <altmember cref="P:System.AppDomainSetup.PrivateBinPath" />
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ResourceResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResourceResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ ResourceResolve;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ResourceResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die Auflösung einer Ressource fehlschlägt, weil die Ressource keine gültige verknüpfte oder eingebettete Ressource in der Assembly ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ResolveEventHandler> für dieses Ereignis versuchen kann, suchen Sie die Assembly mit der Ressource und zurückgeben.  
  
> [!IMPORTANT]
>  Dieses Ereignis wird nicht ausgelöst, wenn die Auflösung fehlschlägt, weil keine Datei für eine gültige verknüpfte Ressource gefunden werden kann. Es wird ausgelöst, wenn ein manifest Ressourcenstream wurde nicht gefunden, aber es wird nicht ausgelöst, wenn ein einzelne Ressourcenschlüssel nicht gefunden werden kann.  
  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]die <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> Eigenschaft enthält die Assembly, die die Ressource angefordert hat. Weitere Informationen finden Sie unter <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Um einen Ereignishandler für dieses Ereignis zu registrieren, benötigen Sie die erforderlichen Berechtigungen, oder ein <xref:System.Security.SecurityException> ausgelöst wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAppDomainPolicy (domainPolicy As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAppDomainPolicy(System::Security::Policy::PolicyLevel ^ domainPolicy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="domainPolicy">Die Sicherheitsrichtlinienebene.</param>
        <summary>Legt die Sicherheitsrichtlinienebene für diese Anwendungsdomäne fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode aufrufen, bevor Sie eine Assembly in geladen ist die <xref:System.AppDomain> in der Reihenfolge für die Sicherheitsrichtlinie Auswirkung hat.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.AppDomain.SetAppDomainPolicy%2A> Methode, um die Sicherheitsrichtlinienebene einer Anwendungsdomäne einzurichten.  
  
 [!code-cpp[ADSetAppDomainPolicy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetAppDomainPolicy/CPP/adsetappdomainpolicy.cpp#1)]
 [!code-csharp[ADSetAppDomainPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetAppDomainPolicy/CS/adsetappdomainpolicy.cs#1)]
 [!code-vb[ADSetAppDomainPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetAppDomainPolicy/VB/adsetappdomainpolicy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domainPolicy" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">Die Sicherheitsrichtlinienebene wurde bereits festgelegt.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetCachePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCachePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetCachePath(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetCachePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der vollqualifizierte Pfad des Speicherortes der Schattenkopie.</param>
        <summary>Legt den angegebenen Verzeichnispfad als Speicherort für gespiegelte Assemblys fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Cachepfad wird ignoriert, wenn die <xref:System.AppDomainSetup.ApplicationName%2A> Eigenschaft nicht festgelegt ist. Siehe <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>-Eigenschaft.  
  
 Weitere Informationen zum Erstellen von Schattenkopien finden Sie unter [von Schattenkopien von Assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Weist einer Anwendungsdomäneneigenschaft einen Wert zu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetData(System::String ^ name, System::Object ^ data);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetData(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Der Name einer zu erstellenden oder zu ändernden benutzerdefinierten Anwendungsdomäneneigenschaft.</param>
        <param name="data">Der Wert der Eigenschaft.</param>
        <summary>Weist der angegebenen Anwendungsdomäneneigenschaft den angegebenen Wert zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit dieser Methode können Sie einen Eintrag einfügen oder ändern Sie den Wert eines Eintrags in einem internen Cache von Name-Daten-Paaren, die Eigenschaften dieser Instanz von beschreiben <xref:System.AppDomain>.  
  
 Der Cache enthält automatisch die vordefinierten Systemdaten-Einträge, die eingefügt werden, wenn die Anwendungsdomäne erstellt wird. Keine einfügen oder Ändern von Systemeinträge mit dieser Methode. Der Aufruf einer Methode, der versucht, einen Eintrag im Dateisystem zu ändern, hat keine Auswirkung. die Methode löst keine Ausnahme. Überprüfen Sie die Werte der Systemeinträge mit der <xref:System.AppDomain.GetData%2A> Methode oder die entsprechende <xref:System.AppDomainSetup> Eigenschaften, die in beschriebenen <xref:System.AppDomain.GetData%2A>.  
  
 Kann, rufen Sie diese Methode zum Festlegen des Werts das standardmäßige Timeoutintervall für die Bewertung von Mustern von regulären Ausdrücken von Netzteils "REGEX_DEFAULT_MATCH_TIMEOUT" als Wert für die `name` Argument und eine <xref:System.TimeSpan> Wert, der das Timeout darstellt. Intervall als Wert für die `data` Argument. Sie können auch einfügen, oder ändern Sie Ihre eigenen benutzerdefinierten Name-Daten-Paare mit dieser Methode, und untersuchen Sie deren Werte mit der <xref:System.AppDomain.GetData%2A> Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29> Methode, um einen neuen Wert-Paar zu erstellen. Anschließend wird die <xref:System.AppDomain.GetData%2A> Methode zum Abrufen des Werts, und wird in der Konsole angezeigt.  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="M:System.AppDomain.GetData(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object, permission As IPermission)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetData(System::String ^ name, System::Object ^ data, System::Security::IPermission ^ permission);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="permission" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="name">Der Name einer zu erstellenden oder zu ändernden benutzerdefinierten Anwendungsdomäneneigenschaft.</param>
        <param name="data">Der Wert der Eigenschaft.</param>
        <param name="permission">Die vom Aufrufer beim Abrufen der Eigenschaft verlangte Berechtigung.</param>
        <summary>Weist der angegebenen Anwendungsdomäneneigenschaft den angegebenen Wert mit einer angegebenen Berechtigung zu, die der Aufrufer beim Abrufen der Eigenschaft besitzen muss.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode zum Einfügen oder bearbeiten Ihre eigenen benutzerdefinierten Einträge in einem internen Cache von Name/Daten-Paare, die Eigenschaften der Anwendungsdomäne beschreiben. Wenn Sie einen Eintrag einfügen, können Sie angeben, eine Berechtigung Anforderung zum erzwingen, wenn der Eintrag abgerufen wird. Darüber hinaus können Sie diese Methode, um das standardmäßige Timeoutintervall für die Bewertung von Mustern von regulären Ausdrücken von Netzteils "REGEX_DEFAULT_MATCH_TIMEOUT" der Wert festgelegt als Wert des Aufrufen der `name` Argument und eine <xref:System.TimeSpan> Wert, der darstellt der Timeoutintervall als Wert für die `data` Argument.  
  
 Diese Methode können Sie eine sicherheitsforderung in eine Zeichenfolge systemdefinierte Eigenschaft zuweisen.  
  
 Der Cache enthält automatisch die vordefinierten Systemdaten-Einträge, die eingefügt werden, wenn die Anwendungsdomäne erstellt wird. Keine einfügen oder Ändern von Systemeinträge mit dieser Methode. Der Aufruf einer Methode, der versucht, einen Eintrag im Dateisystem zu ändern, hat keine Auswirkung. die Methode löst keine Ausnahme. Überprüfen Sie die Werte der Systemeinträge mit der <xref:System.AppDomain.GetData%2A> Methode oder die entsprechende <xref:System.AppDomainSetup> im Abschnitt "Hinweise" beschriebenen Eigenschaften die <xref:System.AppDomain.GetData%2A> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="name" /> gibt eine systemdefinierte Eigenschaftenzeichenfolge an, und <paramref name="permission" /> ist nicht <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetDynamicBase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDynamicBase (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDynamicBase(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der vollqualifizierte Pfad des Basisverzeichnisses, in dem Unterverzeichnisse für die Speicherung dynamischer Assemblys erstellt werden.</param>
        <summary>Legt den angegebenen Verzeichnispfad als das Basisverzeichnis fest, in dem Unterverzeichnisse für die Speicherung und den Zugriff auf dynamisch generierte Dateien erstellt werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode legt die <xref:System.AppDomainSetup.DynamicBase%2A> Eigenschaft des internen <xref:System.AppDomainSetup> dieser Instanz zugeordnet.  
  
   
  
## Examples  
 Diese Methode ist mittlerweile veraltet und sollte nicht für Neuentwicklungen verwendet werden. Im folgende Beispiel wird gezeigt, wie die nicht veraltete Alternative verwenden die <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> Eigenschaft. Eine Erläuterung dieses Beispiels, finden Sie unter der <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> Eigenschaft oder die <xref:System.AppDomain.DynamicDirectory%2A> Eigenschaft.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="P:System.AppDomainSetup.DynamicBase" />
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPrincipalPolicy (policy As PrincipalPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPrincipalPolicy(System::Security::Principal::PrincipalPolicy policy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">Einer der <see cref="T:System.Security.Principal.PrincipalPolicy" />-Werte, die den Typ des Prinzipalobjekts angeben, das an Threads angefügt werden soll.</param>
        <summary>Gibt an, wie Haupt- und Identitätsobjekte an einen Thread angefügt werden sollen, wenn während der Ausführung in dieser Anwendungsdomäne versucht wird, den Thread an einen Prinzipal zu binden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Festlegen dieses Werts werden nur wirksam, wenn Sie es vor der Verwendung Festlegen der <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> Eigenschaft. Z. B., wenn Sie festlegen <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> auf einen bestimmten Prinzipal (z. B. einen generischen Prinzipal) und dann mit der <xref:System.AppDomain.SetPrincipalPolicy%2A> -Methode zum Festlegen der <xref:System.Security.Principal.PrincipalPolicy> auf <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>, der aktuelle Prinzipal bleibt der generischen Prinzipal.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Auswirkung auf Threads der Verwendung der <xref:System.AppDomain.SetPrincipalPolicy%2A> Methode principal Richtlinie der Anwendungsdomäne zu ändern. Außerdem wird gezeigt, die Auswirkung der Verwendung der <xref:System.AppDomain.SetThreadPrincipal%2A> Methode, um den Prinzipal zu ändern, die zum Anfügen an Threads in der Anwendungsdomäne verfügbar ist.  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Fähigkeit zum Bearbeiten des Hauptobjekts. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyFiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetShadowCopyFiles();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aktiviert die Schattenkopiefunktion.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen zu Schattenkopien finden Sie unter [von Schattenkopien von Assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
   
  
## Examples  
 Diese Methode ist mittlerweile veraltet und sollte nicht für Neuentwicklungen verwendet werden.  
  
 [!code-cpp[adproperties#1](~/samples/snippets/cpp/VS_Snippets_CLR/adproperties/CPP/adproperties.cpp#1)]
 [!code-csharp[adproperties#1](~/samples/snippets/csharp/VS_Snippets_CLR/adproperties/CS/adproperties.cs#1)]
 [!code-vb[adproperties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/adproperties/VB/adproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyPath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetShadowCopyPath(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetShadowCopyPath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Eine Liste von Verzeichnisnamen, die durch ein Semikolon voneinander getrennt sind.</param>
        <summary>Legt den angegebenen Verzeichnispfad als Speicherort für zu spiegelnde Assemblys fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig enthält eine Schattenkopie alle Assemblys, die über die Überprüfung. Die <xref:System.AppDomain.SetShadowCopyPath%2A> -Methode beschränkt die Schattenkopie auf die Assemblys in den Verzeichnissen, die vom angegebenen `path`.  
  
 Die <xref:System.AppDomain.SetShadowCopyPath%2A> Methode gibt keinen Weitere Verzeichnisse nach Assemblys gesucht werden soll. Assemblys werden Schattenkopie müssen bereits in den Suchpfad, z. B. unter befinden <xref:System.AppDomain.BaseDirectory%2A>. Die <xref:System.AppDomain.SetShadowCopyPath%2A> Methode gibt an, welche Suchpfade Schattenkopien möglich sind.  
  
 Diese Methode legt die <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> Eigenschaft des internen <xref:System.AppDomainSetup> dieser Instanz zugeordnet.  
  
 Weitere Informationen zu Schattenkopien finden Sie unter [von Schattenkopien von Assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
   
  
## Examples  
 Diese Methode ist mittlerweile veraltet und sollte nicht für Neuentwicklungen verwendet werden.  
  
 [!code-cpp[ADShadowCopy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADShadowCopy/CPP/adshadowcopy.cpp#1)]
 [!code-csharp[ADShadowCopy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADShadowCopy/CS/adshadowcopy.cs#1)]
 [!code-vb[ADShadowCopy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADShadowCopy/VB/adshadowcopy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetThreadPrincipal (principal As IPrincipal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetThreadPrincipal(System::Security::Principal::IPrincipal ^ principal);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <param name="principal">Das Prinzipalobjekt, das an Threads angefügt werden soll.</param>
        <summary>Legt das Standardprinzipalobjekt fest, das an Threads angefügt wird, wenn bei der Ausführung in dieser Anwendungsdomäne versucht wird, diese an einen Prinzipal zu binden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Beispiel zeigt die Auswirkung der Verwendung der <xref:System.AppDomain.SetThreadPrincipal%2A> Methode, um den Prinzipal zu ändern, der zum Anfügen an Threads, die in der Anwendungsdomäne ausgeführt werden, verfügbar ist. Darüber hinaus wird gezeigt, die Auswirkungen auf Threads der Verwendung der <xref:System.AppDomain.SetPrincipalPolicy%2A> Methode principal Richtlinie der Anwendungsdomäne zu ändern.  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="principal" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">Der Principal des Threads wurde bereits festgelegt.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Fähigkeit zum Bearbeiten des Hauptobjekts. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.SetupInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SetupInformation As AppDomainSetup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainSetup ^ SetupInformation { AppDomainSetup ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Konfigurationsinformationen der Anwendungsdomäne für diese Instanz ab.</summary>
        <value>Die Initialisierungsinformationen für die Anwendungsdomäne.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShadowCopyFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShadowCopyFiles { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob die Anwendungsdomäne für das Erstellen von Dateischattenkopien konfiguriert ist.</summary>
        <value>
          <see langword="true" />, wenn in der Anwendungsdomäne Dateischattenkopien erstellt werden, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Weitere Informationen finden Sie unter <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> und [von Schattenkopien von Assemblys](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Der Vorgang wird für eine entladene Anwendungsdomäne ausgeführt.</exception>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AppDomain.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = _AppDomain::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Für zukünftige Verwendung reserviert. Muss IID_NULL sein.</param>
        <param name="rgszNames">Das übergebene Array von zuzuordnenden Namen.</param>
        <param name="cNames">Die Anzahl der zuzuordnenden Namen.</param>
        <param name="lcid">Der Gebietsschemakontext, in dem die Namen interpretiert werden sollen.</param>
        <param name="rgDispId">Das vom Aufrufer zugewiesene Array, das die IDs entsprechend den Namen empfängt.</param>
        <summary>Ordnet eine Reihe von Namen einer entsprechenden Reihe von Dispatchbezeichnern zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetIDsOfNames`, finden Sie in der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AppDomain.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = _AppDomain::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Die zurückzugebenden Typinformationen.</param>
        <param name="lcid">Der Gebietsschemabezeichner für die Typinformationen.</param>
        <param name="ppTInfo">Empfängt einen Zeiger auf das angeforderte Objekt mit den Typinformationen.</param>
        <summary>Ruft die Typinformationen für ein Objekt ab, die dann zum Abrufen der Typinformationen für eine Schnittstelle verwendet werden können.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetTypeInfo`, finden Sie in der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AppDomain.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = _AppDomain::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Zeigt auf einen Speicherort, der die Anzahl der Schnittstellen mit Typinformationen empfängt, die vom Objekt bereitgestellt werden.</param>
        <summary>Ruft die Anzahl der Schnittstellen mit Typinformationen ab, die von einem Objekt bereitgestellt werden (0 oder 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetTypeInfoCount`, finden Sie in der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AppDomain.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = _AppDomain::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Bezeichnet den Member.</param>
        <param name="riid">Für zukünftige Verwendung reserviert. Muss IID_NULL sein.</param>
        <param name="lcid">Der Gebietsschemakontext, in dem Argumente interpretiert werden sollen.</param>
        <param name="wFlags">Flags, die den Kontext des Aufrufs beschreiben.</param>
        <param name="pDispParams">Ein Zeiger auf eine Struktur, die ein Array von Argumenten und ein Array von Argument-DISPIDs für benannte Argumente sowie Zähler für die Anzahl der Elemente in jedem Array enthält.</param>
        <param name="pVarResult">Ein Verweis auf den Speicherort, an dem das Ergebnis gespeichert werden soll.</param>
        <param name="pExcepInfo">Ein Zeiger auf eine Struktur mit Ausnahmeinformationen.</param>
        <param name="puArgErr">Der Index des ersten Arguments mit einem Fehler.</param>
        <summary>Stellt den Zugriff auf von einem Objekt verfügbar gemachte Eigenschaften und Methoden bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::Invoke`, finden Sie in der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft eine Zeichenfolgendarstellung ab, die den angezeigten Namen der Anwendungsdomäne und aller Kontextrichtlinien einschließt.</summary>
        <returns>Eine durch Verketten der literalen Zeichenfolge "Name:", dem angezeigten Namen der Anwendungsdomäne und entweder Zeichenfolgendarstellungen der Kontextrichtlinien oder der Zeichenfolge "Keine Kontextrichtlinien vorhanden" gebildete Zeichenfolge.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel zeigt den Rückgabewert der <xref:System.AppDomain.ToString%2A> Methode.  
  
 [!code-cpp[ADToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADToString/CPP/adtostring.cpp#1)]
 [!code-csharp[ADToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADToString/CS/adtostring.cs#1)]
 [!code-vb[ADToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADToString/VB/adtostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Die durch die aktuelle <see cref="T:System.AppDomain" /> dargestellte Anwendungsdomäne wurde entladen.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.TypeResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TypeResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ TypeResolve;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.TypeResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt ein, wenn die Auflösung eines Typs fehlschlägt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.AppDomain.TypeResolve> Ereignis tritt auf, wenn die common Language Runtime ist nicht die Assembly zu ermitteln, die den angeforderten Typ erstellen können. Dies kann auftreten, wenn der Typ in einer dynamischen Assembly definiert ist, oder der Typ nicht in einer dynamischen Assembly definiert ist, aber die Common Language Runtime weiß nicht, welche Assembly in der Typ definiert ist. Die zweite Situation kann auftreten, wenn <xref:System.Type.GetType%2A?displayProperty=nameWithType> aufgerufen wird und ein Typname, der nicht qualifiziert wird mit dem Assemblynamen angeben.  
  
 Die <xref:System.ResolveEventHandler> für dieses Ereignis versuchen kann, zu suchen, und erstellen Sie den Typ.  
  
 Allerdings die <xref:System.AppDomain.TypeResolve> Ereignis tritt nicht auf, wenn die Common Language Runtime weiß, es ist nicht möglich, einen Typ in bestimmten Assemblys zu suchen. Dieses Ereignis beispielsweise nicht ausgeführt, wenn der Typ nicht in einer statischen Assembly gefunden wird, da die Common Language Runtime weiß, dass Typen dynamisch statische Assemblys hinzugefügt werden können.  
  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]die <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> Eigenschaft enthält die Assembly, die den Typ angefordert hat. Weitere Informationen finden Sie unter <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Um einen Ereignishandler für dieses Ereignis zu registrieren, benötigen Sie die erforderlichen Berechtigungen, oder ein <xref:System.Security.SecurityException> ausgelöst wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.AppDomain.TypeResolve> Ereignis.  
  
 Für dieses Codebeispiel ausführen müssen Sie den vollqualifizierten Assemblynamen bereitstellen. Informationen zur Vorgehensweise zum Abrufen der vollqualifizierte Assemblyname finden Sie unter [Assemblynamen](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_TypeResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_TypeResolve/CPP/typeresolve.cpp#1)]
 [!code-csharp[AppDomain_TypeResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_TypeResolve/CS/typeresolve.cs#1)]
 [!code-vb[AppDomain_TypeResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_TypeResolve/VB/typeresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledException As UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event UnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.UnhandledException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Tritt auf, wenn eine Ausnahme nicht abgefangen wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Ereignis stellt eine Benachrichtigung nicht abgefangene Ausnahmen bereit. Er kann die Anwendung Informationen über die Ausnahme melden, bevor der Standardhandler System die Ausnahme an den Benutzer meldet und die Anwendung beendet. Wenn genügend Informationen über den Zustand der Anwendung verfügbar ist, können andere Aktionen durchgeführt werden – z. B. Speichern von Daten für eine spätere Wiederherstellung aus dem Programm. Vorsicht ist geboten, da es sich bei Programmdaten beschädigt werden können, wenn Ausnahmen nicht behandelt werden.  
  
> [!NOTE]
>  In der .NET Framework-Versionen 1.0 und 1.1 werden Beendigung der Anwendung und Debuggen von Optionen für den Benutzer gemeldet vor dem dieses Ereignis ausgelöst wird, statt nach.  
  
 Dieses Ereignis kann in jeder Anwendungsdomäne behandelt werden. Das Ereignis wird jedoch nicht unbedingt in der Anwendungsdomäne ausgelöst, in dem die Ausnahme aufgetreten ist. Eine Ausnahme wird nicht behandelt, nur dann, wenn der gesamte Stapel des Threads entladen wurde ohne einen entsprechenden Ausnahmehandler gefunden, daher ist der erste Ort, der das Ereignis ausgelöst werden kann in der Anwendungsdomäne, von dem der Thread stammt.  
  
> [!NOTE]
>  Dieses Ereignis tritt in der .NET Framework-Versionen 1.0 und 1.1 nur für die Standardanwendungsdomäne, die vom System erstellt wird, wenn eine Anwendung gestartet wird. Wenn eine Anwendung zusätzliche Anwendungsdomänen erstellt, ist das gibt dabei einen Delegaten für dieses Ereignis in diesen Anwendungsdomänen wirkungslos.  
  
 Wenn die <xref:System.AppDomain.UnhandledException> Ereignis in der Standardanwendungsdomäne behandelt wird, wird es ausgelöst gibt es für eine Ausnahme in einen beliebigen Thread, unabhängig davon, welche Anwendungsdomäne den Thread gestartet nicht behandelt. Wenn der Thread in einer Anwendungsdomäne gestartet, der einen Ereignishandler für <xref:System.AppDomain.UnhandledException>, das Ereignis wird ausgelöst, in der Anwendungsdomäne. Wenn diese Anwendungsdomäne die Standardanwendungsdomäne ist, und in die Standardanwendungsdomäne auch ein Ereignishandler ist, wird das Ereignis in beide Anwendungsdomänen ausgelöst.  
  
 Beispielsweise angenommen, ein Thread startet in Anwendungsdomäne "AD1", ruft eine Methode in der Anwendungsdomäne "AD2" und von dort aus Ruft eine Methode in der Anwendungsdomäne "AD3", wobei wird eine Ausnahme ausgelöst. Die erste Anwendungsdomäne, in dem die <xref:System.AppDomain.UnhandledException> -Ereignis ausgelöst werden kann, ist "AD1". Wenn diese Anwendungsdomäne nicht die Standardanwendungsdomäne ist, kann das Ereignis auch in der Standardanwendungsdomäne ausgelöst werden.  
  
> [!NOTE]
>  Die common Language Runtime anhält, Threadabbrüche während Ereignishandler für das <xref:System.AppDomain.UnhandledException> Ereignis ausgeführt werden.  
  
 Wenn der Ereignishandler verfügt über eine <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> Attribut mit den geeigneten Flags wird der Ereignishandler als einem eingeschränkten Ausführungsbereich behandelt.  
  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], dieses Ereignis wird nicht ausgelöst, für die Ausnahmen, die den Status des Prozesses beschädigt, z. B. Stapelüberläufe oder zugriffsverletzungen, wenn der Ereignishandler als sicherheitskritisch wird und die <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> Attribut.  
  
 In der .NET Framework-Versionen 1.0 und 1.1 eine nicht behandelte Ausnahme, die in einem anderen Thread als Thread der hauptanwendung auftritt, wird von der Laufzeit abgefangen und aus diesem Grund führt nicht dazu, dass das Beenden der Anwendung. Daher ist es möglich, dass die <xref:System.AppDomain.UnhandledException> Ereignisses ohne die Anwendung beendet werden. Beginnend mit .NET Framework, Version 2.0, wurde diese Abfangfunktion für nicht behandelte Ausnahmen in untergeordneten Threads entfernt werden, da es sich bei der kumulierte Auswirkung solche automatische Fehler enthalten, Leistungseinbußen, beschädigte Daten und Abstürze, die schwer zu wurden, Debuggen. Weitere Informationen, einschließlich einer Liste von Fällen, in denen die Common Language Runtime nicht beendet wird, finden Sie unter [Ausnahmen in verwalteten Threads](~/docs/standard/threading/exceptions-in-managed-threads.md).  
  
 Um einen Ereignishandler für dieses Ereignis zu registrieren, benötigen Sie die erforderlichen Berechtigungen, oder ein <xref:System.Security.SecurityException> ausgelöst wird.  
  
 Weitere Informationen zur Behandlung von Ereignissen finden Sie unter [behandeln und Auslösen von Ereignissen](~/docs/standard/events/index.md).  
  
## <a name="other-events-for-unhandled-exceptions"></a>Andere Ereignisse für nicht behandelte Ausnahmen  
 Für bestimmte Anwendungsmodelle der <xref:System.AppDomain.UnhandledException> Ereignis kann andere Ereignisse unterbrochen werden, wenn im Thread hauptanwendung die nicht behandelte Ausnahme auftritt.  
  
 In Anwendungen, Windows Forms verwenden, nicht behandelte Ausnahmen in der hauptanwendung Thread Ursache der <xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType> Ereignis ausgelöst wurde. Wenn dieses Ereignis behandelt wird, ist das Standardverhalten, dass die Anwendung nicht in die nicht behandelte Ausnahme beendet wird, obwohl die Anwendung in einem unbekannten Zustand verbleibt. In diesem Fall die <xref:System.AppDomain.UnhandledException> Ereignis wird nicht ausgelöst. Dieses Verhalten kann geändert werden, mithilfe der Anwendungskonfigurationsdatei oder mit der <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType> Methode, um den Modus ändern <xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType> vor der <xref:System.Windows.Forms.Application.ThreadException> Ereignishandler verknüpft ist. Dies gilt nur für den Thread der hauptanwendung. Die <xref:System.AppDomain.UnhandledException> Ereignis wird für nicht behandelte Ausnahmen in anderen Threads.  
  
 Ab Microsoft Visual Studio 2005 stellt das Visual Basic-Anwendungsframework ein anderes Ereignis für nicht behandelte Ausnahmen in Thread der hauptanwendung bereit. Finden Sie unter der <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType> Ereignis. Dieses Ereignis verfügt über ein Ereignis Arguments-Objekt mit dem gleichen Namen wie das Ereignisargumentobjekt, die verwendet werden, indem <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>, jedoch mit anderen Eigenschaften. Insbesondere dieser Ereignis-Arguments-Objekt verfügt über eine <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> Clustereigenschaft, mit der die Anwendung weiterhin ausgeführt wird, wird ignoriert, die nicht behandelte Ausnahme (und die Anwendung in einem unbekannten Zustand verlassen). In diesem Fall die <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> Ereignis wird nicht ausgelöst.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.AppDomain.UnhandledException> Ereignis. Definiert einen Ereignishandler `MyHandler`, die aufgerufen wird, wenn eine nicht behandelte Ausnahme, in der Standardanwendungsdomäne ausgelöst wird. Es wird dann zwei Ausnahmen ausgelöst. Die erste erfolgt durch eine **Try/Catch-** Block. Der zweite nicht behandelt wird, und ruft die `MyHandle` Routine, bevor die Anwendung beendet wird.  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Unload(System.AppDomain)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unload (domain As AppDomain)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unload(AppDomain ^ domain);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <param name="domain">Eine zu entladende Anwendungsdomäne.</param>
        <summary>Entlädt die angegebene Anwendungsdomäne.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .NET Framework, Version 2.0 ist ein Thread für das Entladen von Anwendungsdomänen. Dies verbessert die Zuverlässigkeit, insbesondere, wenn .NET Framework gehostet wird. Wenn ein Thread aufruft, <xref:System.AppDomain.Unload%2A>, die Zieldomäne für das Entladen markiert ist. Der dedizierte Thread versucht, die Domäne zu entladen, und alle Threads in der Domäne werden abgebrochen. Wenn ein Thread nicht, z. B. abgebrochen wird, weil er nicht verwalteten Code ausgeführt wird, oder weil es ausgeführt wird eine `finally` Block, klicken Sie dann nach einer Zeitperiode eine <xref:System.CannotUnloadAppDomainException> wird ausgelöst, in dem Thread, der ursprünglich aufgerufen <xref:System.AppDomain.Unload%2A>. Nach Beendigung des Threads, die letztendlich nicht abgebrochen werden konnte, ist die Zieldomäne nicht entladen. Folglich in .NET Framework, Version 2.0 `domain` wird nicht entladen wird, garantiert, da es möglicherweise nicht möglich, die Ausführung von Threads zu beenden.  
  
> [!NOTE]
>  In einigen Fällen Aufrufen <xref:System.AppDomain.Unload%2A> bewirkt eine sofortige <xref:System.CannotUnloadAppDomainException>, z. B. Wenn sie in einer Finalize-Methode aufgerufen wird.  
  
 Threads in `domain` werden beendet, mit der <xref:System.Threading.Thread.Abort%2A> -Methode, die löst eine <xref:System.Threading.ThreadAbortException> im Thread. Obwohl der Thread umgehend beendet werden soll, weiterhin ausgeführt wird, unvorhersehbar Zeit in einem `finally` Klausel.  
  
## <a name="version-compatibility"></a>Versionskompatibilität  
 In .NET Framework, Version 1.0 und 1.1, wenn der Thread aufruft <xref:System.AppDomain.Unload%2A> läuft in `domain`, ein anderer Thread zum Ausführen des Entladevorgangs gestartet wird. Wenn `domain` kann nicht entladen werden kann, eine <xref:System.CannotUnloadAppDomainException> wird ausgelöst, in diesem Thread nicht im ursprünglichen Thread, die aufgerufen <xref:System.AppDomain.Unload%2A>. Jedoch, wenn der Thread aufruft <xref:System.AppDomain.Unload%2A> ausgeführt wird, außerhalb `domain`, dass der Thread die Ausnahme empfangen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie eine Anwendungsdomäne entladen wird.  
  
 [!code-cpp[ADUnload#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADUnload/CPP/adunload.cpp#1)]
 [!code-csharp[ADUnload#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADUnload/CS/adunload.cs#1)]
 [!code-vb[ADUnload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADUnload/VB/adunload.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.CannotUnloadAppDomainException">
          <paramref name="domain" /> konnte nicht entladen werden.</exception>
        <exception cref="T:System.Exception">Während des Entladeprozesses ist ein Fehler aufgetreten.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Um einen Ereignishandler für dieses Ereignis hinzuzufügen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" /> Sicherheitsaktion: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
  </Members>
</Type>