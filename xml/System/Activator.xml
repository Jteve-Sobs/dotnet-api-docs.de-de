<Type Name="Activator" FullName="System.Activator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a912c36148a235cad7f0213e4ea2fe09d1b2b8fa" />
    <Meta Name="ms.sourcegitcommit" Value="6ee2e6b2c5d7c5bd66feeb362d29e65fdf858836" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/15/2018" />
    <Meta Name="ms.locfileid" Value="51691559" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Activator : System.Runtime.InteropServices._Activator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Activator extends System.Object implements class System.Runtime.InteropServices._Activator" />
  <TypeSignature Language="DocId" Value="T:System.Activator" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Activator&#xA;Implements _Activator" />
  <TypeSignature Language="C++ CLI" Value="public ref class Activator sealed : System::Runtime::InteropServices::_Activator" />
  <TypeSignature Language="F#" Value="type Activator = class&#xA;    interface _Activator" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Activator</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Activator))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Enthält Methoden, mit denen Objekttypen lokal oder remote erstellt und Verweise auf vorhandene Remoteobjekte abgerufen werden können. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Activator.CreateInstance%2A> Methode erstellt eine Instanz eines Typs durch Aufrufen der am besten übereinstimmende Konstruktor in einer Assembly definiert den angegebenen Argumenten. Wenn keine Argumente angegeben werden, wird der Konstruktor, der keine Parameter, d. h. den Standard-Konstruktor akzeptiert, aufgerufen.  
  
 Sie müssen über ausreichende Berechtigungen zum Suchen und einen Konstruktor aufrufen; Andernfalls wird eine Ausnahme ausgelöst. Standardmäßig gelten nur die öffentliche Konstruktoren bei der Suche nach einem Konstruktor. Wenn kein Konstruktor oder die Standard-Konstruktor gefunden werden kann, wird eine Ausnahme ausgelöst.  
  
 Ein Binderparameter gibt an, ein Objekt, das eine Assembly für die kein geeigneter Konstruktor durchsucht wird. Sie können Ihre eigenen Binder und Kriterien angeben. Wenn kein Binder angegeben wird, wird der Standardbinder verwendet. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Reflection.Binder?displayProperty=nameWithType>-Klasse und zur <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>-Klasse.  
  
 Ein Evidence-Parameter wirkt sich auf die Sicherheitsrichtlinie und die Berechtigungen für den Konstruktor. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Security.Policy.Evidence?displayProperty=nameWithType>-Klasse.  
  
 Eine Instanz eines Typs kann an einem lokalen oder entfernten Standort erstellt werden. Wenn der Typ Remote erstellt wird, gibt ein Aktivierungsattribut-Parameter der URI des remote-standortsystemserver an. Der Aufruf zum Erstellen der Instanz kann Standorte dazwischen durchlaufen, bevor sie die remote-standortsystemserver erreicht. Die Umgebung oder der Kontext, in dem der Aufruf an den Vermittler und remote-Standorten ausgeführt wird, können andere Aktivierungsattribute ändern.  
  
 Wenn die Instanz lokal erstellt wird, wird ein Verweis auf dieses Objekt zurückgegeben. Wenn die Instanz Remote erstellt wird, wird ein Verweis auf einen Proxy zurückgegeben. Das Remoteobjekt bearbeitet wird über den Proxy, als handele es sich um ein lokales Objekt.  
  
 Die <xref:System.Activator.GetObject%2A> Methode erstellt einen Proxy für einen aktuell ausgeführten Remoteobjekt, bekannte vom Server aktivierten Objekt oder XML-Webdienst. Sie können das Verbindungsmedium, d. h. den Kanal angeben. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Runtime.Remoting.Channels.ChannelServices?displayProperty=nameWithType>-Klasse.  
  
 Assemblys enthalten Definitionen. Die <xref:System.Activator.CreateInstance%2A> Methode erstellt eine Instanz eines Typs aus einer aktuell ausgeführten Assembly. Die <xref:System.Activator.CreateInstanceFrom%2A> Methode erstellt eine Instanz aus einer Datei, die eine Assembly enthält. Die <xref:System.Activator.CreateComInstanceFrom%2A> Methode erstellt eine Instanz eines COM-Objekts aus einer Datei, die eine Assembly enthält.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mit der <xref:System.Activator> Klasse, um Objekte zur Laufzeit dynamisch zu erstellen.  
  
 [!code-cpp[ActivatorX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/ActivatorX.cpp#1)]
 [!code-csharp[ActivatorX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/ActivatorX.cs#1)]
 [!code-vb[ActivatorX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/ActivatorX.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine Instanz des COM-Objekts, dessen Name angegeben wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Name einer Datei, die eine Assembly enthält, in der der Typ mit dem Namen <paramref name="typeName" /> gesucht wird.</param>
        <param name="typeName">Der Name des bevorzugten Typs.</param>
        <summary>Erstellt eine Instanz des COM-Objekts mit dem angegebenen Namen unter Verwendung der angegebenen Assemblydatei und des Standardkonstruktors.</summary>
        <returns>Ein Handle, das für den Zugriff auf die neu erstellte Instanz entwrappt werden muss.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> Methode, um den Rückgabewert zu entpacken.  
  
 Ein <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> Attribut mit einem Wert von `true` müssen entweder explizit oder standardmäßig angewendet werden, die COM-Typ daher <xref:System.Activator.CreateComInstanceFrom%2A> -Methode können Sie eine Instanz dieses Typs erstellen, andernfalls <xref:System.TypeLoadException> ausgelöst.  
  
 Informationen zu anderen Ausnahmen, die von aufgerufenen Methoden ausgelöst werden können, finden Sie im Abschnitt "Ausnahmen" von der <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> und <xref:System.Activator.CreateInstance%2A> Methoden.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, um nicht öffentliche Typen zu erstellen, wenn der Aufrufer erteilt wurde, <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flag und der Berechtigungssatz der Assembly, die den nicht öffentlichen Typen des Aufrufers GRANT beschränkt ist Festlegen oder eine Teilmenge davon. (Finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> oder <paramref name="assemblyName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Eine Instanz kann nicht durch COM erstellt werden.  
  
- oder -  
 <paramref name="typename" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender Konstruktor gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden, oder das Modul, das Sie laden möchten, gibt keine Dateinamenerweiterung an.</exception>
        <exception cref="T:System.MemberAccessException">Es können keine Instanzen von abstrakten Klassen erstellt werden.  
  
- oder -  
Dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> ist die leere Zeichenfolge ("").</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für den Zugriff auf nicht öffentliche Typen unabhängig von deren Berechtigungssatz. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateComInstanceFrom (assemblyName As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateComInstanceFrom (assemblyName, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Name einer Datei, die eine Assembly enthält, in der der Typ mit dem Namen <paramref name="typeName" /> gesucht wird.</param>
        <param name="typeName">Der Name des bevorzugten Typs.</param>
        <param name="hashValue">Der Wert des errechneten Hashcodes.</param>
        <param name="hashAlgorithm">Der Hashalgorithmus für das Hashing von Dateien und das Generieren des starken Namens.</param>
        <summary>Erstellt eine Instanz des COM-Objekts mit dem angegebenen Namen unter Verwendung der angegebenen Assemblydatei und des Standardkonstruktors.</summary>
        <returns>Ein Handle, das für den Zugriff auf die neu erstellte Instanz entwrappt werden muss.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> Methode, um den Rückgabewert zu entpacken.  
  
 Ein <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> Attribut mit einem Wert von `true` müssen entweder explizit oder standardmäßig angewendet werden, die COM-Typ daher <xref:System.Activator.CreateComInstanceFrom%2A> -Methode können Sie eine Instanz dieses Typs erstellen, andernfalls <xref:System.TypeLoadException> ausgelöst.  
  
 Informationen zu anderen Ausnahmen, die von aufgerufenen Methoden ausgelöst werden können, finden Sie im Abschnitt "Ausnahmen" von der <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> und <xref:System.Activator.CreateInstance%2A> Methoden.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, um nicht öffentliche Typen zu erstellen, wenn der Aufrufer erteilt wurde, <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flag und der Berechtigungssatz der Assembly, die den nicht öffentlichen Typen des Aufrufers GRANT beschränkt ist Festlegen oder eine Teilmenge davon. (Finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> oder <paramref name="assemblyName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyName" /> ist die leere Zeichenfolge ("").</exception>
        <exception cref="T:System.IO.PathTooLongException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.
        
- oder -  
 <paramref name="assemblyName" /> übersteigt die vom System definierte Höchstlänge.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden, oder das Modul, das Sie laden möchten, gibt keine Dateinamenerweiterung an.</exception>
        <exception cref="T:System.IO.FileLoadException">
          <paramref name="assemblyName" /> wurde gefunden, kann aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.</exception>
        <exception cref="T:System.Security.SecurityException">Eine Codebasis, die nicht mit „file://“ beginnt, wurde ohne die erforderliche <see langword="WebPermission" /> angegeben.</exception>
        <exception cref="T:System.TypeLoadException">Eine Instanz kann nicht durch COM erstellt werden.  
  
- oder -  
 <paramref name="typename" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender Konstruktor gefunden.</exception>
        <exception cref="T:System.MemberAccessException">Es kann keine Instanz einer abstrakten Klasse erstellt werden.  
  
- oder -  
Dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <exception cref="T:System.NotSupportedException">Der Aufrufer kann keine Aktivierungsattribute für ein Objekt bereitstellen, das nicht von <see cref="T:System.MarshalByRefObject" /> erbt.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für den Zugriff auf nicht öffentliche Typen unabhängig von deren Berechtigungssatz. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für das Lesen von eines URIS, der mit "file://" beginnt. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">für das Lesen von eines URIS, der nicht mit "file://" beginnt.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt mit dem am besten mit den angegebenen Parametern übereinstimmenden Konstruktor eine Instanz des angegebenen Typs.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (ActivationContext activationContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.ActivationContext activationContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.ActivationContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(ActivationContext ^ activationContext);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : ActivationContext -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance activationContext" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
      </Parameters>
      <Docs>
        <param name="activationContext">Ein Aktivierungskontextobjekt, das das zu erstellende Objekt angibt.</param>
        <summary>Erstellt eine Instanz des Typs, der vom angegebenen <see cref="T:System.ActivationContext" />-Objekt festgelegt wurde.</summary>
        <returns>Ein Handle, das für den Zugriff auf das neu erstellte Objekt entwrappt werden muss.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> Methode, um den Rückgabewert zu entpacken.  
  
 Der Aktivierungskontext wird während der manifestbasierten Aktivierung, um die Domänenrichtlinie einzurichten und zu einer Anwendung basierendes Sicherheitsmodell verwendet. Die <xref:System.ActivationContext> -Klasse enthält eine <xref:System.ApplicationIdentity> -Objekt, das Zugriff auf das Anwendungsmanifest bietet. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Security.Policy.ApplicationSecurityManager>-Klasse.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ActivationContext" />
        <altmember cref="T:System.ApplicationIdentity" />
        <altmember cref="T:System.Security.Policy.ApplicationSecurityManager" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type -&gt; obj" Usage="System.Activator.CreateInstance type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des zu erstellenden Objekts.</param>
        <summary>Erstellt mit dem Standardkonstruktor dieses Typs eine Instanz des angegebenen Typs.</summary>
        <returns>Ein Verweis auf das neu erstellte Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Konstruktor aufgerufen werden, muss zugänglich sein.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, um Zugriff auf nicht öffentliche Typen, wenn der Aufrufer erteilt wurde, <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flag und der Berechtigungssatz der Assembly, die den nicht öffentlichen Typen des Aufrufers GRANT beschränkt ist Festlegen oder eine Teilmenge davon. (Finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Aufrufen der <xref:System.Activator.CreateInstance%28System.Type%29> Methode. Instanzen mit unterschiedlichen Typen werden erstellt, und ihre Standardwerte angezeigt.  
  
 [!code-cpp[ActivatorX#4](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/source2.cpp#4)]
 [!code-csharp[ActivatorX#4](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/source2.cs#4)]
 [!code-vb[ActivatorX#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/source2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> ist keine <see langword="RuntimeType" />.  
  
- oder -  
 <paramref name="type" /> ist ein offener generischer Typ (die <see cref="P:System.Type.ContainsGenericParameters" />-Eigenschaft gibt folglich <see langword="true" /> zurück).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> darf nicht <see cref="T:System.Reflection.Emit.TypeBuilder" /> sein.  
  
- oder -  
Die Erstellung der Typen <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> und <see cref="T:System.RuntimeArgumentHandle" /> bzw. von Arrays dieser Typen wird nicht unterstützt.  
  
- oder -  
Die Assembly mit <paramref name="type" /> ist eine dynamische Assembly, die mit <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" /> erstellt wurde.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Das Aufrufen des Konstruktors löst eine Ausnahme aus.</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para>  
 Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.MemberAccessException" /> ab.  
  
</para>
          </block>  
  
 Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MemberAccessException">Eine Instanz einer abstrakten Klasse kann nicht erstellt werden, oder dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Der COM-Typ wurde nicht über <see cref="Overload:System.Type.GetTypeFromProgID" /> oder <see cref="Overload:System.Type.GetTypeFromCLSID" /> abgerufen.</exception>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para>  
 Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.MissingMemberException" /> ab.  
  
</para>
          </block>  
  
 Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> ist ein COM-Objekt, aber der Klassenbezeichner zum Abrufen des Typs ist ungültig , oder die bezeichnete Klasse wurde nicht registriert.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> ist kein gültiger Typ.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Möglichkeit, die nicht verwalteten Code aufrufen, wenn Sie eine Instanz eines Delegaten zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">Legt fest, für den Zugriff auf nicht öffentliche Typen unabhängig von deren Berechtigungssatz. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (ActivationContext activationContext, string[] activationCustomData);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.ActivationContext activationContext, string[] activationCustomData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.ActivationContext,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(ActivationContext ^ activationContext, cli::array &lt;System::String ^&gt; ^ activationCustomData);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : ActivationContext * string[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (activationContext, activationCustomData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activationContext" Type="System.ActivationContext" />
        <Parameter Name="activationCustomData" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="activationContext">Ein Aktivierungskontextobjekt, das das zu erstellende Objekt angibt.</param>
        <param name="activationCustomData">Ein Array von Unicode-Zeichenfolgen mit benutzerdefinierten Aktivierungsdaten.</param>
        <summary>Erstellt eine Instanz des Typs, der vom angegebenen <see cref="T:System.ActivationContext" />-Objekt festgelegt und mit den angegebenen benutzerdefinierten Aktivierungsdaten aktiviert wird.</summary>
        <returns>Ein Handle, das für den Zugriff auf das neu erstellte Objekt entwrappt werden muss.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> Methode, um den Rückgabewert zu entpacken.  
  
 Der Aktivierungskontext wird während der manifestbasierten Aktivierung, um die Domänenrichtlinie einzurichten und zu einer Anwendung basierendes Sicherheitsmodell verwendet. Die <xref:System.ActivationContext> -Klasse enthält eine <xref:System.ApplicationIdentity> -Objekt, das Zugriff auf das Anwendungsmanifest bietet. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Security.Policy.ApplicationSecurityManager>-Klasse.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ActivationContext" />
        <altmember cref="T:System.ApplicationIdentity" />
        <altmember cref="T:System.Security.Policy.ApplicationSecurityManager" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Name der Assembly, in der der Typ mit dem Namen <paramref name="typeName" /> gesucht wird. Wenn <paramref name="assemblyName" /><see langword="null" /> ist, wird die derzeit ausgeführte Assembly durchsucht.</param>
        <param name="typeName">Der vollqualifizierte Name des bevorzugten Typs.</param>
        <summary>Erstellt eine Instanz des Typs mit dem angegebenen Namen unter Verwendung der angegebenen Assembly und des Standardkonstruktors.</summary>
        <returns>Ein Handle, das für den Zugriff auf die neu erstellte Instanz entwrappt werden muss.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> den Rückgabewert zu entpacken.  
  
 `assemblyName` Dabei kann es sich um eine der folgenden sein:  
  
-   Der einfache Name, der eine Assembly ohne Dateierweiterung Pfad- oder Dateiname. Beispielsweise würden Sie angeben `TypeExtensions` für eine Assembly, deren Pfad und Namen.\bin\TypeExtensions.dll werden.  
  
-   Der vollständige Name einer signierten Assembly, die aus der einfache Name, Version, Kultur und Token des öffentlichen Schlüssels besteht; z. B. "TypeExtensions, Version = 1.0.0.0, Culture = Neutral, PublicKeyToken = 181869f2f7435b51".  
  
 Weitere Informationen wie die common Language Runtime identifiziert und lädt Assemblys finden Sie unter [How the Runtime Locates Assemblies](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md). Weitere Informationen zur Verwendung der Konfigurationsdatei der Speicherorte von Assemblys zu definieren, finden Sie unter [angeben des Speicherortes einer Assembly](~/docs/framework/configure-apps/specify-assembly-location.md). Wenn `assemblyName` gefunden wird, wird es in den Standardkontext geladen wird.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, um nicht öffentliche Typen zu erstellen, wenn der Aufrufer erteilt wurde, <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flag und der Berechtigungssatz der Assembly, die den nicht öffentlichen Typen des Aufrufers GRANT beschränkt ist Festlegen oder eine Teilmenge davon. (Finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
   
  
## Examples  
 Das folgende Beispiel definiert eine Klasse namens `Person` in einer Assembly mit dem Namen `PersonInfo`. Beachten Sie, dass die `Person` Klasse besitzt zwei Konstruktoren, einer davon ohne Parameter ist.  
  
 [!code-csharp[System.Activator.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/personinfo.cs#1)]
 [!code-vb[System.Activator.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/personinfo.vb#1)]  
  
 Im folgenden Beispiel wird die <xref:System.Activator.CreateInstance%28System.String%2CSystem.String%29> Methode zum Instanziieren der `Person` Klasse. Muss einen Verweis auf PersonInfo.dll zum Projekt hinzugefügt werden. Da die <xref:System.Activator.CreateInstance%28System.String%2CSystem.String%29> Methodenaufrufe der `Person` Standardkonstruktor der Klasse im Beispiel wird einen Wert zugewiesen. die `Name` Eigenschaft.  
  
 [!code-csharp[System.Activator.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstanceex1.cs#2)]
 [!code-vb[System.Activator.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstanceex1.vb#2)]  
  
 Allerdings <xref:System.Activator.CreateInstance%2A> häufig aufgerufen, um einen Typ zu instanziieren, die über mehrere Computer oder die, die zur Entwurfszeit nicht bekannt. In diesem Fall Sie keinen Verweis auf die Assembly in das Projekt einbezogen werden und keine Member des Typs früh gebundene Aufrufe vornehmen. Um diese Einschränkung zu umgehen, die im folgenden Beispiel wird die <xref:System.Activator.CreateInstance%2A> -Methode zusammen mit Reflektion, um einen Wert zuweisen der `Person` des Objekts `Name` Eigenschaft und Wert angezeigt werden.  
  
 [!code-csharp[System.Activator.CreateInstance#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstanceex1a.cs#3)]
 [!code-vb[System.Activator.CreateInstance#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstanceex1a.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MemberAccessException">Sie können keine Instanz einer abstrakten Klasse erstellen, oder dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Der Konstruktor, der durch Reflektion aufgerufen wurde, hat eine Ausnahme ausgelöst.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Der COM-Typ wurde nicht über <see cref="Overload:System.Type.GetTypeFromProgID" /> oder <see cref="Overload:System.Type.GetTypeFromCLSID" /> abgerufen.</exception>
        <exception cref="T:System.NotSupportedException">Die Erstellung der Typen <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> und <see cref="T:System.RuntimeArgumentHandle" /> bzw. von Arrays dieser Typen wird nicht unterstützt.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
- oder -  
Die Common Language Runtime (CLR) Version 2.0 oder höher ist derzeit geladen, und <paramref name="assemblyName" /> wurde für eine höhere CLR-Version als die derzeit geladene kompiliert. Beachten Sie, dass die .NET Framework-Versionen 2.0, 3.0 und 3.5 alle CLR Version 2.0 verwenden.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.  
  
- oder -  
Der Assemblyname oder die Codebasis ist ungültig.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Möglichkeit, die nicht verwalteten Code aufrufen, wenn Sie eine Instanz eines Delegaten zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für den Zugriff auf nicht öffentliche Typen unabhängig von deren Berechtigungssatz. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, bool nonPublic);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, bool nonPublic) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, bool nonPublic);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * bool -&gt; obj" Usage="System.Activator.CreateInstance (type, nonPublic)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="nonPublic" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des zu erstellenden Objekts.</param>
        <param name="nonPublic">
          <see langword="true" />, wenn ein öffentlicher oder nicht öffentlicher Standardkonstruktor als Entsprechung möglich ist; <see langword="false" />, wenn nur ein öffentlicher Standardkonstruktor als Entsprechung möglich ist.</param>
        <summary>Erstellt mit dem Standardkonstruktor dieses Typs eine Instanz des angegebenen Typs.</summary>
        <returns>Ein Verweis auf das neu erstellte Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, um nicht öffentliche Typen und Member zugreifen, wenn der Aufrufer erteilt wurde, <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flag und der Berechtigungssatz der Assembly, die nicht öffentliche Typen und Member enthält, beschränkt ist. Erteilen Sie auf die festgelegt oder auf eine Teilmenge davon. (Finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> ist keine <see langword="RuntimeType" />.  
  
- oder -  
 <paramref name="type" /> ist ein offener generischer Typ (die <see cref="P:System.Type.ContainsGenericParameters" />-Eigenschaft gibt folglich <see langword="true" /> zurück).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> darf nicht <see cref="T:System.Reflection.Emit.TypeBuilder" /> sein.  
  
- oder -  
Die Erstellung der Typen <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> und <see cref="T:System.RuntimeArgumentHandle" /> bzw. von Arrays dieser Typen wird nicht unterstützt.  
  
- oder -  
Die Assembly mit <paramref name="type" /> ist eine dynamische Assembly, die mit <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" /> erstellt wurde.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Das Aufrufen des Konstruktors löst eine Ausnahme aus.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MemberAccessException">Eine Instanz einer abstrakten Klasse kann nicht erstellt werden, oder dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Der COM-Typ wurde nicht über <see cref="Overload:System.Type.GetTypeFromProgID" /> oder <see cref="Overload:System.Type.GetTypeFromCLSID" /> abgerufen.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> ist ein COM-Objekt, aber der Klassenbezeichner zum Abrufen des Typs ist ungültig , oder die bezeichnete Klasse wurde nicht registriert.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> ist kein gültiger Typ.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Möglichkeit, die nicht verwalteten Code aufrufen, wenn Sie eine Instanz eines Delegaten zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für den Zugriff auf nicht öffentliche Typen und Member unabhängig vom entsprechenden Berechtigungssatz. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, ... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="type">Der Typ des zu erstellenden Objekts.</param>
        <param name="args">Ein Array von Argumenten, das bezüglich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmt. Wenn <paramref name="args" /> ein leeres Array oder <see langword="null" /> ist, wird der Konstruktor aufgerufen, der keine Parameter akzeptiert, d. h. der Standardkonstruktor.</param>
        <summary>Erstellt mit dem am besten mit den angegebenen Parametern übereinstimmenden Konstruktor eine Instanz des angegebenen Typs.</summary>
        <returns>Ein Verweis auf das neu erstellte Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Konstruktor aufgerufen werden muss zugänglich sein und muss die spezifischste Übereinstimmung bereitstellen, mit der angegebenen Argumentliste.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, um Zugriff auf nicht öffentliche Typen, wenn der Aufrufer erteilt wurde, <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flag und der Berechtigungssatz der Assembly, die den nicht öffentlichen Typen des Aufrufers GRANT beschränkt ist Festlegen oder eine Teilmenge davon. (Finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Object%5B%5D%29> Methode zum Erstellen einer <xref:System.String> Objekt. Ruft die <xref:System.String.%23ctor%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> Konstruktor, um eine Zeichenfolge zu instanziieren, das zehn Elemente aus einem Array von Zeichen ab dem 14. Position enthält.  
  
 [!code-csharp[System.Activator.CreateInstance#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/CreateInstance5.cs#5)]
 [!code-vb[System.Activator.CreateInstance#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/CreateInstance5.vb#5)]  
  
 Im folgenden Beispiel wird ein verzweigtes Array, dessen Elemente sind Argumente übergeben werden soll, eine <xref:System.String> Konstruktor. Im Beispiel übergibt dann jedes Arrays, um die <xref:System.Activator.CreateInstance%28System.Type%2CSystem.Object%5B%5D%29> Methode, um die entsprechende Zeichenfolge-Konstruktor aufrufen.  
  
 [!code-csharp[System.Activator.CreateInstance#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activator.createinstance/cs/createinstance2.cs#4)]
 [!code-vb[System.Activator.CreateInstance#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activator.createinstance/vb/createinstance2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> ist keine <see langword="RuntimeType" />.  
  
- oder -  
 <paramref name="type" /> ist ein offener generischer Typ (die <see cref="P:System.Type.ContainsGenericParameters" />-Eigenschaft gibt folglich <see langword="true" /> zurück).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> darf nicht <see cref="T:System.Reflection.Emit.TypeBuilder" /> sein.  
  
- oder -  
Die Erstellung der Typen <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> und <see cref="T:System.RuntimeArgumentHandle" /> bzw. von Arrays dieser Typen wird nicht unterstützt.  
  
- oder -  
Die Assembly mit <paramref name="type" /> ist eine dynamische Assembly, die mit <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" /> erstellt wurde.  
  
- oder -  
Der mit <paramref name="args" /> am besten übereinstimmende Konstruktor verfügt über <see langword="varargs" />-Argumente.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Das Aufrufen des Konstruktors löst eine Ausnahme aus.</exception>
        <exception cref="T:System.MethodAccessException">
          <block subset="none" type="note">
            <para>  
 Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.MemberAccessException" /> ab.  
  
</para>
          </block>  
  
 Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MemberAccessException">Eine Instanz einer abstrakten Klasse kann nicht erstellt werden, oder dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Der COM-Typ wurde nicht über <see cref="Overload:System.Type.GetTypeFromProgID" /> oder <see cref="Overload:System.Type.GetTypeFromCLSID" /> abgerufen.</exception>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para>  
 Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.MissingMemberException" /> ab.  
  
</para>
          </block>  
  
 Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> ist ein COM-Objekt, aber der Klassenbezeichner zum Abrufen des Typs ist ungültig , oder die bezeichnete Klasse wurde nicht registriert.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> ist kein gültiger Typ.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Möglichkeit, die nicht verwalteten Code aufrufen, wenn Sie eine Instanz eines Delegaten zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für den Zugriff auf nicht öffentliche Typen unabhängig von deren Berechtigungssatz. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (domain As AppDomain, assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="domain">Die Remotedomäne, in der der Typ <paramref name="typeName" /> erstellt wird.</param>
        <param name="assemblyName">Der Name der Assembly, in der der Typ mit dem Namen <paramref name="typeName" /> gesucht wird. Wenn <paramref name="assemblyName" /><see langword="null" /> ist, wird die derzeit ausgeführte Assembly durchsucht.</param>
        <param name="typeName">Der vollqualifizierte Name des bevorzugten Typs.</param>
        <summary>Erstellt eine Instanz des Typs mit dem in der angegebenen Remotedomäne angegebenen Namen unter Verwendung der angegebenen Assembly und des Standardkonstruktors.</summary>
        <returns>Ein Handle, das für den Zugriff auf die neu erstellte Instanz entwrappt werden muss.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Activator.CreateInstance%2A> Wenn ein Host muss zum Ausführen von Code in einer Anwendungsdomäne, die über eingeschränkte Sicherheitsberechtigungen verfügt.  
  
 Verwendung <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> den Rückgabewert zu entpacken.  
  
> [!NOTE]
>  Diese Methode verwendet <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> den unmittelbaren Aufrufer volle Vertrauenswürdigkeit erforderlich ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> oder <paramref name="domain" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MemberAccessException">Es kann keine Instanz eines abstrakten Typs erstellt werden.  
  
- oder -  
Dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Der Konstruktor, der durch Reflektion aufgerufen wurde, hat eine Ausnahme ausgelöst.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Der COM-Typ wurde nicht über <see cref="Overload:System.Type.GetTypeFromProgID" /> oder <see cref="Overload:System.Type.GetTypeFromCLSID" /> abgerufen.</exception>
        <exception cref="T:System.NotSupportedException">Die Erstellung der Typen <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> und <see cref="T:System.RuntimeArgumentHandle" /> bzw. von Arrays dieser Typen wird nicht unterstützt.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
- oder -  
Die Common Language Runtime (CLR) Version 2.0 oder höher ist derzeit geladen, und <paramref name="assemblyName" /> wurde für eine höhere CLR-Version als die derzeit geladene kompiliert. Beachten Sie, dass die .NET Framework-Versionen 2.0, 3.0 und 3.5 alle CLR Version 2.0 verwenden.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.  
  
- oder -  
Der Assemblyname oder die Codebasis ist ungültig.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Möglichkeit, die nicht verwalteten Code aufrufen, wenn Sie eine Instanz eines Delegaten zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für die Möglichkeit, Vorgänge auf alle Typmember aufzurufen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Name der Assembly, in der der Typ mit dem Namen <paramref name="typeName" /> gesucht wird. Wenn <paramref name="assemblyName" /><see langword="null" /> ist, wird die derzeit ausgeführte Assembly durchsucht.</param>
        <param name="typeName">Der vollqualifizierte Name des bevorzugten Typs.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Dies ist üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <summary>Erstellt eine Instanz des Typs mit dem angegebenen Namen unter Verwendung der angegebenen Assembly und des Standardkonstruktors.</summary>
        <returns>Ein Handle, das für den Zugriff auf die neu erstellte Instanz entwrappt werden muss.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> den Rückgabewert zu entpacken.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, um nicht öffentliche Typen zu erstellen, wenn der Aufrufer erteilt wurde, <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flag und der Berechtigungssatz für den nicht öffentlichen Typen beschränkt, Berechtigungssatz des Aufrufers oder eine Teilmenge davon ist. (Finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MemberAccessException">Eine Instanz einer abstrakten Klasse kann nicht erstellt werden, oder dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Der COM-Typ wurde nicht über <see cref="Overload:System.Type.GetTypeFromProgID" /> oder <see cref="Overload:System.Type.GetTypeFromCLSID" /> abgerufen.</exception>
        <exception cref="T:System.NotSupportedException">Die Erstellung der Typen <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> und <see cref="T:System.RuntimeArgumentHandle" /> bzw. von Arrays dieser Typen wird nicht unterstützt.  
  
- oder -  
 <paramref name="activationAttributes" /> ist kein leeres Array, und der erstellte Typ wird nicht von <see cref="T:System.MarshalByRefObject" /> abgeleitet.  
  
- oder -  
 <paramref name="activationAttributes" /> ist kein <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-  
  
Array.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
- oder -  
Die Common Language Runtime (CLR) Version 2.0 oder höher ist derzeit geladen, und <paramref name="assemblyName" /> wurde für eine höhere CLR-Version als die derzeit geladene kompiliert. Beachten Sie, dass die .NET Framework-Versionen 2.0, 3.0 und 3.5 alle CLR Version 2.0 verwenden.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.  
  
- oder -  
Der Assemblyname oder die Codebasis ist ungültig.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Bei dem Versuch einer Remoteaktivierung in einem in <paramref name="activationAttributes" /> angegebenen Ziel ist ein Fehler aufgetreten.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Möglichkeit, die nicht verwalteten Code aufrufen, wenn Sie eine Instanz eines Delegaten zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für den Zugriff auf nicht öffentliche Typen unabhängig von deren Berechtigungssatz. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, object[] args, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, object[] args, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Object[],System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * obj[] * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, args, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des zu erstellenden Objekts.</param>
        <param name="args">Ein Array von Argumenten, das bezüglich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmt. Wenn <paramref name="args" /> ein leeres Array oder <see langword="null" /> ist, wird der Konstruktor aufgerufen, der keine Parameter akzeptiert, d. h. der Standardkonstruktor.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Dies ist üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <summary>Erstellt mit dem am besten mit den angegebenen Parametern übereinstimmenden Konstruktor eine Instanz des angegebenen Typs.</summary>
        <returns>Ein Verweis auf das neu erstellte Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Konstruktor aufgerufen werden muss zugänglich sein und muss die spezifischste Übereinstimmung bereitstellen, mit der angegebenen Argumentliste.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, um Zugriff auf nicht öffentliche Typen, wenn der Aufrufer erteilt wurde, <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flag und der Berechtigungssatz der Assembly, die den nicht öffentlichen Typen des Aufrufers GRANT beschränkt ist Festlegen oder eine Teilmenge davon. (Finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> ist keine <see langword="RuntimeType" />.  
  
- oder -  
 <paramref name="type" /> ist ein offener generischer Typ (die <see cref="P:System.Type.ContainsGenericParameters" />-Eigenschaft gibt folglich <see langword="true" /> zurück).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> darf nicht <see cref="T:System.Reflection.Emit.TypeBuilder" /> sein.  
  
- oder -  
Die Erstellung der Typen <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> und <see cref="T:System.RuntimeArgumentHandle" /> bzw. von Arrays dieser Typen wird nicht unterstützt.  
  
- oder -  
 <paramref name="activationAttributes" /> ist kein leeres Array, und der erstellte Typ wird nicht von <see cref="T:System.MarshalByRefObject" /> abgeleitet.  
  
- oder -  
Die Assembly mit <paramref name="type" /> ist eine dynamische Assembly, die mit <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" /> erstellt wurde.  
  
- oder -  
Der mit <paramref name="args" /> am besten übereinstimmende Konstruktor verfügt über <see langword="varargs" />-Argumente.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Das Aufrufen des Konstruktors löst eine Ausnahme aus.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MemberAccessException">Eine Instanz einer abstrakten Klasse kann nicht erstellt werden, oder dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Der COM-Typ wurde nicht über <see cref="Overload:System.Type.GetTypeFromProgID" /> oder <see cref="Overload:System.Type.GetTypeFromCLSID" /> abgerufen.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> ist ein COM-Objekt, aber der Klassenbezeichner zum Abrufen des Typs ist ungültig , oder die bezeichnete Klasse wurde nicht registriert.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> ist kein gültiger Typ.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Möglichkeit, die nicht verwalteten Code aufrufen, wenn Sie eine Instanz eines Delegaten zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für den Zugriff auf nicht öffentliche Typen unabhängig von deren Berechtigungssatz. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="System.Activator.CreateInstance (type, bindingAttr, binder, args, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des zu erstellenden Objekts.</param>
        <param name="bindingAttr">Eine Kombination von 0 oder mehr Bitflags, die die Suche nach dem <paramref name="type" />-Konstruktor beeinflussen. Wenn <paramref name="bindingAttr" /> 0 ist, wird eine Suche nach öffentlichen Konstruktoren mit Beachtung der Groß-/Kleinschreibung durchgeführt.</param>
        <param name="binder">Ein Objekt, das <paramref name="bindingAttr" /> und <paramref name="args" /> für die Suche und Bestimmung des <paramref name="type" />-Konstruktors verwendet. Wenn <paramref name="binder" /> den Wert <see langword="null" /> aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Ein Array von Argumenten, das bezüglich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmt. Wenn <paramref name="args" /> ein leeres Array oder <see langword="null" /> ist, wird der Konstruktor aufgerufen, der keine Parameter akzeptiert, d. h. der Standardkonstruktor.</param>
        <param name="culture">Kulturabhängige Informationen, die die Umwandlung von <paramref name="args" /> in die für den <paramref name="type" />-Konstruktor deklarierten formalen Typen bestimmen. Wenn <paramref name="culture" /> den Wert <see langword="null" /> hat, wird die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet.</param>
        <summary>Erstellt mit dem am besten mit den angegebenen Parametern übereinstimmenden Konstruktor eine Instanz des angegebenen Typs.</summary>
        <returns>Ein Verweis auf das neu erstellte Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Konstruktor aufgerufen werden, muss die spezifischste Übereinstimmung mit der angegebenen Argumentliste unter den Einschränkungen des angegebenen Binders und Binden von Attributen angeben.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, um nicht öffentliche Typen und Member zugreifen, wenn der Aufrufer erteilt wurde, <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flag und der Berechtigungssatz der Assembly, die nicht öffentliche Typen und Member enthält, beschränkt ist. Erteilen Sie auf die festgelegt oder auf eine Teilmenge davon. (Finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> ist keine <see langword="RuntimeType" />.  
  
- oder -  
 <paramref name="type" /> ist ein offener generischer Typ (die <see cref="P:System.Type.ContainsGenericParameters" />-Eigenschaft gibt folglich <see langword="true" /> zurück).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> darf nicht <see cref="T:System.Reflection.Emit.TypeBuilder" /> sein.  
  
- oder -  
Die Erstellung der Typen <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> und <see cref="T:System.RuntimeArgumentHandle" /> bzw. von Arrays dieser Typen wird nicht unterstützt.  
  
- oder -  
Die Assembly mit <paramref name="type" /> ist eine dynamische Assembly, die mit <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" /> erstellt wurde.  
  
- oder -  
Der mit <paramref name="args" /> am besten übereinstimmende Konstruktor verfügt über <see langword="varargs" />-Argumente.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Das Aufrufen des Konstruktors löst eine Ausnahme aus.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MemberAccessException">Eine Instanz einer abstrakten Klasse kann nicht erstellt werden, oder dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Der COM-Typ wurde nicht über <see cref="Overload:System.Type.GetTypeFromProgID" /> oder <see cref="Overload:System.Type.GetTypeFromCLSID" /> abgerufen.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender Konstruktor gefunden.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> ist ein COM-Objekt, aber der Klassenbezeichner zum Abrufen des Typs ist ungültig, oder die bezeichnete Klasse wurde nicht registriert.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> ist kein gültiger Typ.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Möglichkeit, die nicht verwalteten Code aufrufen, wenn Sie eine Instanz eines Delegaten zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für den Zugriff auf nicht öffentliche Typen und Member unabhängig vom entsprechenden Berechtigungssatz. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static object CreateInstance (Type type, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object CreateInstance(class System.Type type, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ CreateInstance(Type ^ type, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : Type * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="System.Activator.CreateInstance (type, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des zu erstellenden Objekts.</param>
        <param name="bindingAttr">Eine Kombination von 0 oder mehr Bitflags, die die Suche nach dem <paramref name="type" />-Konstruktor beeinflussen. Wenn <paramref name="bindingAttr" /> 0 ist, wird eine Suche nach öffentlichen Konstruktoren mit Beachtung der Groß-/Kleinschreibung durchgeführt.</param>
        <param name="binder">Ein Objekt, das <paramref name="bindingAttr" /> und <paramref name="args" /> für die Suche und Bestimmung des <paramref name="type" />-Konstruktors verwendet. Wenn <paramref name="binder" /> den Wert <see langword="null" /> aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Ein Array von Argumenten, das bezüglich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmt. Wenn <paramref name="args" /> ein leeres Array oder <see langword="null" /> ist, wird der Konstruktor aufgerufen, der keine Parameter akzeptiert, d. h. der Standardkonstruktor.</param>
        <param name="culture">Kulturabhängige Informationen, die die Umwandlung von <paramref name="args" /> in die für den <paramref name="type" />-Konstruktor deklarierten formalen Typen bestimmen. Wenn <paramref name="culture" /> den Wert <see langword="null" /> hat, wird die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Dies ist üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <summary>Erstellt mit dem am besten mit den angegebenen Parametern übereinstimmenden Konstruktor eine Instanz des angegebenen Typs.</summary>
        <returns>Ein Verweis auf das neu erstellte Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Konstruktor aufgerufen werden, muss die spezifischste Übereinstimmung mit der angegebenen Argumentliste unter den Einschränkungen des angegebenen Binders und Binden von Attributen angeben.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, um nicht öffentliche Typen und Member zugreifen, wenn der Aufrufer erteilt wurde, <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Satz an Berechtigungen Flag und der Berechtigungssatz für die nicht öffentliche Typen und Member an des Aufrufers des beschränkt ist oder Um eine Teilmenge davon. (Finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> ist keine <see langword="RuntimeType" />.  
  
- oder -  
 <paramref name="type" /> ist ein offener generischer Typ (die <see cref="P:System.Type.ContainsGenericParameters" />-Eigenschaft gibt folglich <see langword="true" /> zurück).</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="type" /> darf nicht <see cref="T:System.Reflection.Emit.TypeBuilder" /> sein.  
  
- oder -  
Die Erstellung der Typen <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> und <see cref="T:System.RuntimeArgumentHandle" /> bzw. von Arrays dieser Typen wird nicht unterstützt.  
  
- oder -  
 <paramref name="activationAttributes" /> ist kein leeres Array, und der erstellte Typ wird nicht von <see cref="T:System.MarshalByRefObject" /> abgeleitet.  
  
- oder -  
Die Assembly mit <paramref name="type" /> ist eine dynamische Assembly, die mit <see cref="F:System.Reflection.Emit.AssemblyBuilderAccess.Save" /> erstellt wurde.  
  
- oder -  
Der mit <paramref name="args" /> am besten übereinstimmende Konstruktor verfügt über <see langword="varargs" />-Argumente.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Das Aufrufen des Konstruktors löst eine Ausnahme aus.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MemberAccessException">Eine Instanz einer abstrakten Klasse kann nicht erstellt werden, oder dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Der COM-Typ wurde nicht über <see cref="Overload:System.Type.GetTypeFromProgID" /> oder <see cref="Overload:System.Type.GetTypeFromCLSID" /> abgerufen.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender Konstruktor gefunden.</exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <paramref name="type" /> ist ein COM-Objekt, aber der Klassenbezeichner zum Abrufen des Typs ist ungültig, oder die bezeichnete Klasse wurde nicht registriert.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="type" /> ist kein gültiger Typ.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Angeben von Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für den Zugriff auf nicht öffentliche Typen und Member unabhängig vom entsprechenden Berechtigungssatz. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Name der Assembly, in der der Typ mit dem Namen <paramref name="typeName" /> gesucht wird. Wenn <paramref name="assemblyName" /><see langword="null" /> ist, wird die derzeit ausgeführte Assembly durchsucht.</param>
        <param name="typeName">Der vollqualifizierte Name des bevorzugten Typs.</param>
        <param name="ignoreCase">
          <see langword="true" />, wenn bei der Suche nach <paramref name="typeName" /> die Groß-/Kleinschreibung nicht beachtet werden soll; <see langword="false" />, wenn bei der Suche die Groß-/Kleinschreibung beachtet werden soll.</param>
        <param name="bindingAttr">Eine Kombination von 0 oder mehr Bitflags, die die Suche nach dem <paramref name="typeName" />-Konstruktor beeinflussen. Wenn <paramref name="bindingAttr" /> 0 ist, wird eine Suche nach öffentlichen Konstruktoren mit Beachtung der Groß-/Kleinschreibung durchgeführt.</param>
        <param name="binder">Ein Objekt, das <paramref name="bindingAttr" /> und <paramref name="args" /> für die Suche und Bestimmung des <paramref name="typeName" />-Konstruktors verwendet. Wenn <paramref name="binder" /> den Wert <see langword="null" /> aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Ein Array von Argumenten, das bezüglich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmt. Wenn <paramref name="args" /> ein leeres Array oder <see langword="null" /> ist, wird der Konstruktor aufgerufen, der keine Parameter akzeptiert, d. h. der Standardkonstruktor.</param>
        <param name="culture">Kulturabhängige Informationen, die die Umwandlung von <paramref name="args" /> in die für den <paramref name="typeName" />-Konstruktor deklarierten formalen Typen bestimmen. Wenn <paramref name="culture" /> den Wert <see langword="null" /> hat, wird die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Dies ist üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <summary>Erstellt eine Instanz des Typs mit dem angegebenen Namen unter Verwendung der angegebenen Assembly und des Konstruktors, der mit den angegebenen Parametern am besten übereinstimmt.</summary>
        <returns>Ein Handle, das für den Zugriff auf die neu erstellte Instanz entwrappt werden muss.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> den Rückgabewert zu entpacken.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, um nicht öffentliche Typen und Member zu erstellen, wenn der Aufrufer erteilt wurde, <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flag und der Berechtigungssatz der Assembly, die nicht öffentliche Typen und Member enthält, beschränkt ist. Erteilen Sie auf die festgelegt oder auf eine Teilmenge davon. (Finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender Konstruktor gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MemberAccessException">Eine Instanz einer abstrakten Klasse kann nicht erstellt werden, oder dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Der Konstruktor, der durch Reflektion aufgerufen wurde, hat eine Ausnahme ausgelöst.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Der COM-Typ wurde nicht über <see cref="Overload:System.Type.GetTypeFromProgID" /> oder <see cref="Overload:System.Type.GetTypeFromCLSID" /> abgerufen.</exception>
        <exception cref="T:System.NotSupportedException">Die Erstellung der Typen <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> und <see cref="T:System.RuntimeArgumentHandle" /> bzw. von Arrays dieser Typen wird nicht unterstützt.  
  
- oder -  
 <paramref name="activationAttributes" /> ist kein leeres Array, und der erstellte Typ wird nicht von <see cref="T:System.MarshalByRefObject" /> abgeleitet.  
  
- oder -  
Der am besten übereinstimmende Konstruktor <paramref name="args" /> verfügt über <see langword="varargs" />-Argumente.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
- oder -  
Die Common Language Runtime (CLR) Version 2.0 oder höher ist derzeit geladen, und <paramref name="assemblyName" /> wurde für eine höhere CLR-Version als die derzeit geladene kompiliert. Beachten Sie, dass die .NET Framework-Versionen 2.0, 3.0 und 3.5 alle CLR Version 2.0 verwenden.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.  
  
- oder -  
Der Assemblyname oder die Codebasis ist ungültig.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Möglichkeit, die nicht verwalteten Code aufrufen, wenn Sie eine Instanz eines Delegaten zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für den Zugriff auf nicht öffentliche Typen und Member unabhängig vom entsprechenden Berechtigungssatz. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="domain">Die Domäne, in der der Typ <paramref name="typeName" /> erstellt wird.</param>
        <param name="assemblyName">Der Name der Assembly, in der der Typ mit dem Namen <paramref name="typeName" /> gesucht wird. Wenn <paramref name="assemblyName" /><see langword="null" /> ist, wird die derzeit ausgeführte Assembly durchsucht.</param>
        <param name="typeName">Der vollqualifizierte Name des bevorzugten Typs.</param>
        <param name="ignoreCase">
          <see langword="true" />, wenn bei der Suche nach <paramref name="typeName" /> die Groß-/Kleinschreibung nicht beachtet werden soll; <see langword="false" />, wenn bei der Suche die Groß-/Kleinschreibung beachtet werden soll.</param>
        <param name="bindingAttr">Eine Kombination von 0 oder mehr Bitflags, die die Suche nach dem <paramref name="typeName" />-Konstruktor beeinflussen. Wenn <paramref name="bindingAttr" /> 0 ist, wird eine Suche nach öffentlichen Konstruktoren mit Beachtung der Groß-/Kleinschreibung durchgeführt.</param>
        <param name="binder">Ein Objekt, das <paramref name="bindingAttr" /> und <paramref name="args" /> für die Suche und Bestimmung des <paramref name="typeName" />-Konstruktors verwendet. Wenn <paramref name="binder" /> den Wert <see langword="null" /> aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Ein Array von Argumenten, das bezüglich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmt. Wenn <paramref name="args" /> ein leeres Array oder <see langword="null" /> ist, wird der Konstruktor aufgerufen, der keine Parameter akzeptiert, d. h. der Standardkonstruktor.</param>
        <param name="culture">Kulturabhängige Informationen, die die Umwandlung von <paramref name="args" /> in die für den <paramref name="typeName" />-Konstruktor deklarierten formalen Typen bestimmen. Wenn <paramref name="culture" /> den Wert <see langword="null" /> hat, wird die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Dies ist üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <summary>Erstellt eine Instanz des Typs mit dem in der angegebenen Remotedomäne angegebenen Namen unter Verwendung der angegebenen Assembly und des Konstruktors, der den angegebenen Parametern am besten entspricht.</summary>
        <returns>Ein Handle, das für den Zugriff auf die neu erstellte Instanz entwrappt werden muss.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Activator.CreateInstance%2A> Wenn ein Host muss zum Ausführen von Code in einer Anwendungsdomäne, die über eingeschränkte Sicherheitsberechtigungen verfügt.  
  
 Verwendung <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> den Rückgabewert zu entpacken.  
  
> [!NOTE]
>  Diese Methode verwendet <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> den unmittelbaren Aufrufer volle Vertrauenswürdigkeit erforderlich ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> oder <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender Konstruktor gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MemberAccessException">Eine Instanz einer abstrakten Klasse kann nicht erstellt werden, oder dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Der Konstruktor, der durch Reflektion aufgerufen wurde, hat eine Ausnahme ausgelöst.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Der COM-Typ wurde nicht über <see cref="Overload:System.Type.GetTypeFromProgID" /> oder <see cref="Overload:System.Type.GetTypeFromCLSID" /> abgerufen.</exception>
        <exception cref="T:System.NotSupportedException">Die Erstellung der Typen <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> und <see cref="T:System.RuntimeArgumentHandle" /> bzw. von Arrays dieser Typen wird nicht unterstützt.  
  
- oder -  
 <paramref name="activationAttributes" /> ist kein leeres Array, und der erstellte Typ wird nicht von <see cref="T:System.MarshalByRefObject" /> abgeleitet.  
  
- oder -  
Der am besten übereinstimmende Konstruktor <paramref name="args" /> verfügt über <see langword="varargs" />-Argumente.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
- oder -  
Die Common Language Runtime (CLR) Version 2.0 oder höher ist derzeit geladen, und <paramref name="assemblyName" /> wurde für eine höhere CLR-Version als die derzeit geladene kompiliert. Beachten Sie, dass die .NET Framework-Versionen 2.0, 3.0 und 3.5 alle CLR Version 2.0 verwenden.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.  
  
- oder -  
Der Assemblyname oder die Codebasis ist ungültig.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Möglichkeit, die nicht verwalteten Code aufrufen, wenn Sie eine Instanz eines Delegaten zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für die Möglichkeit, Vorgänge auf alle Typmember aufzurufen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Der Name der Assembly, in der der Typ mit dem Namen <paramref name="typeName" /> gesucht wird. Wenn <paramref name="assemblyName" /><see langword="null" /> ist, wird die derzeit ausgeführte Assembly durchsucht.</param>
        <param name="typeName">Der vollqualifizierte Name des bevorzugten Typs.</param>
        <param name="ignoreCase">
          <see langword="true" />, wenn bei der Suche nach <paramref name="typeName" /> die Groß-/Kleinschreibung nicht beachtet werden soll; <see langword="false" />, wenn bei der Suche die Groß-/Kleinschreibung beachtet werden soll.</param>
        <param name="bindingAttr">Eine Kombination von 0 oder mehr Bitflags, die die Suche nach dem <paramref name="typeName" />-Konstruktor beeinflussen. Wenn <paramref name="bindingAttr" /> 0 ist, wird eine Suche nach öffentlichen Konstruktoren mit Beachtung der Groß-/Kleinschreibung durchgeführt.</param>
        <param name="binder">Ein Objekt, das <paramref name="bindingAttr" /> und <paramref name="args" /> für die Suche und Bestimmung des <paramref name="typeName" />-Konstruktors verwendet. Wenn <paramref name="binder" /> den Wert <see langword="null" /> aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Ein Array von Argumenten, das bezüglich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmt. Wenn <paramref name="args" /> ein leeres Array oder <see langword="null" /> ist, wird der Konstruktor aufgerufen, der keine Parameter akzeptiert, d. h. der Standardkonstruktor.</param>
        <param name="culture">Kulturabhängige Informationen, die die Umwandlung von <paramref name="args" /> in die für den <paramref name="typeName" />-Konstruktor deklarierten formalen Typen bestimmen. Wenn <paramref name="culture" /> den Wert <see langword="null" /> hat, wird die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Dies ist üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <param name="securityInfo">Informationen, die bei Entscheidungen bezüglich Sicherheitsrichtlinien und beim Gewähren von Codeberechtigungen herangezogen werden.</param>
        <summary>Erstellt eine Instanz des Typs mit dem angegebenen Namen unter Verwendung der angegebenen Assembly und des Konstruktors, der mit den angegebenen Parametern am besten übereinstimmt.</summary>
        <returns>Ein Handle, das für den Zugriff auf die neu erstellte Instanz entwrappt werden muss.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> den Rückgabewert zu entpacken.  
  
> [!NOTE]
>  Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, um nicht öffentliche Typen und Member zu erstellen, wenn der Aufrufer erteilt wurde, <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> Flag und der Berechtigungssatz der Assembly, die nicht öffentliche Typen und Member enthält, beschränkt ist. Erteilen Sie auf die festgelegt oder auf eine Teilmenge davon. (Finden Sie unter [Überlegungen zur Sicherheit für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.   
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender Konstruktor gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MemberAccessException">Eine Instanz einer abstrakten Klasse kann nicht erstellt werden, oder dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Der Konstruktor, der durch Reflektion aufgerufen wurde, hat eine Ausnahme ausgelöst.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Der COM-Typ wurde nicht über <see cref="Overload:System.Type.GetTypeFromProgID" /> oder <see cref="Overload:System.Type.GetTypeFromCLSID" /> abgerufen.</exception>
        <exception cref="T:System.NotSupportedException">Die Erstellung der Typen <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> und <see cref="T:System.RuntimeArgumentHandle" /> bzw. von Arrays dieser Typen wird nicht unterstützt.  
  
- oder -  
 <paramref name="activationAttributes" /> ist kein leeres Array, und der erstellte Typ wird nicht von <see cref="T:System.MarshalByRefObject" /> abgeleitet.  
  
- oder -  
Der am besten übereinstimmende Konstruktor <paramref name="args" /> verfügt über <see langword="varargs" />-Argumente.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
- oder -  
Die Common Language Runtime (CLR) Version 2.0 oder höher ist derzeit geladen, und <paramref name="assemblyName" /> wurde für eine höhere CLR-Version als die derzeit geladene kompiliert. Beachten Sie, dass die .NET Framework-Versionen 2.0, 3.0 und 3.5 alle CLR Version 2.0 verwenden.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.  
  
- oder -  
Der Assemblyname oder die Codebasis ist ungültig.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Möglichkeit, die nicht verwalteten Code aufrufen, wenn Sie eine Instanz eines Delegaten zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für den Zugriff auf nicht öffentliche Typen und Member unabhängig vom entsprechenden Berechtigungssatz. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstance (AppDomain domain, string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstance(class System.AppDomain domain, string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstance(AppDomain ^ domain, System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstance : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstance (domain, assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="domain">Die Domäne, in der der Typ <paramref name="typeName" /> erstellt wird.</param>
        <param name="assemblyName">Der Name der Assembly, in der der Typ mit dem Namen <paramref name="typeName" /> gesucht wird. Wenn <paramref name="assemblyName" /><see langword="null" /> ist, wird die derzeit ausgeführte Assembly durchsucht.</param>
        <param name="typeName">Der vollqualifizierte Name des bevorzugten Typs.</param>
        <param name="ignoreCase">
          <see langword="true" />, wenn bei der Suche nach <paramref name="typeName" /> die Groß-/Kleinschreibung nicht beachtet werden soll; <see langword="false" />, wenn bei der Suche die Groß-/Kleinschreibung beachtet werden soll.</param>
        <param name="bindingAttr">Eine Kombination von 0 oder mehr Bitflags, die die Suche nach dem <paramref name="typeName" />-Konstruktor beeinflussen. Wenn <paramref name="bindingAttr" /> 0 ist, wird eine Suche nach öffentlichen Konstruktoren mit Beachtung der Groß-/Kleinschreibung durchgeführt.</param>
        <param name="binder">Ein Objekt, das <paramref name="bindingAttr" /> und <paramref name="args" /> für die Suche und Bestimmung des <paramref name="typeName" />-Konstruktors verwendet. Wenn <paramref name="binder" /> den Wert <see langword="null" /> aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Ein Array von Argumenten, das bezüglich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmt. Wenn <paramref name="args" /> ein leeres Array oder <see langword="null" /> ist, wird der Konstruktor aufgerufen, der keine Parameter akzeptiert, d. h. der Standardkonstruktor.</param>
        <param name="culture">Kulturabhängige Informationen, die die Umwandlung von <paramref name="args" /> in die für den <paramref name="typeName" />-Konstruktor deklarierten formalen Typen bestimmen. Wenn <paramref name="culture" /> den Wert <see langword="null" /> hat, wird die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. In der Regel ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält. Das <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> gibt die URL an, die zum Aktivieren eines Remoteobjekts erforderlich ist.</param>
        <param name="securityAttributes">Informationen, die bei Entscheidungen bezüglich Sicherheitsrichtlinien und beim Gewähren von Codeberechtigungen herangezogen werden.</param>
        <summary>Erstellt eine Instanz des Typs mit dem in der angegebenen Remotedomäne angegebenen Namen unter Verwendung der angegebenen Assembly und des Konstruktors, der den angegebenen Parametern am besten entspricht.</summary>
        <returns>Ein Handle, das für den Zugriff auf die neu erstellte Instanz entwrappt werden muss.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Activator.CreateInstance%2A> Wenn ein Host muss zum Ausführen von Code in einer Anwendungsdomäne, die über eingeschränkte Sicherheitsberechtigungen verfügt.  
  
 Verwendung <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> den Rückgabewert zu entpacken.  
  
> [!NOTE]
>  Diese Methode verwendet <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> den unmittelbaren Aufrufer volle Vertrauenswürdigkeit erforderlich ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> oder <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender Konstruktor gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyName" /> nicht gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MemberAccessException">Eine Instanz einer abstrakten Klasse kann nicht erstellt werden, oder dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Der Konstruktor, der durch Reflektion aufgerufen wurde, hat eine Ausnahme ausgelöst.</exception>
        <exception cref="T:System.Runtime.InteropServices.InvalidComObjectException">Der COM-Typ wurde nicht über <see cref="Overload:System.Type.GetTypeFromProgID" /> oder <see cref="Overload:System.Type.GetTypeFromCLSID" /> abgerufen.</exception>
        <exception cref="T:System.NotSupportedException">Die Erstellung der Typen <see cref="T:System.TypedReference" />, <see cref="T:System.ArgIterator" />, <see cref="T:System.Void" /> und <see cref="T:System.RuntimeArgumentHandle" /> bzw. von Arrays dieser Typen wird nicht unterstützt.  
  
- oder -  
 <paramref name="activationAttributes" /> ist kein leeres Array, und der erstellte Typ wird nicht von <see cref="T:System.MarshalByRefObject" /> abgeleitet.  
  
- oder -  
Der am besten übereinstimmende Konstruktor <paramref name="args" /> verfügt über <see langword="varargs" />-Argumente.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> ist keine gültige Assembly.  
  
- oder -  
Die Common Language Runtime (CLR) Version 2.0 oder höher ist derzeit geladen, und <paramref name="assemblyName" /> wurde für eine höhere CLR-Version als die derzeit geladene kompiliert. Beachten Sie, dass die .NET Framework-Versionen 2.0, 3.0 und 3.5 alle CLR Version 2.0 verwenden.</exception>
        <exception cref="T:System.IO.FileLoadException">Eine Assembly oder ein Modul wurde zweimal mit zwei unterschiedlichen Beweisen geladen.  
  
- oder -  
Der Assemblyname oder die Codebasis ist ungültig.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Möglichkeit, die nicht verwalteten Code aufrufen, wenn Sie eine Instanz eines Delegaten zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für die Möglichkeit, Vorgänge auf alle Typmember aufzurufen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T CreateInstance&lt;T&gt; ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T CreateInstance&lt;T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstance``1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstance(Of T) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T CreateInstance();" />
      <MemberSignature Language="F#" Value="static member CreateInstance : unit -&gt; 'T" Usage="System.Activator.CreateInstance " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Der zu erstellende Typ.</typeparam>
        <summary>Erstellt mit dem parameterlosen Konstruktor eine Instanz des Typs, der vom angegebenen generischen Typparameter festgelegt wurde.</summary>
        <returns>Ein Verweis auf das neu erstellte Objekt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Activator.CreateInstance%60%601> generische Methode wird von Compilern verwendet, um die Instanziierung von Typparametern angegebene Typen implementieren. Beispielsweise in der folgenden generischen Methode, die Implementierung der `new T()` (`gcnew T()` in C++) verwendet die <xref:System.Activator.CreateInstance%60%601> generische Methode.  
  
 [!code-cpp[System.Activation.CreateInstance~~1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.activation.createinstance~~1/cpp/remarks.cpp#1)]
 [!code-csharp[System.Activation.CreateInstance~~1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.activation.createinstance~~1/cs/remarks.cs#1)]
 [!code-vb[System.Activation.CreateInstance~~1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.activation.createinstance~~1/vb/remarks.vb#1)]  
  
 Im Allgemeinen, es werden keine für die <xref:System.Activator.CreateInstance%60%601> generische Methode in der Anwendung code, da der Typ zum Zeitpunkt der Kompilierung bekannt sein muss. Wenn der Typ zur Kompilierzeit bekannt ist, kann die der normalen Instanziierungssyntax verwendet werden (`new` -Operator in c#, `New` in Visual Basic `gcnew` in C++). Wenn der Typ zur Kompilierzeit nicht bekannt ist, können Sie eine nicht generische Überladung von Aufrufen <xref:System.Activator.CreateInstance%2A>.  
  
 Es gibt keine Überladungen der <xref:System.Activator.CreateInstance%60%601> generische Methode, die Argumentlisten, dauern, da die nicht generische von Überladungen <xref:System.Activator.CreateInstance%2A> bereits eine Konstruktor für spät gebundene Auflösung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MissingMethodException">
          <block subset="none" type="note">
            <para>  
 Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.MissingMemberException" /> ab.  
  
</para>
          </block>  
  
 Der Typ, der für <paramref name="T" /> angegeben ist, besitzt keinen parameterlosen Konstruktor.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt eine Instanz des Typs mit dem angegebenen Namen unter Verwendung der angegebenen Assemblydatei und des Konstruktors, der mit den angegebenen Parametern am besten übereinstimmt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name einer Datei, die eine Assembly enthält, in der der Typ mit dem Namen <paramref name="typeName" /> gesucht wird.</param>
        <param name="typeName">Der Name des bevorzugten Typs.</param>
        <summary>Erstellt eine Instanz des Typs mit dem angegebenen Namen unter Verwendung der angegebenen Assemblydatei und des Standardkonstruktors.</summary>
        <returns>Ein Handle, das für den Zugriff auf die neu erstellte Instanz entwrappt werden muss.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> Methode, um den Rückgabewert zu entpacken.  
  
 Informationen zu anderen Ausnahmen, die von aufgerufenen Methoden ausgelöst werden können, finden Sie im Abschnitt "Ausnahmen" von der <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> und <xref:System.Activator.CreateInstance%2A> Methoden.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Aufrufen der <xref:System.Activator.CreateInstanceFrom%2A> Methode. Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Activator> Klasse.  
  
 [!code-cpp[ActivatorX#3](~/samples/snippets/cpp/VS_Snippets_CLR/ActivatorX/cpp/ActivatorX.cpp#3)]
 [!code-csharp[ActivatorX#3](~/samples/snippets/csharp/VS_Snippets_CLR/ActivatorX/cs/ActivatorX.cs#3)]
 [!code-vb[ActivatorX#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/ActivatorX/VB/ActivatorX.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyFile" /> nicht gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MemberAccessException">Eine Instanz einer abstrakten Klasse kann nicht erstellt werden, oder dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Der Konstruktor, der durch Reflektion aufgerufen wurde, hat eine Ausnahme ausgelöst.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
- oder -  
Die Common Language Runtime (CLR) Version 2.0 oder höher ist derzeit geladen, und <paramref name="assemblyName" /> wurde für eine höhere CLR-Version als die derzeit geladene kompiliert. Beachten Sie, dass die .NET Framework-Versionen 2.0, 3.0 und 3.5 alle CLR Version 2.0 verwenden.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Möglichkeit, die nicht verwalteten Code aufrufen, wenn Sie eine Instanz eines Delegaten zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für die Fähigkeit zum Durchsuchen von Verzeichnispfaden und ihren Inhalt zu lesen. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für den Zugriff auf nicht öffentliche Typen unabhängig von deren Berechtigungssatz. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (domain As AppDomain, assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="domain">Die Remotedomäne, in der der Typ <paramref name="typeName" /> erstellt wird.</param>
        <param name="assemblyFile">Der Name einer Datei, die eine Assembly enthält, in der der Typ mit dem Namen <paramref name="typeName" /> gesucht wird.</param>
        <param name="typeName">Der Name des bevorzugten Typs.</param>
        <summary>Erstellt eine Instanz des Typs mit dem in der angegebenen Remotedomäne angegebenen Namen unter Verwendung der angegebenen Assemblydatei und des Standardkonstruktors.</summary>
        <returns>Ein Handle, das für den Zugriff auf die neu erstellte Instanz entwrappt werden muss.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Activator.CreateInstanceFrom%2A> Wenn ein Host muss zum Ausführen von Code in einer Anwendungsdomäne, die über eingeschränkte Sicherheitsberechtigungen verfügt.  
  
 Verwenden der <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> Methode, um den Rückgabewert zu entpacken.  
  
> [!NOTE]
>  Diese Methode verwendet <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> den unmittelbaren Aufrufer volle Vertrauenswürdigkeit erforderlich ist.  
  
 Informationen zu anderen Ausnahmen, die von aufgerufenen Methoden ausgelöst werden können, finden Sie im Abschnitt "Ausnahmen" von der <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> und <xref:System.Activator.CreateInstance%2A> Methoden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> oder <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyFile" /> nicht gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MemberAccessException">Eine Instanz einer abstrakten Klasse kann nicht erstellt werden, oder dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Der Konstruktor, der durch Reflektion aufgerufen wurde, hat eine Ausnahme ausgelöst.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
- oder -  
Die Common Language Runtime (CLR) Version 2.0 oder höher ist derzeit geladen, und <paramref name="assemblyName" /> wurde für eine höhere CLR-Version als die derzeit geladene kompiliert. Beachten Sie, dass die .NET Framework-Versionen 2.0, 3.0 und 3.5 alle CLR Version 2.0 verwenden.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Möglichkeit, die nicht verwalteten Code aufrufen, wenn Sie eine Instanz eines Delegaten zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für die Fähigkeit zum Durchsuchen von Verzeichnispfaden und ihren Inhalt zu lesen. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name einer Datei, die eine Assembly enthält, in der der Typ mit dem Namen <paramref name="typeName" /> gesucht wird.</param>
        <param name="typeName">Der Name des bevorzugten Typs.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Dies ist üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <summary>Erstellt eine Instanz des Typs mit dem angegebenen Namen unter Verwendung der angegebenen Assemblydatei und des Standardkonstruktors.</summary>
        <returns>Ein Handle, das für den Zugriff auf die neu erstellte Instanz entwrappt werden muss.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> Methode, um den Rückgabewert zu entpacken.  
  
 Informationen zu anderen Ausnahmen, die von aufgerufenen Methoden ausgelöst werden können, finden Sie im Abschnitt "Ausnahmen" von der <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> und <xref:System.Activator.CreateInstance%2A> Methoden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender öffentlicher Konstruktor gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyFile" /> nicht gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MemberAccessException">Eine Instanz einer abstrakten Klasse kann nicht erstellt werden, oder dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Der Konstruktor, der durch Reflektion aufgerufen wurde, hat eine Ausnahme ausgelöst.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> ist kein leeres Array, und der erstellte Typ wird nicht von <see cref="T:System.MarshalByRefObject" /> abgeleitet.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
- oder -  
Die Common Language Runtime (CLR) Version 2.0 oder höher ist derzeit geladen, und <paramref name="assemblyName" /> wurde für eine höhere CLR-Version als die derzeit geladene kompiliert. Beachten Sie, dass die .NET Framework-Versionen 2.0, 3.0 und 3.5 alle CLR Version 2.0 verwenden.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Möglichkeit, die nicht verwalteten Code aufrufen, wenn Sie eine Instanz eines Delegaten zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für die Fähigkeit zum Durchsuchen von Verzeichnispfaden und ihren Inhalt zu lesen. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für den Zugriff auf nicht öffentliche Typen unabhängig von deren Berechtigungssatz. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name einer Datei, die eine Assembly enthält, in der der Typ mit dem Namen <paramref name="typeName" /> gesucht wird.</param>
        <param name="typeName">Der Name des bevorzugten Typs.</param>
        <param name="ignoreCase">
          <see langword="true" />, wenn bei der Suche nach <paramref name="typeName" /> die Groß-/Kleinschreibung nicht beachtet werden soll; <see langword="false" />, wenn bei der Suche die Groß-/Kleinschreibung beachtet werden soll.</param>
        <param name="bindingAttr">Eine Kombination von 0 oder mehr Bitflags, die die Suche nach dem <paramref name="typeName" />-Konstruktor beeinflussen. Wenn <paramref name="bindingAttr" /> 0 ist, wird eine Suche nach öffentlichen Konstruktoren mit Beachtung der Groß-/Kleinschreibung durchgeführt.</param>
        <param name="binder">Ein Objekt, das <paramref name="bindingAttr" /> und <paramref name="args" /> für die Suche und Bestimmung des <paramref name="typeName" />-Konstruktors verwendet. Wenn <paramref name="binder" /> den Wert <see langword="null" /> aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Ein Array von Argumenten, das bezüglich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmt. Wenn <paramref name="args" /> ein leeres Array oder <see langword="null" /> ist, wird der Konstruktor aufgerufen, der keine Parameter akzeptiert, d. h. der Standardkonstruktor.</param>
        <param name="culture">Kulturabhängige Informationen, die die Umwandlung von <paramref name="args" /> in die für den <paramref name="typeName" />-Konstruktor deklarierten formalen Typen bestimmen. Wenn <paramref name="culture" /> den Wert <see langword="null" /> hat, wird die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Dies ist üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <summary>Erstellt eine Instanz des Typs mit dem angegebenen Namen unter Verwendung der angegebenen Assemblydatei und des Konstruktors, der mit den angegebenen Parametern am besten übereinstimmt.</summary>
        <returns>Ein Handle, das für den Zugriff auf die neu erstellte Instanz entwrappt werden muss.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> Methode, um den Rückgabewert zu entpacken.  
  
 Informationen zu anderen Ausnahmen, die von aufgerufenen Methoden ausgelöst werden können, finden Sie im Abschnitt "Ausnahmen" von der <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> und <xref:System.Activator.CreateInstance%2A> Methoden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender Konstruktor gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyFile" /> nicht gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MemberAccessException">Eine Instanz einer abstrakten Klasse kann nicht erstellt werden, oder dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Der Konstruktor, der durch Reflektion aufgerufen wurde, hat eine Ausnahme ausgelöst.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> ist kein leeres Array, und der erstellte Typ wird nicht von <see cref="T:System.MarshalByRefObject" /> abgeleitet.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
- oder -  
Die Common Language Runtime (CLR) Version 2.0 oder höher ist derzeit geladen, und <paramref name="assemblyName" /> wurde für eine höhere CLR-Version als die derzeit geladene kompiliert. Beachten Sie, dass die .NET Framework-Versionen 2.0, 3.0 und 3.5 alle CLR Version 2.0 verwenden.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Möglichkeit, die nicht verwalteten Code aufrufen, wenn Sie eine Instanz eines Delegaten zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für die Fähigkeit zum Durchsuchen von Verzeichnispfaden und ihren Inhalt zu lesen. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für den Zugriff auf nicht öffentliche Typen und Member unabhängig vom entsprechenden Berechtigungssatz. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="domain">Die Remotedomäne, in der der Typ <paramref name="typeName" /> erstellt wird.</param>
        <param name="assemblyFile">Der Name einer Datei, die eine Assembly enthält, in der der Typ mit dem Namen <paramref name="typeName" /> gesucht wird.</param>
        <param name="typeName">Der Name des bevorzugten Typs.</param>
        <param name="ignoreCase">
          <see langword="true" />, wenn bei der Suche nach <paramref name="typeName" /> die Groß-/Kleinschreibung nicht beachtet werden soll; <see langword="false" />, wenn bei der Suche die Groß-/Kleinschreibung beachtet werden soll.</param>
        <param name="bindingAttr">Eine Kombination von 0 oder mehr Bitflags, die die Suche nach dem <paramref name="typeName" />-Konstruktor beeinflussen. Wenn <paramref name="bindingAttr" /> 0 ist, wird eine Suche nach öffentlichen Konstruktoren mit Beachtung der Groß-/Kleinschreibung durchgeführt.</param>
        <param name="binder">Ein Objekt, das <paramref name="bindingAttr" /> und <paramref name="args" /> für die Suche und Bestimmung des <paramref name="typeName" />-Konstruktors verwendet. Wenn <paramref name="binder" /> den Wert <see langword="null" /> aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Ein Array von Argumenten, das bezüglich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmt. Wenn <paramref name="args" /> ein leeres Array oder <see langword="null" /> ist, wird der Konstruktor aufgerufen, der keine Parameter akzeptiert, d. h. der Standardkonstruktor.</param>
        <param name="culture">Kulturabhängige Informationen, die die Umwandlung von <paramref name="args" /> in die für den <paramref name="typeName" />-Konstruktor deklarierten formalen Typen bestimmen. Wenn <paramref name="culture" /> den Wert <see langword="null" /> hat, wird die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Dies ist üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <summary>Erstellt eine Instanz des Typs mit dem in der angegebenen Remotedomäne angegebenen Namen unter Verwendung der angegebenen Assemblydatei und des Konstruktors, der den angegebenen Parametern am besten entspricht.</summary>
        <returns>Ein Handle, das für den Zugriff auf die neu erstellte Instanz entwrappt werden muss.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Activator.CreateInstanceFrom%2A> Wenn ein Host muss zum Ausführen von Code in einer Anwendungsdomäne, die über eingeschränkte Sicherheitsberechtigungen verfügt.  
  
 Verwenden der <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> Methode, um den Rückgabewert zu entpacken.  
  
 Informationen zu anderen Ausnahmen, die von aufgerufenen Methoden ausgelöst werden können, finden Sie in den Abschnitten zu Ausnahmen die <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> und <xref:System.Activator.CreateInstance%2A> Methoden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> oder <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender Konstruktor gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyFile" /> nicht gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MemberAccessException">Eine Instanz einer abstrakten Klasse kann nicht erstellt werden, oder dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Der Konstruktor, der durch Reflektion aufgerufen wurde, hat eine Ausnahme ausgelöst.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> ist kein leeres Array, und der erstellte Typ wird nicht von <see cref="T:System.MarshalByRefObject" /> abgeleitet.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
- oder -  
 <paramref name="assemblyName" /> wurde für eine höhere Version der Common Language Runtime als die derzeit geladene Version kompiliert.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Angeben von Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für die Fähigkeit zum Durchsuchen von Verzeichnispfaden und ihren Inhalt zu lesen. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für den Zugriff auf nicht öffentliche Typen und Member unabhängig vom entsprechenden Berechtigungssatz. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Der Name einer Datei, die eine Assembly enthält, in der der Typ mit dem Namen <paramref name="typeName" /> gesucht wird.</param>
        <param name="typeName">Der Name des bevorzugten Typs.</param>
        <param name="ignoreCase">
          <see langword="true" />, wenn bei der Suche nach <paramref name="typeName" /> die Groß-/Kleinschreibung nicht beachtet werden soll; <see langword="false" />, wenn bei der Suche die Groß-/Kleinschreibung beachtet werden soll.</param>
        <param name="bindingAttr">Eine Kombination von 0 oder mehr Bitflags, die die Suche nach dem <paramref name="typeName" />-Konstruktor beeinflussen. Wenn <paramref name="bindingAttr" /> 0 ist, wird eine Suche nach öffentlichen Konstruktoren mit Beachtung der Groß-/Kleinschreibung durchgeführt.</param>
        <param name="binder">Ein Objekt, das <paramref name="bindingAttr" /> und <paramref name="args" /> für die Suche und Bestimmung des <paramref name="typeName" />-Konstruktors verwendet. Wenn <paramref name="binder" /> den Wert <see langword="null" /> aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Ein Array von Argumenten, das bezüglich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmt. Wenn <paramref name="args" /> ein leeres Array oder <see langword="null" /> ist, wird der Konstruktor aufgerufen, der keine Parameter akzeptiert, d. h. der Standardkonstruktor.</param>
        <param name="culture">Kulturabhängige Informationen, die die Umwandlung von <paramref name="args" /> in die für den <paramref name="typeName" />-Konstruktor deklarierten formalen Typen bestimmen. Wenn <paramref name="culture" /> den Wert <see langword="null" /> hat, wird die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Dies ist üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <param name="securityInfo">Informationen, die bei Entscheidungen bezüglich Sicherheitsrichtlinien und beim Gewähren von Codeberechtigungen herangezogen werden.</param>
        <summary>Erstellt eine Instanz des Typs mit dem angegebenen Namen unter Verwendung der angegebenen Assemblydatei und des Konstruktors, der mit den angegebenen Parametern am besten übereinstimmt.</summary>
        <returns>Ein Handle, das für den Zugriff auf die neu erstellte Instanz entwrappt werden muss.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> Methode, um den Rückgabewert zu entpacken.  
  
 Informationen zu anderen Ausnahmen, die von aufgerufenen Methoden ausgelöst werden können, finden Sie im Abschnitt "Ausnahmen" von der <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> und <xref:System.Activator.CreateInstance%2A> Methoden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender Konstruktor gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyFile" /> nicht gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MemberAccessException">Eine Instanz einer abstrakten Klasse kann nicht erstellt werden, oder dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Der Konstruktor, der durch Reflektion aufgerufen wurde, hat eine Ausnahme ausgelöst.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> ist kein leeres Array, und der erstellte Typ wird nicht von <see cref="T:System.MarshalByRefObject" /> abgeleitet.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
- oder -  
Die Common Language Runtime (CLR) Version 2.0 oder höher ist derzeit geladen, und <paramref name="assemblyName" /> wurde für eine höhere CLR-Version als die derzeit geladene kompiliert. Beachten Sie, dass die .NET Framework-Versionen 2.0, 3.0 und 3.5 alle CLR Version 2.0 verwenden.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">für die Möglichkeit, die nicht verwalteten Code aufrufen, wenn Sie eine Instanz eines Delegaten zu erstellen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für die Fähigkeit zum Durchsuchen von Verzeichnispfaden und ihren Inhalt zu lesen. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für den Zugriff auf nicht öffentliche Typen und Member unabhängig vom entsprechenden Berechtigungssatz. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(class System.AppDomain domain, string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.CreateInstanceFrom(System.AppDomain,System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(AppDomain ^ domain, System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="static member CreateInstanceFrom : AppDomain * string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="System.Activator.CreateInstanceFrom (domain, assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use Evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="domain">Die Remotedomäne, in der der Typ <paramref name="typeName" /> erstellt wird.</param>
        <param name="assemblyFile">Der Name einer Datei, die eine Assembly enthält, in der der Typ mit dem Namen <paramref name="typeName" /> gesucht wird.</param>
        <param name="typeName">Der Name des bevorzugten Typs.</param>
        <param name="ignoreCase">
          <see langword="true" />, wenn bei der Suche nach <paramref name="typeName" /> die Groß-/Kleinschreibung nicht beachtet werden soll; <see langword="false" />, wenn bei der Suche die Groß-/Kleinschreibung beachtet werden soll.</param>
        <param name="bindingAttr">Eine Kombination von 0 oder mehr Bitflags, die die Suche nach dem <paramref name="typeName" />-Konstruktor beeinflussen. Wenn <paramref name="bindingAttr" /> 0 ist, wird eine Suche nach öffentlichen Konstruktoren mit Beachtung der Groß-/Kleinschreibung durchgeführt.</param>
        <param name="binder">Ein Objekt, das <paramref name="bindingAttr" /> und <paramref name="args" /> für die Suche und Bestimmung des <paramref name="typeName" />-Konstruktors verwendet. Wenn <paramref name="binder" /> den Wert <see langword="null" /> aufweist, wird der Standardbinder verwendet.</param>
        <param name="args">Ein Array von Argumenten, das bezüglich Anzahl, Reihenfolge und Typ mit den Parametern des aufzurufenden Konstruktors übereinstimmt. Wenn <paramref name="args" /> ein leeres Array oder <see langword="null" /> ist, wird der Konstruktor aufgerufen, der keine Parameter akzeptiert, d. h. der Standardkonstruktor.</param>
        <param name="culture">Kulturabhängige Informationen, die die Umwandlung von <paramref name="args" /> in die für den <paramref name="typeName" />-Konstruktor deklarierten formalen Typen bestimmen. Wenn <paramref name="culture" /> den Wert <see langword="null" /> hat, wird die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet.</param>
        <param name="activationAttributes">Ein Array mit einem oder mehreren Attributen, die an der Aktivierung beteiligt sein können. Dies ist üblicherweise ein Array, das ein einzelnes <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />-Objekt enthält, das die zum Aktivieren eines Remoteobjekts erforderliche URL angibt.  
  
Der Parameter ist vom Client aktivierten Objekten zugeordnet. Die Clientaktivierung ist eine veraltete Technologie, die zum Zweck der Abwärtskompatibilität mit vorhandenen Anwendungen beibehalten, jedoch nicht für die Neuentwicklung empfohlen wird. Für verteilte Anwendungen sollte stattdessen Windows Communication Foundation verwendet werden.</param>
        <param name="securityAttributes">Informationen, die bei Entscheidungen bezüglich Sicherheitsrichtlinien und beim Gewähren von Codeberechtigungen herangezogen werden.</param>
        <summary>Erstellt eine Instanz des Typs mit dem in der angegebenen Remotedomäne angegebenen Namen unter Verwendung der angegebenen Assemblydatei und des Konstruktors, der den angegebenen Parametern am besten entspricht.</summary>
        <returns>Ein Handle, das für den Zugriff auf die neu erstellte Instanz entwrappt werden muss.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendung <xref:System.Activator.CreateInstanceFrom%2A> Wenn ein Host muss zum Ausführen von Code in einer Anwendungsdomäne, die über eingeschränkte Sicherheitsberechtigungen verfügt.  
  
 Verwenden der <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType> Methode, um den Rückgabewert zu entpacken.  
  
> [!NOTE]
>  Diese Methode verwendet <xref:System.Security.Permissions.SecurityAction.LinkDemand?displayProperty=nameWithType> den unmittelbaren Aufrufer volle Vertrauenswürdigkeit erforderlich ist.  
  
 Informationen zu anderen Ausnahmen, die von aufgerufenen Methoden ausgelöst werden können, finden Sie im Abschnitt "Ausnahmen" von der <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> und <xref:System.Activator.CreateInstance%2A> Methoden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="domain" /> oder <paramref name="typeName" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde kein übereinstimmender Konstruktor gefunden.</exception>
        <exception cref="T:System.TypeLoadException">
          <paramref name="typename" /> wurde in <paramref name="assemblyFile" /> nicht gefunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.MethodAccessException">Der Aufrufer hat keine Berechtigung zum Aufrufen dieses Konstruktors.</exception>
        <exception cref="T:System.MemberAccessException">Eine Instanz einer abstrakten Klasse kann nicht erstellt werden, oder dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Der Konstruktor, der durch Reflektion aufgerufen wurde, hat eine Ausnahme ausgelöst.</exception>
        <exception cref="T:System.Security.SecurityException">Der Aufrufer verfügt nicht über die erforderliche <see cref="T:System.Security.Permissions.FileIOPermission" />.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="activationAttributes" /> ist kein leeres Array, und der erstellte Typ wird nicht von <see cref="T:System.MarshalByRefObject" /> abgeleitet.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> ist keine gültige Assembly.  
  
- oder -  
Die Common Language Runtime (CLR) Version 2.0 oder höher ist derzeit geladen, und <paramref name="assemblyName" /> wurde für eine höhere CLR-Version als die derzeit geladene kompiliert. Beachten Sie, dass die .NET Framework-Versionen 2.0, 3.0 und 3.5 alle CLR Version 2.0 verwenden.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Angeben von Beweisen. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">für die Fähigkeit zum Durchsuchen von Verzeichnispfaden und ihren Inhalt zu lesen. Zugeordnete Enumerationen: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> und <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">für den Zugriff auf nicht öffentliche Typen und Member unabhängig vom entsprechenden Berechtigungssatz. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Erstellt einen Proxy für ein bekanntes Objekt oder einen XML-Webdienst.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (Type type, string url);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObject(class System.Type type, string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.GetObject(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObject(Type ^ type, System::String ^ url);" />
      <MemberSignature Language="F#" Value="static member GetObject : Type * string -&gt; obj" Usage="System.Activator.GetObject (type, url)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des bekannten Objekts, mit dem Sie eine Verbindung herstellen möchten.</param>
        <param name="url">Die URL des bekannten Objekts.</param>
        <summary>Erstellt einen Proxy für das bekannte Objekt, das durch die Angabe von Typ und URL bestimmt wird.</summary>
        <returns>Ein Proxy, der auf einen Endpunkt zeigt, der von dem angeforderten bekannten Objekt unterstützt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie den Proxy zum Senden von Nachrichten an das Remoteobjekt. Bis für den Proxy eine Methode aufgerufen wird, werden keine Nachrichten über das Netzwerk gesendet.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> oder <paramref name="url" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="type" /> wird nicht als Verweis gemarshallt und ist keine Schnittstelle.</exception>
        <exception cref="T:System.MemberAccessException">Dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownObjectMode" />
        <altmember cref="T:System.Runtime.Remoting.RemotingConfiguration" />
      </Docs>
    </Member>
    <Member MemberName="GetObject">
      <MemberSignature Language="C#" Value="public static object GetObject (Type type, string url, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetObject(class System.Type type, string url, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.GetObject(System.Type,System.String,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetObject(Type ^ type, System::String ^ url, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member GetObject : Type * string * obj -&gt; obj" Usage="System.Activator.GetObject (type, url, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ des bekannten Objekts, mit dem Sie eine Verbindung herstellen möchten.</param>
        <param name="url">Die URL des bekannten Objekts.</param>
        <param name="state">Channelspezifische Daten oder <see langword="null" />.</param>
        <summary>Erstellt einen Proxy für das bekannte Objekt, das durch die Angabe von Typ, URL und Channeldaten bestimmt wird.</summary>
        <returns>Ein Proxy, der auf einen Endpunkt zeigt, der von dem angeforderten bekannten Objekt unterstützt wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie den Proxy zum Senden von Nachrichten an das Remoteobjekt. Bis für den Proxy eine Methode aufgerufen wird, werden keine Nachrichten über das Netzwerk gesendet.  
  
 Die `state` Parameter Informationen an den Channel und wird zum Übergeben der <xref:System.Runtime.Remoting.Channels.IChannelSender.CreateMessageSink%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> oder <paramref name="url" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Runtime.Remoting.RemotingException">
          <paramref name="type" /> wird nicht als Verweis gemarshallt und ist keine Schnittstelle.</exception>
        <exception cref="T:System.MemberAccessException">Dieser Member wurde durch einen Mechanismus mit später Bindung aufgerufen.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer. Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</permission>
        <altmember cref="T:System.Runtime.Remoting.WellKnownObjectMode" />
        <altmember cref="T:System.Runtime.Remoting.RemotingConfiguration" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Activator.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Activator.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Activator::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Für zukünftige Verwendung reserviert. Muss IID_NULL sein.</param>
        <param name="rgszNames">Das übergebene Array der zuzuordnenden Namen.</param>
        <param name="cNames">Die Anzahl der zuzuordnenden Namen.</param>
        <param name="lcid">Der Gebietsschemakontext, in dem die Namen interpretiert werden sollen.</param>
        <param name="rgDispId">Das vom Aufrufer zugeordnete Array, das die den Namen entsprechenden IDs empfängt.</param>
        <summary>Ordnet eine Reihe von Namen einer entsprechenden Reihe von Dispatchbezeichnern zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, um verwaltete Klassen, die von nicht verwaltetem Code Zugriff auf und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetIDsOfNames`, finden Sie unter der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Activator.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Activator.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Activator::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Die zurückzugebenden Typinformationen.</param>
        <param name="lcid">Der Gebietsschemabezeichner für die Typinformationen.</param>
        <param name="ppTInfo">Ein Objekt, das einen Zeiger auf das angeforderte Typinformationsobjekt empfängt.</param>
        <summary>Ruft die Typinformationen für ein Objekt ab, die dann zum Abrufen der Typinformationen für eine Schnittstelle verwendet werden können.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, um verwaltete Klassen, die von nicht verwaltetem Code Zugriff auf und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetTypeInfo`, finden Sie unter der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Activator.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Activator.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Activator::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Diese Methode gibt einen Zeiger auf einen Speicherort zurück, der die Anzahl der von dem Objekt bereitgestellten Schnittstellen mit Typinformationen empfängt. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Ruft die Anzahl der Schnittstellen mit Typinformationen ab, die von einem Objekt bereitgestellt werden (0 oder 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, um verwaltete Klassen, die von nicht verwaltetem Code Zugriff auf und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetTypeInfoCount`, finden Sie unter der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Activator.Invoke">
      <MemberSignature Language="C#" Value="void _Activator.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Activator.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Activator.System#Runtime#InteropServices#_Activator#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Activator.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Activator.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Activator::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Activator.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Ein Dispatchbezeichner, der den Member angibt.</param>
        <param name="riid">Für zukünftige Verwendung reserviert. Muss IID_NULL sein.</param>
        <param name="lcid">Der Gebietsschemakontext, in dem Argumente interpretiert werden sollen.</param>
        <param name="wFlags">Flags, die den Kontext des Aufrufs beschreiben.</param>
        <param name="pDispParams">Ein Zeiger auf eine Struktur, die ein Array von Argumenten und ein Array von Argument-DISPIDs für benannte Argumente sowie Zähler für die Anzahl der Elemente in jedem Array enthält.</param>
        <param name="pVarResult">Ein Zeiger auf den Speicherort, an dem das Ergebnis gespeichert werden soll.</param>
        <param name="pExcepInfo">Ein Zeiger auf eine Struktur mit Ausnahmeinformationen.</param>
        <param name="puArgErr">Der Index des ersten Arguments mit einem Fehler.</param>
        <summary>Stellt den Zugriff auf von einem Objekt verfügbar gemachte Eigenschaften und Methoden bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, um verwaltete Klassen, die von nicht verwaltetem Code Zugriff auf und sollte nicht von verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::Invoke`, finden Sie unter der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
  </Members>
</Type>