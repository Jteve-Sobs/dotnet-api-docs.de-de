<Type Name="Double" FullName="System.Double">
  <Metadata><Meta Name="ms.openlocfilehash" Value="9cca51947031d1c00924ff36666a4a51c24b2be2" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82495434" /></Metadata><TypeSignature Language="C#" Value="public struct Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float64&gt;, class System.IConvertible, class System.IEquatable`1&lt;float64&gt;, class System.IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Double" />
  <TypeSignature Language="VB.NET" Value="Public Structure Double&#xA;Implements IComparable, IComparable(Of Double), IConvertible, IEquatable(Of Double), IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public value class Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type double = struct&#xA;    interface IConvertible&#xA;    interface IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="C#" Value="public struct Double : IComparable, IConvertible, IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IConvertible, class System.IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public Structure Double&#xA;Implements IComparable, IConvertible, IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public value class Double : IComparable, IConvertible, IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="F#" Value="type double = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float64&gt;, class System.IConvertible, class System.IEquatable`1&lt;float64&gt;, class System.IFormattable" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C#" Value="public struct Double : IComparable, IComparable&lt;double&gt;, IEquatable&lt;double&gt;, IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float64&gt;, class System.IEquatable`1&lt;float64&gt;, class System.IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="VB.NET" Value="Public Structure Double&#xA;Implements IComparable, IComparable(Of Double), IEquatable(Of Double), IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="C++ CLI" Value="public value class Double : IComparable, IComparable&lt;double&gt;, IEquatable&lt;double&gt;, IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="F#" Value="type double = struct&#xA;    interface IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Gleitkommazahl mit doppelter Genauigkeit dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Double> Werttyp stellt eine 64-Bit-Zahl mit doppelter Genauigkeit dar, deren Werte zwischen negativer 1.79769313486232 E308 und positiv 1.79769313486232 E308 liegen, sowie positive oder negative NULL-Werte, <xref:System.Double.PositiveInfinity>, <xref:System.Double.NegativeInfinity>und keine Zahl (<xref:System.Double.NaN>). Er soll Werte darstellen, die sehr groß sind (z. b. Entfernungen zwischen Planeten oder Galaxien) oder extrem klein sind (z. b. die molekulare Masse eines Stoffs in Kilo Meter) und häufig unpräzise sind (z. b. die Entfernung von der Erde zu einem anderen Sonnensystem). Der <xref:System.Double>-Typ entspricht dem IEC 60559:1989 (IEEE 754)-Standard für binäre Gleit Komma Arithmetik.  
  
 Dieses Thema enthält folgende Abschnitte:  
  
-   [Darstellung und Genauigkeit von Gleit Komma Werten](#Precision)  
  
-   [Testen auf Gleichheit](#Equality)  
  
-   [Gleit Komma Werte und-Ausnahmen](#Exceptions)  
  
-   [Typkonvertierungen und die Double-Struktur](#Conversions)  
  
-   [Gleit Komma Funktionen](#Functionality)  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>Darstellung und Genauigkeit von Gleit Komma Werten  
 Der <xref:System.Double>-Datentyp speichert Gleit Komma Werte mit doppelter Genauigkeit in einem 64-Bit-Binärformat, wie in der folgenden Tabelle dargestellt:  
  
|-Komponente|Bits|  
|----------|----------|  
|Signifikanor oder Mantisse|0-51|  
|Exponent|52-62|  
|Vorzeichen (0 = positiv, 1 = negativ)|63|  
  
 Ebenso wie dezimale Bruchteile einige Bruchzahlen nicht exakt darstellen können (z. b. 1/3 oder <xref:System.Math.PI?displayProperty=nameWithType>), können binäre Bruchteile einige Bruchzahlen nicht darstellen. Beispielsweise wird 1/10, der genau von 1 als Dezimal Bruch dargestellt wird, durch. 001100110011 als binärer Bruchteil dargestellt, wobei das Muster "0011" in unendlich wiederholt wird. In diesem Fall stellt der Gleit Komma Wert eine ungenaue Darstellung der Zahl dar, die er darstellt. Das Ausführen zusätzlicher mathematischer Operationen für den ursprünglichen Gleit Komma Wert neigt häufig dazu, den Mangel an Genauigkeit zu erhöhen. Wenn wir beispielsweise das Ergebnis der Multiplikation von 1 bis 10 und das Addieren von 1 bis 1 9 mal vergleichen, sehen wir, dass das Hinzufügen, da es acht weitere Vorgänge umfasste, das weniger genaue Ergebnis erzeugt hat. Beachten Sie, dass diese Differenz nur offensichtlich ist, wenn die beiden <xref:System.Double> Werte mit der [standardmäßigen numerischen Format Zeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md)"R" angezeigt werden, die bei Bedarf alle 17 Ziffern der Genauigkeit anzeigt, die vom <xref:System.Double>-Typ unterstützt werden.  
  
 [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
 [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
 Da einige Zahlen nicht exakt als binäre Binär Werte dargestellt werden können, können Gleit Komma zahlen nur in Bezug auf reelle Zahlen stehen.  
  
 Alle Gleit Komma Zahlen verfügen auch über eine begrenzte Anzahl signifikanter Ziffern, die außerdem bestimmen, wie genau ein Gleit Komma Wert einer reellen Zahl entspricht.   Ein <xref:System.Double> Wert hat bis zu 15 Dezimalstellen, obwohl intern höchstens 17 Ziffern aufbewahrt werden. Dies bedeutet, dass einige Gleit Komma Vorgänge möglicherweise nicht die Genauigkeit zum Ändern eines Gleit Komma Werts haben. Dies wird im folgenden Beispiel veranschaulicht. Dabei wird ein sehr großer Gleit Komma Wert definiert, und dann wird das Produkt von <xref:System.Double.Epsilon?displayProperty=nameWithType> und einem vierwertigen Wert hinzugefügt. Das Produkt ist jedoch zu klein, um den ursprünglichen Gleit Komma Wert zu ändern. Die am wenigsten bedeutende Ziffer ist Tausendstel, wohingegen die signifikanteste Ziffer im Produkt 10<sup>-309</sup>ist.  
  
 [!code-csharp[System.Double.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation2.cs#4)]
 [!code-vb[System.Double.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation2.vb#4)]  
  
 Die begrenzte Genauigkeit einer Gleit Komma Zahl hat mehrere folgen:  
  
-   Zwei Gleitkommazahlen, die für eine bestimmte Genauigkeit identisch zu sein scheinen, können sich als unterschiedlich erweisen, wenn sich die zwei letzten Ziffern unterscheiden. Im folgenden Beispiel wird eine Reihe von Zahlen addiert, und ihr Gesamtwert wird mit dem erwarteten Gesamtwert verglichen. Obwohl die beiden Werte identisch sind, gibt ein Aufrufder `Equals`-Methode an, dass dies nicht der Fall ist.  
  
     [!code-csharp[System.Double.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Double.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist3.vb#6)]  
  
     Wenn Sie die Format Elemente in der <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> `{1}`-Anweisung von `{0}` ändern und in `{0:R}` und `{1:R}` alle wichtigen Ziffern der beiden <xref:System.Double> Werte anzeigen, ist klar, dass die beiden Werte aufgrund eines Genauigkeits Verlusts bei den Additions Vorgängen ungleich sind. In diesem Fall kann das Problem gelöst werden, indem Sie die <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType>-Methode aufrufen, um die <xref:System.Double> Werte auf die gewünschte Genauigkeit zu runden, bevor Sie den Vergleich durchführen.  
  
-   Eine mathematische oder Vergleichsoperation, die eine Gleit Komma Zahl verwendet, ergibt möglicherweise nicht dasselbe Ergebnis, wenn eine Dezimalzahl verwendet wird, da die binäre Gleit Komma Zahl möglicherweise nicht mit der Dezimalzahl übereinstimmt. Im vorherigen Beispiel wurde dies veranschaulicht, indem das Ergebnis der Multiplikation von 1 bis 10 und das Hinzufügen von. 1 Mal angezeigt wurde.  
  
     Wenn die Genauigkeit in numerischen Vorgängen mit Bruch Werten wichtig ist, können Sie die <xref:System.Decimal> anstelle des <xref:System.Double> Typs verwenden. Wenn die Genauigkeit in numerischen Vorgängen mit ganzzahligen Werten außerhalb des Bereichs der <xref:System.Int64>-oder <xref:System.UInt64> Typen wichtig ist, verwenden Sie den <xref:System.Numerics.BigInteger>-Typ.  
  
-   Ein Wert ist möglicherweise kein Roundtrip, wenn eine Gleit Komma Zahl beteiligt ist. Ein Wert wird als Roundtrip bezeichnet, wenn ein Vorgang eine ursprüngliche Gleit Komma Zahl in ein anderes Format konvertiert, ein umgekehrter Vorgang das konvertierte Formular wieder in eine Gleit Komma Zahl umwandelt und die abschließende Gleit Komma Zahl nicht der ursprünglichen Gleit Komma Zahl entspricht. Der Roundtrip kann fehlschlagen, weil mindestens eine signifikante Ziffer verloren geht oder bei einer Konvertierung geändert wird. Im folgenden Beispiel werden drei <xref:System.Double> Werte in Zeichen folgen konvertiert und in einer Datei gespeichert. Wie die Ausgabe zeigt, sind die wiederhergestellten Werte jedoch nicht mit den ursprünglichen Werten identisch, obwohl die Werte als identisch angezeigt werden.  
  
     [!code-csharp[System.Double.Structure#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist4.cs#7)]
     [!code-vb[System.Double.Structure#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist4.vb#7)]  
  
     In diesem Fall können die Werte erfolgreich mit der [standardmäßigen numerischen Format Zeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md) "G17" abgerundet werden, um die vollständige Genauigkeit <xref:System.Double> Werte beizubehalten, wie im folgenden Beispiel gezeigt.  
  
     [!code-csharp[System.Double.Structure#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist5.cs#8)]
     [!code-vb[System.Double.Structure#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist5.vb#8)]  

   > [!IMPORTANT]
   >  Bei Verwendung mit einem <xref:System.Double> Wert kann der Format Bezeichner "R" in einigen Fällen keinen erfolgreichen Roundtrip für den ursprünglichen Wert durchgeführt werden. Verwenden Sie den Format Bezeichner "G17", um sicherzustellen, dass der Roundtrip für <xref:System.Double>-Werte erfolgreich ist.

-   <xref:System.Single> Werte haben weniger Genauigkeit als <xref:System.Double> Werte. Ein <xref:System.Single> Wert, der in eine scheinbar äquivalente <xref:System.Double> konvertiert wird, ist aufgrund der Unterschiede in der Genauigkeit oft nicht mit dem <xref:System.Double> Wert identisch. Im folgenden Beispiel wird das Ergebnis von identischen Divisions Vorgängen einem <xref:System.Double> und einem <xref:System.Single> Wert zugewiesen. Nachdem der <xref:System.Single> Wert in eine <xref:System.Double>umgewandelt wurde, zeigt ein Vergleich der beiden Werte, dass Sie ungleich sind.  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     Um dieses Problem zu vermeiden, verwenden Sie entweder die <xref:System.Double> anstelle des <xref:System.Single> Datentyps, oder verwenden Sie die <xref:System.Math.Round%2A>-Methode, sodass beide Werte dieselbe Genauigkeit aufweisen.  
  
 Außerdem kann sich das Ergebnis von arithmetischen und Zuweisungs Vorgängen mit <xref:System.Double> Werten aufgrund der Genauigkeits Verluste des <xref:System.Double> Typs leicht durch die Plattform unterscheiden. Das Ergebnis der Zuweisung eines literalen <xref:System.Double> Werts kann sich z. b. in den 32-Bit-und 64-Bit-Versionen des .NET Framework unterscheiden. Im folgenden Beispiel wird dieser Unterschied veranschaulicht, wenn der Literalwert-4.42330604244772 e-305 und eine Variable, deren Wert-4.42330604244772 e-305 ist, einer <xref:System.Double> Variablen zugewiesen werden. Beachten Sie, dass das Ergebnis der <xref:System.Double.Parse%28System.String%29>-Methode in diesem Fall nicht mit einem Genauigkeits Verlust beeinträchtigt wird.  
  
 [!code-csharp[System.Double.Class.Precision#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.class.precision/cs/precision1.cs#1)]
 [!code-vb[System.Double.Class.Precision#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.class.precision/vb/precision1.vb#1)]  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>Testen auf Gleichheit  
 Um als gleich betrachtet zu werden, müssen zwei <xref:System.Double> Werte identische Werte darstellen. Aufgrund von Unterschieden in der Genauigkeit zwischen Werten oder aufgrund eines Genauigkeits Verlusts durch einen oder beide Werte werden Gleit Komma Werte, die als identisch erwartet werden, aufgrund von Unterschieden in den am wenigsten wichtigen Ziffern oft als ungleich fest. Dies führt dazu, dass Aufrufe der-Methode <xref:System.Double.Equals%2A>, um zu bestimmen, ob zwei Werte gleich sind, oder Aufrufe der <xref:System.Double.CompareTo%2A>-Methode, um die Beziehung zwischen zwei <xref:System.Double>-Werten zu ermitteln, oft unerwartete Ergebnisse ergeben. Dies ist im folgenden Beispiel ersichtlich, in dem zwei scheinbar gleich <xref:System.Double> Werte sich als ungleich erweisen, da der erste 15 Ziffern der Genauigkeit aufweist, während der zweite über 17 Zeichen verfügt.  
  
 [!code-csharp[System.Double.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Double.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison1.vb#9)]  
  
 Berechnete Werte, die auf unterschiedliche Codepfade folgen und auf unterschiedliche Weise bearbeitet werden, werden oft als ungleich feststellen. Im folgenden Beispiel ist ein <xref:System.Double> Wert quadratisch, und dann wird die Quadratwurzel berechnet, um den ursprünglichen Wert wiederherzustellen. Ein zweiter <xref:System.Double> wird mit 3,51 und quadriert, bevor die Quadratwurzel des Ergebnisses durch 3,51 geteilt wird, um den ursprünglichen Wert wiederherzustellen. Obwohl die beiden Werte scheinbar identisch sind, gibt ein Aufrufder <xref:System.Double.Equals%28System.Double%29>-Methode an, dass Sie nicht gleich sind. Wenn Sie die Standardformat Zeichenfolge "R" verwenden, um eine Ergebnis Zeichenfolge zurückzugeben, die alle signifikanten Ziffern jedes doppelten Werts anzeigt, wird angezeigt, dass der zweite Wert .0000000000001 kleiner als der erste Wert ist.  
  
 [!code-csharp[System.Double.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Double.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison2.vb#10)]  
  
 In Fällen, in denen sich der Genauigkeits Verlust wahrscheinlich auf das Ergebnis eines Vergleichs auswirkt, können Sie eine der folgenden Alternativen zum Aufrufen der Methode <xref:System.Double.Equals%2A> oder <xref:System.Double.CompareTo%2A> übernehmen:  
  
-   Ruft die <xref:System.Math.Round%2A?displayProperty=nameWithType>-Methode auf, um sicherzustellen, dass beide Werte dieselbe Genauigkeit aufweisen. Im folgenden Beispiel wird ein vorheriges Beispiel dahingehend geändert, dass diese Vorgehensweise verwendet wird, damit zwei Dezimalzahlen gleichwertig sind.  
  
     [!code-csharp[System.Double.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Double.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison3.vb#11)]  
  
     Beachten Sie jedoch, dass das Genauigkeits Problem weiterhin für die Rundung von Mittelpunkt Werten gilt. Weitere Informationen finden Sie unter der Methode <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType>.  
  
-   Testen Sie auf ungefähre Gleichheit anstatt auf Gleichheit. Dies erfordert, dass Sie einen absoluten Betrag definieren, um den sich die beiden Werte unterscheiden können, aber dennoch gleich sind, oder dass Sie einen relativen Betrag definieren, um den der kleinere Wert vom größeren Wert abweichen kann.  
  
    > [!WARNING]
    >  <xref:System.Double.Epsilon?displayProperty=nameWithType> wird manchmal als absolutes Maß der Entfernung zwischen zwei <xref:System.Double> Werten beim Testen auf Gleichheit verwendet.  <xref:System.Double.Epsilon?displayProperty=nameWithType> misst jedoch den kleinsten möglichen Wert, der einem <xref:System.Double>, dessen Wert gleich 0 (null) ist, hinzugefügt oder von diesem subtrahiert werden kann. Bei den meisten positiven und negativen <xref:System.Double> Werten ist der Wert <xref:System.Double.Epsilon?displayProperty=nameWithType> zu klein, um erkannt zu werden. Mit Ausnahme von Werten, die 0 (null) sind, empfiehlt es sich daher nicht, die Verwendung in Tests auf Gleichheit zu übernehmen.  
  
     Im folgenden Beispiel wird der letztere Ansatz verwendet, um eine `IsApproximatelyEqual` Methode zu definieren, die den relativen Unterschied zwischen zwei Werten testet. Außerdem wird das Ergebnis von Aufrufen der `IsApproximatelyEqual`-Methode und der <xref:System.Double.Equals%28System.Double%29>-Methode als gegenübersteht.  
  
     [!code-csharp[System.Double.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Double.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>Gleit Komma Werte und-Ausnahmen  
 Anders als bei Vorgängen mit ganzzahligen Typen, die Ausnahmen bei Überlauf-oder unzulässigen Vorgängen auslösen, wie z. b. Division durch Null, lösen Vorgänge mit Gleit Komma Werten keine Ausnahmen aus. Stattdessen ist in Ausnahmefällen das Ergebnis einer Gleit Komma Operation 0 (null), positiv unendlich, minus unendlich oder keine Zahl (NaN):  
  
-   Wenn das Ergebnis einer Gleit Komma Operation für das Zielformat zu klein ist, ist das Ergebnis 0 (null). Dies kann vorkommen, wenn zwei sehr kleine Zahlen multipliziert werden, wie im folgenden Beispiel gezeigt.  
  
     [!code-csharp[System.Double.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Double.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional1.vb#1)]  
  
-   Wenn die Größe des Ergebnisses einer Gleit Komma Operation den Bereich des Ziel Formats überschreitet, wird das Ergebnis des Vorgangs <xref:System.Double.PositiveInfinity> oder <xref:System.Double.NegativeInfinity>, was für das Vorzeichen des Ergebnisses geeignet ist. Das Ergebnis eines Vorgangs, der einen Überlauf verursacht <xref:System.Double.MaxValue?displayProperty=nameWithType> ist <xref:System.Double.PositiveInfinity>, und das Ergebnis eines Vorgangs, der <xref:System.Double.MinValue?displayProperty=nameWithType> über läuft, ist <xref:System.Double.NegativeInfinity>, wie im folgenden Beispiel gezeigt.  
  
     [!code-csharp[System.Double.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Double.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Double.PositiveInfinity> auch Ergebnisse aus einer Division durch 0 (null) mit einer positiven Dividende und <xref:System.Double.NegativeInfinity> Ergebnisse aus einer Division durch 0 (null) mit einer negativen Dividende.  
  
-   Wenn ein Gleit Komma Vorgang ungültig ist, wird das Ergebnis des Vorgangs <xref:System.Double.NaN>. <xref:System.Double.NaN> z. b. die Ergebnisse der folgenden Vorgänge:  
  
    -   Division durch 0 (null) mit einer Dividende von NULL. Beachten Sie, dass andere Fälle der Division durch Null entweder zu <xref:System.Double.PositiveInfinity> oder <xref:System.Double.NegativeInfinity>führen.  
  
-   Eine beliebige Gleit Komma Operation mit einer ungültigen Eingabe. Wenn Sie z. b. die <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>-Methode mit einem negativen Wert aufrufen, wird <xref:System.Double.NaN>zurückgegeben, ebenso wie das Aufrufen der <xref:System.Math.Acos%2A?displayProperty=nameWithType>-Methode mit einem Wert, der größer als 1 oder kleiner als minus eins ist.  
  
-   Jeder Vorgang mit einem Argument, dessen Wert <xref:System.Double.NaN?displayProperty=nameWithType>ist.  
  
<a name="Conversions"></a>   
## <a name="type-conversions-and-the-double-structure"></a>Typkonvertierungen und die Double-Struktur  
 Die <xref:System.Double> Struktur definiert keine expliziten oder impliziten Konvertierungs Operatoren. Stattdessen werden Konvertierungen vom Compiler implementiert.  
  
 Die Konvertierung des Werts eines beliebigen primitiven numerischen Typs in eine <xref:System.Double> ist eine erweiternde Konvertierung und erfordert daher keinen expliziten Umwandlungs Operator oder einen aufzurufenden Umwandlungs Methode, es sei denn, ein Compiler erfordert dies explizit. Der C# Compiler benötigt z. b. einen Umwandlungs Operator für Konvertierungen von <xref:System.Decimal> in <xref:System.Double>, während der Visual Basic Compiler dies nicht tut. Im folgenden Beispiel wird der minimale oder maximale Wert anderer primitiver numerischer Typen in eine <xref:System.Double>konvertiert.  
  
 [!code-csharp[System.Double.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert1.cs#20)]
 [!code-vb[System.Double.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert1.vb#20)]  
  
 Außerdem werden die <xref:System.Single> Werte <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>und <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> in <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>bzw. <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>konvertiert.  
  
 Beachten Sie, dass die Konvertierung des Werts einiger numerischer Typen in einen <xref:System.Double> Wert einen Genauigkeits Verlust beinhalten kann. Wie das Beispiel veranschaulicht, ist ein Genauigkeits Verlust möglich, wenn <xref:System.Decimal>-, <xref:System.Int64>-, <xref:System.Single>-und <xref:System.UInt64>-Werte in <xref:System.Double> Werte umgerechnet werden.  
  
 Die Konvertierung eines <xref:System.Double> Werts in einen Wert eines beliebigen anderen primitiven numerischen Datentyps ist eine einschränkende Konvertierung und erfordert einen Cast Operator C#(in), eine Konvertierungsmethode (in Visual Basic) oder einen-aufrufungs-<xref:System.Convert> Methode. Werte, die sich außerhalb des Bereichs des Ziel Datentyps befinden, der durch die Eigenschaften `MinValue` und `MaxValue` des Zieltyps definiert wird, Verhalten sich wie in der folgenden Tabelle gezeigt.  
  
|Zieltyp|Ergebnis|  
|-----------------|------------|  
|Beliebige ganzzahlige Typen|Eine <xref:System.OverflowException> Ausnahme, wenn die Konvertierung in einem überprüften Kontext erfolgt.<br /><br /> Wenn die Konvertierung in einem nicht überprüften Kontext erfolgt (der C#Standardwert in), wird der Konvertierungs Vorgang erfolgreich ausgeführt, der Wert wird jedoch überlaufen.|  
|<xref:System.Decimal>|Eine <xref:System.OverflowException>-Ausnahme.|  
|<xref:System.Single>|<xref:System.Single.NegativeInfinity?displayProperty=nameWithType> für negative Werte.<br /><br /> <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> für positive Werte.|  
  
 <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>und <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> lösen außerdem eine <xref:System.OverflowException> für Konvertierungen in ganze Zahlen in einem überprüften Kontext aus, diese Werte überschreiten jedoch bei der Konvertierung in ganze Zahlen in einem nicht überprüften Kontext einen Überlauf. Bei Konvertierungen in <xref:System.Decimal>wird immer ein <xref:System.OverflowException>ausgelöst. Konvertierung in <xref:System.Single>, sie konvertieren in <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, und <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>bzw.  
  
 Beachten Sie, dass ein Genauigkeits Verlust möglicherweise durch die <xref:System.Double>-Wert in einen anderen numerischen Typ verursacht wird. Wenn nicht integrale <xref:System.Double> Werte konvertiert werden, wie die Ausgabe des Beispiels zeigt, geht die Dezimalstelle verloren, wenn der <xref:System.Double> Wert entweder gerundet wird (wie in Visual Basic) oder abgeschnitten wird (wie in C#). Bei Konvertierungen in <xref:System.Decimal> und <xref:System.Single> Werte hat der <xref:System.Double> Wert möglicherweise keine genaue Darstellung im Ziel Datentyp.  
  
 Im folgenden Beispiel wird eine Anzahl von <xref:System.Double> Werten in mehrere andere numerische Typen konvertiert. Die Konvertierungen erfolgen in einem überprüften Kontext in Visual Basic (Standardeinstellung) C# und in (aufgrund des [geprüften](~/docs/csharp/language-reference/keywords/checked.md) Schlüssel Worts). Die Ausgabe aus dem Beispiel zeigt das Ergebnis für Konvertierungen in einem überprüften, nicht überprüften Kontext. Sie können Konvertierungen in einem nicht überprüften Kontext in Visual Basic ausführen, indem Sie mit dem `/removeintchecks+` C# -Compilerschalter und in durch Kompilieren der `checked`-Anweisung kompilieren.  
  
 [!code-csharp[System.Double.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert2.cs#21)]
 [!code-vb[System.Double.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert2.vb#21)]  
  
 Weitere Informationen zur Konvertierung numerischer Typen finden Sie unter [Typkonvertierung in den .NET Framework](~/docs/standard/base-types/type-conversion.md) -und [Typkonvertierungs Tabellen](~/docs/standard/base-types/conversion-tables.md).  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>Gleit Komma Funktionen  
 Die <xref:System.Double> Struktur und verwandte Typen bieten Methoden zum Ausführen von Vorgängen in den folgenden Bereichen:  
  
-   **Vergleich von-Werten**. Sie können die <xref:System.Double.Equals%2A>-Methode aufzurufen, um zu bestimmen, ob zwei <xref:System.Double> Werte gleich sind, oder die <xref:System.Double.CompareTo%2A>-Methode, um die Beziehung zwischen zwei Werten zu bestimmen.  
  
     Die <xref:System.Double>-Struktur unterstützt auch einen kompletten Satz von Vergleichs Operatoren. Beispielsweise können Sie auf Gleichheit oder Ungleichheit testen oder feststellen, ob ein Wert größer oder gleich einem anderen Wert ist. Wenn einer der Operanden ein numerischer Typ ist, der kein <xref:System.Double>ist, wird er vor der Durchführung des Vergleichs in eine <xref:System.Double> konvertiert.  
  
    > [!WARNING]
    >  Aufgrund von Unterschieden in der Genauigkeit können zwei <xref:System.Double> Werte, die erwartet werden, sich als ungleich erweisen. Dies wirkt sich auf das Ergebnis des Vergleichs aus. Weitere Informationen zum Vergleichen von zwei <xref:System.Double> Werten finden Sie im Abschnitt [Tests für Gleichheit](#Equality) .  
  
     Sie können auch die Methoden <xref:System.Double.IsNaN%2A>, <xref:System.Double.IsInfinity%2A>, <xref:System.Double.IsPositiveInfinity%2A>und <xref:System.Double.IsNegativeInfinity%2A> aufzurufen, um diese speziellen Werte zu testen.  
  
-   **Mathematische Vorgänge**. Gängige arithmetische Operationen, z. b. Addition, Subtraktion, Multiplikation und Division, werden von sprach Compilern und Common Intermediate Language-Anweisungen (CIL) implementiert, nicht durch <xref:System.Double> Methoden. Wenn einer der Operanden in einer mathematischen Operation ein numerischer Typ ist, der kein <xref:System.Double>ist, wird er vor dem Ausführen des Vorgangs in eine <xref:System.Double> konvertiert. Das Ergebnis des Vorgangs ist ebenfalls ein <xref:System.Double> Wert.  
  
     Andere mathematische Vorgänge können durch Aufrufen von `static` (`Shared` in Visual Basic)-Methoden in der <xref:System.Math?displayProperty=nameWithType>-Klasse ausgeführt werden. Sie enthält zusätzliche Methoden, die häufig für arithmetische (z. b. <xref:System.Math.Abs%2A?displayProperty=nameWithType>, <xref:System.Math.Sign%2A?displayProperty=nameWithType>und <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>), Geometrie (z. b. <xref:System.Math.Cos%2A?displayProperty=nameWithType> und <xref:System.Math.Sin%2A?displayProperty=nameWithType>) und Berechnungen (z. b. <xref:System.Math.Log%2A?displayProperty=nameWithType>) verwendet werden.  
  
     Sie können auch die einzelnen Bits in einem <xref:System.Double> Wert bearbeiten. Die <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType>-Methode behält das Bitmuster eines <xref:System.Double> Werts in einer 64-Bit-Ganzzahl. Die <xref:System.BitConverter.GetBytes%28System.Double%29?displayProperty=nameWithType>-Methode gibt das Bitmuster in einem Bytearray zurück.  
  
-   **Rundung**. Die Rundung wird häufig als Technik zum Verringern der Auswirkung von Unterschieden zwischen Werten verwendet, die durch Probleme mit der Gleit Komma Darstellung und-Genauigkeit verursacht werden. Sie können einen <xref:System.Double> Wert Runden, indem Sie die <xref:System.Math.Round%2A?displayProperty=nameWithType>-Methode aufrufen.  
  
-   **Formatierung**. Sie können einen <xref:System.Double> Wert in seine Zeichen folgen Darstellung konvertieren, indem Sie die <xref:System.Double.ToString%2A>-Methode aufrufen oder die Funktion für die kombinierte Formatierung verwenden. Informationen dazu, wie Format Zeichenfolgen die Zeichen folgen Darstellung von Gleit Komma Werten steuern, finden Sie in den Themen [Standard Format](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen für Zahlen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md) Zeichenfolgen.  
  
-   Zeichen folgen werden **verarbeitet.** Sie können die Zeichen folgen Darstellung eines Gleit Komma Werts in einen <xref:System.Double> Wert konvertieren, indem Sie entweder die <xref:System.Double.Parse%2A>-Methode oder die <xref:System.Double.TryParse%2A>-Methode aufrufen. Wenn der Analyse Vorgang fehlschlägt, löst die <xref:System.Double.Parse%2A> Methode eine Ausnahme aus, während die <xref:System.Double.TryParse%2A> Methode `false`zurückgibt.  
  
-   **Typkonvertierung**. Die <xref:System.Double>-Struktur stellt eine explizite Schnittstellen Implementierung für die <xref:System.IConvertible>-Schnittstelle bereit, die die Konvertierung zwischen zwei Datentypen vom Typ Standard .NET Framework unterstützt. Sprach Compiler unterstützen auch die implizite Konvertierung von Werten aller anderen numerischen Standardtypen in <xref:System.Double> Werte. Die Konvertierung eines Werts eines beliebigen standardmäßigen numerischen Typs in eine <xref:System.Double> ist eine erweiternde Konvertierung und erfordert nicht den Benutzer eines Umwandlungs Operators oder einer Konvertierungsmethode.  
  
     Die Konvertierung von <xref:System.Int64>-und <xref:System.Single>-Werten kann jedoch einen Genauigkeits Verlust beinhalten. In der folgenden Tabelle sind die Unterschiede in der Genauigkeit für die einzelnen Typen aufgeführt:  
  
    |Typ|Maximale Genauigkeit|Interne Genauigkeit|  
    |----------|-----------------------|------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int64>|19 Dezimalziffern|19 Dezimalziffern|  
    |<xref:System.Single>|7 Dezimalziffern|9 Dezimalziffern|  
  
     Das Problem der Genauigkeit wirkt sich am häufigsten auf <xref:System.Single> Werte aus, die in <xref:System.Double> Werte konvertiert werden. Im folgenden Beispiel sind zwei Werte, die von identischen Divisions Vorgängen erzeugt werden, ungleich, da einer der-Werte ein Gleit Komma Wert mit einfacher Genauigkeit ist, der in einen <xref:System.Double>konvertiert wird.  
  
     [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
     [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung von <xref:System.Double>veranschaulicht:  
  
 [!code-cpp[Double Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#1)]
 [!code-csharp[Double Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#1)]
 [!code-vb[Double Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle Member dieses Typs sind Thread sicher. Member, die scheinbar den Instanzzustand ändern, geben tatsächlich eine neue Instanz zurück, die mit dem neuen Wert initialisiert wurde. Wie bei jedem anderen Typ muss das Lesen und Schreiben in eine freigegebene Variable, die eine Instanz dieses Typs enthält, durch eine Sperre geschützt werden, um die Thread Sicherheit zu gewährleisten.</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Single" />
    <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/winforms-formatting-utility-cs/">Beispiel: .net Core-Hilfsprogramm zur FormatierungC#von WinForms ()</related>
    <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/winforms-formatting-utility-vb/">Beispiel: .net Core-Hilfsprogramm für die WinForms-Formatierung (Visual Basic)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt oder einem <see cref="T:System.Double" />-Objekt und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert des angegebenen Objekts bzw. des <see cref="T:System.Double" />-Objekts ist oder mit diesem übereinstimmt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Double) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(double value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : double -&gt; int&#xA;override this.CompareTo : double -&gt; int" Usage="double.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Eine Gleitkommazahl mit doppelter Genauigkeit, mit der der Vergleich erfolgen soll.</param>
        <summary>Vergleicht diese Instanz mit einer angegebenen Gleitkommazahl mit doppelter Genauigkeit und gibt eine Ganzzahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert der angegebenen Gleitkommazahl mit doppelter Genauigkeit ist oder mit dieser übereinstimmt.</summary>
        <returns>Eine Zahl mit Vorzeichen, die das Verhältnis zwischen dem Wert dieser Instanz und <paramref name="value" /> angibt.  
  
 <list type="table"><listheader><term> Rückgabewert 
 </term><description> Beschreibung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Diese Instanz ist kleiner als <paramref name="value" />.  
  
- oder - 
Diese Instanz ist keine Zahl (<see cref="F:System.Double.NaN" />), und <paramref name="value" /> ist eine Zahl.  
  
 </description></item><item><term> Null 
 </term><description> Diese Instanz ist gleich <paramref name="value" />.  
  
- oder - 
Sowohl diese Instanz als auch <paramref name="value" /> sind keine Zahl (<see cref="F:System.Double.NaN" />), <see cref="F:System.Double.PositiveInfinity" />, oder <see cref="F:System.Double.NegativeInfinity" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Diese Instanz ist größer als <paramref name="value" />.  
  
- oder - 
Diese Instanz ist eine Zahl, und <paramref name="value" /> ist keine Zahl (<see cref="F:System.Double.NaN" />).  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Werte müssen identisch sein, damit Sie als gleich betrachtet werden. Insbesondere wenn Gleit Komma Werte von mehreren mathematischen Operationen abhängen, ist es üblich, dass Sie Genauigkeit verlieren und ihre Werte nahezu identisch sind, mit Ausnahme der am wenigsten signifikanten Ziffern. Aus diesem Grund mag der Rückgabewert der <xref:System.Double.CompareTo%2A>-Methode zu Zeiten überraschend erscheinen. Beispielsweise sollte die Multiplikation mit einem bestimmten Wert, gefolgt von der Division durch denselben Wert, den ursprünglichen Wert ergeben. Im folgenden Beispiel erweist sich der berechnete Wert jedoch als größer als der ursprüngliche Wert. Wenn alle signifikanten Ziffern der beiden Werte mithilfe der [standardmäßigen numerischen Format Zeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md) "R" angezeigt werden, wird angegeben, dass der berechnete Wert vom ursprünglichen Wert in den geringsten Ziffern abweicht. Informationen zur Behandlung solcher Vergleiche finden Sie im Abschnitt "Hinweise" der <xref:System.Double.Equals%28System.Double%29>-Methode.  
  
 [!code-csharp[System.Double.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Double.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto2.vb#1)]  
  
 Diese Methode implementiert die <xref:System.IComparable%601?displayProperty=nameWithType>-Schnittstelle und bietet eine etwas bessere Leistung als die <xref:System.Double.CompareTo%2A?displayProperty=nameWithType>-Methode, da der `value`-Parameter nicht in ein-Objekt konvertiert werden muss.  
  
 Beachten Sie, dass ein Objekt, dessen Wert <xref:System.Double.NaN> ist, nicht gleich einem anderen Objekt ist, dessen Wert <xref:System.Double.NaN> (selbst) ist, die <xref:System.IComparable%601>-Schnittstelle erfordert, dass `A.CompareTo(A)` 0 (null) zurückgibt.  
  
## <a name="widening-conversions"></a>Erweiternde Konvertierungen  
 Abhängig von ihrer Programmiersprache kann es möglich sein, eine <xref:System.Double.CompareTo%2A> Methode zu codieren, bei der der Parametertyp weniger Bits (ist schmaler) als der Instanztyp aufweist. Dies ist möglich, weil einige Programmiersprachen eine implizite erweiternde Konvertierung durchführen, die den Parameter als Typ mit so vielen Bits wie die Instanz darstellt.  
  
 Angenommen, der Instanztyp ist <xref:System.Double>, und der Parametertyp ist <xref:System.Int32>. Der Microsoft C# -Compiler generiert Anweisungen, um den Wert des Parameters als <xref:System.Double> Objekt darzustellen, und generiert dann eine <xref:System.Double.CompareTo%28System.Double%29?displayProperty=nameWithType> Methode, die die Werte der Instanz und die erweiterte Darstellung des Parameters vergleicht.  
  
 Überprüfen Sie die Dokumentation der Programmiersprache, um zu bestimmen, ob der Compiler implizite erweiternde Konvertierungen numerischer Typen durchführt. Weitere Informationen finden Sie im Thema [Typkonvertierungs Tabellen](~/docs/standard/base-types/conversion-tables.md) .  
  
## <a name="precision-in-comparisons"></a>Genauigkeit in vergleichen  
 Die Genauigkeit von Gleit Komma Zahlen jenseits der dokumentierten Genauigkeit ist spezifisch für die Implementierung und die Version der .NET Framework. Folglich kann sich ein Vergleich zweier bestimmter Zahlen zwischen den Versionen der .NET Framework ändern, da sich die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden generische und nicht generische Versionen der <xref:System.Double.CompareTo%2A>-Methode für verschiedene Wert-und Verweis Typen veranschaulicht.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="double.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">Ein Vergleichsobjekt oder <see langword="null" />.</param>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert des angegebenen Objekts ist oder mit diesem übereinstimmt.</summary>
        <returns>Eine Zahl mit Vorzeichen, die das Verhältnis zwischen dem Wert dieser Instanz und <paramref name="value" /> angibt.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Beschreibung 
 </description></listheader><item><term> Eine negative ganze Zahl 
 </term><description> Diese Instanz ist kleiner als <paramref name="value" />.  
  
- oder - 
Diese Instanz ist keine Zahl (<see cref="F:System.Double.NaN" />), und <paramref name="value" /> ist eine Zahl.  
  
 </description></item><item><term> Null 
 </term><description> Diese Instanz ist gleich <paramref name="value" />.  
  
- oder - 
Diese Instanz und <paramref name="value" /> sind beide <see langword="Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" /> oder <see cref="F:System.Double.NegativeInfinity" /></description></item><item><term> Positive Ganzzahl 
 </term><description> Diese Instanz ist größer als <paramref name="value" />.  
  
- oder - 
Diese Instanz ist eine Zahl, und <paramref name="value" /> ist keine Zahl (<see cref="F:System.Double.NaN" />).  
  
- oder - 
 <paramref name="value" /> ist <see langword="null" />  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `value`-Parameter muss `null` oder eine Instanz von `Double`sein. Andernfalls wird eine Ausnahme ausgelöst. Jede Instanz von <xref:System.Double>unabhängig von ihrem Wert als größer als `null`.  
  
 Werte müssen identisch sein, damit Sie als gleich betrachtet werden. Insbesondere wenn Gleit Komma Werte von mehreren mathematischen Operationen abhängen, ist es üblich, dass Sie Genauigkeit verlieren und ihre Werte nahezu identisch sind, mit Ausnahme der am wenigsten signifikanten Ziffern. Aus diesem Grund mag der Rückgabewert der <xref:System.Double.CompareTo%2A>-Methode zu Zeiten überraschend erscheinen. Beispielsweise sollte die Multiplikation mit einem bestimmten Wert, gefolgt von der Division durch denselben Wert, den ursprünglichen Wert ergeben. Im folgenden Beispiel erweist sich der berechnete Wert jedoch als größer als der ursprüngliche Wert. Wenn alle signifikanten Ziffern der beiden Werte mithilfe der [standardmäßigen numerischen Format Zeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md) "R" angezeigt werden, wird angegeben, dass der berechnete Wert vom ursprünglichen Wert in den geringsten Ziffern abweicht. Informationen zur Behandlung solcher Vergleiche finden Sie im Abschnitt "Hinweise" der <xref:System.Double.Equals%28System.Double%29>-Methode.  
  
 [!code-csharp[System.Double.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Double.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto3.vb#2)]  
  
 Diese Methode wird implementiert, um die <xref:System.IComparable>-Schnittstelle zu unterstützen. Beachten Sie Folgendes: Obwohl eine <xref:System.Double.NaN> nicht als gleich einer anderen <xref:System.Double.NaN> betrachtet wird, erfordert die <xref:System.IComparable>-Schnittstelle, dass `A.CompareTo(A)` 0 (null) zurückgibt.  
  
## <a name="precision-in-comparisons"></a>Genauigkeit in vergleichen  
 Die Genauigkeit von Gleit Komma Zahlen jenseits der dokumentierten Genauigkeit ist spezifisch für die Implementierung und die Version der .NET Framework. Folglich kann sich ein Vergleich zweier bestimmter Zahlen zwischen den Versionen der .NET Framework ändern, da sich die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung von `CompareTo` im Zusammenhang mit `Double`veranschaulicht.  
  
 [!code-cpp[System.Double#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#16)]
 [!code-csharp[System.Double#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#16)]
 [!code-vb[System.Double#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> ist keine <see cref="T:System.Double" />.</exception>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 Epsilon = float64(4.94065645841247E-324)" />
      <MemberSignature Language="DocId" Value="F:System.Double.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Double  = 4.94065645841247E-324" />
      <MemberSignature Language="C++ CLI" Value="public: double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="F#" Value="val mutable Epsilon : double" Usage="System.double.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>4.94065645841247E-324</MemberValue>
      <Docs>
        <summary>Stellt den kleinsten positiven <see cref="T:System.Double" />-Wert dar, der größer als 0 (null) ist. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert der <xref:System.Double.Epsilon>-Eigenschaft gibt den kleinsten positiven <xref:System.Double> Wert wieder, der bei numerischen Vorgängen oder Vergleichen von Bedeutung ist, wenn der Wert der <xref:System.Double> Instanz 0 (null) ist. Der folgende Code zeigt z. b., dass NULL und <xref:System.Double.Epsilon> als ungleich Werte angesehen werden, wohingegen NULL und die Hälfte des Werts <xref:System.Double.Epsilon> als gleich betrachtet werden.  
  
 [!code-csharp[System.Double.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Double.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon.vb#5)]  
  
 Genauer gesehen besteht das Gleit Komma Format aus einem Vorzeichen, einer 52-Bit-Mantisse oder signifikanund einem 11-Bit-Exponenten. Wie das folgende Beispiel zeigt, hat null einen Exponenten von-1022 und eine Mantisse von 0. <xref:System.Double.Epsilon> hat einen Exponenten von-1022 und eine Mantisse von 1. Dies bedeutet, dass <xref:System.Double.Epsilon> der kleinste positive <xref:System.Double> Wert größer als 0 (null) ist und den kleinsten möglichen Wert und das kleinste mögliche Inkrement für einen <xref:System.Double> darstellt, dessen Exponent-1022 ist.  
  
 [!code-csharp[System.Double.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Double.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon1.vb#6)]  
  
 Die <xref:System.Double.Epsilon>-Eigenschaft ist jedoch kein allgemeines Maß für die Genauigkeit des <xref:System.Double> Typs. Dies gilt nur für <xref:System.Double> Instanzen, die den Wert 0 (null) oder einen Exponenten von-1022 aufweisen.  
  
> [!NOTE]
>  Der Wert der <xref:System.Double.Epsilon>-Eigenschaft entspricht nicht dem Computer Epsilon, der die obere Grenze des relativen Fehlers darstellt, weil die Gleit Komma Arithmetik gerundet wird.  
  
 Der Wert dieser Konstante ist 94065645841247E e-324.  
  
 Zwei scheinbar äquivalente Gleit Komma Zahlen können aufgrund von Unterschieden in den geringsten Ziffern nicht gleich sein. Beispielsweise vergleicht der C# Ausdruck `(double)1/3 == (double)0.33333`nicht gleich, da der Divisions Vorgang auf der linken Seite eine maximale Genauigkeit aufweist, während die Konstante auf der rechten Seite nur für die angegebenen Ziffern präzise ist. Wenn Sie einen benutzerdefinierten Algorithmus erstellen, der bestimmt, ob zwei Gleit Komma Zahlen als gleich betrachtet werden können, wird nicht empfohlen, dass Sie den Algorithmus auf dem Wert der <xref:System.Double.Epsilon> Konstante basieren, um die akzeptable absolute Differenz Spanne für die beiden Werte festzulegen, die als gleich betrachtet werden sollen.  (In der Regel ist dieser Unterschieds Unterschied oft größer als <xref:System.Double.Epsilon>.) Weitere Informationen zum Vergleichen von zwei Gleit Komma Werten mit doppelter Genauigkeit finden Sie unter <xref:System.Double> und <xref:System.Double.Equals%28System.Double%29>.  
  
## <a name="platform-notes"></a>Hinweise zur Plattform  
 Auf ARM-Systemen ist der Wert der <xref:System.Double.Epsilon> Konstante zu klein, um erkannt zu werden, sodass er 0 (null) entspricht. Sie können stattdessen einen alternativen Epsilon-Wert definieren, der 2.2250738585072014 e-308 gleich ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei Instanzen der <see cref="T:System.Double" />-Struktur denselben Wert darstellen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (double obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float64 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(double obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : double -&gt; bool" Usage="double.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Ein mit dieser Instanz zu vergleichendes <see cref="T:System.Double" />-Objekt.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz und ein angegebenes <see cref="T:System.Double" />-Objekt den gleichen Wert darstellen.</summary>
        <returns><see langword="true" />, wenn <paramref name="obj" /> gleich dieser Instanz ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode implementiert die <xref:System.IEquatable%601?displayProperty=nameWithType>-Schnittstelle und bietet eine etwas bessere Leistung als <xref:System.Double.Equals%2A>, da der `obj`-Parameter nicht in ein-Objekt konvertiert werden muss.  
  
## <a name="widening-conversions"></a>Erweiternde Konvertierungen  
 Abhängig von ihrer Programmiersprache kann es möglich sein, eine <xref:System.Double.Equals%2A> Methode zu codieren, bei der der Parametertyp weniger Bits (ist schmaler) als der Instanztyp aufweist. Dies ist möglich, weil einige Programmiersprachen eine implizite erweiternde Konvertierung durchführen, die den Parameter als Typ mit so vielen Bits wie die Instanz darstellt.  
  
 Angenommen, der Instanztyp ist <xref:System.Double>, und der Parametertyp ist <xref:System.Int32>. Der Microsoft C# -Compiler generiert Anweisungen, um den Wert des Parameters als <xref:System.Double> Objekt darzustellen, und generiert dann eine <xref:System.Double.Equals%28System.Double%29?displayProperty=nameWithType> Methode, die die Werte der Instanz und die erweiterte Darstellung des Parameters vergleicht.  
  
 Überprüfen Sie die Dokumentation der Programmiersprache, um zu bestimmen, ob der Compiler implizite erweiternde Konvertierungen numerischer Typen durchführt. Weitere Informationen finden Sie im Thema [Typkonvertierungs Tabellen](~/docs/standard/base-types/conversion-tables.md) .  
  
## <a name="precision-in-comparisons"></a>Genauigkeit in vergleichen  
 Die <xref:System.Double.Equals%2A>-Methode sollte mit Bedacht verwendet werden, da zwei scheinbar äquivalente Werte aufgrund der unterschiedlichen Genauigkeit der beiden Werte ungleich sein können. Im folgenden Beispiel wird berichtet, dass der <xref:System.Double> Wert. 333333 und der <xref:System.Double> Wert, der durch Division von 1 durch 3 zurückgegeben wurde, ungleich sind.  
  
 [!code-csharp[System.Double.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#1)]
 [!code-vb[System.Double.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#1)]  
  
 Anstatt Vergleich, Gleichheit, eine Technik wird eine akzeptable relative Rand Unterschied zwischen zwei Werten definieren (z. B. 001 % einer der Werte). Wenn der absolute Wert des Unterschieds zwischen den beiden Werten kleiner oder gleich diesem Rand ist, ist der Unterschied wahrscheinlich auf Unterschiede bei der Genauigkeit zurückzuführen, und daher sind die Werte wahrscheinlich gleich. Im folgenden Beispiel wird diese Technik zum Vergleichen von. 33333 und 1/3 verwendet, die beiden <xref:System.Double> Werte, die im vorherigen Codebeispiel als ungleich festgestellt wurden. In diesem Fall sind die Werte gleich.  
  
 [!code-csharp[System.Double.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#2)]
 [!code-vb[System.Double.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#2)]  
  
> [!NOTE]
>  Da <xref:System.Double.Epsilon> den minimalen Ausdruck eines positiven Werts definiert, dessen Bereich nahe Null ist, muss der Rand der Differenz zwischen zwei ähnlichen Werten größer als <xref:System.Double.Epsilon>sein. In der Regel ist es oft größer als <xref:System.Double.Epsilon>. Aus diesem Grund wird empfohlen, dass Sie beim Vergleichen <xref:System.Double> Werte auf Gleichheit <xref:System.Double.Epsilon> nicht verwenden.  
  
 Eine zweite Methode besteht darin, den Unterschied zwischen zwei Gleit Komma Zahlen mit einem absoluten Wert zu vergleichen. Wenn die Differenz kleiner oder gleich dem absoluten Wert ist, sind die Zahlen gleich. Wenn Sie größer ist, sind die Zahlen nicht gleich. Eine Alternative besteht darin, willkürlich einen absoluten Wert auszuwählen. Dies ist jedoch problematisch, da eine akzeptable Differenz Spanne von der Größe der <xref:System.Double> Werte abhängig ist. Eine zweite Alternative nutzt eine Entwurfs Funktion des Gleit Komma Formats: der Unterschied zwischen der ganzzahligen Darstellung von zwei Gleit Komma Werten gibt die Anzahl möglicher Gleit Komma Werte an, die Sie trennt. Beispielsweise ist der Unterschied zwischen 0,0 und <xref:System.Double.Epsilon> 1, da <xref:System.Double.Epsilon> der kleinste darstellbare Wert ist, wenn Sie mit einer <xref:System.Double> arbeiten, deren Wert 0 (null) ist. Im folgenden Beispiel wird dieses Verfahren zum Vergleichen von. 33333 und 1/3 verwendet, bei denen es sich um die beiden <xref:System.Double> Werte handelt, die das vorherige Codebeispiel mit der <xref:System.Double.Equals%28System.Double%29>-Methode als ungleich gefunden hat. Beachten Sie, dass im Beispiel die <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType>-Methode verwendet wird, um einen Gleit Komma Wert mit doppelter Genauigkeit in seine ganzzahlige Darstellung zu konvertieren.  
  
 [!code-csharp[System.Double.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Double.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsabs1.vb#1)]  
  
 Die Genauigkeit von Gleit Komma Zahlen jenseits der dokumentierten Genauigkeit ist spezifisch für die Implementierung und die Version der .NET Framework. Folglich kann sich ein Vergleich zweier bestimmter Zahlen zwischen den Versionen der .NET Framework ändern, da sich die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
 Wenn zwei <xref:System.Double.NaN?displayProperty=nameWithType> Werte auf Gleichheit getestet werden, indem die <xref:System.Double.Equals%2A>-Methode aufgerufen wird, gibt die Methode `true`zurück. Wenn jedoch zwei <xref:System.Double.NaN> Werte mit dem Gleichheits Operator auf Gleichheit getestet werden, gibt der Operator `false`zurück. Wenn Sie bestimmen möchten, ob der Wert einer <xref:System.Double> keine Zahl (NaN) ist, besteht eine Alternative darin, die <xref:System.Double.IsNaN%2A>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Die Auflösung der compilerüberladung kann einen offensichtlichen Unterschied im Verhalten der beiden <see cref="M:System.Double.Equals(System.Object)" /> Methoden Überladungen berücksichtigen. Wenn eine implizite Konvertierung zwischen dem <paramref name="obj" />-Argument und einem <see cref="T:System.Double" /> definiert ist und das-Argument nicht als <see cref="T:System.Object" />typisiert ist, können Compiler eine implizite Konvertierung durchführen und die <see cref="M:System.Double.Equals(System.Double)" />-Methode aufzurufen. Andernfalls wird die <see cref="M:System.Double.Equals(System.Object)" />-Methode aufgerufen, die immer <see langword="false" /> zurückgibt, wenn das <paramref name="obj" />-Argument kein <see cref="T:System.Double" /> Wert ist. Das folgende Beispiel veranschaulicht den Unterschied im Verhalten zwischen den zwei Methoden Überladungen. Bei allen primitiven numerischen Typen mit Ausnahme von <see cref="T:System.Decimal" /> und in C#gibt der erste Vergleich <see langword="true" /> zurück, da der Compiler automatisch eine erweiternde Konvertierung ausführt und die <see cref="M:System.Double.Equals(System.Double)" />-Methode aufruft, während der zweite Vergleich <see langword="false" /> zurückgibt, da der Compiler die <see cref="M:System.Double.Equals(System.Object)" />-Methode aufruft.  
  
[! Code-csharp[System. Double. ist mit # 2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)] [! Code-vb[System. Double. ist mit # 2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Double.Equals(System.Object)" />
        <altmember cref="Overload:System.Double.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="double.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Ein Objekt, das mit dieser Instanz verglichen werden soll.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz mit einem angegebenen Objekt übereinstimmt.</summary>
        <returns><see langword="true" />, wenn <paramref name="obj" /> eine Instanz von <see cref="T:System.Double" /> ist, deren Wert gleich dem Wert dieser Instanz ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.Equals%2A>-Methode sollte mit Bedacht verwendet werden, da zwei scheinbar äquivalente Werte aufgrund der unterschiedlichen Genauigkeit der beiden Werte ungleich sein können. Im folgenden Beispiel wird berichtet, dass der <xref:System.Double> Wert. 3333 und die von Division 1 durch 3 zurückgegebenen <xref:System.Double> ungleich sind.  
  
 [!code-csharp[System.Double.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#3)]
 [!code-vb[System.Double.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#3)]  
  
 Alternativen zum Aufrufen der <xref:System.Double.Equals%2A>-Methode finden Sie in der Dokumentation zur <xref:System.Double.Equals%28System.Double%29> Überladung.  
  
> [!NOTE]
>  Da <xref:System.Double.Epsilon> den minimalen Ausdruck eines positiven Werts definiert, dessen Bereich nahe Null ist, muss der Rand der Differenz zwischen zwei ähnlichen Werten größer als <xref:System.Double.Epsilon>sein. In der Regel ist es oft größer als <xref:System.Double.Epsilon>.  
  
 Die Genauigkeit von Gleit Komma Zahlen jenseits der dokumentierten Genauigkeit ist spezifisch für die Implementierung und die Version der .NET Framework. Folglich kann sich ein Vergleich zweier bestimmter Zahlen zwischen den Versionen der .NET Framework ändern, da sich die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
 Wenn zwei <xref:System.Double.NaN?displayProperty=nameWithType> Werte auf Gleichheit getestet werden, indem die <xref:System.Double.Equals%2A>-Methode aufgerufen wird, gibt die Methode `true`zurück. Wenn jedoch zwei <xref:System.Double.NaN> Werte mit dem Gleichheits Operator auf Gleichheit getestet werden, gibt der Operator `false`zurück. Wenn Sie bestimmen möchten, ob der Wert einer <xref:System.Double> keine Zahl (NaN) ist, besteht eine Alternative darin, die <xref:System.Double.IsNaN%2A>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Die Auflösung der compilerüberladung kann einen offensichtlichen Unterschied im Verhalten der beiden <see cref="M:System.Double.Equals(System.Object)" /> Methoden Überladungen berücksichtigen. Wenn eine implizite Konvertierung zwischen dem <paramref name="obj" />-Argument und einem <see cref="T:System.Double" /> definiert ist und das-Argument nicht als <see cref="T:System.Object" />typisiert ist, können Compiler eine implizite Konvertierung durchführen und die <see cref="M:System.Double.Equals(System.Double)" />-Methode aufzurufen. Andernfalls wird die <see cref="M:System.Double.Equals(System.Object)" />-Methode aufgerufen, die immer <see langword="false" /> zurückgibt, wenn das <paramref name="obj" />-Argument kein <see cref="T:System.Double" /> Wert ist. Das folgende Beispiel veranschaulicht den Unterschied im Verhalten zwischen den zwei Methoden Überladungen. Bei allen primitiven numerischen Typen mit Ausnahme von <see cref="T:System.Decimal" /> und in C#gibt der erste Vergleich <see langword="true" /> zurück, da der Compiler automatisch eine erweiternde Konvertierung ausführt und die <see cref="M:System.Double.Equals(System.Double)" />-Methode aufruft, während der zweite Vergleich <see langword="false" /> zurückgibt, da der Compiler die <see cref="M:System.Double.Equals(System.Object)" />-Methode aufruft.  
  
[! Code-csharp[System. Double. ist mit # 2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)] [! Code-vb[System. Double. ist mit # 2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para></block>
        <altmember cref="M:System.Double.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="double.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für diese Instanz zurück.</summary>
        <returns>Ein Hashcode in Form einer 32-Bit-Ganzzahl mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="double.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den <see cref="T:System.TypeCode" /> für den Werttyp <see cref="T:System.Double" /> zurück.</summary>
        <returns>Die Enumerationskonstante <see cref="F:System.TypeCode.Double" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsFinite(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(double d);" />
      <MemberSignature Language="F#" Value="static member IsFinite : double -&gt; bool" Usage="System.double.IsFinite d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="d">Eine Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Diese Methode bestimmt, ob der Wert endlich ist (Null, subnormal oder normal).</summary>
        <returns><see langword="true" />, wenn der Wert endlich ist (Null, subnormal oder normal); sonst <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : double -&gt; bool" Usage="System.double.IsInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Eine Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der Wert der angegebenen Zahl -unendlich oder +unendlich ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="d" /> entweder <see cref="F:System.Double.PositiveInfinity" /> oder <see cref="F:System.Double.NegativeInfinity" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gleit Komma Operationen geben <xref:System.Double.PositiveInfinity> oder <xref:System.Double.NegativeInfinity> zurück, um eine Überlauf Bedingung zu signalisieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung von <xref:System.Double.IsInfinity%2A>veranschaulicht:  
  
 [!code-cpp[System.Double#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#11)]
 [!code-csharp[System.Double#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#11)]
 [!code-vb[System.Double#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNaN(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(double d);" />
      <MemberSignature Language="F#" Value="static member IsNaN : double -&gt; bool" Usage="System.double.IsNaN d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Eine Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der angegebene Wert keine Zahl ist (<see cref="F:System.Double.NaN" />).</summary>
        <returns><see langword="true" />, wenn <paramref name="d" /><see cref="F:System.Double.NaN" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gleit Komma Vorgänge geben <xref:System.Double.NaN> zurück, um zu signalisieren, dass das Ergebnis des Vorgangs nicht definiert ist. Beispielsweise führt die Division von 0,0 durch 0,0 zu <xref:System.Double.NaN>.  
  
> [!NOTE]
>  <xref:System.Double.IsNaN%2A> gibt `false` zurück, wenn ein <xref:System.Double> Wert entweder <xref:System.Double.PositiveInfinity> oder <xref:System.Double.NegativeInfinity>ist. Um diese Werte zu testen, verwenden Sie die Methoden <xref:System.Double.IsInfinity%2A>, <xref:System.Double.IsPositiveInfinity%2A>und <xref:System.Double.IsNegativeInfinity%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung von <xref:System.Double.IsNaN%2A>veranschaulicht:  
  
 [!code-cpp[System.Double#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#8)]
 [!code-csharp[System.Double#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#8)]
 [!code-vb[System.Double#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Double.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (double d);" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float64 d) cil managed" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegative(System.Double)" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (d As Double) As Boolean" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(double d);" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="F#" Value="static member IsNegative : double -&gt; bool" Usage="System.double.IsNegative d" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="d">Eine Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Bestimmt, ob der angegebene Wert negativ ist.</summary>
        <returns><see langword="true" />, wenn der Wert negativ ist; sonst <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegativeInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : double -&gt; bool" Usage="System.double.IsNegativeInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Eine Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die angegebene Zahl minus unendlich ergibt.</summary>
        <returns><see langword="true" />, wenn <paramref name="d" /><see cref="F:System.Double.NegativeInfinity" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gleit Komma Operationen geben <xref:System.Double.NegativeInfinity> zurück, um eine Überlauf Bedingung zu signalisieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung von <xref:System.Double.IsNegativeInfinity%2A>veranschaulicht:  
  
 [!code-cpp[System.Double#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#13)]
 [!code-csharp[System.Double#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#13)]
 [!code-vb[System.Double#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#13)]  
[!code-cpp[System.Double#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#4)]
[!code-csharp[System.Double#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#4)]
[!code-vb[System.Double#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#4)]  
[!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
[!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
[!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(double d);" />
      <MemberSignature Language="F#" Value="static member IsNormal : double -&gt; bool" Usage="System.double.IsNormal d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="d">Eine Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Bestimmt, ob der angegebene Wert normal ist.</summary>
        <returns><see langword="true" />, wenn der Wert normal ist; sonst <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsPositiveInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : double -&gt; bool" Usage="System.double.IsPositiveInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Eine Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die angegebene Zahl plus unendlich ergibt.</summary>
        <returns><see langword="true" />, wenn <paramref name="d" /><see cref="F:System.Double.PositiveInfinity" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gleit Komma Operationen geben <xref:System.Double.PositiveInfinity> zurück, um eine Überlauf Bedingung zu signalisieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung von <xref:System.Double.IsPositiveInfinity%2A>veranschaulicht:  
  
 [!code-cpp[System.Double#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#12)]
 [!code-csharp[System.Double#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#12)]
 [!code-vb[System.Double#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsSubnormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(double d);" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : double -&gt; bool" Usage="System.double.IsSubnormal d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="d">Eine Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Bestimmt, ob der angegebene Wert subnormal ist.</summary>
        <returns><see langword="true" />, wenn der Wert subnormal ist; sonst <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const double MaxValue = 1.7976931348623157E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MaxValue = float64(1.7976931348623157E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Double  = 1.7976931348623157E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MaxValue = 1.7976931348623157E+308;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : double" Usage="System.double.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>1.7976931348623157E+308</MemberValue>
      <Docs>
        <summary>Stellt den größtmöglichen Wert von <see cref="T:System.Double" /> dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstante ist positiv 1.7976931348623157 e + 308.  
  
 Das Ergebnis eines Vorgangs, der die <xref:System.Double.MaxValue?displayProperty=nameWithType> überschreitet, ist <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>. Im folgenden Beispiel <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> Ergebnisse aus Addition, Multiplikation und exponentiations Vorgängen, wenn das Ergebnis <xref:System.Double.MaxValue?displayProperty=nameWithType>überschreitet.  
  
 [!code-csharp[System.Double.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Double.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung von <xref:System.Double.MaxValue?displayProperty=nameWithType>veranschaulicht:  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const double MinValue = -1.7976931348623157E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MinValue = float64(-1.7976931348623157E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Double  = -1.7976931348623157E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MinValue = -1.7976931348623157E+308;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : double" Usage="System.double.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-1.7976931348623157E+308</MemberValue>
      <Docs>
        <summary>Stellt den kleinstmöglichen Wert von <see cref="T:System.Double" /> dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstante ist negativ 1.7976931348623157 e + 308.  
  
 Das Ergebnis eines Vorgangs, der kleiner als <xref:System.Double.MinValue?displayProperty=nameWithType> ist, ist <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>. Im folgenden Beispiel <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> Ergebnisse aus Subtraktions-und Multiplikations Vorgängen, wenn das Ergebnis kleiner als <xref:System.Double.MinValue?displayProperty=nameWithType>ist.  
  
 [!code-csharp[System.Double.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Double.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung von <xref:System.Double.MinValue?displayProperty=nameWithType>veranschaulicht:  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const double NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NaN = float64(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Double  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: double NaN = NaN;" />
      <MemberSignature Language="F#" Value="val mutable NaN : double" Usage="System.double.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>Stellt einen Wert dar, der keine Zahl ist (<see langword="NaN" />). Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Methode oder ein Operator gibt <xref:System.Double.NaN> zurück, wenn das Ergebnis eines Vorgangs nicht definiert ist. Beispielsweise wird das Ergebnis der Division von NULL durch Null <xref:System.Double.NaN>, wie im folgenden Beispiel gezeigt. (Beachten Sie jedoch, dass die Division einer Zahl ungleich NULL durch Null entweder <xref:System.Double.PositiveInfinity> oder <xref:System.Double.NegativeInfinity>zurückgibt, je nach Vorzeichen des Divisors.)  
  
 [!code-csharp[System.Double.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#1)]
 [!code-vb[System.Double.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#1)]  
  
 Außerdem gibt ein Methodenaufrufe mit einem <xref:System.Double.NaN> Wert oder einem Vorgang für einen <xref:System.Double.NaN> Wert <xref:System.Double.NaN>zurück, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Double.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#2)]
 [!code-vb[System.Double.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#2)]  
  
 Verwenden Sie die <xref:System.Double.IsNaN%2A>-Methode, um zu bestimmen, ob ein Wert keine Zahl ist. Der <xref:System.Double.op_Equality%2A>-Operator betrachtet zwei <xref:System.Double.NaN> Werte als ungleich zueinander. Im Allgemeinen können <xref:System.Double>-Operatoren nicht zum Vergleichen von <xref:System.Double.NaN?displayProperty=nameWithType> mit anderen <xref:System.Double>-Werten verwendet werden, obwohl Vergleichsmethoden (z. b. <xref:System.Double.Equals%2A> und <xref:System.Double.CompareTo%2A>) möglich sind. Das folgende Beispiel veranschaulicht den Unterschied im Verhalten zwischen <xref:System.Double> Vergleichs Operatoren und Methoden.  
  
 [!code-csharp[System.Double.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/double.nan4.cs#4)]
 [!code-vb[System.Double.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/double.nan4.vb#4)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung von <xref:System.Double.NaN> veranschaulicht:  
  
 [!code-cpp[System.Double#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#7)]
 [!code-csharp[System.Double#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#7)]
 [!code-vb[System.Double#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNaN(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NegativeInfinity = float64(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Double  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="F#" Value="val mutable NegativeInfinity : double" Usage="System.double.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>Stellt minus unendlich dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstante ist das Ergebnis der Division einer negativen Zahl durch 0 (null).  
  
 Diese Konstante wird zurückgegeben, wenn das Ergebnis eines Vorgangs kleiner als <xref:System.Double.MinValue?displayProperty=nameWithType>ist.  
  
 Verwenden Sie <xref:System.Double.IsNegativeInfinity%2A>, um zu bestimmen, ob ein Wert zu minus unendlich ausgewertet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung von <xref:System.Double.NegativeInfinity>veranschaulicht:  
  
 [!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
 [!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
 [!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Equality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : double * double -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei angegebene <see cref="T:System.Double" />-Werte gleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit der <xref:System.Double.op_Equality%2A>-Methode wird der Gleichheits Operator für <xref:System.Double> Werte definiert.  
  
 Wenn zwei <xref:System.Double.NaN?displayProperty=nameWithType> Werte mit dem Gleichheits Operator auf Gleichheit getestet werden, ist das Ergebnis `false`. zwei <xref:System.Double.NaN?displayProperty=nameWithType> Werte werden nicht als gleich betrachtet. Wenn Sie auf Gleichheit geprüft werden, indem Sie die <xref:System.Double.Equals%2A>-Methode aufrufen, wird das Ergebnis `true`.  Wenn Sie bestimmen möchten, ob der Wert einer <xref:System.Double> keine Zahl (NaN) ist, besteht eine Alternative darin, die <xref:System.Double.IsNaN%2A>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : double * double -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Double" />-Wert größer als ein anderer angegebener <see cref="T:System.Double" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.op_GreaterThan%2A>-Methode definiert den Vorgang des Operators "größer als" für <xref:System.Double> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : double * double -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Double" />-Wert größer oder gleich einem anderen angegebenen <see cref="T:System.Double" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> größer oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.op_GreaterThanOrEqual%2A>-Methode definiert den Vorgang des größer-als-oder-gleich-Operators für <xref:System.Double> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Inequality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : double * double -&gt; bool" Usage="System.double.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei angegebene <see cref="T:System.Double" />-Werte gleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.op_Inequality%2A>-Methode definiert den Ungleichheits Operator für <xref:System.Double> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : double * double -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Double" />-Wert größer als ein anderer angegebener <see cref="T:System.Double" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.op_LessThan%2A>-Methode definiert den Vorgang des less-than-Operators für <xref:System.Double> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : double * double -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Double" /> -Wert kleiner oder gleich einem anderen angegebenen <see cref="T:System.Double" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.op_LessThanOrEqual%2A>-Methode definiert den Vorgang des less-than-or-equal-Operators für <xref:System.Double> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in die entsprechende Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <altmember cref="Overload:System.Double.TryParse" />
        <remarks>In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <see cref="F:System.Double.PositiveInfinity" /> oder <see cref="F:System.Double.NegativeInfinity" /> gerundet, wie für die IEEE 754-Spezifikation erforderlich. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.</remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; double" Usage="System.double.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in die entsprechende Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit doppelter Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <xref:System.Double.PositiveInfinity> oder <xref:System.Double.NegativeInfinity> gerundet, wie für die IEEE 754-Spezifikation erforderlich. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.

 Der `s`-Parameter kann die <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>oder eine Zeichenfolge der aktuellen Kultur enthalten:  
  
 [*WS*] [*Sign*] [ganzzahlige*Ziffern*[*,*]] ganzzahlige *Ziffern*[*.* [*Bruch Ziffern*]] [E [*Sign*]*exponentialziffern*] [*WS*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen.|  
|*sign*|Ein negatives Vorzeichen Symbol (-) oder ein positives Vorzeichen Symbol (+). Es kann nur ein führendes Vorzeichen verwendet werden.|  
|*ganzzahlige Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Ausführungen ganzzahliger *Ziffern* können durch ein Gruppen Trennzeichen partitioniert werden. In einigen Kulturen werden z. b. durch Kommas (,) Gruppen von Tausenden voneinander getrennt. Das *integrale Ziffern* Element kann nicht vorhanden sein, wenn die Zeichenfolge das Dezimal *stellen Element enthält* .|  
|,|Ein kulturspezifisches Tausender Trennzeichen.|  
|.|Ein kulturspezifisches Dezimaltrennzeichen.|  
|*Bruch Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den Bruch Teil der Zahl angeben.|  
|E|Das Zeichen "e" oder "e", das angibt, dass der Wert in exponentieller Notation (Scientific) dargestellt wird.|  
|*exponentielle Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die einen Exponenten angeben.|  
  
 Der `s`-Parameter wird mit einer Kombination der <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType>-und <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>-Flags interpretiert. Dies bedeutet, dass leer-und Tausender Trennzeichen zulässig sind, z. b. bei Währungs Symbolen. Um eine präzisere Kontrolle darüber zu erhalten, welche Stilelemente in `s` zulässig sind, damit der Analyse Vorgang erfolgreich ist, können Sie die <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> oder die <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
 Der `s`-Parameter wird mithilfe der Formatierungsinformationen in einem <xref:System.Globalization.NumberFormatInfo> Objekt interpretiert, das für die aktuelle Thread Kultur initialisiert wird. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Um eine Zeichenfolge mit den Formatierungsinformationen einer anderen Kultur zu analysieren, können Sie die <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>-oder <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType>-Methode verwenden.  
  
 Wenn Sie der <xref:System.Double.Parse%2A?displayProperty=nameWithType>-Methode eine Zeichenfolge übergeben, die durch Aufrufen der <xref:System.Double.ToString%2A?displayProperty=nameWithType>-Methode erstellt wird, wird normalerweise der ursprüngliche <xref:System.Double> Wert zurückgegeben. Bei .NET Framework und .net Core 2,2 und früheren Versionen sind die Werte jedoch möglicherweise aufgrund eines Genauigkeits Verlusts nicht gleich. Außerdem kann bei dem Versuch, die Zeichen folgen Darstellung von <xref:System.Double.MinValue?displayProperty=nameWithType> oder <xref:System.Double.MaxValue?displayProperty=nameWithType> zu analysieren, ein Roundtrip nicht durchführt werden. Auf .NET Framework und .net Core 2,2 und früheren Versionen wird eine <xref:System.OverflowException>ausgelöst. Dies wird im folgenden Beispiel veranschaulicht. 
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  

Bei .NET Framework und .net Core 2,2 und früheren Versionen löst die <xref:System.Double.Parse%28System.String%29>-Methode eine <xref:System.OverflowException>aus, wenn `s` außerhalb des Bereichs des <xref:System.Double>-Datentyps liegt.

Unter .net Core 3,0 und höheren Versionen wird keine Ausnahme ausgelöst, wenn `s` außerhalb des Bereichs des <xref:System.Double> Datentyps liegt. In den meisten Fällen gibt die Methode <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>zurück. Es gibt jedoch eine kleine Menge von Werten, die sich als näher an den maximalen oder minimalen Werten von <xref:System.Double> als positiv oder minus unendlich aneignen. In diesen Fällen gibt die Methode <xref:System.Double.MaxValue?displayProperty=nameWithType> oder <xref:System.Double.MinValue?displayProperty=nameWithType>zurück.

Wenn während eines Analyse Vorgangs ein Trennzeichen im `s`-Parameter gefunden wird und die entsprechende Währungs-oder Zahlen Dezimal-und Gruppen Trennzeichen identisch sind, geht der Analyse Vorgang davon aus, dass das Trennzeichen ein Dezimaltrennzeichen und nicht ein Gruppen Trennzeichen ist. Weitere Informationen zu Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.     
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Double.Parse%28System.String%29>-Methode veranschaulicht.  
  
 [!code-cpp[Double Example#5](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#5)]
 [!code-csharp[Double Example#5](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#5)]
 [!code-vb[Double Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> ist <see langword="null" /></exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> stellt keine Zahl in einem gültigen Format dar.</exception>
        <exception cref="T:System.OverflowException">Nur .NET Framework und .NET Core 2.2 und früheren Versionen: <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Double.MinValue" /> oder größer als <see cref="F:System.Double.MaxValue" /> ist.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="M:System.Double.TryParse(System.String,System.Double@)" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; double" Usage="System.double.Parse (s, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die in <paramref name="s" /> vorhanden sein können. Ein häufig anzugebender Wert ist eine Kombination von <see cref="F:System.Globalization.NumberStyles.Float" /> und <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Format in die entsprechende Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit doppelter Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <xref:System.Double.PositiveInfinity> oder <xref:System.Double.NegativeInfinity> gerundet, wie für die IEEE 754-Spezifikation erforderlich. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.

 Der `style`-Parameter definiert die Stilelemente (z. b. Leerzeichen, Tausender Trennzeichen und Währungssymbole), die im `s`-Parameter zulässig sind, damit der Analyse Vorgang erfolgreich ausgeführt werden kann. Dabei muss es sich um eine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> Enumeration handeln. Die folgenden <xref:System.Globalization.NumberStyles> Elemente werden nicht unterstützt:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Der `s`-Parameter kann die <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>oder <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>der aktuellen Kultur enthalten. Abhängig vom Wert von `style`kann dies auch folgende Form annehmen:  
  
 [*WS*] [*$*] [*Sign*] [ganzzahlige*Ziffern*[*,*]] ganzzahlige *Ziffern*[*.* [*Bruch Ziffern*]] [E [*Sign*]*exponentialziffern*] [*WS*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen. Leerraum kann am Anfang der `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>-Flag enthält, und es kann am Ende `s` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>-Flag enthält.|  
|$|Ein kulturspezifisches Währungssymbol. Die Position in der Zeichenfolge wird durch die Eigenschaften <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> der aktuellen Kultur definiert. Das Währungssymbol der aktuellen Kultur kann in `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>-Flag enthält.|  
|*sign*|Ein negatives Vorzeichen Symbol (-) oder ein positives Vorzeichen Symbol (+). Das Vorzeichen kann am Anfang `s` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>-Flag enthält, und es kann am Ende `s` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>-Flag enthält. In `s` können Klammern verwendet werden, um einen negativen Wert anzugeben, wenn `style` das <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>-Flag enthält.|  
|*ganzzahlige Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Das *integrale Ziffern* Element kann nicht vorhanden sein, wenn die Zeichenfolge das Dezimal *stellen Element enthält* .|  
|,|Ein kulturspezifisches Gruppen Trennzeichen. Das Gruppen Trennzeichen der aktuellen Kultur kann in `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>-Flag enthält.|  
|.|Ein kulturspezifisches Dezimaltrennzeichen. Das Dezimaltrennzeichen der aktuellen Kultur kann in `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>-Flag enthält.|  
|*Bruch Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den Bruch Teil der Zahl angeben. Bruch Ziffern können in `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>-Flag enthält.|  
|E|Das Zeichen "e" oder "e", das angibt, dass der Wert in exponentieller Notation (Scientific) dargestellt wird. Der `s`-Parameter kann eine Zahl in Exponentialnotation darstellen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>-Flag enthält.|  
|*exponentielle Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die einen Exponenten angeben.|  
  
> [!NOTE]
> Alle abschließenden NUL-Zeichen (U + 0000) in `s` werden vom Analyse-Vorgang unabhängig vom Wert des `style` Arguments ignoriert.

 Eine Zeichenfolge mit nur Ziffern (die dem <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> Stil entspricht) wird immer erfolgreich analysiert, wenn Sie sich im Bereich des <xref:System.Double> Typs befindet. Die verbleibenden <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Member steuern Elemente, die möglicherweise vorhanden sind, jedoch nicht in der Eingabe Zeichenfolge vorhanden sein müssen. In der folgenden Tabelle wird angegeben, wie einzelne <xref:System.Globalization.NumberStyles> Flags die Elemente beeinflussen, die möglicherweise in `s`vorhanden sind.  
  
|NumberStyles-Wert|In `s` zulässige Elemente zusätzlich zu Ziffern|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Nur das ganzzahlige *Ziffern* Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Die Dezimaltrennzeichen (*.*) und die Elemente der *Bruch Ziffern* .|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das Zeichen "e" oder "e", das die Exponentialschreibweise angibt. Dieses Flag allein unterstützt Werte in der Form *Ziffern*E*Ziffern*. zusätzliche Flags sind erforderlich, um Zeichen folgen mit solchen Elementen wie positive oder negative Vorzeichen und Dezimaltrennzeichen erfolgreich zu analysieren.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Das *WS* -Element am Anfang `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Das *WS* -Element am Ende `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Das *Sign* -Element am Anfang `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Das *Sign* -Element am Ende `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Das *Vorzeichen* Element in der Form von Klammern, das den numerischen Wert einschließt.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das Tausender Trennzeichen (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Currency ($)-Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle-Elemente. `s` kann jedoch keine hexadezimal Zahl oder eine Zahl in Exponentialnotation darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Das *WS* -Element am Anfang oder Ende `s`, Signieren am Anfang `s`und das Dezimal *Trennzeichen* (.). Der `s`-Parameter kann auch die Exponentialnotation verwenden.|  
|<xref:System.Globalization.NumberStyles.Number>|Die Elemente `ws`, `sign`, Tausender Trennzeichen (,) und Dezimaltrennzeichen (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Alle-Elemente. Allerdings kann `s` keine hexadezimal Zahl darstellen.|  
  
 Der `s`-Parameter wird mithilfe der Formatierungsinformationen in einem <xref:System.Globalization.NumberFormatInfo>-Objekt analysiert, das für die aktuelle System Kultur initialisiert wird. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>.  
  
 Wenn Sie der <xref:System.Double.Parse%2A?displayProperty=nameWithType>-Methode eine Zeichenfolge übergeben, die durch Aufrufen der <xref:System.Double.ToString%2A?displayProperty=nameWithType>-Methode erstellt wird, wird normalerweise der ursprüngliche <xref:System.Double> Wert zurückgegeben. Aufgrund eines Genauigkeits Verlusts sind die Werte jedoch möglicherweise nicht gleich. Außerdem kann bei dem Versuch, die Zeichen folgen Darstellung von <xref:System.Double.MinValue?displayProperty=nameWithType> oder <xref:System.Double.MaxValue?displayProperty=nameWithType> zu analysieren, ein Roundtrip nicht durchführt werden. Auf .NET Framework und .net Core 2,2 und früheren Versionen wird eine <xref:System.OverflowException>ausgelöst. In .net Core 3,0 und höheren Versionen wird <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> zurückgegeben, wenn Sie versuchen, <xref:System.Double.MinValue?displayProperty=nameWithtype> zu analysieren oder <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, wenn Sie versuchen, <xref:System.Double.MaxValue?displayProperty=nameWithtype>zu analysieren. Dies wird im folgenden Beispiel veranschaulicht. 
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]   

Bei .NET Framework und .net Core 2,2 und früheren Versionen löst die <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29>-Methode eine <xref:System.OverflowException>aus, wenn `s` außerhalb des Bereichs des <xref:System.Double>-Datentyps liegt.

Unter .net Core 3,0 und höheren Versionen wird keine Ausnahme ausgelöst, wenn `s` außerhalb des Bereichs des <xref:System.Double> Datentyps liegt. In den meisten Fällen gibt die <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> Methode <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>zurück. Es gibt jedoch eine kleine Menge von Werten, die sich als näher an den maximalen oder minimalen Werten von <xref:System.Double> als positiv oder minus unendlich aneignen. In diesen Fällen gibt die Methode <xref:System.Double.MaxValue?displayProperty=nameWithType> oder <xref:System.Double.MinValue?displayProperty=nameWithType>zurück.

Wenn während eines Analyse Vorgangs ein Trennzeichen im `s`-Parameter gefunden wird und die entsprechende Währungs-oder Zahlen Dezimal-und Gruppen Trennzeichen identisch sind, geht der Analyse Vorgang davon aus, dass das Trennzeichen ein Dezimaltrennzeichen und nicht ein Gruppen Trennzeichen ist. Weitere Informationen zu Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29>-Methode verwendet, um die Zeichen folgen Darstellungen von <xref:System.Double> Werten mit der Kultur "en-US" zu analysieren.  
  
 [!code-csharp[System.Double.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse.cs#1)]
 [!code-vb[System.Double.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> ist <see langword="null" /></exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> stellt keine Zahl in einem gültigen Format dar.</exception>
        <exception cref="T:System.OverflowException">Nur .NET Framework und .NET Core 2.2 und früheren Versionen: <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Double.MinValue" /> oder größer als <see cref="F:System.Double.MaxValue" /> ist.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder - 
 <paramref name="style" /> enthält den <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Wert.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; double" Usage="System.double.Parse (s, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="s" /> bereitstellt.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem bestimmten kulturspezifischen Format in die entsprechende Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit doppelter Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <xref:System.Double.PositiveInfinity> oder <xref:System.Double.NegativeInfinity> gerundet, wie für die IEEE 754-Spezifikation erforderlich. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.

 Diese Überladung der <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29>-Methode wird in der Regel verwendet, um Text zu konvertieren, der auf verschiedene Weise auf einen <xref:System.Double> Wert formatiert werden kann. Beispielsweise kann es verwendet werden, um den Text, der von einem Benutzer eingegeben wurde, in ein HTML-Textfeld in einen numerischen Wert zu konvertieren.  
  
 Der `s`-Parameter wird mit einer Kombination der <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType>-und <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>-Flags interpretiert. Der `s`-Parameter kann für die durch `provider`angegebene Kultur <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>oder <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> enthalten, oder er kann eine Zeichenfolge in der Form enthalten:  
  
 [*WS*] [*Sign*] ganzzahlige *Ziffern*[*.* [*Bruch Ziffern*]] [E [*Sign*]*exponentialziffern*] [*WS*]  
  
 Optionale Elemente werden in eckige Klammern ([und]) eingeschlossen. Elemente, die den Begriff "Ziffern" enthalten, bestehen aus einer Reihe von numerischen Zeichen zwischen 0 und 9.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen.|  
|*sign*|Ein negatives Vorzeichen Symbol (-) oder ein positives Vorzeichen Symbol (+).|  
|*ganzzahlige Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Ausführungen ganzzahliger *Ziffern* können durch ein Gruppen Trennzeichen partitioniert werden. In einigen Kulturen werden z. b. durch Kommas (,) Gruppen von Tausenden voneinander getrennt. Das *integrale Ziffern* Element kann nicht vorhanden sein, wenn die Zeichenfolge das Dezimal *stellen Element enthält* .|  
|.|Ein kulturspezifisches Dezimaltrennzeichen.|  
|*Bruch Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den Bruch Teil der Zahl angeben.|  
|E|Das Zeichen "e" oder "e", das angibt, dass der Wert in exponentieller Notation (Scientific) dargestellt wird.|  
|*exponentielle Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die einen Exponenten angeben.|  
  
 Weitere Informationen zu numerischen Formaten finden Sie im Thema [Formatierungs Typen](~/docs/standard/base-types/formatting-types.md) .  
  
 Der `provider`-Parameter ist eine <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A>-Methode ein <xref:System.Globalization.NumberFormatInfo> Objekt zurückgibt, das kulturspezifische Informationen bereitstellt, die zum Interpretieren des Formats von `s`verwendet werden. In der Regel handelt es sich um eine <xref:System.Globalization.NumberFormatInfo>-oder <xref:System.Globalization.CultureInfo>-Objekt. Wenn `provider` `null` oder ein <xref:System.Globalization.NumberFormatInfo> nicht abgerufen werden kann, werden die Formatierungsinformationen für die aktuelle System Kultur verwendet.  
  
 Wenn Sie der <xref:System.Double.Parse%2A?displayProperty=nameWithType>-Methode eine Zeichenfolge übergeben, die durch Aufrufen der <xref:System.Double.ToString%2A?displayProperty=nameWithType>-Methode erstellt wird, wird normalerweise der ursprüngliche <xref:System.Double> Wert zurückgegeben. Aufgrund eines Genauigkeits Verlusts sind die Werte jedoch möglicherweise nicht gleich. Außerdem kann bei dem Versuch, die Zeichen folgen Darstellung von <xref:System.Double.MinValue?displayProperty=nameWithType> oder <xref:System.Double.MaxValue?displayProperty=nameWithType> zu analysieren, ein Roundtrip nicht durchführt werden. Auf .NET Framework und .net Core 2,2 und früheren Versionen wird eine <xref:System.OverflowException>ausgelöst. In .net Core 3,0 und höheren Versionen wird <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> zurückgegeben, wenn Sie versuchen, <xref:System.Double.MinValue?displayProperty=nameWithtype> zu analysieren oder <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, wenn Sie versuchen, <xref:System.Double.MaxValue?displayProperty=nameWithtype>zu analysieren. Dies wird im folgenden Beispiel veranschaulicht.
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  

Bei .NET Framework und .net Core 2,2 und früheren Versionen löst die <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29>-Methode eine <xref:System.OverflowException>aus, wenn `s` außerhalb des Bereichs des <xref:System.Double>-Datentyps liegt.

Unter .net Core 3,0 und höheren Versionen wird keine Ausnahme ausgelöst, wenn `s` außerhalb des Bereichs des <xref:System.Double> Datentyps liegt. In den meisten Fällen gibt die <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> Methode <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>zurück. Es gibt jedoch eine kleine Menge von Werten, die sich als näher an den maximalen oder minimalen Werten von <xref:System.Double> als positiv oder minus unendlich aneignen. In diesen Fällen gibt die Methode <xref:System.Double.MaxValue?displayProperty=nameWithType> oder <xref:System.Double.MinValue?displayProperty=nameWithType>zurück.

Wenn während eines Analyse Vorgangs ein Trennzeichen im `s`-Parameter gefunden wird und die entsprechende Währungs-oder Zahlen Dezimal-und Gruppen Trennzeichen identisch sind, geht der Analyse Vorgang davon aus, dass das Trennzeichen ein Dezimaltrennzeichen und nicht ein Gruppen Trennzeichen ist. Weitere Informationen zu Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
 
## Examples  
 Das folgende Beispiel ist der Button Click-Ereignishandler eines Webformulars. Er verwendet das von der <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType>-Eigenschaft zurückgegebene Array, um das Gebiets Schema des Benutzers zu bestimmen. Anschließend wird ein <xref:System.Globalization.CultureInfo> Objekt instanziiert, das diesem Gebiets Schema entspricht. Das <xref:System.Globalization.NumberFormatInfo> Objekt, das zu diesem <xref:System.Globalization.CultureInfo> Objekt gehört, wird dann an die <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29>-Methode weitergegeben, um die Eingabe des Benutzers in einen <xref:System.Double> Wert zu konvertieren.  
  
 [!code-csharp[ParseMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#2)]
 [!code-vb[ParseMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> ist <see langword="null" /></exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> stellt keine Zahl in einem gültigen Format dar.</exception>
        <exception cref="T:System.OverflowException">Nur .NET Framework und .NET Core 2.2 und früheren Versionen: <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Double.MinValue" /> oder größer als <see cref="F:System.Double.MaxValue" /> ist.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As Double" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; double" Usage="System.double.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenspanne, die die zu konvertierende Zahl enthält</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die in <paramref name="s" /> vorhanden sein können.  Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="s" /> bereitstellt.</param>
        <summary>Konvertiert eine Zeichenspanne mit der Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit doppelter Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <xref:System.Double.PositiveInfinity> oder <xref:System.Double.NegativeInfinity> gerundet, wie für die IEEE 754-Spezifikation erforderlich. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.

Wenn `s` außerhalb des Bereichs des <xref:System.Double> Datentyps liegt, gibt die Methode <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> zurück, wenn `s` kleiner als <xref:System.Double.MinValue?displayProperty=nameWithType> ist, und <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, wenn `s` größer als <xref:System.Double.MaxValue?displayProperty=nameWithType>ist.

         ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="s" /> stellt keinen numerischen Wert dar.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder - 
 <paramref name="style" /> ist der <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; double" Usage="System.double.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die in <paramref name="s" /> vorhanden sein können. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="s" /> bereitstellt.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit doppelter Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <xref:System.Double.PositiveInfinity> oder <xref:System.Double.NegativeInfinity> gerundet, wie für die IEEE 754-Spezifikation erforderlich. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.

 Der `style`-Parameter definiert die Stilelemente (z. b. Leerzeichen, Tausender Trennzeichen und Währungssymbole), die im `s`-Parameter zulässig sind, damit der Analyse Vorgang erfolgreich ausgeführt werden kann. Dabei muss es sich um eine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> Enumeration handeln. Die folgenden <xref:System.Globalization.NumberStyles> Elemente werden nicht unterstützt:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Der `s`-Parameter kann für die durch `provider`angegebene Kultur <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>oder <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> enthalten. Abhängig vom Wert von `style`kann dies auch folgende Form annehmen:  
  
 [*WS*] [*$*] [*Sign*] [ganzzahlige*Ziffern*,] ganzzahlige *Ziffern*[. [ *Bruch Ziffern*]] [E [*Sign*]*exponentialziffern*] [*WS*]  
  
 In eckige Klammern ([und]) eineckige Elemente sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen. Leerraum kann am Anfang der `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>-Flag enthält, und es kann am Ende `s` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>-Flag enthält.|  
|$|Ein kulturspezifisches Währungssymbol. Die Position in der Zeichenfolge wird durch die Eigenschaften <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> der aktuellen Kultur definiert. Das Währungssymbol der aktuellen Kultur kann in `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>-Flag enthält.|  
|*sign*|Ein negatives Vorzeichen Symbol (-) oder ein positives Vorzeichen Symbol (+). Das Vorzeichen kann am Anfang `s` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>-Flag enthält, und es kann am Ende `s` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>-Flag enthält. In `s` können Klammern verwendet werden, um einen negativen Wert anzugeben, wenn `style` das <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>-Flag enthält.|  
|*ganzzahlige Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Das *integrale Ziffern* Element kann nicht vorhanden sein, wenn die Zeichenfolge das Dezimal *stellen Element enthält* .|  
|,|Ein kulturspezifisches Gruppen Trennzeichen. Das Gruppen Trennzeichen der aktuellen Kultur kann in `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>-Flag enthält.|  
|.|Ein kulturspezifisches Dezimaltrennzeichen. Das Dezimaltrennzeichen der aktuellen Kultur kann in `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>-Flag enthält.|  
|*Bruch Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den Bruch Teil der Zahl angeben. Bruch Ziffern können in `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>-Flag enthält.|  
|E|Das Zeichen "e" oder "e", das angibt, dass der Wert in exponentieller Notation (Scientific) dargestellt wird. Der `s`-Parameter kann eine Zahl in Exponentialnotation darstellen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>-Flag enthält.|  
|*exponentielle Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die einen Exponenten angeben.|  
  
> [!NOTE]
> Alle abschließenden NUL-Zeichen (U + 0000) in `s` werden vom Analyse-Vorgang unabhängig vom Wert des `style` Arguments ignoriert.

 Eine Zeichenfolge mit nur Ziffern (die dem <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> Stil entspricht) wird immer erfolgreich analysiert, wenn Sie sich im Bereich des <xref:System.Double> Typs befindet. Die verbleibenden <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Member steuern Elemente, die möglicherweise vorhanden sind, jedoch nicht in der Eingabe Zeichenfolge vorhanden sein müssen. In der folgenden Tabelle wird angegeben, wie einzelne <xref:System.Globalization.NumberStyles> Flags die Elemente beeinflussen, die möglicherweise in `s`vorhanden sind.  
  
|NumberStyles-Wert|In `s` zulässige Elemente zusätzlich zu Ziffern|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Nur das ganzzahlige *Ziffern* Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Die Dezimaltrennzeichen (*.*) und die Elemente der *Bruch Ziffern* .|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das Zeichen "e" oder "e", das die Exponentialschreibweise angibt. Dieses Flag allein unterstützt Werte in der Form *Ziffern*E*Ziffern*. zusätzliche Flags sind erforderlich, um Zeichen folgen mit solchen Elementen wie positive oder negative Vorzeichen und Dezimaltrennzeichen erfolgreich zu analysieren.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Das *WS* -Element am Anfang `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Das *WS* -Element am Ende `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Das *Sign* -Element am Anfang `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Das *Sign* -Element am Ende `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Das *Vorzeichen* Element in der Form von Klammern, das den numerischen Wert einschließt.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das Tausender Trennzeichen (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Currency ($)-Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle-Elemente. `s` kann jedoch keine hexadezimal Zahl oder eine Zahl in Exponentialnotation darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Das *WS* -Element am Anfang oder Ende `s`, Signieren am Anfang `s`und das Dezimal *Trennzeichen* (.). Der `s`-Parameter kann auch die Exponentialnotation verwenden.|  
|<xref:System.Globalization.NumberStyles.Number>|Die Elemente `ws`, `sign`, Tausender Trennzeichen (,) und Dezimaltrennzeichen (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Alle-Elemente. Allerdings kann `s` keine hexadezimal Zahl darstellen.|  
  
 Der `provider`-Parameter ist eine <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A>-Methode ein <xref:System.Globalization.NumberFormatInfo> Objekt zurückgibt, das kulturspezifische Informationen bereitstellt, die zum Interpretieren des Formats von `s`verwendet werden. In der Regel handelt es sich um eine <xref:System.Globalization.NumberFormatInfo>-oder <xref:System.Globalization.CultureInfo>-Objekt. Wenn `provider` `null` oder ein <xref:System.Globalization.NumberFormatInfo> nicht abgerufen werden kann, werden die Formatierungsinformationen für die aktuelle System Kultur verwendet.  
  
 Wenn Sie der <xref:System.Double.Parse%2A?displayProperty=nameWithType>-Methode eine Zeichenfolge übergeben, die durch Aufrufen der <xref:System.Double.ToString%2A?displayProperty=nameWithType>-Methode erstellt wird, wird normalerweise der ursprüngliche <xref:System.Double> Wert zurückgegeben. Aufgrund eines Genauigkeits Verlusts sind die Werte jedoch möglicherweise nicht gleich. Außerdem kann bei dem Versuch, die Zeichen folgen Darstellung von <xref:System.Double.MinValue?displayProperty=nameWithtype> oder <xref:System.Double.MaxValue?displayProperty=nameWithType> zu analysieren, ein Roundtrip nicht durchführt werden. Auf .NET Framework und .net Core 2,2 und früheren Versionen wird eine <xref:System.OverflowException>ausgelöst. In .net Core 3,0 und höheren Versionen wird <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> zurückgegeben, wenn Sie versuchen, <xref:System.Double.MinValue?displayProperty=nameWithtype> zu analysieren oder <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, wenn Sie versuchen, <xref:System.Double.MaxValue?displayProperty=nameWithtype>zu analysieren. Dies wird im folgenden Beispiel veranschaulicht.   
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  

Bei .NET Framework und .net Core 2,2 und früheren Versionen löst die <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>-Methode eine <xref:System.OverflowException>aus, wenn `s` außerhalb des Bereichs des <xref:System.Double>-Datentyps liegt.

Unter .net Core 3,0 und höheren Versionen wird keine Ausnahme ausgelöst, wenn `s` außerhalb des Bereichs des <xref:System.Double> Datentyps liegt. In den meisten Fällen gibt die <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> Methode <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>zurück. Es gibt jedoch eine kleine Menge von Werten, die sich als näher an den maximalen oder minimalen Werten von <xref:System.Double> als positiv oder minus unendlich aneignen. In diesen Fällen gibt die Methode <xref:System.Double.MaxValue?displayProperty=nameWithType> oder <xref:System.Double.MinValue?displayProperty=nameWithType>zurück.

Wenn während eines Analyse Vorgangs ein Trennzeichen im `s`-Parameter gefunden wird und die entsprechende Währungs-oder Zahlen Dezimal-und Gruppen Trennzeichen identisch sind, geht der Analyse Vorgang davon aus, dass das Trennzeichen ein Dezimaltrennzeichen und nicht ein Gruppen Trennzeichen ist. Weitere Informationen zu Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  

## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>-Methode, um einem `Temperature`-Objekt mehrere Zeichen folgen Darstellungen von Temperaturwerten zuzuweisen.  
  
 [!code-csharp[System.Double.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse3.cs#2)]
 [!code-vb[System.Double.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> ist <see langword="null" /></exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> stellt keinen numerischen Wert dar.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder - 
 <paramref name="style" /> ist der <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Wert.</exception>
        <exception cref="T:System.OverflowException">Nur .NET Framework und .NET Core 2.2 und früheren Versionen: <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Double.MinValue" /> oder größer als <see cref="F:System.Double.MaxValue" /> ist.</exception>
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const double PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 PositiveInfinity = float64(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Double  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double PositiveInfinity = Infinity;" />
      <MemberSignature Language="F#" Value="val mutable PositiveInfinity : double" Usage="System.double.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>Stellt plus unendlich dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstante ist das Ergebnis der Division einer positiven Zahl durch 0 (null).  
  
 Diese Konstante wird zurückgegeben, wenn das Ergebnis eines Vorgangs größer als <xref:System.Double.MaxValue?displayProperty=nameWithType>ist.  
  
 Verwenden Sie <xref:System.Double.IsPositiveInfinity%2A>, um zu bestimmen, ob ein Wert als positiv unendlich ausgewertet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung von <xref:System.Double.PositiveInfinity>veranschaulicht:  
  
 [!code-cpp[System.Double#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#10)]
 [!code-csharp[System.Double#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#10)]
 [!code-vb[System.Double#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberSignature Language="F#" Value="abstract member System.IComparable.CompareTo : obj -&gt; int&#xA;override this.System.IComparable.CompareTo : obj -&gt; int" Usage="double.System.IComparable.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">Das zu vergleichende Objekt.</param>
        <summary>Vergleicht die aktuelle Instanz mit einem anderen Objekt vom selben Typ und gibt eine ganze Zahl zurück, die angibt, ob die aktuelle Instanz in der Sortierreihenfolge vor oder nach dem anderen Objekt oder an derselben Position auftritt.</summary>
        <returns>Ein Wert, der die relative Reihenfolge der verglichenen Objekte angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IComparable>-Schnittstelle umgewandelt wird.

Der Rückgabewert hat folgende Bedeutungen:

| Wert             | Bedeutung                                                                 |
|-------------------|-------------------------------------------------------------------------|
| Kleiner als 0 (null)    | Diese Instanz befindet sich in der Sortierreihenfolge vor `value`.                       |
| Null              | Diese Instanz tritt in der Sortierreihenfolge an der gleichen Position wie `value` auf. |
| Größer als 0 (null) | Diese Instanz folgt in der Sortierreihenfolge auf `value`.                        |

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.GetTypeCode : unit -&gt; TypeCode&#xA;override this.System.IConvertible.GetTypeCode : unit -&gt; TypeCode" Usage="double.System.IConvertible.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den <see cref="T:System.TypeCode" /> für diese Instanz zurück.</summary>
        <returns>Die Enumerationskonstante, die den <see cref="T:System.TypeCode" /> des Klassen- oder Werttyps darstellt, der diese Schnittstelle implementiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToBoolean : IFormatProvider -&gt; bool&#xA;override this.System.IConvertible.ToBoolean : IFormatProvider -&gt; bool" Usage="double.System.IConvertible.ToBoolean provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns><see langword="true" />, wenn der Wert der aktuellen Instanz nicht 0 (null) ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToBoolean%28System.Double%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToByte : IFormatProvider -&gt; byte&#xA;override this.System.IConvertible.ToByte : IFormatProvider -&gt; byte" Usage="double.System.IConvertible.ToByte provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Byte" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToByte%28System.Double%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToChar : IFormatProvider -&gt; char&#xA;override this.System.IConvertible.ToChar : IFormatProvider -&gt; char" Usage="double.System.IConvertible.ToChar provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Diese Konvertierung wird nicht unterstützt. Bei dem Versuch der Verwendung dieser Methode wird eine <see cref="T:System.InvalidCastException" /> ausgelöst.</summary>
        <returns>Diese Konvertierung wird nicht unterstützt. Es wird kein Wert zurückgegeben.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In allen Fällen.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDateTime : IFormatProvider -&gt; DateTime&#xA;override this.System.IConvertible.ToDateTime : IFormatProvider -&gt; DateTime" Usage="double.System.IConvertible.ToDateTime provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Diese Konvertierung wird nicht unterstützt. Bei dem Versuch der Verwendung dieser Methode wird eine <see cref="T:System.InvalidCastException" /> ausgelöst.</summary>
        <returns>Diese Konvertierung wird nicht unterstützt. Es wird kein Wert zurückgegeben.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In allen Fällen.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDecimal : IFormatProvider -&gt; decimal&#xA;override this.System.IConvertible.ToDecimal : IFormatProvider -&gt; decimal" Usage="double.System.IConvertible.ToDecimal provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Decimal" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToDecimal%28System.Double%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDouble : IFormatProvider -&gt; double&#xA;override this.System.IConvertible.ToDouble : IFormatProvider -&gt; double" Usage="double.System.IConvertible.ToDouble provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Der unveränderte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt16 : IFormatProvider -&gt; int16&#xA;override this.System.IConvertible.ToInt16 : IFormatProvider -&gt; int16" Usage="double.System.IConvertible.ToInt16 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int16" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToInt16%28System.Double%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt32 : IFormatProvider -&gt; int&#xA;override this.System.IConvertible.ToInt32 : IFormatProvider -&gt; int" Usage="double.System.IConvertible.ToInt32 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int32" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToInt32%28System.Double%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt64 : IFormatProvider -&gt; int64&#xA;override this.System.IConvertible.ToInt64 : IFormatProvider -&gt; int64" Usage="double.System.IConvertible.ToInt64 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int64" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToInt64%28System.Double%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToSByte : IFormatProvider -&gt; sbyte&#xA;override this.System.IConvertible.ToSByte : IFormatProvider -&gt; sbyte" Usage="double.System.IConvertible.ToSByte provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.SByte" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToSByte%28System.Double%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToSingle : IFormatProvider -&gt; single&#xA;override this.System.IConvertible.ToSingle : IFormatProvider -&gt; single" Usage="double.System.IConvertible.ToSingle provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Single" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToSingle%28System.Double%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToType (type As Type, provider As IFormatProvider) As Object Implements IConvertible.ToType" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToType : Type * IFormatProvider -&gt; obj&#xA;override this.System.IConvertible.ToType : Type * IFormatProvider -&gt; obj" Usage="double.System.IConvertible.ToType (type, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, in den dieser <see cref="T:System.Double" />-Wert konvertiert werden soll.</param>
        <param name="provider">Eine <see cref="T:System.IFormatProvider" />-Implementierung, die kulturspezifische Informationen zum Format des zurückgegebenen Werts bereitstellt.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Der in <paramref name="type" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die `static` (`Shared` in Visual Basic) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt16 : IFormatProvider -&gt; uint16&#xA;override this.System.IConvertible.ToUInt16 : IFormatProvider -&gt; uint16" Usage="double.System.IConvertible.ToUInt16 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt16" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToUInt16%28System.Double%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt32 : IFormatProvider -&gt; uint32&#xA;override this.System.IConvertible.ToUInt32 : IFormatProvider -&gt; uint32" Usage="double.System.IConvertible.ToUInt32 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt32" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToUInt32%28System.Double%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt64 : IFormatProvider -&gt; uint64&#xA;override this.System.IConvertible.ToUInt64 : IFormatProvider -&gt; uint64" Usage="double.System.IConvertible.ToUInt64 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Members finden Sie unter <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt64" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Member ist eine explizite Schnittstellen-Memberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die <xref:System.Convert.ToUInt64%28System.Double%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert den Wert dieser Instanz in die entsprechende Zeichenfolgendarstellung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="double.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert den Wert dieser Instanz in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.ToString>-Methode formatiert einen <xref:System.Double>-Wert im Standardformat ("G" oder allgemein) der aktuellen Kultur. Wenn Sie ein anderes Format, eine andere Genauigkeit oder eine andere Kultur angeben möchten, verwenden Sie die anderen über Ladungen der <xref:System.Double.ToString%2A>-Methode wie folgt:  
  
|So verwenden Sie das Format|Für Kultur|Verwenden der Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Ein bestimmtes Format oder eine bestimmte Genauigkeit|Standard Kultur (aktuell)|<xref:System.Double.ToString%28System.String%29>|  
|Ein bestimmtes Format oder eine bestimmte Genauigkeit|Eine bestimmte Kultur|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der Rückgabewert kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>oder eine Zeichenfolge in der Form lauten:  
  
 [Sign] ganzzahlige Ziffern [. [ Bruch Ziffern]] [E [Sign] exponentialziffern]  
  
 Optionale Elemente werden in eckige Klammern ([und]) eingeschlossen. Elemente, die den Begriff "Ziffern" enthalten, bestehen aus einer Reihe von numerischen Zeichen zwischen 0 und 9. Die in der folgenden Tabelle aufgeführten Elemente werden unterstützt.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*sign*|Ein negatives Vorzeichen-oder positives Vorzeichen Symbol.|  
|*ganzzahlige Ziffern*|Eine Reihe von Ziffern, die den ganzzahligen Teil der Zahl angibt. Ganzzahlige Ziffern können nicht vorhanden sein, wenn es sich um Bruch Ziffern handelt.|  
|'*.*'|Ein kulturspezifisches Dezimaltrennzeichen.|  
|*Bruch Ziffern*|Eine Reihe von Ziffern, die den Bruch Teil der Zahl angibt.|  
|"*E*"|Ein Großbuchstabe "E", der die exponentielle (wissenschaftliche) Notation angibt.|  
|*exponentielle Ziffern*|Eine Reihe von Ziffern, die einen Exponenten angeben.|  
  
 Einige Beispiele für den Rückgabewert sind "100", "-123.456.789", "123,45 e + 6", "500", "3,1416", "600", "-0,123" und "-Infinity".  
  
 Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Formatierungs Themen ausführlicher beschrieben wird:  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Standard <xref:System.Double.ToString?displayProperty=nameWithType>-Methode verwendet, um die Zeichen folgen Darstellungen einer Reihe von <xref:System.Double> Werten anzuzeigen.  
  
 [!code-csharp[System.Double.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Double.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#1)]  
  
 Im folgenden Beispiel wird die Verwendung von <xref:System.Double.ToString%2A>veranschaulicht.  
  
 [!code-cpp[System.Double#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#3)]
 [!code-csharp[System.Double#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#3)]
 [!code-vb[System.Double#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="double.ToString provider" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz unter Berücksichtigung der angegebenen kulturabhängigen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.ToString%28System.IFormatProvider%29>-Methode formatiert einen <xref:System.Double>-Wert im Standardformat ("G" oder allgemein) einer angegebenen Kultur. Wenn Sie ein anderes Format oder eine andere Kultur angeben möchten, verwenden Sie die anderen über Ladungen der <xref:System.Double.ToString%2A>-Methode wie folgt:  
  
|So verwenden Sie das Format|Für Kultur|Verwenden der Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Standard (aktuell)|<xref:System.Double.ToString>|  
|Ein bestimmtes Format oder eine bestimmte Genauigkeit|Standard Kultur (aktuell)|<xref:System.Double.ToString%28System.String%29>|  
|Ein bestimmtes Format oder eine bestimmte Genauigkeit|Eine bestimmte Kultur|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der Rückgabewert kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>oder eine Zeichenfolge in der Form lauten:  
  
 [Sign] ganzzahlige Ziffern [. [ Bruch Ziffern]] [E [Sign] exponentialziffern]  
  
 Optionale Elemente werden in eckige Klammern ([und]) eingeschlossen. Elemente, die den Begriff "Ziffern" enthalten, bestehen aus einer Reihe von numerischen Zeichen zwischen 0 und 9. Die in der folgenden Tabelle aufgeführten Elemente werden unterstützt.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*sign*|Ein negatives Vorzeichen-oder positives Vorzeichen Symbol.|  
|*ganzzahlige Ziffern*|Eine Reihe von Ziffern, die den ganzzahligen Teil der Zahl angibt. Ganzzahlige Ziffern können nicht vorhanden sein, wenn es sich um Bruch Ziffern handelt.|  
|'*.*'|Ein kulturspezifisches Dezimaltrennzeichen.|  
|*Bruch Ziffern*|Eine Reihe von Ziffern, die den Bruch Teil der Zahl angibt.|  
|"*E*"|Ein Großbuchstabe "E", der die exponentielle (wissenschaftliche) Notation angibt.|  
|*exponentielle Ziffern*|Eine Reihe von Ziffern, die einen Exponenten angeben.|  
  
 Einige Beispiele für den Rückgabewert sind "100", "-123.456.789", "123,45 e + 6", "500", "3,1416", "600", "-0,123" und "-Infinity".  
  
 Diese Instanz ist mit dem allgemeinen numerischen Format Bezeichner ("G") formatiert.  
  
 Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Formatierungs Themen ausführlicher beschrieben wird:  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Der `provider`-Parameter ist eine <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A>-Methode ein <xref:System.Globalization.NumberFormatInfo> Objekt zurückgibt. In der Regel ist `provider` ein <xref:System.Globalization.CultureInfo>-Objekt oder ein <xref:System.Globalization.NumberFormatInfo>-Objekt. Der `provider`-Parameter liefert kulturspezifische Informationen, die bei der Formatierung verwendet werden. Wenn `provider` `null`ist, wird der Rückgabewert mit dem <xref:System.Globalization.NumberFormatInfo>-Objekt für die aktuelle Kultur formatiert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Zeichen folgen Darstellung von zwei <xref:System.Double>-Werten mit <xref:System.Globalization.CultureInfo> Objekten angezeigt, die verschiedene Kulturen darstellen.  
  
 [!code-csharp[System.Double.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#2)]
 [!code-vb[System.Double.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#2)]  
  
 Das folgende Beispiel veranschaulicht die Verwendung von <xref:System.Double.ToString%2A>, wobei ein <xref:System.String> und eine <xref:System.IFormatProvider> als Parameter verwendet werden.  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="double.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Eine numerische Formatierungszeichenfolge.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz in die entsprechende Zeichenfolgendarstellung unter Berücksichtigung des angegebenen Formats.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.ToString%28System.String%29>-Methode formatiert einen <xref:System.Double>-Wert in einem angegebenen Format unter Verwendung der Konventionen der aktuellen Kultur. Wenn Sie ein anderes Format oder eine andere Kultur angeben möchten, verwenden Sie die anderen über Ladungen der <xref:System.Double.ToString%2A>-Methode wie folgt:  
  
|So verwenden Sie das Format|Für Kultur|Verwenden der Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Standard Kultur (aktuell)|<xref:System.Double.ToString>|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Ein bestimmtes Format oder eine bestimmte Genauigkeit|Eine bestimmte Kultur|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der Rückgabewert kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>oder die Zeichen folgen Darstellung einer Zahl sein, wie von `format`angegeben.  
  
 Der `format`-Parameter kann ein beliebiger gültiger numerischer Standardformat Bezeichner mit Ausnahme von D und X sowie eine beliebige Kombination von benutzerdefinierten numerischen Format Bezeichnern sein. Wenn `format` `null` oder eine leere Zeichenfolge ist, wird der Rückgabewert mit dem allgemeinen numerischen Format Bezeichner ("G") formatiert.  
  
 Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Formatierungs Themen ausführlicher beschrieben wird:  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Standardmäßig enthält der Rückgabewert nur 15 Dezimalstellen, obwohl intern ein Maximum von 17 Ziffern beibehalten wird. Wenn der Wert dieser Instanz mehr als 15 Ziffern hat, gibt <xref:System.Double.ToString%2A> <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> oder <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> anstelle der erwarteten Zahl zurück. Wenn Sie mehr Genauigkeit benötigen, geben Sie `format` mit der Format Spezifikation "G17" an, die immer 17 Ziffern der Genauigkeit zurückgibt, oder "R", die 15 Ziffern zurückgibt, wenn die Zahl mit dieser Genauigkeit oder 17 Ziffern dargestellt werden kann, wenn die Zahl nur mit maximaler Genauigkeit dargestellt werden kann.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein numerischer Wert definiert und als Währungswert formatiert, indem die standardmäßige numerische Format Zeichenfolge "C" und ein numerischer Wert für drei Dezimalstellen mit der standardmäßigen numerischen Format Zeichenfolge "N" verwendet wird. Die Ergebnis Zeichenfolgen werden anhand der Konventionen der Kultur "en-US" formatiert. Weitere Informationen zu numerischen Format Zeichenfolgen finden Sie unter [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.  
  
 [!code-csharp[System.Double.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString7.cs#7)]
 [!code-vb[System.Double.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString7.vb#7)]  
  
 Im folgenden Beispiel werden mehrere <xref:System.Double> Werte mit den unterstützten numerischen Standardformat Bezeichnerzeichen und drei benutzerdefinierten numerischen Format Zeichenfolgen angezeigt. Eine dieser benutzerdefinierten Format Zeichenfolgen veranschaulicht, wie ein <xref:System.Single> Wert mit führenden Nullen aufgefüllt wird. Außerdem verwendet das Beispiel genauigkeitsspezifizierer mit jedem Standardformat Bezeichner mit Ausnahme von "R". Die Werte der genauigkeitsspezifizierer liegen zwischen 0 und 3. Zum Konvertieren der numerischen Werte in Zeichen folgen verwendet das Beispiel die Formatierungs Konventionen der Kultur "en-US".  
  
 [!code-cpp[System.Double.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Double.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Double.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist ungültig.</exception>
        <block subset="none" type="usage"><para>In einigen Fällen werden <see cref="T:System.Double" />-Werte, die mit der Standardformatzeichenfolge für Zahlen "R" formatiert sind, nicht erfolgreich zurückkonvertiert, wenn sie mit dem <see langword="/platform:x64" />- oder dem <see langword="/platform:anycpu" />-Parameter kompiliert wurden und auf 64-Bit-Systemen ausgeführt werden. Um dieses Problem zu umgehen, formatieren Sie <see cref="T:System.Double" />-Werte mit der Standardformatzeichenfolge für Zahlen "G17". Im folgenden Beispiel wird die Formatzeichenfolge "R" mit einem <see cref="T:System.Double" />-Wert verwendet, der nicht erfolgreich zurückkonvertiert wird, und es wird die Formatzeichenfolge "G17" verwendet, um erfolgreich in den ursprünglichen Wert zurückzukonvertieren.  
  
[! Code-csharp[System. Double.-Zeichenfolge # 6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/roundtripex2.cs#6)] [! Code-vb[System. Double.-Zeichenfolge # 6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/roundtripex2.vb#6)]</para></block>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">Gewusst wie: Auffüllen einer Zahl mit führenden Nullen</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="double.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Eine numerische Formatierungszeichenfolge.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz unter Verwendung des angegebenen Formats und der angegebenen kulturabhängigen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="format" /> und <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>-Methode formatiert einen <xref:System.Double>-Wert in einem angegebenen Format einer angegebenen Kultur. Wenn Sie ein anderes Format oder eine andere Kultur angeben möchten, verwenden Sie die anderen über Ladungen der <xref:System.Double.ToString%2A>-Methode wie folgt:  
  
|So verwenden Sie das Format|Für Kultur|Verwenden der Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Standard Kultur (aktuell)|<xref:System.Double.ToString>|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Ein bestimmtes Format oder eine bestimmte Genauigkeit|Standard Kultur (aktuell)|<xref:System.Double.ToString%28System.String%29>|  
  
 Der Rückgabewert kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>oder die Zeichen folgen Darstellung einer Zahl sein, wie von `format`angegeben.  
  
 Der `format`-Parameter kann ein beliebiger gültiger numerischer Standardformat Bezeichner mit Ausnahme von D und X sowie eine beliebige Kombination von benutzerdefinierten numerischen Format Bezeichnern sein. Wenn `format` `null` oder eine leere Zeichenfolge ist, wird der Rückgabewert für diese Instanz mit dem allgemeinen numerischen Format Bezeichner ("G") formatiert.  
  
 Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Formatierungs Themen ausführlicher beschrieben wird:  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Der `provider`-Parameter ist eine <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A>-Methode ein <xref:System.Globalization.NumberFormatInfo> Objekt zurückgibt. In der Regel ist `provider` ein <xref:System.Globalization.CultureInfo>-Objekt oder ein <xref:System.Globalization.NumberFormatInfo>-Objekt. Der `provider`-Parameter liefert kulturspezifische Informationen, die bei der Formatierung verwendet werden. Wenn `provider` `null`ist, wird der Rückgabewert mit dem <xref:System.Globalization.NumberFormatInfo>-Objekt für die aktuelle Kultur formatiert.  
  
 Standardmäßig enthält der Rückgabewert nur 15 Dezimalstellen, obwohl intern ein Maximum von 17 Ziffern beibehalten wird. Wenn der Wert dieser Instanz mehr als 15 Ziffern hat, gibt <xref:System.Double.ToString%2A> <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> oder <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> anstelle der erwarteten Zahl zurück. Wenn Sie mehr Genauigkeit benötigen, geben Sie `format` mit der Format Spezifikation "G17" an, die immer 17 Ziffern der Genauigkeit zurückgibt, oder "R", die 15 Ziffern zurückgibt, wenn die Zahl mit dieser Genauigkeit oder 17 Ziffern dargestellt werden kann, wenn die Zahl nur mit maximaler Genauigkeit dargestellt werden kann.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.Double> Wert mit den unterstützten numerischen Standardformat bezeichnerwerten für verschiedene Kulturen angezeigt.  
  
 [!code-cpp[System.Double.ToString#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring1.cpp#4)]
 [!code-csharp[System.Double.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Double.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#4)]  
  
 Das folgende Beispiel veranschaulicht die Verwendung von <xref:System.Double.ToString%2A>, wobei ein <xref:System.String> und eine <xref:System.IFormatProvider> als Parameter verwendet werden.  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>In einigen Fällen werden <see cref="T:System.Double" />-Werte, die mit der Standardformatzeichenfolge für Zahlen "R" formatiert sind, nicht erfolgreich zurückkonvertiert, wenn sie mit dem <see langword="/platform:x64" />- oder dem <see langword="/platform:anycpu" />-Parameter kompiliert wurden und auf 64-Bit-Systemen ausgeführt werden. Um dieses Problem zu umgehen, formatieren Sie <see cref="T:System.Double" />-Werte mit der Standardformatzeichenfolge für Zahlen "G17". Im folgenden Beispiel wird die Formatzeichenfolge "R" mit einem <see cref="T:System.Double" />-Wert verwendet, der nicht erfolgreich zurückkonvertiert wird, und es wird die Formatzeichenfolge "G17" verwendet, um erfolgreich in den ursprünglichen Wert zurückzukonvertieren.  
  
[! Code-csharp[System. Double.-Zeichenfolge Nr. 5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/roundtripex1.cs#5)] [! Code-vb[System. Double.-Zeichenfolge Nr. 5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/roundtripex1.vb#5)]</para></block>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">Gewusst wie: Auffüllen einer Zahl mit führenden Nullen</related>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/winforms-formatting-utility-cs/">Beispiel: .net Core-Hilfsprogramm zur FormatierungC#von WinForms ()</related>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/winforms-formatting-utility-vb/">Beispiel: .net Core-Hilfsprogramm für die WinForms-Formatierung (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default, IFormatProvider provider = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="double.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination">Nach Ausführung dieser Methode wird der Wert dieser Instanz als Zeichenspanne formatiert.</param>
        <param name="charsWritten">Nach Ausführung dieser Methode die Anzahl der in <paramref name="destination" /> geschriebenen Zeichen.</param>
        <param name="format">Eine Zeichenspanne, die eine standardmäßige oder benutzerdefinierte Formatzeichenfolge darstellt, die das akzeptable Format für <paramref name="destination" /> definiert.</param>
        <param name="provider">Ein optionales Objekt, das kulturspezifische Formatierungsinformationen für <paramref name="destination" /> bereitstellt</param>
        <summary>Versucht, den Wert der aktuellen Doppelinstanz in die angegebene Zeichenspanne zu formatieren.</summary>
        <returns><see langword="true" />, wenn die Formatierung erfolgreich war, andernfalls <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in die entsprechende Gleitkommazahl mit doppelter Genauigkeit. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <remarks>In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <see cref="F:System.Double.PositiveInfinity" /> oder <see cref="F:System.Double.NegativeInfinity" /> gerundet, wie für die IEEE 754-Spezifikation erforderlich. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.</remarks>
        <altmember cref="Overload:System.Double.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * double -&gt; bool" Usage="System.double.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.Double" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenspanne, die die Zeichenfolgendarstellung der zu konvertierenden Zahl enthält.</param>
        <param name="result">Diese Methode gibt bei erfolgreicher Konvertierung die Gleitkommazahl mit doppelter Genauigkeit zurück, die dem numerischen Wert oder dem im <paramref name="s" />-Parameter enthaltenen Symbol entspricht, oder 0 (null), wenn die Konvertierung fehlgeschlagen ist. Die Konvertierung schlägt fehl, wenn der <paramref name="s" />-Parameter gleich <see langword="null" /> oder leer ist oder nicht in einem Format vorliegt, das mit <paramref name="style" /> kompatibel ist. Die Konvertierung schlägt auch fehl, wenn <paramref name="style" /> keine gültige Kombination von enumerierten <see cref="T:System.Globalization.NumberStyles" />-Konstanten ist. Wenn <paramref name="s" /> eine gültige Zahl kleiner als <see cref="F:System.Double.MinValue" /> ist, ist <paramref name="result" /> gleich <see cref="F:System.Double.NegativeInfinity" />. Wenn <paramref name="s" /> eine gültige Zahl größer als <see cref="F:System.Double.MaxValue" /> ist, ist <paramref name="result" /> gleich <see cref="F:System.Double.PositiveInfinity" />. Dieser Parameter wird nicht initialisiert übergeben. Jeder Wert, der ursprünglich im bereitgestellten <paramref name="result" /> überschrieben werden.</param>
        <summary>Konvertiert die Spannendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende Gleitkommazahl mit doppelter Genauigkeit. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns><see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <see cref="F:System.Double.PositiveInfinity" /> oder <see cref="F:System.Double.NegativeInfinity" /> gerundet, wie für die IEEE 754-Spezifikation erforderlich. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * double -&gt; bool" Usage="System.double.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Double" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die die zu konvertierende Zahl enthält.</param>
        <param name="result">Wenn diese Methode zurückgegeben wird, enthält sie bei erfolgreicher Konvertierung eine Gleitkommazahl mit doppelter Genauigkeit, die dem <paramref name="s" />-Parameter entspricht, oder 0 (null), wenn die Konvertierung fehlgeschlagen ist. Die Konvertierung schlägt fehl, wenn der <paramref name="s" />-Parameter <see langword="null" />, <see cref="F:System.String.Empty" /> oder keine Zahl im gültigen Format ist. Außerdem schlägt sie in .NET Framework und .NET Core 2.2 und früheren Versionen fehl, wenn <paramref name="s" /> eine Zahl kleiner als <see cref="F:System.Double.MinValue" /> oder größer als <see cref="F:System.Double.MaxValue" /> darstellt. Dieser Parameter wird nicht initialisiert übergeben. Jeder Wert, der ursprünglich im bereitgestellten <paramref name="result" /> überschrieben werden.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in die entsprechende Gleitkommazahl mit doppelter Genauigkeit. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns><see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <xref:System.Double.PositiveInfinity> oder <xref:System.Double.NegativeInfinity> gerundet, wie für die IEEE 754-Spezifikation erforderlich. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.

 Diese Überladung unterscheidet sich von der <xref:System.Double.Parse%28System.String%29?displayProperty=nameWithType>-Methode, indem ein boolescher Wert zurückgegeben wird, der angibt, ob der Analyse Vorgang erfolgreich war, anstatt den analysierten numerischen Wert zurückzugeben. Es entfällt, dass die Ausnahmebehandlung verwendet werden muss, um auf eine <xref:System.FormatException> zu testen, wenn `s` ungültig ist und nicht erfolgreich analysiert werden kann.  
  
 Der `s`-Parameter kann die <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType><xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> der aktuellen Kultur enthalten (beim Zeichen folgen Vergleich wird die Groß-/Kleinschreibung beachtet), oder eine Zeichenfolge in der Form:  
  
 Gefangener Gebärden [integrale Ziffern,] ganzzahlige Ziffern [. [ Bruch Ziffern]] [e [Sign] exponentialziffern] [WS]  
  
 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen.|  
|*sign*|Ein negatives Vorzeichen-oder positives Vorzeichen Symbol.|  
|*ganzzahlige Ziffern*|Eine Reihe von numerischen Zeichen im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Ganzzahlige Ziffern können nicht vorhanden sein, wenn es sich um Bruch Ziffern handelt.|  
|*,*|Ein kulturspezifisches Gruppen Trennzeichen.|  
|*.*|Ein kulturspezifisches Dezimaltrennzeichen.|  
|*Bruch Ziffern*|Eine Reihe von numerischen Zeichen im Bereich von 0 bis 9, die den Bruchteil der Zahl angeben.|  
|*E*|Ein Großbuchstabe oder ein Kleinbuchstabe "e", der die exponentielle (wissenschaftliche) Notation angibt.|  
|*exponentielle Ziffern*|Eine Reihe von numerischen Zeichen im Bereich von 0 bis 9, die einen Exponenten angeben.|  
  
 Weitere Informationen zu numerischen Formaten finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Der `s`-Parameter wird mit einer Kombination der <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType>-und <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>-Flags interpretiert. Dies bedeutet, dass Leerzeichen und Tausender Trennzeichen zulässig sind, aber Währungssymbole nicht. Verwenden Sie die <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType>-Methoden Überladung, um die Elemente (z. b. Währungssymbole, Tausende Trennzeichen und Leerzeichen), die in `s`vorhanden sein können, explizit zu definieren.  
  
 Der `s`-Parameter wird mithilfe der Formatierungsinformationen in einem <xref:System.Globalization.NumberFormatInfo>-Objekt analysiert, das für die aktuelle System Kultur initialisiert wird. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Verwenden Sie die <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType>-Methoden Überladung, um eine Zeichenfolge mit den Formatierungsinformationen einer anderen angegebenen Kultur zu analysieren.  
  
 Wenn Sie der <xref:System.Double.TryParse%2A?displayProperty=nameWithType>-Methode eine Zeichenfolge übergeben, die durch Aufrufen der <xref:System.Double.ToString%2A?displayProperty=nameWithType>-Methode erstellt wird, wird normalerweise der ursprüngliche <xref:System.Double> Wert zurückgegeben. Aufgrund eines Genauigkeits Verlusts sind die Werte jedoch möglicherweise nicht gleich. Außerdem kann bei dem Versuch, die Zeichen folgen Darstellung von <xref:System.Double.MinValue?displayProperty=nameWithType> oder <xref:System.Double.MaxValue?displayProperty=nameWithType> zu analysieren, ein Roundtrip nicht durchführt werden. Auf .NET Framework und .net Core 2,2 und früheren Versionen wird eine <xref:System.OverflowException>ausgelöst. In .net Core 3,0 und höheren Versionen wird <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> zurückgegeben, wenn Sie versuchen, <xref:System.Double.MinValue?displayProperty=nameWithtype> zu analysieren oder <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, wenn Sie versuchen, <xref:System.Double.MaxValue?displayProperty=nameWithtype>zu analysieren. Dies wird im folgenden Beispiel veranschaulicht. 
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  

Bei .NET Framework und .net Core 2,2 und früheren Versionen löst die <xref:System.Double.TryParse%28System.String%2CSystem.Double%40%29>-Methode eine <xref:System.OverflowException>aus, wenn `s` außerhalb des Bereichs des <xref:System.Double>-Datentyps liegt.

Unter .net Core 3,0 und höheren Versionen wird keine Ausnahme ausgelöst, wenn `s` außerhalb des Bereichs des <xref:System.Double> Datentyps liegt. In den meisten Fällen berechnet die <xref:System.Double.TryParse%28System.String%2CSystem.Double%40%29>-Methode das Ergebnis <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>. Es gibt jedoch eine kleine Menge von Werten, die sich als näher an den maximalen oder minimalen Werten von <xref:System.Double> als positiv oder minus unendlich aneignen. In diesen Fällen berechnet die Methode das Ergebnis <xref:System.Double.MaxValue?displayProperty=nameWithType> oder <xref:System.Double.MinValue?displayProperty=nameWithType>.

Wenn während eines Analyse Vorgangs ein Trennzeichen im `s`-Parameter gefunden wird und die Dezimal-und Gruppen Trennzeichen identisch sind, geht der Analyse Vorgang davon aus, dass das Trennzeichen ein dezimales Trennzeichen anstelle eines Gruppen Trennzeichens ist. Weitere Informationen zu Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Double.TryParse%28System.String%2CSystem.Double%40%29>-Methode verwendet, um die Zeichen folgen Darstellungen numerischer Werte in <xref:System.Double> Werte zu konvertieren. Dabei wird davon ausgegangen, dass "en-US" die aktuelle Kultur ist.  
  
 [!code-csharp[System.Double.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse1a.cs#1)]
 [!code-vb[System.Double.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse1a.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analysieren numerischer Zeichenfolgen in .NET</related>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/winforms-formatting-utility-cs/">Beispiel: .net Core-Hilfsprogramm zur FormatierungC#von WinForms ()</related>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/winforms-formatting-utility-vb/">Beispiel: .net Core-Hilfsprogramm für die WinForms-Formatierung (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider * double -&gt; bool" Usage="System.double.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.Double" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s">Eine schreibgeschützte Zeichenspanne, die die zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination von <see cref="T:System.Globalization.NumberStyles" />-Werten, die das zulässige Format von <paramref name="s" /> angibt. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="s" /> bereitstellt.</param>
        <param name="result">Diese Methode gibt bei erfolgreicher Konvertierung eine Gleitkommazahl mit doppelter Genauigkeit zurück, die dem numerischen Wert oder dem im <paramref name="s" />-Parameter enthaltenen Symbol entspricht, oder 0 (null), wenn die Konvertierung fehlgeschlagen ist. Die Konvertierung schlägt fehl, wenn der Parameter <paramref name="s" /><see langword="null" /> oder eine leere Zeichenspanne ist oder nicht in einem Format vorliegt, das mit <paramref name="style" /> kompatibel ist. Wenn <paramref name="s" /> eine gültige Zahl kleiner als <see cref="F:System.Double.MinValue" /> ist, ist <paramref name="result" /> gleich <see cref="F:System.Double.NegativeInfinity" />. Wenn <paramref name="s" /> eine gültige Zahl größer als <see cref="F:System.Double.MaxValue" /> ist, ist <paramref name="result" /> gleich <see cref="F:System.Double.PositiveInfinity" />. Dieser Parameter wird nicht initialisiert übergeben. Jeder Wert, der ursprünglich im bereitgestellten <paramref name="result" /> überschrieben werden.</param>
        <summary>Konvertiert eine Zeichenspanne mit der Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende Gleitkommazahl mit doppelter Genauigkeit. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns><see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <see cref="F:System.Double.PositiveInfinity" /> oder <see cref="F:System.Double.NegativeInfinity" /> gerundet, wie für die IEEE 754-Spezifikation erforderlich. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider * double -&gt; bool" Usage="System.double.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Double" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die die zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination von <see cref="T:System.Globalization.NumberStyles" />-Werten, die das zulässige Format von <paramref name="s" /> angibt. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Eine <see cref="T:System.IFormatProvider" />-Schnittstelle, die kulturspezifische Formatierungsinformationen zu <paramref name="s" /> bereitstellt.</param>
        <param name="result">Diese Methode gibt bei erfolgreicher Konvertierung eine Gleitkommazahl mit doppelter Genauigkeit zurück, die dem numerischen Wert oder dem im <paramref name="s" />-Parameter enthaltenen Symbol entspricht, oder 0 (null), wenn die Konvertierung fehlgeschlagen ist. Die Konvertierung kann nicht durchgeführt werden, wenn der <paramref name="s" />-Parameter <see langword="null" /> oder <see cref="F:System.String.Empty" /> ist, kein mit <paramref name="style" /> kompatibles Format aufweist oder <paramref name="style" /> keine gültige Kombination von <see cref="T:System.Globalization.NumberStyles" />-Enumerationskonstanten ist. Außerdem schlägt sie in .NET Framework oder .NET Core 2.2 und früheren Versionen fehl, wenn <paramref name="s" /> eine Zahl kleiner als <see cref="F:System.SByte.MinValue" /> oder größer als <see cref="F:System.SByte.MaxValue" /> darstellt. Dieser Parameter wird nicht initialisiert übergeben. Jeder Wert, der ursprünglich im bereitgestellten <paramref name="result" /> überschrieben werden.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende Gleitkommazahl mit doppelter Genauigkeit. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns><see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <xref:System.Double.PositiveInfinity> oder <xref:System.Double.NegativeInfinity> gerundet, wie für die IEEE 754-Spezifikation erforderlich. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.

 Die <xref:System.Double.TryParse%2A>-Methode ähnelt der <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>-Methode, außer diese Methode löst keine Ausnahme aus, wenn bei der Konvertierung ein Fehler auftritt. Wenn die Konvertierung erfolgreich ist, wird der Rückgabewert `true`, und der `result`-Parameter wird auf das Ergebnis der Konvertierung festgelegt. Wenn bei der Konvertierung ein Fehler auftritt, wird der Rückgabewert `false` und der `result`-Parameter auf 0 (null) festgelegt. Dadurch entfällt die Notwendigkeit, die Ausnahmebehandlung zu verwenden, um auf eine <xref:System.FormatException> zu testen, wenn `s` ungültig ist und nicht erfolgreich analysiert werden kann.  
  
 Der `style`-Parameter definiert das zulässige Format des `s`-Parameters, damit der Analyse Vorgang erfolgreich ausgeführt wird. Dabei muss es sich um eine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> Enumeration handeln. Die folgenden <xref:System.Globalization.NumberStyles> Elemente werden nicht unterstützt:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 Der `s`-Parameter kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>oder <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> für die Kultur enthalten, die durch `provider`angegeben wird. Außerdem kann der `s` Parameter abhängig vom Wert `style`die folgenden Elemente enthalten:  
  
 Gefangener [$] Gebärden [ganzzahlige Ziffern,] ganzzahlige Ziffern [. Bruch Ziffern] [e [Sign] exponentialziffern] [WS]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum. Leerraum kann am Anfang `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>-Flag enthält. Sie kann am Ende der `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>-Flag enthält.|  
|*$*|Ein kulturspezifisches Währungssymbol. Die Position in der Zeichenfolge wird durch die Eigenschaften <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> oder <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> des <xref:System.Globalization.NumberFormatInfo> Objekts definiert, das von der <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType>-Methode des `provider`-Parameters zurückgegeben wird. Das Währungssymbol kann in `s` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>-Flag enthält.|  
|*sign*|Ein optionales Vorzeichen. Das Vorzeichen kann am Anfang `s` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>-Flag enthält, und es kann am Ende `s` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>-Flag enthält. In `s` können Klammern verwendet werden, um einen negativen Wert anzugeben, wenn `style` das <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>-Flag enthält.|  
|*ganzzahlige Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Ganzzahlige Ziffern können nicht vorhanden sein, wenn es sich um Bruch Ziffern handelt.|  
|*,*|Ein kulturspezifisches Tausender Trennzeichen. Das Tausender Trennzeichen der aktuellen Kultur kann in `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>-Flag enthält.|  
|*.*|Ein kulturspezifisches Dezimaltrennzeichen. Das Dezimaltrennzeichen der aktuellen Kultur kann in `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>-Flag enthält.|  
|*Bruch Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den Bruch Teil der Zahl angeben. Bruch Ziffern können in `s` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>-Flag enthält.|  
|*e*|Das e-oder e-Zeichen, das angibt, dass `s` eine Zahl mit exponentieller Notation darstellen kann. Der `s`-Parameter kann eine Zahl in Exponentialnotation darstellen, wenn style das <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>-Flag enthält.|  
|*exponentielle Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die einen Exponenten angeben.|  
  
> [!NOTE]
> Alle abschließenden NUL-Zeichen (U + 0000) in `s` werden vom Analyse-Vorgang unabhängig vom Wert des `style` Arguments ignoriert.

 Eine Zeichenfolge mit nur Ziffern (die dem <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> Stil entspricht) wird immer erfolgreich analysiert, wenn Sie sich im Bereich des <xref:System.Double> Typs befindet. Die verbleibenden <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Member steuern Elemente, die möglicherweise, jedoch nicht in der Eingabe Zeichenfolge vorhanden sein müssen. In der folgenden Tabelle wird angegeben, wie einzelne <xref:System.Globalization.NumberStyles> Flags die Elemente beeinflussen, die möglicherweise in `s`vorhanden sind.  
  
|NumberStyles-Wert|In s zulässige Elemente zusätzlich zu Ziffern|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Nur das ganzzahlige *Ziffern* Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Das Sprachelement *.* und *Bruch Ziffern* Elemente.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Der `s`-Parameter kann auch die Exponentialnotation verwenden. Dieses Flag allein unterstützt Werte in der Form ganzzahlige *Ziffern*E*exponentialziffern*. zusätzliche Flags sind erforderlich, um Zeichen folgen in Exponentialnotation mit solchen Elementen wie positive oder negative Vorzeichen und Dezimaltrennzeichen erfolgreich zu analysieren.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Das *WS* -Element am Anfang `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Das *WS* -Element am Ende `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Das *Sign* -Element am Anfang `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Das *Sign* -Element am Ende `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Das *Vorzeichen* Element in der Form von Klammern, das den numerischen Wert einschließt.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das *-* Element.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das *$* Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|All. Der `s`-Parameter kann keine hexadezimal Zahl oder eine Zahl in Exponentialnotation darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Das *WS* -Element am Anfang oder Ende `s`, *signiert* am Anfang `s`und *.* Tick. Der `s`-Parameter kann auch die Exponentialnotation verwenden.|  
|<xref:System.Globalization.NumberStyles.Number>|Die Elemente `ws`, `sign`, Tausender Trennzeichen (*,)* und Dezimaltrennzeichen (*.*).|  
|<xref:System.Globalization.NumberStyles.Any>|Alle Stile, außer `s` können keine hexadezimal Zahl darstellen.|  
  
 Der `provider`-Parameter ist eine <xref:System.IFormatProvider> Implementierung, z. b. ein <xref:System.Globalization.NumberFormatInfo> oder ein <xref:System.Globalization.CultureInfo> Objekt. Der `provider`-Parameter liefert kulturspezifische Informationen, die beim Parsen verwendet werden. Wenn `provider` `null` oder ein <xref:System.Globalization.NumberFormatInfo> Objekt nicht abgerufen werden kann, werden die Formatinformationen für die aktuelle Kultur verwendet.  
  
 Bei der Konvertierung tritt ein Fehler auf, wenn der `s`-Parameter `null` oder kein numerischer Wert ist. der `provider`-Parameter ergibt kein <xref:System.Globalization.NumberFormatInfo> Objekt, oder der `style`-Parameter ist keine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles>-Enumeration.  
  
 Wenn Sie der <xref:System.Double.TryParse%2A?displayProperty=nameWithType>-Methode eine Zeichenfolge übergeben, die durch Aufrufen der <xref:System.Double.ToString%2A?displayProperty=nameWithType>-Methode erstellt wird, wird normalerweise der ursprüngliche <xref:System.Double> Wert zurückgegeben. Aufgrund eines Genauigkeits Verlusts sind die Werte jedoch möglicherweise nicht gleich. Außerdem kann bei dem Versuch, die Zeichen folgen Darstellung von <xref:System.Double.MinValue?displayProperty=nameWithType> oder <xref:System.Double.MaxValue?displayProperty=nameWithType> zu analysieren, ein Roundtrip nicht durchführt werden. Auf .NET Framework und .net Core 2,2 und früheren Versionen wird eine <xref:System.OverflowException>ausgelöst. In .net Core 3,0 und höheren Versionen wird <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> zurückgegeben, wenn Sie versuchen, <xref:System.Double.MinValue?displayProperty=nameWithtype> zu analysieren oder <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, wenn Sie versuchen, <xref:System.Double.MaxValue?displayProperty=nameWithtype>zu analysieren. Dies wird im folgenden Beispiel veranschaulicht.
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  

Bei .NET Framework und .net Core 2,2 und früheren Versionen löst die <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType>-Methode eine <xref:System.OverflowException>aus, wenn `s` außerhalb des Bereichs des <xref:System.Double>-Datentyps liegt.

Unter .net Core 3,0 und höheren Versionen wird keine Ausnahme ausgelöst, wenn `s` außerhalb des Bereichs des <xref:System.Double> Datentyps liegt. In den meisten Fällen berechnet die <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType>-Methode das Ergebnis <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>. Es gibt jedoch eine kleine Menge von Werten, die sich als näher an den maximalen oder minimalen Werten von <xref:System.Double> als positiv oder minus unendlich aneignen. In diesen Fällen berechnet die Methode das Ergebnis <xref:System.Double.MaxValue?displayProperty=nameWithType> oder <xref:System.Double.MinValue?displayProperty=nameWithType>.

 Wenn während eines Analyse Vorgangs ein Trennzeichen im `s`-Parameter gefunden wird und die entsprechende Währungs-oder Zahlen Dezimal-und Gruppen Trennzeichen identisch sind, geht der Analyse Vorgang davon aus, dass das Trennzeichen ein Dezimaltrennzeichen und nicht ein Gruppen Trennzeichen ist. Weitere Informationen zu Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType>-Methode verwendet wird, um die Zeichen folgen Darstellung von Zahlen zu analysieren, die einen bestimmten Stil aufweisen und mit den Konventionen einer bestimmten Kultur formatiert werden.  
  
 [!code-csharp[System.Double.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Double.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/TryParse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder - 
 <paramref name="style" /> enthält den <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Wert.</exception>
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>
