<Type Name="Double" FullName="System.Double">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f6efd450291ee1ecb6fb857186be54a8c761d4b7" />
    <Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="11/27/2018" />
    <Meta Name="ms.locfileid" Value="52384902" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float64&gt;, class System.IConvertible, class System.IEquatable`1&lt;float64&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Double" />
  <TypeSignature Language="VB.NET" Value="Public Structure Double&#xA;Implements IComparable, IComparable(Of Double), IConvertible, IEquatable(Of Double), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type double = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Gleitkommazahl mit doppelter Genauigkeit dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double> Werttyp stellt eine 64-Bit-Zahl mit doppelter Genauigkeit mit Werten, die im Bereich von negativen 1,79769313486232e308 bis positive 1,79769313486232E308 als auch positive oder negative 0 (null), <xref:System.Double.PositiveInfinity>, <xref:System.Double.NegativeInfinity>, und keine Zahl (<xref:System.Double.NaN>). Es dient zur Darstellung von Werten, dass sind (z. B. die Abstände zwischen Planeten oder Galaxies) sehr große oder sehr klein (molekulare Masse einer Substanz in Kilogramm) und die häufig unpräzise sind (wie der Abstand von der Erde zu einem anderen Sonnensystem), sind die <xref:System.Double> Typ den IEC 60559: 1989 (IEEE 754) für binäre Gleitkommaarithmetik standard entspricht.  
  
 Dieses Thema enthält folgende Abschnitte:  
  
-   [Gleitkommadarstellung und Genauigkeit](#Precision)  
  
-   [Testen auf Gleichheit](#Equality)  
  
-   [Gleitkommazahlen-Punktwerte und Ausnahmen](#Exceptions)  
  
-   [Typumwandlungen und die Double-Struktur](#Conversions)  
  
-   [Gleitkomma-Funktion](#Functionality)  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>Gleitkommadarstellung und Genauigkeit  
 Die <xref:System.Double> -Datentyp speichert in einem binären Format 64-Bit-Gleitkommawerte mit doppelter Genauigkeit, wie in der folgenden Tabelle dargestellt:  
  
|Segment|Bits|  
|----------|----------|  
|Signifikanden oder Mantisse|0-51|  
|Exponent|52-62|  
|Sign (0 = positiv, 1 = Negative)|63|  
  
 Genau wie die Dezimalstellen nicht einige Werte genau darstellen können (z. B. 1/3 oder <xref:System.Math.PI?displayProperty=nameWithType>), binäre Brüche sind nicht möglich, einige Werte darstellen. 1/10, der genau vom.1 als Dezimalbruch dargestellt wird, wird z. B. durch.001100110011 als Binärbruch, mit dem Muster "0011" Wiederholen bis unendlich dargestellt. In diesem Fall bietet der Gleitkommawert eine ungenaue Darstellung der Zahl, die es darstellt. Zusätzliche mathematische Operationen für den ursprünglichen Gleitkommawert häufig ausführen, steigt üblicherweise, ihr Mangel an Genauigkeit. Z. B. wenn wir das Ergebnis Vergleichen der Multiplikation.1 von 10 und Hinzufügen zum.1.1 neunmal, wir finden Sie unter diesen Zusatz, da sie acht weitere Vorgänge beteiligt ist, hat weniger präzise Ergebnis erzeugt. Beachten Sie, dass die Abweichung ist offensichtlich, nur dann, wenn wir die beiden anzeigen <xref:System.Double> Werte mithilfe der "R" [standardmäßige numerische Formatzeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md), wenn nötig angezeigt werden alle 17 Ziffern für die Genauigkeit, die von unterstützt die <xref:System.Double> Typ.  
  
 [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
 [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
 Da einige Zahlen, genau wie Sekundenbruchteile binäre Werte dargestellt werden können, können Gleitkommazahlen ungefähre reelle Zahlen.  
  
 Alle Gleitkommazahlen haben auch eine begrenzte Anzahl von signifikanten Stellen, die auch bestimmt, wie genau ein Gleitkommawert eine reellen Zahl entspricht.   Ein <xref:System.Double> Wert hat bis zu 15 Dezimalstellen, obwohl intern ein Maximum von 17 Ziffern gespeichert wird. Dies bedeutet, dass einige Operationen mit Gleitkommazahlen die Genauigkeit um eine Gleitkommazahl zu ändern. fehlt möglicherweise Wert. Dies wird im folgenden Beispiel veranschaulicht. Es definiert einen sehr großen Gleitkommawert und fügt dann das Produkt der <xref:System.Double.Epsilon?displayProperty=nameWithType> und dabei darauf. Das Produkt ist jedoch zu klein, um den ursprünglichen Gleitkommawert zu ändern. Die am wenigsten signifikante Ziffer ist Zehntausendstel-, während die signifikanteste Ziffer des Produkts 10 ist<sup>-309</sup>.  
  
 [!code-csharp[System.Double.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation2.cs#4)]
 [!code-vb[System.Double.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation2.vb#4)]  
  
 Der eingeschränkte Genauigkeit einer Gleitkommazahl hat mehrere folgen:  
  
-   Zwei Gleitkommazahlen, die für eine bestimmte Genauigkeit gleich angezeigt werden möglicherweise nicht gleich, da es sich bei ihrer letzten gültigen Ziffern unterscheiden. Im folgenden Beispiel werden eine Reihe von Zahlen addiert, und deren Summe wird mit der ihre erwartete Summe verglichen. Obwohl die beiden Werte angezeigt werden, identisch, einen Aufruf der `Equals` -Methode gibt an, dass dies nicht der Fall.  
  
     [!code-csharp[System.Double.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Double.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist3.vb#6)]  
  
     Wenn Sie die Formatelemente in Ändern der <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> -Anweisung aus `{0}` und `{1}` zu `{0:R}` und `{1:R}` anzuzeigende alle signifikanten Ziffern der beiden <xref:System.Double> Werte, es ist klar, dass die beiden Werte ungleich sind, da von einem Genauigkeitsverlust während der Vorgänge hinzufügen. In diesem Fall kann das Problem gelöst werden, durch den Aufruf der <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType> Methode, um das Abrunden der <xref:System.Double> Werte vor dem Vergleich der gewünschten Genauigkeit.  
  
-   Eine mathematische oder Vergleichsoperation-Operation, die eine Gleitkommazahl verwendet möglicherweise nicht das gleiche Ergebnis erzielt, wenn eine Dezimalzahl verwendet wird, da die binäre Gleitkommazahl möglicherweise nicht die Dezimalzahl Wert. In einem vorherigen Beispiel veranschaulicht dies durch das Ergebnis der Multiplikation.1 von 10 und das Hinzufügen von.1 Mal anzeigen.  
  
     Wenn die Genauigkeit der numerischen Operationen mit Bruchwerten wichtig ist, können Sie mithilfe der <xref:System.Decimal> anstelle der <xref:System.Double> Typ. Bei der Genauigkeit der numerischen Operationen mit ganzzahligen Werten außerhalb des Gültigkeitsbereichs für die <xref:System.Int64> oder <xref:System.UInt64> Typen ist wichtig, verwenden Sie die <xref:System.Numerics.BigInteger> Typ.  
  
-   Ein Wert kann nicht zurückkonvertiert, wenn eine Gleitkommazahl einbezogen ist. Ein Wert wird als Roundtrip bezeichnet, wenn ein Vorgang eine ursprüngliche Gleitkommazahl in ein anderes Format wandelt, ein umgekehrter Vorgang das konvertierte Format zurück in eine Gleitkommazahl transformiert und die endgültige Gleitkommazahl nicht gleich dem ursprünglichen ist Gleitkommazahl. Der Roundtrip kann fehlschlagen, da eine oder mehrere Ziffern verloren gehen oder bei einer Konvertierung geändert. Im folgenden Beispiel drei <xref:System.Double> Werte in Zeichenfolgen konvertiert und in einer Datei gespeichert werden. Die wiederhergestellte Werte sind nicht gleich die ursprünglichen Werte, wie die Ausgabe, jedoch zeigt auch, wenn die Werte angezeigt werden, identisch sein.  
  
     [!code-csharp[System.Double.Structure#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist4.cs#7)]
     [!code-vb[System.Double.Structure#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist4.vb#7)]  
  
     In diesem Fall den möglich erfolgreich Roundtrip mithilfe der "G17" [standardmäßige numerische Formatzeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md) die vollständige Genauigkeit beibehalten <xref:System.Double> -Werte, wie im folgenden Beispiel gezeigt.  
  
     [!code-csharp[System.Double.Structure#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist5.cs#8)]
     [!code-vb[System.Double.Structure#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist5.vb#8)]  

   > [!IMPORTANT]
   >  Bei Verwendung mit einem <xref:System.Double> Wert, der Formatbezeichner "R" in einigen Fällen keinen Roundtrip den ursprünglichen Wert. Um sicherzustellen, dass <xref:System.Double> Werte, die erfolgreich in der Formatbezeichner "G17" zu verwenden.

-   <xref:System.Single> Werte müssen weniger Genauigkeit als <xref:System.Double> Werte. Ein <xref:System.Single> -Wert, der in eine entsprechende scheinbar konvertiert wird <xref:System.Double> häufig entspricht nicht der <xref:System.Double> Wert aufgrund der Unterschiede bei mit einfacher Genauigkeit. Im folgenden Beispiel ist das Ergebnis identisch divisionsvorgängen zugewiesen wird eine <xref:System.Double> und <xref:System.Single> Wert. Nach der <xref:System.Single> Wert umgewandelt wird eine <xref:System.Double>, ein Vergleich der beiden Werte wird gezeigt, dass sie ungleich sind.  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     Um dieses Problem zu vermeiden, verwenden Sie entweder die <xref:System.Double> anstelle von der <xref:System.Single> Datentyp aufweisen, oder Verwenden der <xref:System.Math.Round%2A> Methode, damit beide die gleiche Genauigkeit verfügen.  
  
 Außerdem wird das Ergebnis der arithmetischen und Zuordnungsvorgänge mit <xref:System.Double> Werte möglicherweise unterscheiden sich geringfügig von Plattform aufgrund der Präzisionsverlust, der die <xref:System.Double> Typ. Z. B. das Ergebnis der Zuweisung eines literalen <xref:System.Double> Wert kann in den 32-Bit und 64-Bit-Versionen von .NET Framework unterscheiden. Das folgende Beispiel veranschaulicht dies Unterschied, wenn das Literal Wert – 4.42330604244772E-305 und eine Variable, deren Wert - 4.42330604244772E-305 zugewiesen sind eine <xref:System.Double> Variable. Beachten Sie, dass das Ergebnis der <xref:System.Double.Parse%28System.String%29> Methode ist in diesem Fall nicht aus einem Genauigkeitsverlust beeinträchtigt.  
  
 [!code-csharp[System.Double.Class.Precision#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.class.precision/cs/precision1.cs#1)]
 [!code-vb[System.Double.Class.Precision#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.class.precision/vb/precision1.vb#1)]  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>Testen auf Gleichheit  
 Um als gleich betrachtet werden zwei <xref:System.Double> Werte müssen identische Werte darstellen. Jedoch aktivieren aufgrund von Unterschieden in der Genauigkeit zwischen Werten oder aufgrund einer Unterbrechung der Genauigkeit von einem oder beiden Werten, Gleitkommazahlen-Punktwerte, die häufig identisch sein sollen aufgrund der Unterschiede bei ihrer letzten gültigen Ziffern berücksichtigt werden. Daher Aufrufe von der <xref:System.Double.Equals%2A> Methode, um zu bestimmen, ob zwei Werte gleich sind, oder Aufrufe an die <xref:System.Double.CompareTo%2A> Methode, um zu bestimmen, die Beziehung zwischen zwei <xref:System.Double> Werte ergeben häufig unerwartete Ergebnisse. Dies ist im folgenden Beispiel ersichtlich, gleich, in denen zwei scheinbar <xref:System.Double> erweisen Werte berücksichtigt werden, da die erste, 15 Dezimalstellen aufweist, die zweite 17 hat.  
  
 [!code-csharp[System.Double.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Double.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison1.vb#9)]  
  
 Berechnete Werte, die unterschiedliche Codepfade folgen und, die bearbeitet werden auf unterschiedliche Weise häufig, nachweisen berücksichtigt werden. Im folgenden Beispiel eine <xref:System.Double> Wert quadriert wird, und klicken Sie dann die Quadratwurzel berechnet wird, um den ursprünglichen Wert wiederherzustellen. Ein zweites <xref:System.Double> 3.51 multipliziert und Quadrat, bevor die Quadratwurzel des Ergebnisses durch 3.51 auf den ursprünglichen Wert wiederherzustellen dividiert wird. Obwohl die beiden Werte angezeigt werden, identisch sein einen Aufruf der <xref:System.Double.Equals%28System.Double%29> -Methode gibt an, dass sie nicht gleich sind. Zeigt mithilfe der standardmäßigen Formatzeichenfolge "R", um eine Ergebniszeichenfolge zurückzugeben, die alle signifikanten Stellen der einzelnen Double-Wert zeigt an, dass der zweite Wert.0000000000001 ist kleiner als die erste.  
  
 [!code-csharp[System.Double.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Double.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison2.vb#10)]  
  
 In Fällen, in denen ein Verlust der Genauigkeit, die das Ergebnis eines Vergleichs beeinflussen, können Sie eine der folgenden Alternativen zum Aufruf übernehmen die <xref:System.Double.Equals%2A> oder <xref:System.Double.CompareTo%2A> Methode:  
  
-   Rufen Sie die <xref:System.Math.Round%2A?displayProperty=nameWithType> Methode, um sicherzustellen, dass beide Werte die gleiche Genauigkeit enthalten. Das folgende Beispiel ändert die in einem vorherigen Beispiel zum Verwenden dieses Ansatzes damit, dass zwei Bruchzahlen äquivalent sind.  
  
     [!code-csharp[System.Double.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Double.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison3.vb#11)]  
  
     Beachten Sie jedoch, dass das Problem der Genauigkeit weiterhin gilt auf der mittleren Werte gerundet. Weitere Informationen finden Sie unter der Methode <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType>.  
  
-   Test auf Gleichheit ungefähre anstatt auf Gleichheit. Dies erfordert, dass Sie entweder ein absoluter definieren Menge mit dem die beiden Werte unterscheiden sich aber trotzdem können identisch sein, oder, die Sie definieren einen relativen Betrag an, die mit dem der kleinere Wert von der jeweils größere Wert voneinander abweichen kann.  
  
    > [!WARNING]
    >  <xref:System.Double.Epsilon?displayProperty=nameWithType> wird manchmal als eine absolute Maßeinheit für die Entfernung zwischen zwei verwendet <xref:System.Double> Werten, wenn der Test auf Gleichheit.  Allerdings <xref:System.Double.Epsilon?displayProperty=nameWithType> misst den kleinstmöglichen Wert, der hinzugefügt oder davon subtrahiert werden kann eine <xref:System.Double> , deren Wert ist 0 (null). Für die meisten Positive und negative <xref:System.Double> Werte wird der Wert des <xref:System.Double.Epsilon?displayProperty=nameWithType> ist zu klein, um erkannt zu werden. Aus diesem Grund mit Ausnahme der Werte, die 0 (null) sind, empfehlen wir nicht die Verwendung in prüft auf Gleichheit.  
  
     Im folgenden Beispiel wird den zweiten Ansatz zum Definieren einer `IsApproximatelyEqual` -Methode, die die relative Differenz zwischen zwei Werten überprüft. Außerdem im Gegensatz dazu des Ergebnis von Aufrufen an die `IsApproximatelyEqual` Methode und die <xref:System.Double.Equals%28System.Double%29> Methode.  
  
     [!code-csharp[System.Double.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Double.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>Gleitkommazahlen-Punktwerte und Ausnahmen  
 Im Gegensatz zu Vorgängen mit integralen Typen, die Auslösen von Ausnahmen im Fall von Überlauf oder unzulässige Vorgänge, z. B. Division durch 0 (null), sind für Operationen mit Gleitkommazahlen-Punktwerte keine Ausnahmen auslösen. Stattdessen ist das Ergebnis einer Gleitkommaoperation in Ausnahmefällen, 0 (null), + unendlich, negativ unendlich oder keine Zahl (NaN):  
  
-   Wenn das Ergebnis einer Gleitkommaoperation zu klein für das Zielformat ist, ist das Ergebnis 0 (null). Dies kann auftreten, wenn zwei sehr kleine Zahlen, wie im folgenden Beispiel gezeigt multipliziert werden.  
  
     [!code-csharp[System.Double.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Double.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional1.vb#1)]  
  
-   Wenn das Ergebnis einer Gleitkommaoperation des Bereichs des Ziel-Formats überschreitet, wird das Ergebnis des Vorgangs <xref:System.Double.PositiveInfinity> oder <xref:System.Double.NegativeInfinity>je nach Bedarf für das Vorzeichen des Ergebnisses. Das Ergebnis eines Vorgangs, der führt zu einem Überlauf <xref:System.Double.MaxValue?displayProperty=nameWithType> ist <xref:System.Double.PositiveInfinity>, und das Ergebnis eines Vorgangs, der führt zu einem Überlauf <xref:System.Double.MinValue?displayProperty=nameWithType> ist <xref:System.Double.NegativeInfinity>, wie im folgende Beispiel gezeigt.  
  
     [!code-csharp[System.Double.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Double.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Double.PositiveInfinity> auch aus einer Division durch 0 (null), mit der eine positive Dividenden, ausgegeben und <xref:System.Double.NegativeInfinity> führt eine Division durch 0 (null) mit einem negativen Dividend.  
  
-   Wenn eine Gleitkommaoperation ungültig ist, ist das Ergebnis des Vorgangs <xref:System.Double.NaN>. Z. B. <xref:System.Double.NaN> ergibt die folgenden Vorgänge:  
  
    -   Division durch 0 (null) mit einer Dividende 0 (null). Beachten Sie, dass andere Fälle der Division durch 0 (null) Ergebnis entweder <xref:System.Double.PositiveInfinity> oder <xref:System.Double.NegativeInfinity>.  
  
-   Alle Gleitkommaoperation mit eine ungültige Eingabe. Zum Beispiel der Aufruf der <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> Methodenrückgabe mit einem negativen Wert <xref:System.Double.NaN>, wie der Aufruf wird die <xref:System.Math.Acos%2A?displayProperty=nameWithType> Methode mit einem Wert, der größer als oder kleiner als eine negative Zahl ist.  
  
-   Jeder Vorgang mit einem Argument, dessen Wert <xref:System.Double.NaN?displayProperty=nameWithType>.  
  
<a name="Conversions"></a>   
## <a name="type-conversions-and-the-double-structure"></a>Typumwandlungen und die Double-Struktur  
 Die <xref:System.Double> Struktur definiert explizite oder implizite Konvertierungsoperatoren keine; stattdessen Konvertierungen werden vom Compiler implementiert werden.  
  
 Die Konvertierung des Werts eines beliebigen primitiven numerischen Typs auf eine <xref:System.Double> eine erweiternde Konvertierung und daher nicht erfordern einen expliziten Cast-Operator oder eine Konvertierungsmethode aufrufen, es sei denn, sie explizit einen Compiler erfordert. Beispielsweise erfordert der C#-Compiler einen Typumwandlungsoperator für Konvertierungen von <xref:System.Decimal> zu <xref:System.Double>, während Visual Basic-Compiler nicht der Fall ist. Im folgenden Beispiel wird die minimalen oder maximalen Wert von anderen primitiven numerischen Typen in einem <xref:System.Double>.  
  
 [!code-csharp[System.Double.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert1.cs#20)]
 [!code-vb[System.Double.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert1.vb#20)]  
  
 Darüber hinaus die <xref:System.Single> Werte <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, und <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> konvertieren, <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, und <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>bzw.  
  
 Beachten Sie, dass die Konvertierung des Werts der einige numerischen Typen und eine <xref:System.Double> Wert kann ein Genauigkeitsverlust umfassen. Wie im Beispiel wird veranschaulicht, ein Genauigkeitsverlust kann bei der Konvertierung <xref:System.Decimal>, <xref:System.Int64>, <xref:System.Single>, und <xref:System.UInt64> Werte <xref:System.Double> Werte.  
  
 Die Konvertierung von einer <xref:System.Double> Wert mit einem Wert von einem beliebigen anderen primitiven numerischen Datentyp ist eine einschränkende Konvertierung und erfordert ein Cast-Operator (in c#), eine Konvertierungsmethode (in Visual Basic) oder einen Aufruf einer <xref:System.Convert> Methode. Werte außerhalb des Bereichs der der Zieldatentyp, die von des Zieltyps definiert werden `MinValue` und `MaxValue` Eigenschaften verhalten sich wie in der folgenden Tabelle gezeigt.  
  
|Zieltyp|Ergebnis|  
|-----------------|------------|  
|Beliebiger ganzzahliger Typ|Ein <xref:System.OverflowException> -Ausnahme aus, wenn die Konvertierung in einem überprüften Kontext auftritt.<br /><br /> Bei die Konvertierung in einem ungeprüften Kontext (die Standardeinstellung in c#) wird der Konvertierungsvorgang erfolgreich ist, aber der Wert überläuft.|  
|<xref:System.Decimal>|Eine <xref:System.OverflowException>-Ausnahme.|  
|<xref:System.Single>|<xref:System.Single.NegativeInfinity?displayProperty=nameWithType> für negative Werte.<br /><br /> <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> für positive Werte.|  
  
 Darüber hinaus <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, und <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> Auslösen einer <xref:System.OverflowException> für Konvertierungen zu einer ganzen Zahl in einem überprüften Kontext, aber diese Werte Überlauf beim Konvertieren in einem nicht geprüften Kontext zu ganzen Zahlen. Konvertierung in <xref:System.Decimal>, sie immer eine aus einer <xref:System.OverflowException>. Konvertierung in <xref:System.Single>, sie konvertieren in <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, und <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>bzw.  
  
 Beachten Sie, dass es sich bei einem Genauigkeitsverlust führen kann, durch Konvertieren einer <xref:System.Double> Wert in einen anderen numerischen Typ. Bei der Konvertierung von nicht ganzzahligen <xref:System.Double> Werte, wie die Ausgabe des Beispiels zeigt, der Nachkommawert wird abgebrochen, wenn die <xref:System.Double> Wert ist entweder (wie in Visual Basic) gerundet oder gekürzt (wie in C# -Referenz). Konvertierung in <xref:System.Decimal> und <xref:System.Single> Werte, die <xref:System.Double> Wert möglicherweise nicht präzise dargestellt in den Zieldatentyp.  
  
 Im folgenden Beispiel wird eine Anzahl von <xref:System.Double> Werte in verschiedene andere numerischen Typen. Die Konvertierungen erfolgen, in einem überprüften Kontext, in Visual Basic (Standard) und in c# (aufgrund von der [überprüft](~/docs/csharp/language-reference/keywords/checked.md) Schlüsselwort). Die Ausgabe des Beispiels zeigt das Ergebnis für Konvertierungen in einen aktivierten einem nicht geprüften Kontext. Sie können die Konvertierungen in einem nicht geprüften Kontext in Visual Basic durchführen, durch die Kompilierung mit der `/removeintchecks+` Compilerschalter und in c# durch Auskommentieren der `checked` Anweisung.  
  
 [!code-csharp[System.Double.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert2.cs#21)]
 [!code-vb[System.Double.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert2.vb#21)]  
  
 Weitere Informationen zur Konvertierung von numerischen Typen finden Sie unter [Typkonvertierung in .NET Framework](~/docs/standard/base-types/type-conversion.md) und [Typkonvertierungstabellen](~/docs/standard/base-types/conversion-tables.md).  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>Gleitkomma-Funktion  
 Die <xref:System.Double> Struktur und verwandte Typen bieten Ihnen Methoden zum Ausführen von Vorgängen in den folgenden Bereichen:  
  
-   **Vergleich von Werten**. Rufen Sie die <xref:System.Double.Equals%2A> Methode, um zu bestimmen, ob zwei <xref:System.Double> Werte gleich sind, oder die <xref:System.Double.CompareTo%2A> Methode, um die Beziehung zwischen zwei Werten festzulegen.  
  
     Die <xref:System.Double> Struktur unterstützt auch einen vollständigen Satz von Vergleichsoperatoren. Sie können z. B. für Gleichheit oder Ungleichheit testen oder bestimmen, ob ein Wert größer als oder gleich einem anderen ist. Wenn einer der Operanden ein numerischer Typ, außer ist einem <xref:System.Double>, wird eine Konvertierung in einen <xref:System.Double> vor dem Vergleich.  
  
    > [!WARNING]
    >  Aufgrund der Unterschiede bei der Genauigkeit von zwei <xref:System.Double> Werte, die Sie erwarten, gleich sind möglicherweise ausgeschaltet werden, werden die wirkt sich auf das Ergebnis des Vergleichs. Finden Sie unter den [Testen auf Gleichheit](#Equality) Abschnitt, um weitere Informationen zum Vergleichen von zwei <xref:System.Double> Werte.  
  
     Sie können auch aufrufen, die <xref:System.Double.IsNaN%2A>, <xref:System.Double.IsInfinity%2A>, <xref:System.Double.IsPositiveInfinity%2A>, und <xref:System.Double.IsNegativeInfinity%2A> Methoden, um diese speziellen Werte testen.  
  
-   **Mathematische Operationen**. Allgemeine arithmetische Operationen wie Addition, Subtraktion, Multiplikation und Division, implementiert durch Sprachcompiler und Common Intermediate Language (CIL)-Anweisungen und nicht durch <xref:System.Double> Methoden. Wenn einer der Operanden in einer mathematischen Operation ein numerischer Typ, außer ist einem <xref:System.Double>, wird eine Konvertierung in einen <xref:System.Double> vor dem Ausführen des Vorgangs. Das Ergebnis des Vorgangs ist ebenfalls ein <xref:System.Double> Wert.  
  
     Andere mathematischen Operationen ausgeführt werden können, durch den Aufruf `static` (`Shared` in Visual Basic) Methoden in der <xref:System.Math?displayProperty=nameWithType> Klasse. Sie enthält zusätzliche Methoden, die häufig für arithmetische verwendet (z. B. <xref:System.Math.Abs%2A?displayProperty=nameWithType>, <xref:System.Math.Sign%2A?displayProperty=nameWithType>, und <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>), Geometrie (z. B. <xref:System.Math.Cos%2A?displayProperty=nameWithType> und <xref:System.Math.Sin%2A?displayProperty=nameWithType>), und berechnen (z. B. <xref:System.Math.Log%2A?displayProperty=nameWithType>).  
  
     Sie können auch den einzelnen Bits in Bearbeiten einer <xref:System.Double> Wert. Die <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> Methode behält eine <xref:System.Double> Wert die Bitmuster in einer 64-Bit-Ganzzahl. Die <xref:System.BitConverter.GetBytes%28System.Double%29?displayProperty=nameWithType> Methode verwendet wird, gibt die Bitmuster in ein Bytearray zurück.  
  
-   **Rundung**. Rundung wird häufig als eine Methode verwendet zum Reduzieren der Auswirkungen der unterschiedlichen Werte, die aufgrund von Problemen mit der gleitkommadarstellung und die Genauigkeit. Runden Sie können eine <xref:System.Double> -Wert durch Aufrufen der <xref:System.Math.Round%2A?displayProperty=nameWithType> Methode.  
  
-   **Formatieren von**. Sie konvertieren ein <xref:System.Double> Wert in seine Zeichenfolgendarstellung durch Aufrufen der <xref:System.Double.ToString%2A> Methode oder mithilfe der Funktion für kombinierte Formatierung. Weitere Informationen dazu, wie die Zeichenfolgendarstellung von Gleitkommazahlen-Punktwerte Formatzeichenfolgen gesteuert werden, finden Sie unter den [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md) Themen.  
  
-   **Analysieren von Zeichenfolgen**. Sie können angeben, konvertieren die angegebene Zeichenfolgendarstellung eines Gleitkommawerts auf einen <xref:System.Double> Wert durch Aufrufen von entweder die <xref:System.Double.Parse%2A> oder <xref:System.Double.TryParse%2A> Methode. Wenn der Analysevorgang misslingt, die <xref:System.Double.Parse%2A> Methode eine Ausnahme auslöst, während die <xref:System.Double.TryParse%2A> Methodenrückgabe `false`.  
  
-   **Typkonvertierung**. Die <xref:System.Double> -Struktur bietet eine explizite schnittstellenimplementierung für die <xref:System.IConvertible> -Schnittstelle, die Konvertierung zwischen jedem zwei standardmäßigen .NET Framework-Datentypen unterstützt. Sprachcompiler unterstützen auch die implizite Konvertierung von Werten für alle anderen standardmäßigen numerischen Typen zu <xref:System.Double> Werte. Konvertierung von einem standardmäßigen numerischen Datentyp, der Wert einer <xref:System.Double> eine erweiternde Konvertierung und nicht, dass der Benutzer einer Umwandlung Operator oder Konvertierung die Methode,  
  
     Allerdings Konvertierung <xref:System.Int64> und <xref:System.Single> Werte, können mit einem Genauigkeitsverlust verbunden. In der folgende Tabelle sind die Unterschiede bei der Genauigkeit für jeden dieser Typen aufgeführt:  
  
    |Typ|Die maximale Genauigkeit|Interne Genauigkeit|  
    |----------|-----------------------|------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int64>|19 Dezimalstellen.|19 Dezimalstellen.|  
    |<xref:System.Single>|7 Dezimalstellen|9 Dezimalstellen|  
  
     Das Problem der Genauigkeit am häufigsten wirkt sich auf <xref:System.Single> Werte, die konvertiert werden <xref:System.Double> Werte. Im folgenden Beispiel zwei Werte, die, die durch identische divisionsvorgängen sind ungleich, da einer der Werte ist, dass ein mit einfacher Genauigkeit Gleitkommawert konvertiert eine <xref:System.Double>.  
  
     [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
     [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Double>:  
  
 [!code-cpp[Double Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#1)]
 [!code-csharp[Double Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#1)]
 [!code-vb[Double Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle Member dieses Typs sind threadsicher. Mitglieder, die angezeigt werden, so ändern Sie den Zustand der Instanz zurück tatsächlich eine neue Instanz initialisiert wird, mit dem neuen Wert an. Wie bei jeder anderen Art werden lesen und Schreiben in eine freigegebene Variable, die eine Instanz dieses Typs enthält durch eine Sperre um Threadsicherheit zu gewährleisten geschützt.</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Single" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/NET-Framework-4-Formatting-9c4dae8d">Beispiel: .NET Framework 4-Hilfsprogramm zur Formatierung</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt oder einem <see cref="T:System.Double" />-Objekt und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert des angegebenen Objekts bzw. des <see cref="T:System.Double" />-Objekts ist oder mit diesem übereinstimmt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Double) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(double value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : double -&gt; int&#xA;override this.CompareTo : double -&gt; int" Usage="double.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Eine Gleitkommazahl mit doppelter Genauigkeit, mit der der Vergleich erfolgen soll.</param>
        <summary>Vergleicht diese Instanz mit einer angegebenen Gleitkommazahl mit doppelter Genauigkeit und gibt eine Ganzzahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert der angegebenen Gleitkommazahl mit doppelter Genauigkeit ist oder mit dieser übereinstimmt.</summary>
        <returns>Eine Zahl mit Vorzeichen, die das Verhältnis zwischen dem Wert dieser Instanz und <paramref name="value" /> angibt.  
  
 <list type="table"><listheader><term> Rückgabewert 
 </term><description> Beschreibung  
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Diese Instanz ist kleiner als <paramref name="value" />.  
  
- oder -  
Diese Instanz ist keine Zahl (<see cref="F:System.Double.NaN" />), und <paramref name="value" /> ist eine Zahl.  
  
 </description></item><item><term> Zero 
 </term><description> Diese Instanz ist gleich <paramref name="value" />.  
  
- oder -  
Sowohl diese Instanz als auch <paramref name="value" /> sind keine Zahl (<see cref="F:System.Double.NaN" />), <see cref="F:System.Double.PositiveInfinity" />, oder <see cref="F:System.Double.NegativeInfinity" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Diese Instanz ist größer als <paramref name="value" />.  
  
- oder -  
Diese Instanz ist eine Zahl, und <paramref name="value" /> ist keine Zahl (<see cref="F:System.Double.NaN" />).  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Werte müssen als gleich betrachtet werden identisch sein. Insbesondere dann, wenn mehrere mathematische Vorgänge Gleitkommazahlen-Punktwerte abhängig sind, ist es üblich, bis sie an Genauigkeit verlieren und ihre Werte nahezu identisch mit Ausnahme von ihren letzten gültigen Ziffern. Daher den Rückgabewert der <xref:System.Double.CompareTo%2A> Methode manchmal mag überraschend. Multiplikation nach einem bestimmten Wert gefolgt von einer Division durch den gleichen Wert sollte z. B. den ursprünglichen Wert ergeben. Im folgenden Beispiel stellt sich jedoch der berechnete Wert heraus größer als der ursprüngliche Wert sein. Zeigt alle signifikanten Ziffern der beiden Werte mithilfe der "R" [standardmäßige numerische Formatzeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md) gibt an, dass der ursprüngliche Wert in der letzten gültigen Ziffern der berechnete Wert unterscheidet. Informationen zur Behandlung solcher Vergleiche können, finden Sie im Abschnitt "Hinweise" der <xref:System.Double.Equals%28System.Double%29> Methode.  
  
 [!code-csharp[System.Double.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Double.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto2.vb#1)]  
  
 Diese Methode implementiert die <xref:System.IComparable%601?displayProperty=nameWithType> -Schnittstelle und führt etwas bessere Leistung als die <xref:System.Double.CompareTo%2A?displayProperty=nameWithType> Methode, da es keine konvertieren die `value` Parameter für ein Objekt.  
  
 Beachten Sie, dass, obwohl ein Objekt, dessen Wert <xref:System.Double.NaN> gilt als nicht gleich einem anderen Objekt, dessen Wert <xref:System.Double.NaN> (selbst selbst), die <xref:System.IComparable%601> Schnittstelle erfordert, dass `A.CompareTo(A)` 0 (null) zurück.  
  
## <a name="widening-conversions"></a>Erweiterungskonvertierungen  
 Abhängig von der Programmiersprache, ist es eventuell möglich, Code eine <xref:System.Double.CompareTo%2A> Methode, bei der Parametertyp weniger Bits hat (schmaler ist) als der Instanztyp. Dies ist möglich, da einige Programmiersprachen eine implizite erweiternde Konvertierung durchführen, die den Parameter als einen Typ mit wie vielen Bits als die Instanz darstellt.  
  
 Nehmen wir beispielsweise an, der Instanztyp <xref:System.Double> und der Parametertyp ist <xref:System.Int32>. Microsoft c#-Compiler generiert den Anweisungen, um den Wert des Parameters als darstellen einer <xref:System.Double> Objekt und erstellt dann eine <xref:System.Double.CompareTo%28System.Double%29?displayProperty=nameWithType> -Methode, die die Werte der Instanz und die erweiterten Darstellung des Parameters vergleicht.  
  
 Ihre bevorzugte Programmiersprache Dokumentation, um festzustellen, ob der Compiler führt eine implizite erweiternde Konvertierungen von numerischen Typen. Weitere Informationen finden Sie unter den [Typkonvertierungstabellen](~/docs/standard/base-types/conversion-tables.md) Thema.  
  
## <a name="precision-in-comparisons"></a>Genauigkeit in Vergleichen  
 Die Genauigkeit von Gleitkommazahlen außerhalb der dokumentierten Genauigkeit richtet sich nach der Implementierung und die Version von .NET Framework zur Verfügung. Daher kann ein Vergleich von zwei bestimmten Zahlen zwischen den Versionen von .NET Framework geändert werden, da die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, generische und nicht generische Versionen der <xref:System.Double.CompareTo%2A> Methode für verschiedene Wert- und Verweistypen.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="double.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Ein Vergleichsobjekt oder <see langword="null" />.</param>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert des angegebenen Objekts ist oder mit diesem übereinstimmt.</summary>
        <returns>Eine Zahl mit Vorzeichen, die das Verhältnis zwischen dem Wert dieser Instanz und <paramref name="value" /> angibt.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Beschreibung  
 </description></listheader><item><term> Eine negative ganze Zahl 
 </term><description> Diese Instanz ist kleiner als <paramref name="value" />.  
  
- oder -  
Diese Instanz ist keine Zahl (<see cref="F:System.Double.NaN" />), und <paramref name="value" /> ist eine Zahl.  
  
 </description></item><item><term> Zero 
 </term><description> Diese Instanz ist gleich <paramref name="value" />.  
  
- oder -  
Diese Instanz und <paramref name="value" /> sind beide <see langword="Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" /> oder <see cref="F:System.Double.NegativeInfinity" /></description></item><item><term> Eine positive ganze Zahl 
 </term><description> Diese Instanz ist größer als <paramref name="value" />.  
  
- oder -  
Diese Instanz ist eine Zahl, und <paramref name="value" /> ist keine Zahl (<see cref="F:System.Double.NaN" />).  
  
- oder -  
 <paramref name="value" /> ist <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `value` -Parameter muss sein `null` oder eine Instanz von `Double`ist, andernfalls wird eine Ausnahme ausgelöst. Jede Instanz von <xref:System.Double>, unabhängig von seinem Wert wird als größer betrachtet `null`.  
  
 Werte müssen als gleich betrachtet werden identisch sein. Insbesondere dann, wenn mehrere mathematische Vorgänge Gleitkommazahlen-Punktwerte abhängig sind, ist es üblich, bis sie an Genauigkeit verlieren und ihre Werte nahezu identisch mit Ausnahme von ihren letzten gültigen Ziffern. Daher den Rückgabewert der <xref:System.Double.CompareTo%2A> Methode manchmal mag überraschend. Multiplikation nach einem bestimmten Wert gefolgt von einer Division durch den gleichen Wert sollte z. B. den ursprünglichen Wert ergeben. Im folgenden Beispiel stellt sich jedoch der berechnete Wert heraus größer als der ursprüngliche Wert sein. Zeigt alle signifikanten Ziffern der beiden Werte mithilfe der "R" [standardmäßige numerische Formatzeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md) gibt an, dass der ursprüngliche Wert in der letzten gültigen Ziffern der berechnete Wert unterscheidet. Informationen zur Behandlung solcher Vergleiche können, finden Sie im Abschnitt "Hinweise" der <xref:System.Double.Equals%28System.Double%29> Methode.  
  
 [!code-csharp[System.Double.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Double.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto3.vb#2)]  
  
 Diese Methode wird implementiert, zur Unterstützung der <xref:System.IComparable> Schnittstelle. Beachten Sie, dass, obwohl ein <xref:System.Double.NaN> ist nicht als gleich einem anderen <xref:System.Double.NaN> (selbst selbst), die <xref:System.IComparable> Schnittstelle erfordert, dass `A.CompareTo(A)` 0 (null) zurück.  
  
## <a name="precision-in-comparisons"></a>Genauigkeit in Vergleichen  
 Die Genauigkeit von Gleitkommazahlen außerhalb der dokumentierten Genauigkeit richtet sich nach der Implementierung und die Version von .NET Framework zur Verfügung. Daher kann ein Vergleich von zwei bestimmten Zahlen zwischen den Versionen von .NET Framework geändert werden, da die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von `CompareTo` im Kontext des `Double`.  
  
 [!code-cpp[System.Double#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#16)]
 [!code-csharp[System.Double#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#16)]
 [!code-vb[System.Double#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> ist keine <see cref="T:System.Double" />.</exception>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 Epsilon = float64(4.94065645841247E-324)" />
      <MemberSignature Language="DocId" Value="F:System.Double.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Double  = 4.94065645841247E-324" />
      <MemberSignature Language="C++ CLI" Value="public: double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="F#" Value="val mutable Epsilon : double" Usage="System.double.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>4.94065645841247E-324</MemberValue>
      <Docs>
        <summary>Stellt den kleinsten positiven <see cref="T:System.Double" />-Wert dar, der größer als 0 (null) ist. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert des der <xref:System.Double.Epsilon> -Eigenschaft gibt den kleinsten positiven <xref:System.Double> Wert, der in numerischen Operationen oder vergleichen besonders wichtig ist bei den Wert des der <xref:System.Double> Instanz ist 0 (null). Beispielsweise der folgende Code zeigt, die 0 (null) und <xref:System.Double.Epsilon> gelten ungleiche Werte sein, während 0 (null) und die Hälfte der Wert der <xref:System.Double.Epsilon> werden als gleich angesehen.  
  
 [!code-csharp[System.Double.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Double.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon.vb#5)]  
  
 Genauer gesagt: die floating Point-Format umfasst ein Zeichen, eine 52-Bit-Mantisse oder Signifikanden und einen 11-Bit-Exponenten. Wie im folgenden Beispiel wird gezeigt, verfügt über 0 (null), einen Exponenten von-1022 und einer Mantisse 0. <xref:System.Double.Epsilon> verfügt über einen Exponenten von-1022 und einer Mantisse von 1. Dies bedeutet, dass <xref:System.Double.Epsilon> ist von der kleinste positiven <xref:System.Double> Wert größer als 0 (null), und stellt den kleinstmöglichen Wert und das kleinste mögliche Inkrement für eine <xref:System.Double> , deren Exponent ist-1022.  
  
 [!code-csharp[System.Double.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Double.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon1.vb#6)]  
  
 Allerdings die <xref:System.Double.Epsilon> Eigenschaft ist nicht als allgemeines Maß für die Genauigkeit des der <xref:System.Double> -Typ. es gilt nur für <xref:System.Double> -Instanzen, die einen Wert von 0 (null) oder Exponenten-1022 verfügen.  
  
> [!NOTE]
>  Der Wert des der <xref:System.Double.Epsilon> Eigenschaft ist nicht identisch mit Computer Epsilon, der die obere Grenze der relativen Fehlers durch runden in der Gleitkommaarithmetik darstellt.  
  
 Der Wert dieser Konstanten 4.94065645841247e-324.  
  
 Aufgrund der Unterschiede bei ihrer letzten gültigen Ziffern können nicht zwei scheinbar gleichwertige Gleitkommazahlen gleich vergleichen. Z. B. der C#-Ausdruck, `(double)1/3 == (double)0.33333`, die nicht gleich, da die Division auf der linken Seite die maximale Genauigkeit ausgeführt, während die Konstante auf der rechten Seite befindet sich nur auf die angegebenen Ziffern. Wenn Sie einen benutzerdefinierten Algorithmus, der bestimmt erstellen, ob zwei Gleitkommazahlen als gleich betrachtet werden können, nicht empfohlen, dass Sie einen Algorithmus auf den Wert der basieren die <xref:System.Double.Epsilon> Konstante, die den zulässigen absoluten Differenz für festzulegen die beiden Werte als gleich betrachtet werden.  (Dieser Unterschied wird in der Regel deutlich größer als <xref:System.Double.Epsilon>.) Informationen zum Vergleichen von zwei Gleitkommazahlen mit doppelter Genauigkeit-Werten, finden Sie unter <xref:System.Double> und <xref:System.Double.Equals%28System.Double%29>.  
  
## <a name="platform-notes"></a>Anmerkungen zur Plattform  
 Auf ARM-Systemen, den Wert des der <xref:System.Double.Epsilon> Konstante ist zu klein, um erkannt zu werden, damit er 0 (null) entspricht. Sie können definieren, einen alternative Epsilonwert, der gleich 2.2250738585072014E-308 stattdessen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei Instanzen der <see cref="T:System.Double" />-Struktur denselben Wert darstellen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (double obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float64 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(double obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : double -&gt; bool" Usage="double.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="obj">Ein mit dieser Instanz zu vergleichendes <see cref="T:System.Double" />-Objekt.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz und ein angegebenes <see cref="T:System.Double" />-Objekt den gleichen Wert darstellen.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="obj" /> gleich dieser Instanz ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode implementiert die <xref:System.IEquatable%601?displayProperty=nameWithType> -Schnittstelle und führt etwas bessere Leistung als <xref:System.Double.Equals%2A> , da es keine konvertieren die `obj` Parameter für ein Objekt.  
  
## <a name="widening-conversions"></a>Erweiterungskonvertierungen  
 Abhängig von der Programmiersprache, ist es eventuell möglich, Code eine <xref:System.Double.Equals%2A> Methode, bei der Parametertyp weniger Bits hat (schmaler ist) als der Instanztyp. Dies ist möglich, da einige Programmiersprachen eine implizite erweiternde Konvertierung durchführen, die den Parameter als einen Typ mit wie vielen Bits als die Instanz darstellt.  
  
 Nehmen wir beispielsweise an, der Instanztyp <xref:System.Double> und der Parametertyp ist <xref:System.Int32>. Microsoft c#-Compiler generiert den Anweisungen, um den Wert des Parameters als darstellen einer <xref:System.Double> Objekt und erstellt dann eine <xref:System.Double.Equals%28System.Double%29?displayProperty=nameWithType> -Methode, die die Werte der Instanz und die erweiterten Darstellung des Parameters vergleicht.  
  
 Ihre bevorzugte Programmiersprache Dokumentation, um festzustellen, ob der Compiler führt eine implizite erweiternde Konvertierungen von numerischen Typen. Weitere Informationen finden Sie unter den [Typkonvertierungstabellen](~/docs/standard/base-types/conversion-tables.md) Thema.  
  
## <a name="precision-in-comparisons"></a>Genauigkeit in Vergleichen  
 Die <xref:System.Double.Equals%2A> -Methode sollte mit Vorsicht, verwendet werden, da zwei offensichtlich gleiche Werte ungleich aufgrund der unterschiedlichen Genauigkeit von zwei Werten sein können. Im folgenden Beispiel gemeldet, die die <xref:System.Double> .333333 Wert und die <xref:System.Double> Rückgabewert von 1 durch 3 dividiert ungleich sind.  
  
 [!code-csharp[System.Double.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#1)]
 [!code-vb[System.Double.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#1)]  
  
 Anstatt Vergleich, Gleichheit, eine Technik wird eine akzeptable relative Rand Unterschied zwischen zwei Werten definieren (z. B. 001 % einer der Werte). Ist der Absolute Wert des Unterschieds zwischen den beiden Werten kleiner als oder gleich der jeweilige Rand, der Unterschied ist wahrscheinlich aufgrund von Unterschieden in Genauigkeit, und daher die Werte gleich wahrscheinlich sind. Im folgenden Beispiel wird dieses Verfahren zum Vergleichen von.33333 und 1/3, die beiden <xref:System.Double> Werte, die im vorherigen Codebeispiel gefunden werden. In diesem Fall sind die Werte gleich.  
  
 [!code-csharp[System.Double.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#2)]
 [!code-vb[System.Double.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#2)]  
  
> [!NOTE]
>  Da <xref:System.Double.Epsilon> definiert den Ausdruck "Mindestwert" des einen positiven Wert, dessen Bereich in der Nähe von 0 (null) ist, der Unterschied zwischen zwei ähnliche Werte muss größer sein als <xref:System.Double.Epsilon>. Es ist in der Regel deutlich größer als <xref:System.Double.Epsilon>. Aus diesem Grund wird empfohlen, dass Sie nicht verwenden <xref:System.Double.Epsilon> beim Vergleich von <xref:System.Double> Werte hinsichtlich ihrer Gleichheit.  
  
 Eine zweite Technik wird durch Vergleichen des Unterschieds zwischen zwei Gleitkommazahlen mit einem absoluten Wert. Kleiner oder gleich diesem absoluten Wert der Unterschied besteht darin, dass die Zahlen gleich sind. Wenn sie größer ist, sind die Zahlen ungleich. Eine Alternative ist die Auswahl, dass nach dem Zufallsprinzip einen absoluten Wert. Dies ist problematisch, jedoch, da eine akzeptable Rand Unterschied, die Größe abhängt der <xref:System.Double> Werte. Eine zweite Alternative nutzt die Vorteile einer Design-Funktion, der das Gleitkommaformat: der Unterschied zwischen der ganzzahldarstellung aus zwei Gleitkommawerten gibt an, die Anzahl der möglichen Werte für Gleitkommazahlen, die voneinander getrennt sind. Beispielsweise der Unterschied zwischen 0,0 und <xref:System.Double.Epsilon> beträgt 1, da <xref:System.Double.Epsilon> die kleinste darstellbare Wert ist, bei der Arbeit mit einem <xref:System.Double> , deren Wert ist 0 (null). Im folgenden Beispiel wird dieses Verfahren zum Vergleichen von.33333 und 1/3, handelt es sich um <xref:System.Double> Werte, mit dem vorherigen Codebeispiel die <xref:System.Double.Equals%28System.Double%29> Methode gefunden werden. Beachten Sie, die im Beispiel wird die <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> Methode, um einen Gleitkommawert mit doppelter Genauigkeit in die Integer-Darstellung zu konvertieren.  
  
 [!code-csharp[System.Double.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Double.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsabs1.vb#1)]  
  
 Die Genauigkeit von Gleitkommazahlen außerhalb der dokumentierten Genauigkeit richtet sich nach der Implementierung und die Version von .NET Framework zur Verfügung. Daher kann ein Vergleich von zwei bestimmten Zahlen zwischen den Versionen von .NET Framework geändert werden, da die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
 Wenn zwei <xref:System.Double.NaN?displayProperty=nameWithType> Werte hinsichtlich ihrer Gleichheit getestet werden, durch Aufrufen der <xref:System.Double.Equals%2A> -Methode der Methodenrückgabe `true`. Allerdings zwei <xref:System.Double.NaN> Werte werden auf Gleichheit getestet, mit dem Gleichheitsoperator, gibt der Operator `false`. Wenn Sie ermitteln möchten, ob der Wert des eine <xref:System.Double> ist keine Zahl (NaN), eine Alternative besteht darin, rufen Sie die <xref:System.Double.IsNaN%2A> Methode.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Überladungsauflösung des Compiler möglicherweise einen offensichtlichen Unterschied im Verhalten der beiden berücksichtigen <see cref="M:System.Double.Equals(System.Object)" /> Überladungen der Methode. Wenn eine implizite Konvertierung zwischen den <paramref name="obj" /> Argument und ein <see cref="T:System.Double" /> definiert ist und das Argument als nicht typisiert ist ein <see cref="T:System.Object" />, Compilern möglicherweise führen Sie eine implizite Konvertierung und rufen die <see cref="M:System.Double.Equals(System.Double)" /> Methode. Sie rufen Sie andernfalls die <see cref="M:System.Double.Equals(System.Object)" /> Methode, die immer zurückgibt <see langword="false" /> wenn seine <paramref name="obj" /> Argument ist keine <see cref="T:System.Double" /> Wert. Das folgende Beispiel veranschaulicht den Unterschied im Verhalten zwischen den zwei Überladungen. Im Fall von alle primitiven numerischen Typen mit Ausnahme von <see cref="T:System.Decimal" /> und in c# ist der erste Vergleich gibt <see langword="true" /> , da der Compiler automatisch eine erweiternde Konvertierung und ruft führt die <see cref="M:System.Double.Equals(System.Double)" /> -Methode, während die zweite Vergleich Gibt <see langword="false" /> , da der Compiler Ruft die <see cref="M:System.Double.Equals(System.Object)" /> Methode.  
  
[! Code-Csharp[System.Double.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)] [! Code – Vb[System.Double.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Double.Equals(System.Object)" />
        <altmember cref="Overload:System.Double.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="double.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Ein Objekt, das mit dieser Instanz verglichen werden soll.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz gleich einem angegebenen Objekt ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="obj" /> eine Instanz von <see cref="T:System.Double" /> ist, deren Wert gleich dem Wert dieser Instanz ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.Equals%2A> -Methode sollte mit Vorsicht, verwendet werden, da zwei offensichtlich gleiche Werte ungleich aufgrund der unterschiedlichen Genauigkeit von zwei Werten sein können. Im folgenden Beispiel gemeldet, die die <xref:System.Double> .3333 Wert und die <xref:System.Double> zurückgegeben durch Dividieren 1 von 3 ungleich sind.  
  
 [!code-csharp[System.Double.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#3)]
 [!code-vb[System.Double.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#3)]  
  
 Alternativen zum Aufrufen der <xref:System.Double.Equals%2A> -Methode finden Sie in der Dokumentation für die <xref:System.Double.Equals%28System.Double%29> überladen.  
  
> [!NOTE]
>  Da <xref:System.Double.Epsilon> definiert den Ausdruck "Mindestwert" des einen positiven Wert, dessen Bereich in der Nähe von 0 (null) ist, der Unterschied zwischen zwei ähnliche Werte muss größer sein als <xref:System.Double.Epsilon>. Es ist in der Regel deutlich größer als <xref:System.Double.Epsilon>.  
  
 Die Genauigkeit von Gleitkommazahlen außerhalb der dokumentierten Genauigkeit richtet sich nach der Implementierung und die Version von .NET Framework zur Verfügung. Daher kann ein Vergleich von zwei bestimmten Zahlen zwischen den Versionen von .NET Framework geändert werden, da die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
 Wenn zwei <xref:System.Double.NaN?displayProperty=nameWithType> Werte hinsichtlich ihrer Gleichheit getestet werden, durch Aufrufen der <xref:System.Double.Equals%2A> -Methode der Methodenrückgabe `true`. Allerdings zwei <xref:System.Double.NaN> Werte werden auf Gleichheit getestet, mit dem Gleichheitsoperator, gibt der Operator `false`. Wenn Sie ermitteln möchten, ob der Wert des eine <xref:System.Double> ist keine Zahl (NaN), eine Alternative besteht darin, rufen Sie die <xref:System.Double.IsNaN%2A> Methode.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Überladungsauflösung des Compiler möglicherweise einen offensichtlichen Unterschied im Verhalten der beiden berücksichtigen <see cref="M:System.Double.Equals(System.Object)" /> Überladungen der Methode. Wenn eine implizite Konvertierung zwischen den <paramref name="obj" /> Argument und ein <see cref="T:System.Double" /> definiert ist und das Argument als nicht typisiert ist ein <see cref="T:System.Object" />, Compilern möglicherweise führen Sie eine implizite Konvertierung und rufen die <see cref="M:System.Double.Equals(System.Double)" /> Methode. Sie rufen Sie andernfalls die <see cref="M:System.Double.Equals(System.Object)" /> Methode, die immer zurückgibt <see langword="false" /> wenn seine <paramref name="obj" /> Argument ist keine <see cref="T:System.Double" /> Wert. Das folgende Beispiel veranschaulicht den Unterschied im Verhalten zwischen den zwei Überladungen. Im Fall von alle primitiven numerischen Typen mit Ausnahme von <see cref="T:System.Decimal" /> und in c# ist der erste Vergleich gibt <see langword="true" /> , da der Compiler automatisch eine erweiternde Konvertierung und ruft führt die <see cref="M:System.Double.Equals(System.Double)" /> -Methode, während die zweite Vergleich Gibt <see langword="false" /> , da der Compiler Ruft die <see cref="M:System.Double.Equals(System.Object)" /> Methode.  
  
[! Code-Csharp[System.Double.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)] [! Code – Vb[System.Double.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Double.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="double.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für diese Instanz zurück.</summary>
        <returns>Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="double.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den <see cref="T:System.TypeCode" /> für den Werttyp <see cref="T:System.Double" /> zurück.</summary>
        <returns>Die Enumerationskonstante <see cref="F:System.TypeCode.Double" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsFinite(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(double d);" />
      <MemberSignature Language="F#" Value="static member IsFinite : double -&gt; bool" Usage="System.double.IsFinite d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : double -&gt; bool" Usage="System.double.IsInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Eine Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der Wert der angegebenen Zahl minus unendlich oder plus unendlich ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="d" /> entweder <see cref="F:System.Double.PositiveInfinity" /> oder <see cref="F:System.Double.NegativeInfinity" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zurückgeben von Gleitkommaoperationen <xref:System.Double.PositiveInfinity> oder <xref:System.Double.NegativeInfinity> ein Überlauf an.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Double.IsInfinity%2A>:  
  
 [!code-cpp[System.Double#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#11)]
 [!code-csharp[System.Double#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#11)]
 [!code-vb[System.Double#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNaN(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(double d);" />
      <MemberSignature Language="F#" Value="static member IsNaN : double -&gt; bool" Usage="System.double.IsNaN d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Eine Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der angegebene Wert keine Zahl ist (<see cref="F:System.Double.NaN" />).</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="d" /><see cref="F:System.Double.NaN" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zurückgeben von Gleitkommaoperationen <xref:System.Double.NaN> zu signalisieren, dass das Ergebnis des Vorgangs nicht definiert ist. Z. B. Division von 0.0 von 0.0 führt <xref:System.Double.NaN>.  
  
> [!NOTE]
>  <xref:System.Double.IsNaN%2A> Gibt `false` Wenn eine <xref:System.Double> Wert lautet entweder <xref:System.Double.PositiveInfinity> oder <xref:System.Double.NegativeInfinity>. Um diese Werte zu testen, verwenden Sie die <xref:System.Double.IsInfinity%2A>, <xref:System.Double.IsPositiveInfinity%2A>, und <xref:System.Double.IsNegativeInfinity%2A> Methoden.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Double.IsNaN%2A>:  
  
 [!code-cpp[System.Double#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#8)]
 [!code-csharp[System.Double#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#8)]
 [!code-vb[System.Double#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Double.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegative(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(double d);" />
      <MemberSignature Language="F#" Value="static member IsNegative : double -&gt; bool" Usage="System.double.IsNegative d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegativeInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : double -&gt; bool" Usage="System.double.IsNegativeInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Eine Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die angegebene Zahl minus unendlich ergibt.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="d" /><see cref="F:System.Double.NegativeInfinity" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zurückgeben von Gleitkommaoperationen <xref:System.Double.NegativeInfinity> ein Überlauf an.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Double.IsNegativeInfinity%2A>:  
  
 [!code-cpp[System.Double#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#13)]
 [!code-csharp[System.Double#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#13)]
 [!code-vb[System.Double#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#13)]  
[!code-cpp[System.Double#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#4)]
[!code-csharp[System.Double#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#4)]
[!code-vb[System.Double#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#4)]  
[!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
[!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
[!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(double d);" />
      <MemberSignature Language="F#" Value="static member IsNormal : double -&gt; bool" Usage="System.double.IsNormal d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsPositiveInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : double -&gt; bool" Usage="System.double.IsPositiveInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Eine Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die angegebene Zahl plus unendlich ergibt.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="d" /><see cref="F:System.Double.PositiveInfinity" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Zurückgeben von Gleitkommaoperationen <xref:System.Double.PositiveInfinity> ein Überlauf an.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Double.IsPositiveInfinity%2A>:  
  
 [!code-cpp[System.Double#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#12)]
 [!code-csharp[System.Double#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#12)]
 [!code-vb[System.Double#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsSubnormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(double d);" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : double -&gt; bool" Usage="System.double.IsSubnormal d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const double MaxValue = 1.79769313486232E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MaxValue = float64(1.79769313486232E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Double  = 1.79769313486232E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MaxValue = 1.79769313486232E+308;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : double" Usage="System.double.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>1.79769313486232E+308</MemberValue>
      <Docs>
        <summary>Stellt den größtmöglichen Wert von <see cref="T:System.Double" /> dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstanten ist die positive 1. 7976931348623157E + 308.  
  
 Das Ergebnis eines Vorgangs, der überschreitet <xref:System.Double.MaxValue?displayProperty=nameWithType> ist <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>. Im folgenden Beispiel <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> von Vorgängen für Addition, muliplikation und Potenzierung führt, wenn das Ergebnis überschreitet <xref:System.Double.MaxValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Double.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Double.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Double.MaxValue>:  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const double MinValue = -1.79769313486232E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MinValue = float64(-1.79769313486232E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Double  = -1.79769313486232E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MinValue = -1.79769313486232E+308;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : double" Usage="System.double.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-1.79769313486232E+308</MemberValue>
      <Docs>
        <summary>Stellt den kleinstmöglichen Wert von <see cref="T:System.Double" /> dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstanten ist negativ 1. 7976931348623157E + 308.  
  
 Das Ergebnis eines Vorgangs, der kleiner als <xref:System.Double.MinValue?displayProperty=nameWithType> ist <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>. Im folgenden Beispiel <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> Subtraktion und Multiplikation Vorgänge führt, wenn das Ergebnis ist kleiner als <xref:System.Double.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Double.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Double.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Double.MinValue>:  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const double NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NaN = float64(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Double  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: double NaN = NaN;" />
      <MemberSignature Language="F#" Value="val mutable NaN : double" Usage="System.double.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>Stellt einen Wert dar, der keine Zahl ist (<see langword="NaN" />). Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gibt eine Methode oder einen Operator <xref:System.Double.NaN> Wenn das Ergebnis eines Vorgangs ist nicht definiert. Das Ergebnis der Division von 0 (null) von 0 (null) ist z. B. <xref:System.Double.NaN>, wie im folgende Beispiel gezeigt. (Aber beachten Sie, dass eine Zahl ungleich NULL durch 0 (null) dividiert einen zurückgibt <xref:System.Double.PositiveInfinity> oder <xref:System.Double.NegativeInfinity>, je nachdem, auf das Vorzeichen des Divisors.)  
  
 [!code-csharp[System.Double.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#1)]
 [!code-vb[System.Double.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#1)]  
  
 Darüber hinaus eine Methode aufzurufen, mit einer <xref:System.Double.NaN> Wert oder einen Vorgang für eine <xref:System.Double.NaN> Wert gibt <xref:System.Double.NaN>, wie im folgende Beispiel gezeigt.  
  
 [!code-csharp[System.Double.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#2)]
 [!code-vb[System.Double.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#2)]  
  
 Verwenden der <xref:System.Double.IsNaN%2A> Methode, um zu bestimmen, ob ein Wert keine Zahl ist. Die <xref:System.Double.op_Equality%2A> Operator betrachtet zwei <xref:System.Double.NaN> Werte miteinander berücksichtigt werden. Im allgemeinen <xref:System.Double> Operatoren können nicht verwendet werden, zu vergleichenden <xref:System.Double.NaN?displayProperty=nameWithType> mit anderen <xref:System.Double> Werte, obwohl Methoden zum Zeichenfolgenvergleich (z. B. <xref:System.Double.Equals%2A> und <xref:System.Double.CompareTo%2A>) kann. Das folgende Beispiel veranschaulicht den Unterschied im Verhalten zwischen <xref:System.Double> Vergleichsoperatoren und Methoden.  
  
 [!code-csharp[System.Double.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/double.nan4.cs#4)]
 [!code-vb[System.Double.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/double.nan4.vb#4)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung von <xref:System.Double.NaN> veranschaulicht:  
  
 [!code-cpp[System.Double#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#7)]
 [!code-csharp[System.Double#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#7)]
 [!code-vb[System.Double#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNaN(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NegativeInfinity = float64(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Double  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="F#" Value="val mutable NegativeInfinity : double" Usage="System.double.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>Stellt minus unendlich dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstanten ist das Ergebnis der Division einer negativen Zahl durch 0 (null).  
  
 Diese Konstante wird zurückgegeben, wenn das Ergebnis eines Vorgangs ist kleiner als <xref:System.Double.MinValue>.  
  
 Verwendung <xref:System.Double.IsNegativeInfinity%2A> zu bestimmen, ob ein Wert minus unendlich ergibt.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Double.NegativeInfinity>:  
  
 [!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
 [!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
 [!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Equality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : double * double -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei angegebene <see cref="T:System.Double" />-Werte gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.op_Equality%2A> Methode definiert den Gleichheitsoperator für <xref:System.Double> Werte.  
  
 Wenn zwei <xref:System.Double.NaN?displayProperty=nameWithType> Werte hinsichtlich ihrer Gleichheit getestet werden, mithilfe des Gleichheitsoperators, das Ergebnis ist `false`; zwei <xref:System.Double.NaN?displayProperty=nameWithType> Werte nicht als gleich betrachtet werden. Wenn sie hinsichtlich ihrer Gleichheit, durch den Aufruf getestet werden der <xref:System.Double.Equals%2A> -Methode, um das Ergebnis ist `true`.  Wenn Sie ermitteln möchten, ob der Wert des eine <xref:System.Double> ist keine Zahl (NaN), eine Alternative besteht darin, rufen Sie die <xref:System.Double.IsNaN%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : double * double -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Double" />-Wert größer als ein anderer angegebener <see cref="T:System.Double" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.op_GreaterThan%2A> Methode definiert, den Vorgang des größer-als-Operators für <xref:System.Double> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : double * double -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Double" />-Wert größer oder gleich einem anderen angegebenen <see cref="T:System.Double" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.op_GreaterThanOrEqual%2A> Methode definiert, das größer-als-oder-gleich-Operator für den Betrieb <xref:System.Double> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Inequality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : double * double -&gt; bool" Usage="System.double.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei angegebene <see cref="T:System.Double" />-Werte gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.op_Inequality%2A> Methode definiert der Ungleichheitsoperator zum <xref:System.Double> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : double * double -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Double" />-Wert größer als ein anderer angegebener <see cref="T:System.Double" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.op_LessThan%2A> Methode definiert, den Vorgang des kleiner-als-Operators für <xref:System.Double> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : double * double -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Double" /> -Wert kleiner oder gleich einem anderen angegebenen <see cref="T:System.Double" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.op_LessThanOrEqual%2A> Methode definiert, der kleiner-als-oder-gleich-Operator für den Betrieb <xref:System.Double> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in die entsprechende Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <altmember cref="Overload:System.Double.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; double" Usage="System.double.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in die entsprechende Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit doppelter Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `s` Parameter kann der aktuellen Kultur enthalten <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>, oder eine Zeichenfolge der Form:  
  
 [*ws*] [*anmelden*] [*ganzzahligen Ziffern*[*,*]]*ganzzahligen Ziffern*[*.* [*Bruchziffern*]] [E [*anmelden*]*Exponenten-Ziffern*] [*ws*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen.|  
|*sign*|Ein Minuszeichen (-) oder ein Pluszeichen (+). Es können nur ein Vorzeichen verwendet werden.|  
|*Ganzzahl-Ziffern*|Eine Folge von Ziffern zwischen 0 und 9, die den ganzzahligen Teil der Zahl angeben. Wird *ganzzahligen Ziffern* durch ein Gruppentrennzeichen partitioniert werden kann. In einigen Kulturen trennt ein Komma (,) z. B. Gruppen von Tausenden. Die *ganzzahligen Ziffern* Element kann nicht vorhanden, wenn die Zeichenfolge enthält den *Bruchziffern* Element.|  
|,|Ein Tausendertrennzeichen kulturspezifische Trennzeichen-Symbol.|  
|sein.|Eine kulturspezifische Dezimaltrennzeichen.|  
|*fractional-digits*|Eine Folge von Ziffern zwischen 0 und 9, die die Nachkommastellen der Zahl angeben.|  
|E|Das "e" oder "E"-Zeichen, die angibt, dass der Wert in Exponentialschreibweise (wissenschaftlich) dargestellt wird.|  
|*exponential-digits*|Eine Folge von Ziffern zwischen 0 und 9, die einen Exponenten angeben.|  
  
 Die `s` Parameter wird eine Kombination von interpretiert die <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flags. Dies bedeutet, dass Leerraum und Tausende Trennzeichen sind z. B. zulässig, während Währungssymbole nicht der Fall. Eine bei steuern, welche Elemente im zulässig sind `s` aufrufen, damit der Analysevorgang erfolgreich ist, die <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> oder <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 Die `s` -Parameter interpretiert wird, unter Verwendung der Formatierungsinformationen in eine <xref:System.Globalization.NumberFormatInfo> -Objekt, das für die aktuelle Threadkultur initialisiert wird. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Um eine Zeichenfolge, die unter Verwendung der Formatierungsinformationen in einer anderen Kultur zu analysieren, rufen Sie die <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> oder <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode.  
  
 Normalerweise übergeben die <xref:System.Double.Parse%2A?displayProperty=nameWithType> Methode eine Zeichenfolge, die durch den Aufruf erstellt wird die <xref:System.Double.ToString%2A?displayProperty=nameWithType> -Methode, die ursprünglichen <xref:System.Double> Wert wird zurückgegeben. Jedoch können aufgrund einer Unterbrechung der Genauigkeit, die Werte sein nicht gleich. Darüber hinaus versucht beim Analysieren der Zeichenfolgendarstellung eines <xref:System.Double.MinValue> oder <xref:System.Double.MaxValue> löst eine <xref:System.OverflowException>, wie im folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Wenn Sie ein Trennzeichen gefunden wird die `s` Parameter bei einem Analysevorgang, und die geltenden Währung oder Zahl, Dezimalzahl und Gruppentrennzeichen sind identisch, die der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe Trennzeichen. Weitere Informationen zu den Trennzeichen, finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Double.Parse%28System.String%29>-Methode veranschaulicht.  
  
 [!code-cpp[Double Example#5](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#5)]
 [!code-csharp[Double Example#5](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#5)]
 [!code-vb[Double Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> stellt keine Zahl in einem gültigen Format dar.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Double.MinValue" /> oder größer als <see cref="F:System.Double.MaxValue" /> ist.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="M:System.Double.TryParse(System.String,System.Double@)" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; double" Usage="System.double.Parse (s, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die in <paramref name="s" /> vorhanden sein können. Ein häufig anzugebender Wert ist eine Kombination von <see cref="F:System.Globalization.NumberStyles.Float" /> und <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Format in die entsprechende Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit doppelter Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `style` Parameter definiert die Stilelemente (z. B. Leerzeichen, Tausende Trennzeichen und Währungssymbolen), sind zulässig, der `s` Parameter, damit der Analysevorgang erfolgreich ist. Es muss eine Kombination von Bitflags aus den <xref:System.Globalization.NumberStyles> Enumeration. Die folgenden <xref:System.Globalization.NumberStyles> Member werden nicht unterstützt:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Die `s` Parameter kann der aktuellen Kultur enthalten <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, oder <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>. Abhängig vom Wert `style`, es dauert auch die Form:  
  
 [*ws*] [*$*] [*anmelden*] [*ganzzahligen Ziffern*[*,*]] *Ganzzahl-Ziffern*[*.* [*Bruchziffern*]] [E [*anmelden*]*Exponenten-Ziffern*] [*ws*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen. Leerzeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> Flag, und es können angezeigt werden, am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> Flag.|  
|$|Eine kulturspezifische Währungssymbol. Seine Position in der Zeichenfolge wird definiert, durch die <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> Eigenschaften der aktuellen Kultur. In der aktuellen Kultur Währungssymbol angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> Flag.|  
|*sign*|Ein Minuszeichen (-) oder ein Pluszeichen (+). Die Zeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> Flag, und es können angezeigt werden, am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> Flag. Klammern können verwendet werden, `s` um einen negativen Wert anzugeben, ob `style` enthält die <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> Flag.|  
|*Ganzzahl-Ziffern*|Eine Folge von Ziffern zwischen 0 und 9, die den ganzzahligen Teil der Zahl angeben. Die *ganzzahligen Ziffern* Element kann nicht vorhanden, wenn die Zeichenfolge enthält den *Bruchziffern* Element.|  
|,|Eine kulturspezifische Gruppentrennzeichen. In der aktuellen Kultur Gruppentrennzeichen angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flag|  
|sein.|Eine kulturspezifische Dezimaltrennzeichen. In der aktuellen Kultur Dezimaltrennzeichen angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag.|  
|*fractional-digits*|Eine Folge von Ziffern zwischen 0 und 9, die die Nachkommastellen der Zahl angeben. Bruchziffern können angezeigt werden, `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag.|  
|E|Das "e" oder "E"-Zeichen, die angibt, dass der Wert in Exponentialschreibweise (wissenschaftlich) dargestellt wird. Die `s` Parameter kann eine Zahl in Exponentialschreibweise darstellen, wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Flag.|  
|*exponential-digits*|Eine Folge von Ziffern zwischen 0 und 9, die einen Exponenten angeben.|  
  
> [!NOTE]
> Alle abschließenden NULL (U + 0000)-Zeichen im `s` werden ignoriert, durch den Analysevorgang, unabhängig vom Wert für die `style` Argument.

 Eine Zeichenfolge mit der nur Ziffern (Dies entspricht der <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> Stil) immer erfolgreich analysiert. Die verbleibenden <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Member steuern Elemente, die möglicherweise vorhanden, jedoch sind nicht erforderlich, in der Eingabezeichenfolge vorhanden sein. Die folgende Tabelle gibt an, wie einzelne <xref:System.Globalization.NumberStyles> Flags wirken sich auf die Elemente, die ggf. im `s`.  
  
|NumberStyles-Wert|Elemente in zulässig `s` neben Ziffern|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Die *ganzzahligen Ziffern* nur-Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Das Dezimaltrennzeichen (*.*) und *Bruchziffern* Elemente.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das "e" oder "E"-Zeichen, das Exponentialschreibweise angibt. Dieses Flag selbst unterstützt Werte im Formular *Ziffern*E*Ziffern*; zusätzliche Flags sind erforderlich, um die Zeichenfolgen mit Elementen wie die positiven und negativen Vorzeichen und Dezimaltrennzeichen erfolgreich analysiert.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Die *ws* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Die *ws* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Die *anmelden* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Die *anmelden* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Die *anmelden* Element in Form von Klammern, die den numerischen Wert einschließen.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|1.000er-Trennzeichen-Element.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Element, Currency ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle Elemente. Allerdings `s` keine hexadezimale Zahl oder eine Zahl in Exponentialschreibweise darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Die *ws* Element am Anfang oder Ende des `s`, *anmelden* am Anfang des `s`, und das Dezimaltrennzeichen (.). Die `s` Parameter können Sie auch Exponentialschreibweise.|  
|<xref:System.Globalization.NumberStyles.Number>|Die `ws`, `sign`, Tausende Trennzeichen (,) und Dezimaltrennzeichen (.)-Elemente.|  
|<xref:System.Globalization.NumberStyles.Any>|Alle Elemente. Allerdings `s` eine hexadezimale Zahl nicht darstellen kann.|  
  
 Die `s` -Parameter wird analysiert, die unter Verwendung der Formatierungsinformationen in eine <xref:System.Globalization.NumberFormatInfo> -Objekt, das für die aktuelle Systemkultur initialisiert wird. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>.  
  
 Normalerweise übergeben die <xref:System.Double.Parse%2A?displayProperty=nameWithType> Methode eine Zeichenfolge, die durch den Aufruf erstellt wird die <xref:System.Double.ToString%2A?displayProperty=nameWithType> -Methode, die ursprünglichen <xref:System.Double> Wert wird zurückgegeben. Jedoch können aufgrund einer Unterbrechung der Genauigkeit, die Werte sein nicht gleich. Darüber hinaus versucht beim Analysieren der Zeichenfolgendarstellung eines <xref:System.Double.MinValue> oder <xref:System.Double.MaxValue> löst eine <xref:System.OverflowException>, wie im folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Wenn Sie ein Trennzeichen gefunden wird die `s` Parameter bei einem Analysevorgang, und die geltenden Währung oder Zahl, Dezimalzahl und Gruppentrennzeichen sind identisch, die der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe Trennzeichen. Weitere Informationen zu den Trennzeichen, finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> Methode, um die Zeichenfolgendarstellung von analysieren <xref:System.Double> Werte, mit der Kultur En-US.  
  
 [!code-csharp[System.Double.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse.cs#1)]
 [!code-vb[System.Double.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> stellt keine Zahl in einem gültigen Format dar.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Double.MinValue" /> oder größer als <see cref="F:System.Double.MaxValue" /> ist.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder -  
 <paramref name="style" /> enthält den <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Wert.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; double" Usage="System.double.Parse (s, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="s" /> bereitstellt.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem bestimmten kulturspezifischen Format in die entsprechende Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit doppelter Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung von der <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> Methode wird normalerweise verwendet, um Text zu konvertieren, die in einer Vielzahl von Möglichkeiten, formatiert werden, kann ein <xref:System.Double> Wert. Es kann z. B. verwendet werden, um den Text zu konvertieren, der von einem Benutzer in einen numerischen Wert in eine HTML-Textfeld eingegeben werden.  
  
 Die `s` Parameter wird eine Kombination von interpretiert die <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flags. Die `s` kann Parameter enthalten <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, oder <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> für die Kultur, die anhand des `provider`, oder eine Zeichenfolge im Format enthalten:  
  
 [*ws*] [*anmelden*]*ganzzahligen Ziffern*[*.* [*Bruchziffern*]] [E [*anmelden*]*Exponenten-Ziffern*] [*ws*]  
  
 Optionale Elemente werden in eckige Klammern eingeschlossen ([und]). Elemente, die die Begriff "Ziffern" enthalten, bestehen aus einer Reihe von numerischen Zeichen, die im Bereich von 0 bis 9.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen.|  
|*sign*|Ein Minuszeichen (-) oder ein Pluszeichen (+).|  
|*Ganzzahl-Ziffern*|Eine Folge von Ziffern zwischen 0 und 9, die den ganzzahligen Teil der Zahl angeben. Wird *ganzzahligen Ziffern* durch ein Gruppentrennzeichen partitioniert werden kann. In einigen Kulturen trennt ein Komma (,) z. B. Gruppen von Tausenden. Die *ganzzahligen Ziffern* Element kann nicht vorhanden, wenn die Zeichenfolge enthält den *Bruchziffern* Element.|  
|sein.|Eine kulturspezifische Dezimaltrennzeichen.|  
|*fractional-digits*|Eine Folge von Ziffern zwischen 0 und 9, die die Nachkommastellen der Zahl angeben.|  
|E|Das "e" oder "E"-Zeichen, die angibt, dass der Wert in Exponentialschreibweise (wissenschaftlich) dargestellt wird.|  
|*exponential-digits*|Eine Folge von Ziffern zwischen 0 und 9, die einen Exponenten angeben.|  
  
 Weitere Informationen über numerische Formate finden Sie unter den [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md) Thema.  
  
 Die `provider` -Parameter ist ein <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A> Methode gibt eine <xref:System.Globalization.NumberFormatInfo> Objekt, das kulturspezifische Informationen zum Interpretieren des Formats der bereitstellt `s`. Normalerweise ist ein <xref:System.Globalization.NumberFormatInfo> oder <xref:System.Globalization.CultureInfo> Objekt. Wenn `provider` ist `null` oder <xref:System.Globalization.NumberFormatInfo> kann nicht abgerufen werden, die Formatierungsinformationen für die aktuelle Systemkultur verwendet wird.  
  
 Normalerweise übergeben die <xref:System.Double.Parse%2A?displayProperty=nameWithType> Methode eine Zeichenfolge, die durch den Aufruf erstellt wird die <xref:System.Double.ToString%2A?displayProperty=nameWithType> -Methode, die ursprünglichen <xref:System.Double> Wert wird zurückgegeben. Jedoch können aufgrund einer Unterbrechung der Genauigkeit, die Werte sein nicht gleich. Darüber hinaus versucht beim Analysieren der Zeichenfolgendarstellung eines <xref:System.Double.MinValue> oder <xref:System.Double.MaxValue> löst eine <xref:System.OverflowException>, wie im folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Wenn Sie ein Trennzeichen gefunden wird die `s` Parameter bei einem Analysevorgang, und die geltenden Währung oder Zahl, Dezimalzahl und Gruppentrennzeichen sind identisch, die der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe Trennzeichen. Weitere Informationen zu den Trennzeichen, finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Im folgende Beispiel wird-Ereignishandler von einem Web Form auf die Schaltfläche klicken. Er verwendet das von zurückgegebene Array die <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> -Eigenschaft können Sie das Gebietsschema des Benutzers zu bestimmen. Klicken Sie dann Instanziieren einer <xref:System.Globalization.CultureInfo> Objekt, das dieses Gebietsschema entspricht. Die <xref:System.Globalization.NumberFormatInfo> -Objekt, das mit dem gehört <xref:System.Globalization.CultureInfo> Objekt wird dann zum Übergeben der <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> Methode zum Konvertieren des Benutzers die Eingabe für eine <xref:System.Double> Wert.  
  
 [!code-csharp[ParseMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#2)]
 [!code-vb[ParseMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> stellt keine Zahl in einem gültigen Format dar.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Double.MinValue" /> oder größer als <see cref="F:System.Double.MaxValue" /> ist.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As Double" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; double" Usage="System.double.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; double" Usage="System.double.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die in <paramref name="s" /> vorhanden sein können. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="s" /> bereitstellt.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit doppelter Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `style` Parameter definiert die Stilelemente (z. B. Leerzeichen, Tausende Trennzeichen und Währungssymbolen), sind zulässig, der `s` Parameter, damit der Analysevorgang erfolgreich ist. Es muss eine Kombination von Bitflags aus den <xref:System.Globalization.NumberStyles> Enumeration. Die folgenden <xref:System.Globalization.NumberStyles> Member werden nicht unterstützt:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Die `s` kann Parameter enthalten <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, oder <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> für die Kultur, die anhand des `provider`. Abhängig vom Wert `style`, es dauert auch die Form:  
  
 [*ws*] [*$*] [*anmelden*] [*ganzzahligen Ziffern*,]*ganzzahligen Ziffern*[. [ *Bruchziffern*]] [E [*anmelden*]*Exponenten-Ziffern*] [*ws*]  
  
 Elemente müssen in eckigen Klammern ([und]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen. Leerzeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> Flag, und es können angezeigt werden, am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> Flag.|  
|$|Eine kulturspezifische Währungssymbol. Seine Position in der Zeichenfolge wird definiert, durch die <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> Eigenschaften der aktuellen Kultur. In der aktuellen Kultur Währungssymbol angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> Flag.|  
|*sign*|Ein Minuszeichen (-) oder ein Pluszeichen (+). Die Zeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> Flag, und es können angezeigt werden, am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> Flag. Klammern können verwendet werden, `s` um einen negativen Wert anzugeben, ob `style` enthält die <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> Flag.|  
|*Ganzzahl-Ziffern*|Eine Folge von Ziffern zwischen 0 und 9, die den ganzzahligen Teil der Zahl angeben. Die *ganzzahligen Ziffern* Element kann nicht vorhanden, wenn die Zeichenfolge enthält den *Bruchziffern* Element.|  
|,|Eine kulturspezifische Gruppentrennzeichen. In der aktuellen Kultur Gruppentrennzeichen angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flag|  
|sein.|Eine kulturspezifische Dezimaltrennzeichen. In der aktuellen Kultur Dezimaltrennzeichen angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag.|  
|*fractional-digits*|Eine Folge von Ziffern zwischen 0 und 9, die die Nachkommastellen der Zahl angeben. Bruchziffern können angezeigt werden, `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag.|  
|E|Das "e" oder "E"-Zeichen, die angibt, dass der Wert in Exponentialschreibweise (wissenschaftlich) dargestellt wird. Die `s` Parameter kann eine Zahl in Exponentialschreibweise darstellen, wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Flag.|  
|*exponential-digits*|Eine Folge von Ziffern zwischen 0 und 9, die einen Exponenten angeben.|  
  
> [!NOTE]
> Alle abschließenden NULL (U + 0000)-Zeichen im `s` werden ignoriert, durch den Analysevorgang, unabhängig vom Wert für die `style` Argument.

 Eine Zeichenfolge mit der nur Ziffern (Dies entspricht der <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> Stil) immer erfolgreich analysiert. Die verbleibenden <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Member steuern Elemente, die möglicherweise vorhanden, jedoch sind nicht erforderlich, in der Eingabezeichenfolge vorhanden sein. Die folgende Tabelle gibt an, wie einzelne <xref:System.Globalization.NumberStyles> Flags wirken sich auf die Elemente, die ggf. im `s`.  
  
|NumberStyles-Wert|Elemente in zulässig `s` neben Ziffern|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Die *ganzzahligen Ziffern* nur-Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Das Dezimaltrennzeichen (*.*) und *Bruchziffern* Elemente.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das "e" oder "E"-Zeichen, das Exponentialschreibweise angibt. Dieses Flag selbst unterstützt Werte im Formular *Ziffern*E*Ziffern*; zusätzliche Flags sind erforderlich, um die Zeichenfolgen mit Elementen wie die positiven und negativen Vorzeichen und Dezimaltrennzeichen erfolgreich analysiert.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Die *ws* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Die *ws* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Die *anmelden* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Die *anmelden* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Die *anmelden* Element in Form von Klammern, die den numerischen Wert einschließen.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|1.000er-Trennzeichen-Element.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Element, Currency ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle Elemente. Allerdings `s` keine hexadezimale Zahl oder eine Zahl in Exponentialschreibweise darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Die *ws* Element am Anfang oder Ende des `s`, *anmelden* am Anfang des `s`, und das Dezimaltrennzeichen (.). Die `s` Parameter können Sie auch Exponentialschreibweise.|  
|<xref:System.Globalization.NumberStyles.Number>|Die `ws`, `sign`, Tausende Trennzeichen (,) und Dezimaltrennzeichen (.)-Elemente.|  
|<xref:System.Globalization.NumberStyles.Any>|Alle Elemente. Allerdings `s` eine hexadezimale Zahl nicht darstellen kann.|  
  
 Die `provider` -Parameter ist ein <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A> Methode gibt eine <xref:System.Globalization.NumberFormatInfo> Objekt, das kulturspezifische Informationen zum Interpretieren des Formats der bereitstellt `s`. Normalerweise ist ein <xref:System.Globalization.NumberFormatInfo> oder <xref:System.Globalization.CultureInfo> Objekt. Wenn `provider` ist `null` oder <xref:System.Globalization.NumberFormatInfo> kann nicht abgerufen werden, die Formatierungsinformationen für die aktuelle Systemkultur verwendet wird.  
  
 Normalerweise übergeben die <xref:System.Double.Parse%2A?displayProperty=nameWithType> Methode eine Zeichenfolge, die durch den Aufruf erstellt wird die <xref:System.Double.ToString%2A?displayProperty=nameWithType> -Methode, die ursprünglichen <xref:System.Double> Wert wird zurückgegeben. Jedoch können aufgrund einer Unterbrechung der Genauigkeit, die Werte sein nicht gleich. Darüber hinaus versucht beim Analysieren der Zeichenfolgendarstellung eines <xref:System.Double.MinValue> oder <xref:System.Double.MaxValue> löst eine <xref:System.OverflowException>, wie im folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Wenn Sie ein Trennzeichen gefunden wird die `s` Parameter bei einem Analysevorgang, und die geltenden Währung oder Zahl, Dezimalzahl und Gruppentrennzeichen sind identisch, die der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe Trennzeichen. Weitere Informationen zu den Trennzeichen, finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> Methode, um mehrere zeichenfolgendarstellungen Temperaturwerte zum Zuweisen einer `Temperature` Objekt.  
  
 [!code-csharp[System.Double.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse3.cs#2)]
 [!code-vb[System.Double.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> stellt keinen numerischen Wert dar.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder -  
 <paramref name="style" /> ist der <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Wert.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Double.MinValue" /> oder größer als <see cref="F:System.Double.MaxValue" /> ist.</exception>
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const double PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 PositiveInfinity = float64(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Double  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double PositiveInfinity = Infinity;" />
      <MemberSignature Language="F#" Value="val mutable PositiveInfinity : double" Usage="System.double.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>Stellt plus unendlich dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstanten ist das Ergebnis der Division einer positiven Zahl durch 0 (null).  
  
 Diese Konstante wird zurückgegeben, wenn das Ergebnis eines Vorgangs übersteigt <xref:System.Double.MaxValue>.  
  
 Verwendung <xref:System.Double.IsPositiveInfinity%2A> zu bestimmen, ob ein Wert plus unendlich ergibt.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von <xref:System.Double.PositiveInfinity>:  
  
 [!code-cpp[System.Double#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#10)]
 [!code-csharp[System.Double#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#10)]
 [!code-vb[System.Double#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>
          <see langword="true" />, wenn der Wert der aktuellen Instanz nicht 0 (null) ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToBoolean%28System.Double%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Byte" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToByte%28System.Double%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Diese Konvertierung wird nicht unterstützt. Bei dem Versuch der Verwendung dieser Methode wird eine <see cref="T:System.InvalidCastException" /> ausgelöst.</summary>
        <returns>Diese Konvertierung wird nicht unterstützt. Es wird kein Wert zurückgegeben.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In allen Fällen.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Diese Konvertierung wird nicht unterstützt. Bei dem Versuch der Verwendung dieser Methode wird eine <see cref="T:System.InvalidCastException" /> ausgelöst.</summary>
        <returns>Diese Konvertierung wird nicht unterstützt. Es wird kein Wert zurückgegeben.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In allen Fällen.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Decimal" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToDecimal%28System.Double%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Der unveränderte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int16" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToInt16%28System.Double%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int32" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToInt32%28System.Double%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int64" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToInt64%28System.Double%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.SByte" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToSByte%28System.Double%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Single" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToSingle%28System.Double%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, in den dieser <see cref="T:System.Double" />-Wert konvertiert werden soll.</param>
        <param name="provider">Eine <see cref="T:System.IFormatProvider" />-Implementierung, die kulturspezifische Informationen zum Format des zurückgegebenen Werts bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Der in <paramref name="type" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der `static` (`Shared` in Visual Basic) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt16" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToUInt16%28System.Double%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt32" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToUInt32%28System.Double%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Dieser Parameter wird ignoriert.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt64" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative ist das Aufrufen der <xref:System.Convert.ToUInt64%28System.Double%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert den Wert dieser Instanz in die entsprechende Zeichenfolgendarstellung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="double.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert den Wert dieser Instanz in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.ToString> -Methode formatiert einen <xref:System.Double> Wert in der Standardeinstellung ("G" oder Allgemein) Format der aktuellen Kultur. Wenn Sie ein anderes Format, die mit einfacher Genauigkeit und die Kultur angeben möchten, verwenden Sie alle anderen Überladungen der der <xref:System.Double.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Einem bestimmten Format oder die Genauigkeit|(Aktueller) Standardkultur|<xref:System.Double.ToString%28System.String%29>|  
|Einem bestimmten Format oder die Genauigkeit|Eine bestimmte Kultur|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der Rückgabewert kann sein <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, oder eine Zeichenfolge der Form:  
  
 [Sign] Ganzzahl-Ziffern [. [ Bruchziffern]] [e [Sign] exponentiellen-Ziffern]  
  
 Optionale Elemente werden in eckige Klammern eingeschlossen ([und]). Elemente, die die Begriff "Ziffern" enthalten, bestehen aus einer Reihe von numerischen Zeichen, die im Bereich von 0 bis 9. Die in der folgenden Tabelle aufgeführten Elemente werden unterstützt.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*sign*|Ein negatives Vorzeichen oder das Pluszeichen.|  
|*Ganzzahl-Ziffern*|Eine Folge von Ziffern, die den ganzzahligen Teil der Zahl. Ganzzahl-Ziffern nicht vorhanden sein können Wenn Bruchziffern vorhanden sind.|  
|'*.* '|Eine kulturspezifische Dezimaltrennzeichen.|  
|*fractional-digits*|Eine Folge von Ziffern, die die Nachkommastellen der Zahl.|  
|"*e*"|Ein Kleinbuchstabe 'e', der angibt, exponential (wissenschaftlich)-Notation.|  
|*exponential-digits*|Eine Folge von Ziffern, die einen Exponenten angibt.|  
  
 Einige Beispiele des Rückgabewerts sind "100", "-123,456,789", "123. 45e + 6", "500", "3.1416", "600", "-0.123" und "-Infinity".  
  
 .NET Framework bietet umfangreiche formatierungsunterstützung, die in den folgenden Themen zur Formatierung ausführlicher beschrieben wird:  
  
-   Weitere Informationen über numerische Formatbezeichner finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Standardwert <xref:System.Double.ToString?displayProperty=nameWithType> die Zeichenfolgendarstellung einer Zahl der anzuzeigenden Methode <xref:System.Double> Werte.  
  
 [!code-csharp[System.Double.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Double.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#1)]  
  
 Das folgende Beispiel veranschaulicht die Verwendung von <xref:System.Double.ToString%2A>.  
  
 [!code-cpp[System.Double#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#3)]
 [!code-csharp[System.Double#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#3)]
 [!code-vb[System.Double#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="double.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz unter Berücksichtigung der angegebenen kulturabhängigen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.ToString%28System.IFormatProvider%29> -Methode formatiert einen <xref:System.Double> Wert in der Standardeinstellung ("G" oder Allgemein) Format einer angegebenen Kultur. Wenn Sie ein anderes Format oder die Kultur angeben möchten, verwenden Sie alle anderen Überladungen der der <xref:System.Double.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Standard (aktueller)|<xref:System.Double.ToString>|  
|Einem bestimmten Format oder die Genauigkeit|(Aktueller) Standardkultur|<xref:System.Double.ToString%28System.String%29>|  
|Einem bestimmten Format oder die Genauigkeit|Eine bestimmte Kultur|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der Rückgabewert kann sein <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, oder eine Zeichenfolge der Form:  
  
 [Sign] Ganzzahl-Ziffern [. [ Bruchziffern]] [e [Sign] exponentiellen-Ziffern]  
  
 Optionale Elemente werden in eckige Klammern eingeschlossen ([und]). Elemente, die die Begriff "Ziffern" enthalten, bestehen aus einer Reihe von numerischen Zeichen, die im Bereich von 0 bis 9. Die in der folgenden Tabelle aufgeführten Elemente werden unterstützt.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*sign*|Ein negatives Vorzeichen oder das Pluszeichen.|  
|*Ganzzahl-Ziffern*|Eine Folge von Ziffern, die den ganzzahligen Teil der Zahl. Ganzzahl-Ziffern nicht vorhanden sein können Wenn Bruchziffern vorhanden sind.|  
|'*.* '|Eine kulturspezifische Dezimaltrennzeichen.|  
|*fractional-digits*|Eine Folge von Ziffern, die die Nachkommastellen der Zahl.|  
|"*e*"|Ein Kleinbuchstabe 'e', der angibt, exponential (wissenschaftlich)-Notation.|  
|*exponential-digits*|Eine Folge von Ziffern, die einen Exponenten angibt.|  
  
 Einige Beispiele des Rückgabewerts sind "100", "-123,456,789", "123. 45e + 6", "500", "3.1416", "600", "-0.123" und "-Infinity".  
  
 Diese Instanz wird mit dem allgemeinen numerische Formatbezeichner ("G") formatiert.  
  
 .NET Framework bietet umfangreiche formatierungsunterstützung, die in den folgenden Themen zur Formatierung ausführlicher beschrieben wird:  
  
-   Weitere Informationen über numerische Formatbezeichner finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Die `provider` -Parameter ist ein <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A> Methode gibt eine <xref:System.Globalization.NumberFormatInfo> Objekt. In der Regel `provider` ist eine <xref:System.Globalization.CultureInfo> Objekt oder ein <xref:System.Globalization.NumberFormatInfo> Objekt. Die `provider` Parameter liefert kulturspezifische Informationen, die bei der Formatierung verwendete. Wenn `provider` ist `null`, der Rückgabewert formatiert wird, mit der <xref:System.Globalization.NumberFormatInfo> Objekt für die aktuelle Kultur.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine Zeichenfolgendarstellung von zwei <xref:System.Double> Werte mithilfe von <xref:System.Globalization.CultureInfo> Objekte, die verschiedene Kulturen darstellen.  
  
 [!code-csharp[System.Double.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#2)]
 [!code-vb[System.Double.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#2)]  
  
 Das folgende Beispiel veranschaulicht die Verwendung von <xref:System.Double.ToString%2A>, wobei eine <xref:System.String> und <xref:System.IFormatProvider> als Parameter.  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="double.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Eine numerische Formatierungszeichenfolge.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz in die entsprechende Zeichenfolgendarstellung unter Berücksichtigung des angegebenen Formats.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.ToString%28System.String%29> -Methode formatiert einen <xref:System.Double> Wert in einem angegebenen Format mithilfe der Konventionen der aktuellen Kultur. Wenn Sie ein anderes Format oder die Kultur angeben möchten, verwenden Sie alle anderen Überladungen der der <xref:System.Double.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|(Aktueller) Standardkultur|<xref:System.Double.ToString>|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Einem bestimmten Format oder die Genauigkeit|Eine bestimmte Kultur|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der Rückgabewert kann sein <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, oder der Zeichenfolgendarstellung einer Zahl laut `format`.  
  
 Die `format` Parameter kann eine beliebige gültige numerischer Standardformatbezeichner mit Ausnahme der Forschung und Entwicklung sowie X sowie eine beliebige Kombination aus benutzerdefinierten Zahlenformatbezeichner sein. Wenn `format` ist `null` oder eine leere Zeichenfolge, die den Rückgabewert mit dem allgemeinen numerische Formatbezeichner ("G") formatiert ist.  
  
 .NET Framework bietet umfangreiche formatierungsunterstützung, die in den folgenden Themen zur Formatierung ausführlicher beschrieben wird:  
  
-   Weitere Informationen über numerische Formatbezeichner finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Standardmäßig enthält der Rückgabewert nur 15 Dezimalstellen, obwohl intern ein Maximum von 17 Ziffern gespeichert wird. Wenn der Wert dieser Instanz mehr als 15 Ziffern verfügt <xref:System.Double.ToString%2A> gibt <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> oder <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> anstelle der erwarteten Anzahl. Wenn Sie eine höhere Genauigkeit benötigen, geben Sie `format` der "G17" Format-Spezifikation, die immer 17 Ziffern, oder "R" zurückgibt, die 15 Ziffern zurückgibt, wenn die Anzahl mit Genauigkeit oder 17 Ziffern dargestellt werden kann, wenn nur die Anzahl werden kann mit der maximalen Genauigkeit dargestellt.  
  
   
  
## Examples  
 Im folgenden Beispiel definiert einen numerischen Wert und formatiert ihn als einen Währungswert unter Verwendung der standardmäßigen numerischen Formatierungszeichenfolge-Zeichenfolge "C" und als numerischer Wert mit drei Dezimalstellen mithilfe der standardmäßigen numerischen Formatierungszeichenfolge von "N". Die Ergebniszeichenfolgen werden mithilfe der Konventionen der Kultur En-US formatiert. Weitere Informationen zu numerischen Formatzeichenfolgen finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
 [!code-csharp[System.Double.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString7.cs#7)]
 [!code-vb[System.Double.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString7.vb#7)]  
  
 Das folgende Beispiel zeigt mehrere <xref:System.Double> Werte mithilfe der unterstützten standardzahlen-Formatbezeichnern zusammen mit drei benutzerdefinierte numerische Formatzeichenfolgen. Eines dieser benutzerdefinierten Formatzeichenfolgen veranschaulicht, wie eine <xref:System.Single> Wert mit führenden Nullen. Darüber hinaus verwendet das Beispiel mit einfacher Genauigkeit Spezifizierer, mit jeder Standardformatbezeichner "R" mit Ausnahme von. Die Werte von der Genauigkeit Spezifizierer zwischen 0 und 3. Um die numerischen Werte in Zeichenfolgen zu konvertieren, wird im Beispiel die Formatierungskonventionen der Kultur En-US verwendet.  
  
 [!code-cpp[System.Double.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Double.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Double.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> ist ungültig.</exception>
        <block subset="none" type="usage">
          <para>In einigen Fällen werden <see cref="T:System.Double" />-Werte, die mit der Standardformatzeichenfolge für Zahlen "R" formatiert sind, nicht erfolgreich zurückkonvertiert, wenn sie mit dem <see langword="/platform:x64" />- oder dem <see langword="/platform:anycpu" />-Parameter kompiliert wurden und auf 64-Bit-Systemen ausgeführt werden. Um dieses Problem zu umgehen, formatieren Sie <see cref="T:System.Double" />-Werte mit der Standardformatzeichenfolge für Zahlen "G17". Im folgenden Beispiel wird die Formatzeichenfolge "R" mit einem <see cref="T:System.Double" />-Wert verwendet, der nicht erfolgreich zurückkonvertiert wird, und es wird die Formatzeichenfolge "G17" verwendet, um erfolgreich in den ursprünglichen Wert zurückzukonvertieren.  
  
[! Code-Csharp[System.Double.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/roundtripex2.cs#6)] [! Code – Vb[System.Double.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/roundtripex2.vb#6)]</para>
        </block>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">Gewusst wie: Auffüllen einer Zahl mit führenden Nullen</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="double.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Eine numerische Formatierungszeichenfolge.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz unter Verwendung des angegebenen Formats und der angegebenen kulturabhängigen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="format" /> und <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29> -Methode formatiert einen <xref:System.Double> Wert in einem angegebenen Format einer angegebenen Kultur. Wenn Sie ein anderes Format oder die Kultur angeben möchten, verwenden Sie alle anderen Überladungen der der <xref:System.Double.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|(Aktueller) Standardkultur|<xref:System.Double.ToString>|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Einem bestimmten Format oder die Genauigkeit|(Aktueller) Standardkultur|<xref:System.Double.ToString%28System.String%29>|  
  
 Der Rückgabewert kann sein <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, oder der Zeichenfolgendarstellung einer Zahl laut `format`.  
  
 Die `format` Parameter kann eine beliebige gültige numerischer Standardformatbezeichner mit Ausnahme der Forschung und Entwicklung sowie X sowie eine beliebige Kombination aus benutzerdefinierten Zahlenformatbezeichner sein. Wenn `format` ist `null` oder eine leere Zeichenfolge und der Rückgabewert für diese Instanz mit dem allgemeinen numerische Formatbezeichner ("G") formatiert ist.  
  
 .NET Framework bietet umfangreiche formatierungsunterstützung, die in den folgenden Themen zur Formatierung ausführlicher beschrieben wird:  
  
-   Weitere Informationen über numerische Formatbezeichner finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Die `provider` -Parameter ist ein <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A> Methode gibt eine <xref:System.Globalization.NumberFormatInfo> Objekt. In der Regel `provider` ist eine <xref:System.Globalization.CultureInfo> Objekt oder ein <xref:System.Globalization.NumberFormatInfo> Objekt. Die `provider` Parameter liefert kulturspezifische Informationen, die bei der Formatierung verwendete. Wenn `provider` ist `null`, der Rückgabewert formatiert wird, mit der <xref:System.Globalization.NumberFormatInfo> Objekt für die aktuelle Kultur.  
  
 Standardmäßig enthält der Rückgabewert nur 15 Dezimalstellen, obwohl intern ein Maximum von 17 Ziffern gespeichert wird. Wenn der Wert dieser Instanz mehr als 15 Ziffern verfügt <xref:System.Double.ToString%2A> gibt <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> oder <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> anstelle der erwarteten Anzahl. Wenn Sie eine höhere Genauigkeit benötigen, geben Sie `format` der "G17" Format-Spezifikation, die immer 17 Ziffern, oder "R" zurückgibt, die 15 Ziffern zurückgibt, wenn die Anzahl mit Genauigkeit oder 17 Ziffern dargestellt werden kann, wenn nur die Anzahl werden kann mit der maximalen Genauigkeit dargestellt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine <xref:System.Double> Wert mit einer der unterstützten standardzahlen-Formatbezeichnern für verschiedene Kulturen.  
  
 [!code-cpp[System.Double.ToString#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring1.cpp#4)]
 [!code-csharp[System.Double.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Double.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#4)]  
  
 Das folgende Beispiel veranschaulicht die Verwendung von <xref:System.Double.ToString%2A>, wobei eine <xref:System.String> und <xref:System.IFormatProvider> als Parameter.  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>In einigen Fällen werden <see cref="T:System.Double" />-Werte, die mit der Standardformatzeichenfolge für Zahlen "R" formatiert sind, nicht erfolgreich zurückkonvertiert, wenn sie mit dem <see langword="/platform:x64" />- oder dem <see langword="/platform:anycpu" />-Parameter kompiliert wurden und auf 64-Bit-Systemen ausgeführt werden. Um dieses Problem zu umgehen, formatieren Sie <see cref="T:System.Double" />-Werte mit der Standardformatzeichenfolge für Zahlen "G17". Im folgenden Beispiel wird die Formatzeichenfolge "R" mit einem <see cref="T:System.Double" />-Wert verwendet, der nicht erfolgreich zurückkonvertiert wird, und es wird die Formatzeichenfolge "G17" verwendet, um erfolgreich in den ursprünglichen Wert zurückzukonvertieren.  
  
[! Code-Csharp[System.Double.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/roundtripex1.cs#5)] [! Code – Vb[System.Double.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/roundtripex1.vb#5)]</para>
        </block>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md">Formatieren von Typen in .NET</related>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/how-to-pad-a-number-with-leading-zeros.md">Gewusst wie: Auffüllen einer Zahl mit führenden Nullen</related>
        <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/NET-Framework-4-Formatting-9c4dae8d">Beispiel: .NET Framework 4-Hilfsprogramm zur Formatierung</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="double.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in die entsprechende Gleitkommazahl mit doppelter Genauigkeit. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <altmember cref="Overload:System.Double.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.double.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Double" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.double.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Double" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die die zu konvertierende Zahl enthält.</param>
        <param name="result">Wenn diese Methode zurückgegeben wird, enthält sie bei erfolgreicher Konvertierung eine Gleitkommazahl mit doppelter Genauigkeit, die dem <paramref name="s" />-Parameter entspricht, oder 0 (null), wenn die Konvertierung fehlgeschlagen ist. Bei der Konvertierung tritt ein Fehler auf, wenn der <paramref name="s" />-Parameter <see langword="null" /> oder <see cref="F:System.String.Empty" /> ist, keine Zahl in einem gültigen Format ist oder eine Zahl kleiner als <see cref="F:System.Double.MinValue" /> oder größer als <see cref="F:System.Double.MaxValue" /> ist. Dieser Parameter wird nicht initialisiert übergeben; in <paramref name="result" /> ursprünglich übergebene Werte werden ausnahmslos überschrieben.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in die entsprechende Gleitkommazahl mit doppelter Genauigkeit. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung unterscheidet sich von der <xref:System.Double.Parse%28System.String%29?displayProperty=nameWithType> Methode durch einen booleschen Wert, der angibt, ob der Analysevorgang erfolgreich war, anstatt den analysierten numerischen Wert zurückgeben. Es entfällt die Notwendigkeit, eine Ausnahmebehandlung verwendet wird, zum Prüfen auf eine <xref:System.FormatException> , `s` ist ungültig und kann nicht erfolgreich analysiert werden kann.  
  
 Die `s` Parameter kann der aktuellen Kultur enthalten <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> (beim Vergleich der Zeichenfolgen wird beachtet), oder eine Zeichenfolge der Form:  
  
 [ws] [SSO] [ganzzahligen Ziffern,] Ganzzahl-Ziffern [. [ Bruchziffern]] [e [Sign] exponentiellen-Ziffern] [ws]  
  
 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen.|  
|*sign*|Ein negatives Vorzeichen oder das Pluszeichen.|  
|*Ganzzahl-Ziffern*|Eine Reihe von numerischen Zeichen, die im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Ganzzahl-Ziffern nicht vorhanden sein können Wenn Bruchziffern vorhanden sind.|  
|*,*|Eine kulturspezifische Gruppentrennzeichen.|  
|*.*|Eine kulturspezifische Dezimaltrennzeichen.|  
|*fractional-digits*|Eine Reihe von numerischen Zeichen, die im Bereich von 0 bis 9, die die Nachkommastellen der Zahl angeben.|  
|*E*|Ein klein-oder Großbuchstaben und Zeichen 'e', der Exponentialschreibweise (wissenschaftlich) angibt.|  
|*exponential-digits*|Eine Reihe von numerischen Zeichen, die im Bereich von 0 bis 9, die einen Exponenten angeben.|  
  
 Weitere Informationen über numerische Formate finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Die `s` Parameter wird mithilfe einer Kombination von interpretiert die <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flags. Dies bedeutet, dass Leerraum und Tausende Trennzeichen zulässig sind Währungssymbole sind jedoch nicht. Die Elemente explizit zu definieren (wie Währungssymbole, Tausende Trennzeichen und Leerraum) in vorhanden sein können `s`, verwenden die <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> -methodenüberladung.  
  
 Die `s` -Parameter wird analysiert, die unter Verwendung der Formatierungsinformationen in eine <xref:System.Globalization.NumberFormatInfo> -Objekt, das für die aktuelle Systemkultur initialisiert wird. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Analysieren eine Zeichenfolge unter Verwendung der Formatierungsinformationen in einer anderen Kultur angegeben, verwenden Sie die <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> -methodenüberladung.  
  
 Normalerweise übergeben die <xref:System.Double.TryParse%2A?displayProperty=nameWithType> Methode eine Zeichenfolge, die durch den Aufruf erstellt wird die <xref:System.Double.ToString%2A?displayProperty=nameWithType> -Methode, die ursprünglichen <xref:System.Double> Wert wird zurückgegeben. Jedoch können aufgrund einer Unterbrechung der Genauigkeit, die Werte sein nicht gleich. Darüber hinaus versucht beim Analysieren der Zeichenfolgendarstellung eines <xref:System.Double.MinValue> oder <xref:System.Double.MaxValue> löst eine <xref:System.OverflowException>, wie im folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  
  
 Wenn eine Trennzeichen, in gefunden wird der `s` Parameter bei einem Analysevorgang, und die Trennzeichen decimal "und" Gruppe identisch sind, die der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen und ein Gruppentrennzeichen ist. Weitere Informationen zu den Trennzeichen, finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Double.TryParse%28System.String%2CSystem.Double%40%29> konvertiert die zeichenfolgendarstellungen von numerischen Werten für die Methode <xref:System.Double> Werte. Es wird davon ausgegangen, dass diese En-US, die aktuelle Kultur ist.  
  
 [!code-csharp[System.Double.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse1a.cs#1)]
 [!code-vb[System.Double.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse1a.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analysieren numerischer Zeichenfolgen in .NET</related>
        <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/NET-Framework-4-Formatting-9c4dae8d">Beispiel: .NET Framework 4-Hilfsprogramm zur Formatierung</related>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.double.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Double" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.double.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Double" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die die zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination von <see cref="T:System.Globalization.NumberStyles" />-Werten, die das zulässige Format von <paramref name="s" /> angibt. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Eine <see cref="T:System.IFormatProvider" />-Schnittstelle, die kulturspezifische Formatierungsinformationen zu <paramref name="s" /> bereitstellt.</param>
        <param name="result">Diese Methode gibt bei erfolgreicher Konvertierung eine Gleitkommazahl mit doppelter Genauigkeit zurück, die dem numerischen Wert oder dem im <paramref name="s" />-Parameter enthaltenen Symbol entspricht, oder 0 (null), wenn die Konvertierung fehlgeschlagen ist. Die Konvertierung kann nicht durchgeführt werden, wenn der <paramref name="s" />-Parameter <see langword="null" /> oder <see cref="F:System.String.Empty" /> ist, kein mit <paramref name="style" /> kompatibles Format aufweist, eine Zahl kleiner als <see cref="F:System.SByte.MinValue" /> oder größer als <see cref="F:System.SByte.MaxValue" /> darstellt, oder wenn <paramref name="style" /> keine gültige Kombination von <see cref="T:System.Globalization.NumberStyles" />-Enumerationskonstanten ist. Dieser Parameter wird nicht initialisiert übergeben; in <paramref name="result" /> ursprünglich übergebene Werte werden ausnahmslos überschrieben.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende Gleitkommazahl mit doppelter Genauigkeit. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.TryParse%2A> Methode entspricht der <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> Methode, außer diese Methode keine Ausnahme auslöst, wenn die Konvertierung schlägt fehl. Wenn die Konvertierung erfolgreich ist, wird der Rückgabewert ist `true` und `result` Parameter auf das Ergebnis der Konvertierung festgelegt ist. Wenn die Konvertierung fehlschlägt, wird der Rückgabewert ist `false` und `result` Parameter auf 0 (null) festgelegt ist. Hierdurch entfällt die Notwendigkeit, Ausnahmebehandlung zu verwenden, um zu testen einer <xref:System.FormatException> , `s` ist ungültig und kann nicht erfolgreich analysiert werden kann.  
  
 Die `style` Parameter definiert das zulässige Format von der `s` Parameter, damit der Analysevorgang erfolgreich ist. Es muss eine Kombination von Bitflags aus den <xref:System.Globalization.NumberStyles> Enumeration. Die folgenden <xref:System.Globalization.NumberStyles> Member werden nicht unterstützt:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 Die `s` kann Parameter enthalten <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, oder <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> für die Kultur, angegeben durch `provider`. Darüber hinaus, abhängig vom Wert `style`, `s` Parameter die folgenden Elemente enthalten:  
  
 [ws] [$] [SSO] [ganzzahligen Ziffern,] [.fractional-Ziffern] [e [Sign] exponentiellen-Ziffern] Ganzzahl-Ziffern [ws]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Optionalen Leerzeichen. Leerzeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> Flag. Es kann angezeigt werden, am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> Flag.|  
|*$*|Eine kulturspezifische Währungssymbol. Seine Position in der Zeichenfolge wird definiert, durch die <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> oder <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> Eigenschaften der <xref:System.Globalization.NumberFormatInfo> zurückgegebenes Objekt der <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> -Methode der der `provider` Parameter. Das Währungssymbol angezeigt werden kann, im `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> Flag.|  
|*sign*|Einem optionalen Vorzeichen. Die Zeichen am Anfang stehen `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> Flag, und es können angezeigt werden, am Ende der `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> Flag. Klammern können verwendet werden, `s` um einen negativen Wert anzugeben, ob `style` enthält die <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> Flag.|  
|*Ganzzahl-Ziffern*|Eine Folge von Ziffern zwischen 0 und 9, die den ganzzahligen Teil der Zahl angeben. Ganzzahl-Ziffern nicht vorhanden sein können Wenn Bruchziffern vorhanden sind.|  
|*,*|Ein Tausendertrennzeichen kulturspezifische Trennzeichen-Symbol. Tausende von der aktuellen Kultur als Trennzeichen kann angezeigt werden, `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flag.|  
|*.*|Eine kulturspezifische Dezimaltrennzeichen. In der aktuellen Kultur Dezimaltrennzeichen angezeigt werden kann `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag.|  
|*fractional-digits*|Eine Folge von Ziffern zwischen 0 und 9, die die Nachkommastellen der Zahl angeben. Bruchziffern können angezeigt werden, `s` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag.|  
|*e*|Das e oder E-Zeichen, der angibt, dass `s` kann eine Zahl, die mit der Exponentialschreibweise darstellen. Die `s` Parameter kann eine Zahl in Exponentialschreibweise darstellen, wenn Style enthält die <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Flag.|  
|*exponential-digits*|Eine Folge von Ziffern zwischen 0 und 9, die einen Exponenten angeben.|  
  
> [!NOTE]
> Alle abschließenden NULL (U + 0000)-Zeichen im `s` werden ignoriert, durch den Analysevorgang, unabhängig vom Wert für die `style` Argument.

 Eine Zeichenfolge mit der nur Ziffern (Dies entspricht der <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> Stil) immer erfolgreich analysiert. Die verbleibenden <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> Elemente steuern, Elemente, die möglicherweise sind jedoch nicht erforderlich, in der Eingabezeichenfolge vorhanden sein muss. Die folgende Tabelle gibt an, wie einzelne <xref:System.Globalization.NumberStyles> Flags wirken sich auf die Elemente, die ggf. im `s`.  
  
|NumberStyles-Wert|Elemente in s neben Ziffern zulässig|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Die *ganzzahligen Ziffern* nur-Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Das Sprachelement *.* und *Bruchziffern* Elemente.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Die `s` Parameter können Sie auch Exponentialschreibweise. Dieses Flag selbst unterstützt Werte im Formular *ganzzahligen Ziffern*E*Exponenten-Ziffern*; zusätzliche Flags sind erforderlich, um die erfolgreichen Analysieren von Zeichenfolgen in Exponentialschreibweise mit Elementen wie positives oder negatives Vorzeichen und ein Dezimaltrennzeichen.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Die *ws* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Die *ws* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Die *anmelden* Element am Anfang des `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Die *anmelden* Element am Ende der `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Die *anmelden* Element in Form von Klammern, die den numerischen Wert einschließen.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Die *,* Element.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Die *$* Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle Die `s` -Parameter kann keine hexadezimale Zahl oder einer Zahl in Exponentialschreibweise darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Die *ws* Element am Anfang oder Ende des `s`, *anmelden* am Anfang des `s`, und die *.* Symbol. Die `s` Parameter können Sie auch Exponentialschreibweise.|  
|<xref:System.Globalization.NumberStyles.Number>|Die `ws`, `sign`, Tausende Trennzeichen (*,),* und Dezimaltrennzeichen (*.*) Elemente.|  
|<xref:System.Globalization.NumberStyles.Any>|Alle Stile mit Ausnahme von `s` eine hexadezimale Zahl nicht darstellen kann.|  
  
 Die `provider` -Parameter ist ein <xref:System.IFormatProvider> Implementierung, wie z. B. eine <xref:System.Globalization.NumberFormatInfo> oder <xref:System.Globalization.CultureInfo> Objekt. Die `provider` Parameter liefert kulturspezifische Informationen, die bei der Analyse verwendet. Wenn `provider` ist `null` oder <xref:System.Globalization.NumberFormatInfo> Objekt kann nicht abgerufen werden, wird die Formatinformationen für die aktuelle Kultur verwendet.  
  
 Die Konvertierung schlägt fehl, wenn die `s` -Parameter ist `null` oder nicht in einen numerischen Wert, der `provider` Parameter ergibt keine <xref:System.Globalization.NumberFormatInfo> Objekt oder die `style` Parameter ist keine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> -Enumeration.  
  
 Normalerweise übergeben die <xref:System.Double.TryParse%2A?displayProperty=nameWithType> Methode eine Zeichenfolge, die durch den Aufruf erstellt wird die <xref:System.Double.ToString%2A?displayProperty=nameWithType> -Methode, die ursprünglichen <xref:System.Double> Wert wird zurückgegeben. Jedoch können aufgrund einer Unterbrechung der Genauigkeit, die Werte sein nicht gleich. Darüber hinaus versucht beim Analysieren der Zeichenfolgendarstellung eines <xref:System.Double.MinValue> oder <xref:System.Double.MaxValue> löst eine <xref:System.OverflowException>, wie im folgende Beispiel veranschaulicht.  
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  
  
 Wenn Sie ein Trennzeichen gefunden wird die `s` Parameter bei einem Analysevorgang, und die geltenden Währung oder Zahl, Dezimalzahl und Gruppentrennzeichen sind identisch, die der Analysevorgang wird davon ausgegangen, dass das Trennzeichen ein Dezimaltrennzeichen anstelle einer Gruppe Trennzeichen. Weitere Informationen zu den Trennzeichen, finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung der <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> Methode, um die Zeichenfolgendarstellung von Zahlen zu analysieren, die einen bestimmten nachrichtenstil und mit den Konventionen einer bestimmten Kultur formatiert.  
  
 [!code-csharp[System.Double.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Double.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/TryParse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder -  
 <paramref name="style" /> enthält den <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Wert.</exception>
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="~/docs/standard/base-types/parsing-numeric.md">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>