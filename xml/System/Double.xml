<Type Name="Double" FullName="System.Double">
  <Metadata><Meta Name="ms.openlocfilehash" Value="551ddd61889d24445fc17d61aaf2e2cb7dd1e1fb" /><Meta Name="ms.sourcegitcommit" Value="57ccffdf8fe8e719b7e778b859bf1ca216879f31" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/28/2020" /><Meta Name="ms.locfileid" Value="87329263" /></Metadata><TypeSignature Language="C#" Value="public struct Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float64&gt;, class System.IConvertible, class System.IEquatable`1&lt;float64&gt;, class System.IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Double" />
  <TypeSignature Language="VB.NET" Value="Public Structure Double&#xA;Implements IComparable, IComparable(Of Double), IConvertible, IEquatable(Of Double), IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public value class Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type double = struct&#xA;    interface IConvertible&#xA;    interface IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="C#" Value="public struct Double : IComparable, IConvertible, IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IConvertible, class System.IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="VB.NET" Value="Public Structure Double&#xA;Implements IComparable, IConvertible, IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="C++ CLI" Value="public value class Double : IComparable, IConvertible, IFormattable" FrameworkAlternate="netframework-1.1" />
  <TypeSignature Language="F#" Value="type double = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float64&gt;, class System.IConvertible, class System.IEquatable`1&lt;float64&gt;, class System.IFormattable" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C#" Value="public struct Double : IComparable, IComparable&lt;double&gt;, IEquatable&lt;double&gt;, IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float64&gt;, class System.IEquatable`1&lt;float64&gt;, class System.IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="VB.NET" Value="Public Structure Double&#xA;Implements IComparable, IComparable(Of Double), IEquatable(Of Double), IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="C++ CLI" Value="public value class Double : IComparable, IComparable&lt;double&gt;, IEquatable&lt;double&gt;, IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <TypeSignature Language="F#" Value="type double = struct&#xA;    interface IFormattable" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.IComparable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <InterfaceName>System.IEquatable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1;netstandard-2.1">
      <AttributeName Language="C#">[System.Runtime.CompilerServices.IsReadOnly]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.CompilerServices.IsReadOnly&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Serializable]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Serializable&gt;]</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName Language="C#">[System.Runtime.InteropServices.ComVisible(true)]</AttributeName>
      <AttributeName Language="F#">[&lt;System.Runtime.InteropServices.ComVisible(true)&gt;]</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine Gleitkommazahl mit doppelter Genauigkeit dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Double> Werttyp stellt eine 64-Bit-Zahl mit doppelter Genauigkeit dar, deren Werte zwischen negativer 1.79769313486232 E308 und positiv 1.79769313486232 E308 liegen, sowie positive oder negative Null, <xref:System.Double.PositiveInfinity> , <xref:System.Double.NegativeInfinity> und keine Zahl ( <xref:System.Double.NaN> ). Er soll Werte darstellen, die sehr groß sind (z. b. Entfernungen zwischen Planeten oder Galaxien) oder extrem klein sind (z. b. die molekulare Masse eines Stoffs in Kilo Meter) und häufig unpräzise sind (z. b. die Entfernung von der Erde zu einem anderen Sonnensystem). Der- <xref:System.Double> Typ entspricht dem IEC 60559:1989 (IEEE 754)-Standard für binäre Gleit Komma Arithmetik.  
  
 Dieses Thema enthält folgende Abschnitte:  
  
-   [Darstellung und Genauigkeit von Gleit Komma Werten](#Precision)  
  
-   [Testen auf Gleichheit](#Equality)  
  
-   [Gleit Komma Werte und-Ausnahmen](#Exceptions)  
  
-   [Typkonvertierungen und die Double-Struktur](#Conversions)  
  
-   [Gleit Komma Funktionen](#Functionality)  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>Darstellung und Genauigkeit von Gleit Komma Werten  
 Der- <xref:System.Double> Datentyp speichert Gleit Komma Werte mit doppelter Genauigkeit in einem 64-Bit-Binärformat, wie in der folgenden Tabelle dargestellt:  
  
|Segment|Bits|  
|----------|----------|  
|Signifikanor oder Mantisse|0-51|  
|Exponent|52-62|  
|Vorzeichen (0 = positiv, 1 = negativ)|63|  
  
 Ebenso wie dezimale Bruchteile nicht exakt einige Bruchwerte darstellen können (z. b. 1/3 oder <xref:System.Math.PI?displayProperty=nameWithType> ), können binäre Bruchteile einige Bruchzahlen nicht darstellen. Beispielsweise wird 1/10, der genau von 1 als Dezimal Bruch dargestellt wird, durch. 001100110011 als binärer Bruchteil dargestellt, wobei das Muster "0011" in unendlich wiederholt wird. In diesem Fall stellt der Gleit Komma Wert eine ungenaue Darstellung der Zahl dar, die er darstellt. Das Ausführen zusätzlicher mathematischer Operationen für den ursprünglichen Gleit Komma Wert neigt häufig dazu, den Mangel an Genauigkeit zu erhöhen. Wenn wir beispielsweise das Ergebnis der Multiplikation von 1 bis 10 und das Addieren von 1 bis 1 9 mal vergleichen, sehen wir, dass das Hinzufügen, da es acht weitere Vorgänge umfasste, das weniger genaue Ergebnis erzeugt hat. Beachten Sie, dass diese Differenz nur offensichtlich ist, wenn die beiden <xref:System.Double> Werte mit der [standardmäßigen numerischen Format Zeichenfolge](/dotnet/standard/base-types/standard-numeric-format-strings)"R" angezeigt werden, die ggf. alle 17 Ziffern der Genauigkeit anzeigt, die vom-Typ unterstützt werden <xref:System.Double> .  
  
 [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
 [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
 Da einige Zahlen nicht exakt als binäre Binär Werte dargestellt werden können, können Gleit Komma zahlen nur in Bezug auf reelle Zahlen stehen.  
  
 Alle Gleit Komma Zahlen verfügen auch über eine begrenzte Anzahl signifikanter Ziffern, die außerdem bestimmen, wie genau ein Gleit Komma Wert einer reellen Zahl entspricht.   Ein <xref:System.Double> Wert kann bis zu 15 Dezimalstellen der Genauigkeit haben, obwohl intern höchstens 17 Ziffern aufbewahrt werden. Dies bedeutet, dass einige Gleit Komma Vorgänge möglicherweise nicht die Genauigkeit zum Ändern eines Gleit Komma Werts haben. Dies wird im folgenden Beispiel veranschaulicht. Dabei wird ein sehr großer Gleit Komma Wert definiert, und anschließend wird das Produkt von <xref:System.Double.Epsilon?displayProperty=nameWithType> und einem vierwertigen Wert hinzugefügt. Das Produkt ist jedoch zu klein, um den ursprünglichen Gleit Komma Wert zu ändern. Die am wenigsten bedeutende Ziffer ist Tausendstel, wohingegen die signifikanteste Ziffer im Produkt 10<sup>-309</sup>ist.  
  
 [!code-csharp[System.Double.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation2.cs#4)]
 [!code-vb[System.Double.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation2.vb#4)]  
  
 Die begrenzte Genauigkeit einer Gleit Komma Zahl hat mehrere folgen:  
  
-   Zwei Gleitkommazahlen, die für eine bestimmte Genauigkeit identisch zu sein scheinen, können sich als unterschiedlich erweisen, wenn sich die zwei letzten Ziffern unterscheiden. Im folgenden Beispiel wird eine Reihe von Zahlen addiert, und ihr Gesamtwert wird mit dem erwarteten Gesamtwert verglichen. Obwohl die beiden Werte gleich sind, `Equals` gibt ein aufrufungsmethode an, dass Sie nicht gleich sind.  
  
     [!code-csharp[System.Double.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Double.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist3.vb#6)]  
  
     Wenn Sie die Format Elemente in der <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> Anweisung von `{0}` und in `{1}` ändern `{0:R}` und `{1:R}` alle wichtigen Ziffern der beiden <xref:System.Double> Werte anzeigen, ist klar, dass die beiden Werte aufgrund eines Genauigkeits Verlusts bei den Additions Vorgängen ungleich sind. In diesem Fall kann das Problem gelöst werden, indem Sie die- <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType> Methode aufrufen, um die <xref:System.Double> Werte auf die gewünschte Genauigkeit zu runden, bevor Sie den Vergleich durchführen.  
  
-   Eine mathematische oder Vergleichsoperation, die eine Gleit Komma Zahl verwendet, ergibt möglicherweise nicht dasselbe Ergebnis, wenn eine Dezimalzahl verwendet wird, da die binäre Gleit Komma Zahl möglicherweise nicht mit der Dezimalzahl übereinstimmt. Im vorherigen Beispiel wurde dies veranschaulicht, indem das Ergebnis der Multiplikation von 1 bis 10 und das Hinzufügen von. 1 Mal angezeigt wurde.  
  
     Wenn die Genauigkeit in numerischen Vorgängen mit Bruch Werten wichtig ist, können Sie <xref:System.Decimal> anstelle des- <xref:System.Double> Typs verwenden. Wenn die Genauigkeit in numerischen Vorgängen mit ganzzahligen Werten außerhalb des Bereichs der <xref:System.Int64> <xref:System.UInt64> Typen oder wichtig ist, verwenden Sie den- <xref:System.Numerics.BigInteger> Typ.  
  
-   Ein Wert ist möglicherweise kein Roundtrip, wenn eine Gleit Komma Zahl beteiligt ist. Ein Wert wird als Roundtrip bezeichnet, wenn ein Vorgang eine ursprüngliche Gleit Komma Zahl in ein anderes Format konvertiert, ein umgekehrter Vorgang das konvertierte Formular wieder in eine Gleit Komma Zahl umwandelt und die abschließende Gleit Komma Zahl nicht der ursprünglichen Gleit Komma Zahl entspricht. Der Roundtrip kann fehlschlagen, weil mindestens eine signifikante Ziffer verloren geht oder bei einer Konvertierung geändert wird. Im folgenden Beispiel werden drei Werte in Zeichen folgen <xref:System.Double> konvertiert und in einer Datei gespeichert. Wie die Ausgabe zeigt, sind die wiederhergestellten Werte jedoch nicht mit den ursprünglichen Werten identisch, obwohl die Werte als identisch angezeigt werden.  
  
     [!code-csharp[System.Double.Structure#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist4.cs#7)]
     [!code-vb[System.Double.Structure#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist4.vb#7)]  
  
     In diesem Fall können die Werte erfolgreich mit der [standardmäßigen numerischen Format Zeichenfolge](/dotnet/standard/base-types/standard-numeric-format-strings) "G17" abgerundet werden, um die vollständige Genauigkeit der <xref:System.Double> Werte beizubehalten, wie im folgenden Beispiel gezeigt.  
  
     [!code-csharp[System.Double.Structure#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist5.cs#8)]
     [!code-vb[System.Double.Structure#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist5.vb#8)]  

   > [!IMPORTANT]
   >  Bei Verwendung mit einem <xref:System.Double> -Wert kann der "R"-Format Bezeichner in einigen Fällen keinen erfolgreichen Roundtrip für den ursprünglichen Wert durchgeführt werden. Verwenden Sie den Format Bezeichner "G17", um sicherzustellen, dass die <xref:System.Double> Werte erfolgreich durchgeführt werden.

-   <xref:System.Single> Werte haben weniger Genauigkeit als <xref:System.Double> Werte. Ein <xref:System.Single> Wert, der in eine scheinbar Äquivalente konvertiert wird, ist <xref:System.Double> <xref:System.Double> aufgrund von Genauigkeits unterschieden oft nicht gleich dem Wert. Im folgenden Beispiel wird das Ergebnis von identischen Divisions Vorgängen einem <xref:System.Double> und einem-Wert zugewiesen <xref:System.Single> . Nachdem der <xref:System.Single> Wert in einen umgewandelt <xref:System.Double> wurde, zeigt ein Vergleich der beiden Werte, dass Sie ungleich sind.  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     Um dieses Problem zu vermeiden, verwenden Sie entweder den <xref:System.Double> anstelle des- <xref:System.Single> Datentyps, oder verwenden Sie die- <xref:System.Math.Round%2A> Methode, sodass beide Werte dieselbe Genauigkeit aufweisen.  
  
 Außerdem kann sich das Ergebnis von arithmetischen und Zuweisungs Vorgängen mit <xref:System.Double> Werten aufgrund des Verlusts der Genauigkeit des Typs leicht durch die Plattform unterscheiden <xref:System.Double> . Das Ergebnis der Zuweisung eines Literalwerts kann sich beispielsweise <xref:System.Double> in den 32-Bit-und 64-Bit-Versionen der .NET Framework unterscheiden. Im folgenden Beispiel wird dieser Unterschied veranschaulicht, wenn der Literalwert-4.42330604244772 e-305 und eine Variable, deren Wert-4.42330604244772 e-305 ist, einer Variablen zugewiesen werden <xref:System.Double> . Beachten Sie, dass das Ergebnis der- <xref:System.Double.Parse%28System.String%29> Methode in diesem Fall bei einem Genauigkeits Verlust nicht beeinträchtigt wird.  
  
 [!code-csharp[System.Double.Class.Precision#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.class.precision/cs/precision1.cs#1)]
 [!code-vb[System.Double.Class.Precision#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.class.precision/vb/precision1.vb#1)]  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>Testen auf Gleichheit  
 Um als gleich betrachtet zu werden, <xref:System.Double> müssen zwei Werte identische Werte darstellen. Aufgrund von Unterschieden in der Genauigkeit zwischen Werten oder aufgrund eines Genauigkeits Verlusts durch einen oder beide Werte werden Gleit Komma Werte, die als identisch erwartet werden, aufgrund von Unterschieden in den am wenigsten wichtigen Ziffern oft als ungleich fest. Dies führt dazu, dass Aufrufe der- <xref:System.Double.Equals%2A> Methode bestimmen, ob zwei Werte gleich sind, oder Aufrufe an die- <xref:System.Double.CompareTo%2A> Methode, um die Beziehung zwischen zwei Werten zu bestimmen <xref:System.Double> , was häufig zu unerwarteten Ergebnissen führt. Dies ist im folgenden Beispiel ersichtlich, in dem zwei scheinbar gleichwertige Werte sich als ungleich erweisen, <xref:System.Double> da der erste 15 Ziffern der Genauigkeit aufweist, während der zweite über 17 Zeichen verfügt.  
  
 [!code-csharp[System.Double.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Double.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison1.vb#9)]  
  
 Berechnete Werte, die auf unterschiedliche Codepfade folgen und auf unterschiedliche Weise bearbeitet werden, werden oft als ungleich feststellen. Im folgenden Beispiel <xref:System.Double> ist ein Wert quadratisch, und dann wird die Quadratwurzel berechnet, um den ursprünglichen Wert wiederherzustellen. Eine zweite <xref:System.Double> wird mit 3,51 und quadriert, bevor die Quadratwurzel des Ergebnisses durch 3,51 geteilt wird, um den ursprünglichen Wert wiederherzustellen. Obwohl die beiden Werte als identisch angezeigt werden, <xref:System.Double.Equals%28System.Double%29> weist ein aufrufungsmethode darauf hin, dass Sie nicht gleich sind. Wenn Sie die Standardformat Zeichenfolge "R" verwenden, um eine Ergebnis Zeichenfolge zurückzugeben, die alle signifikanten Ziffern jedes doppelten Werts anzeigt, wird angezeigt, dass der zweite Wert .0000000000001 kleiner als der erste Wert ist.  
  
 [!code-csharp[System.Double.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Double.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison2.vb#10)]  
  
 In Fällen, in denen sich der Genauigkeits Verlust wahrscheinlich auf das Ergebnis eines Vergleichs auswirkt, können Sie eine der folgenden Alternativen zum Aufrufen der-oder-Methode übernehmen <xref:System.Double.Equals%2A> <xref:System.Double.CompareTo%2A> :  
  
-   Wenden Sie die- <xref:System.Math.Round%2A?displayProperty=nameWithType> Methode an, um sicherzustellen, dass beide Werte dieselbe Genauigkeit aufweisen. Im folgenden Beispiel wird ein vorheriges Beispiel dahingehend geändert, dass diese Vorgehensweise verwendet wird, damit zwei Dezimalzahlen gleichwertig sind.  
  
     [!code-csharp[System.Double.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Double.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison3.vb#11)]  
  
     Beachten Sie jedoch, dass das Genauigkeits Problem weiterhin für die Rundung von Mittelpunkt Werten gilt. Weitere Informationen finden Sie unter der Methode <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType>.  
  
-   Testen Sie auf ungefähre Gleichheit anstatt auf Gleichheit. Dies erfordert, dass Sie einen absoluten Betrag definieren, um den sich die beiden Werte unterscheiden können, aber dennoch gleich sind, oder dass Sie einen relativen Betrag definieren, um den der kleinere Wert vom größeren Wert abweichen kann.  
  
    > [!WARNING]
    >  <xref:System.Double.Epsilon?displayProperty=nameWithType> wird manchmal als absolutes Maß der Entfernung zwischen zwei <xref:System.Double> Werten beim Testen auf Gleichheit verwendet.  Misst jedoch <xref:System.Double.Epsilon?displayProperty=nameWithType> den kleinsten möglichen Wert, der einem hinzugefügt oder von diesem subtrahiert werden kann, <xref:System.Double> dessen Wert 0 (null) ist. Bei den meisten positiven und negativen <xref:System.Double> Werten ist der Wert von <xref:System.Double.Epsilon?displayProperty=nameWithType> zu klein, um erkannt zu werden. Mit Ausnahme von Werten, die 0 (null) sind, empfiehlt es sich daher nicht, die Verwendung in Tests auf Gleichheit zu übernehmen.  
  
     Im folgenden Beispiel wird der letztere Ansatz verwendet, um eine-Methode zu definieren `IsApproximatelyEqual` , die den relativen Unterschied zwischen zwei Werten testet. Außerdem wird das Ergebnis von Aufrufen der `IsApproximatelyEqual` -Methode und der-Methode als gegenübersteht <xref:System.Double.Equals%28System.Double%29> .  
  
     [!code-csharp[System.Double.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Double.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>Gleit Komma Werte und-Ausnahmen  
 Anders als bei Vorgängen mit ganzzahligen Typen, die Ausnahmen bei Überlauf-oder unzulässigen Vorgängen auslösen, wie z. b. Division durch Null, lösen Vorgänge mit Gleit Komma Werten keine Ausnahmen aus. Stattdessen ist in Ausnahmefällen das Ergebnis einer Gleit Komma Operation 0 (null), positiv unendlich, minus unendlich oder keine Zahl (NaN):  
  
-   Wenn das Ergebnis einer Gleit Komma Operation für das Zielformat zu klein ist, ist das Ergebnis 0 (null). Dies kann vorkommen, wenn zwei sehr kleine Zahlen multipliziert werden, wie im folgenden Beispiel gezeigt.  
  
     [!code-csharp[System.Double.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Double.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional1.vb#1)]  
  
-   Wenn die Größe des Ergebnisses einer Gleit Komma Operation den Bereich des Ziel Formats überschreitet, ist das Ergebnis des Vorgangs <xref:System.Double.PositiveInfinity> oder <xref:System.Double.NegativeInfinity> , je nach dem Vorzeichen des Ergebnisses. Das Ergebnis eines Vorgangs, der <xref:System.Double.MaxValue?displayProperty=nameWithType> überläuft, <xref:System.Double.PositiveInfinity> und das Ergebnis eines Vorgangs, der <xref:System.Double.MinValue?displayProperty=nameWithType> überläuft, ist <xref:System.Double.NegativeInfinity> , wie im folgenden Beispiel gezeigt.  
  
     [!code-csharp[System.Double.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Double.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Double.PositiveInfinity> Dies ergibt auch Ergebnisse aus einer Division durch 0 (null) mit einer positiven Dividende und <xref:System.Double.NegativeInfinity> Ergebnisse aus einer Division durch 0 (null) mit einer negativen Dividende.  
  
-   Wenn ein Gleit Komma Vorgang ungültig ist, ist das Ergebnis des Vorgangs <xref:System.Double.NaN> . <xref:System.Double.NaN>Die Ergebnisse der folgenden Vorgänge sind z. b.:  
  
    -   Division durch 0 (null) mit einer Dividende von NULL. Beachten Sie, dass andere Fälle der Division durch Null zu <xref:System.Double.PositiveInfinity> oder führen <xref:System.Double.NegativeInfinity> .  
  
-   Eine beliebige Gleit Komma Operation mit einer ungültigen Eingabe. Das Aufrufen der- <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> Methode mit einem negativen Wert gibt z <xref:System.Double.NaN> . b. zurück, ebenso wie das Aufrufen der- <xref:System.Math.Acos%2A?displayProperty=nameWithType> Methode mit einem Wert, der größer als 1 oder kleiner als minus eins ist.  
  
-   Jeder Vorgang mit einem Argument, dessen Wert ist <xref:System.Double.NaN?displayProperty=nameWithType> .  
  
<a name="Conversions"></a>   
## <a name="type-conversions-and-the-double-structure"></a>Typkonvertierungen und die Double-Struktur  
 Die- <xref:System.Double> Struktur definiert keine expliziten oder impliziten Konvertierungs Operatoren; stattdessen werden Konvertierungen vom Compiler implementiert.  
  
 Die Konvertierung des Werts eines beliebigen primitiven numerischen Typs in eine <xref:System.Double> ist eine erweiternde Konvertierung und erfordert daher keinen expliziten Umwandlungs Operator oder einen aufzurufenden Umwandlungs Methode, es sei denn, ein Compiler erfordert dies explizit. Der c#-Compiler benötigt z. b. einen Umwandlungs Operator für Konvertierungen von <xref:System.Decimal> in <xref:System.Double> , während der Visual Basic-Compiler dies nicht tut. Im folgenden Beispiel wird der minimale oder maximale Wert anderer primitiver numerischer Typen in eine konvertiert <xref:System.Double> .  
  
 [!code-csharp[System.Double.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert1.cs#20)]
 [!code-vb[System.Double.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert1.vb#20)]  
  
 Außerdem werden die Werte, und in <xref:System.Single> <xref:System.Single.NaN?displayProperty=nameWithType> <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> <xref:System.Double.NaN?displayProperty=nameWithType> , <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> bzw. konvertiert.  
  
 Beachten Sie, dass die Konvertierung des Werts einiger numerischer Typen in einen- <xref:System.Double> Wert zu einem Genauigkeits Verlust führen kann. Wie das Beispiel veranschaulicht, ist ein Genauigkeits Verlust möglich, wenn die <xref:System.Decimal> <xref:System.Int64> Werte,, <xref:System.Single> und <xref:System.UInt64> in- <xref:System.Double> Werte umgerechnet werden.  
  
 Die Konvertierung eines <xref:System.Double> Werts in einen Wert eines beliebigen anderen primitiven numerischen Datentyps ist eine einschränkende Konvertierung und erfordert einen Umwandlungs Operator (in c#), eine Konvertierungsmethode (in Visual Basic) oder einen <xref:System.Convert> Methoden aufzurufen. Werte, die sich außerhalb des Bereichs des Ziel Datentyps befinden, der durch die-Eigenschaft und die-Eigenschaft des Zieltyps definiert wird `MinValue` `MaxValue` , Verhalten sich wie in der folgenden Tabelle gezeigt.  
  
|Zieltyp|Ergebnis|  
|-----------------|------------|  
|Beliebige ganzzahlige Typen|Eine <xref:System.OverflowException> Ausnahme, wenn die Konvertierung in einem überprüften Kontext erfolgt.<br /><br /> Wenn die Konvertierung in einem nicht überprüften Kontext (der Standard in c#) erfolgt, wird der Konvertierungs Vorgang erfolgreich ausgeführt, der Wert wird jedoch überlaufen.|  
|<xref:System.Decimal>|Eine <xref:System.OverflowException>-Ausnahme.|  
|<xref:System.Single>|<xref:System.Single.NegativeInfinity?displayProperty=nameWithType> für negative Werte.<br /><br /> <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> für positive Werte.|  
  
 Außerdem lösen, <xref:System.Double.NaN?displayProperty=nameWithType> <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> und <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> einen <xref:System.OverflowException> für Konvertierungen in ganze Zahlen in einem überprüften Kontext aus, diese Werte überschreiten jedoch bei der Konvertierung in ganze Zahlen in einem nicht überprüften Kontext einen Überlauf. Für Konvertierungen in lösen <xref:System.Decimal> Sie immer eine aus <xref:System.OverflowException> . Konvertierung in <xref:System.Single>, sie konvertieren in <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, und <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>bzw.  
  
 Beachten Sie, dass ein Genauigkeits Verlust möglicherweise durch das wandeln eines <xref:System.Double> Werts in einen anderen numerischen Typ verursacht wird. Wenn nicht ganzzahlige <xref:System.Double> Werte konvertiert werden, wie die Ausgabe des Beispiels zeigt, geht die Bruchteile Komponente verloren, wenn der <xref:System.Double> Wert entweder gerundet (wie in Visual Basic) oder abgeschnitten (wie in c#) ist. Für Konvertierungen in <xref:System.Decimal> -und- <xref:System.Single> Werte <xref:System.Double> hat der Wert möglicherweise keine genaue Darstellung im Ziel Datentyp.  
  
 Im folgenden Beispiel wird eine Anzahl von <xref:System.Double> Werten in mehrere andere numerische Typen konvertiert. Die Konvertierungen erfolgen in einem überprüften Kontext in Visual Basic (Standardeinstellung) und in c# (aufgrund des [geprüften](/dotnet/csharp/language-reference/keywords/checked) Schlüssel Worts). Die Ausgabe aus dem Beispiel zeigt das Ergebnis für Konvertierungen in einem überprüften, nicht überprüften Kontext. Sie können Konvertierungen in einem nicht überprüften Kontext in Visual Basic ausführen, indem Sie mit dem `/removeintchecks+` Compilerschalter kompilieren und in c#, indem Sie die-Anweisung auskommentieren `checked` .  
  
 [!code-csharp[System.Double.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert2.cs#21)]
 [!code-vb[System.Double.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert2.vb#21)]  
  
 Weitere Informationen zur Konvertierung numerischer Typen finden Sie unter [Typkonvertierung in den .NET Framework](/dotnet/standard/base-types/type-conversion) -und [Typkonvertierungs Tabellen](/dotnet/standard/base-types/conversion-tables).  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>Gleit Komma Funktionen  
 Die <xref:System.Double> Struktur und die zugehörigen Typen bieten Methoden zum Ausführen von Vorgängen in den folgenden Bereichen:  
  
-   **Vergleich von-Werten**. Sie können die- <xref:System.Double.Equals%2A> Methode aufzurufen, um zu bestimmen, ob zwei <xref:System.Double> Werte gleich sind, oder die- <xref:System.Double.CompareTo%2A> Methode, um die Beziehung zwischen zwei Werten zu bestimmen.  
  
     Die <xref:System.Double> Struktur unterstützt auch einen kompletten Satz von Vergleichs Operatoren. Beispielsweise können Sie auf Gleichheit oder Ungleichheit testen oder feststellen, ob ein Wert größer oder gleich einem anderen Wert ist. Wenn einer der Operanden ein numerischer Typ ist, der nicht eine ist <xref:System.Double> , wird er <xref:System.Double> vor dem Durchführen des Vergleichs in eine konvertiert.  
  
    > [!WARNING]
    >  Aufgrund von Unterschieden in der Genauigkeit können sich zwei Werte, die als <xref:System.Double> gleich erwartet werden, möglicherweise als ungleich erweisen, was sich auf das Ergebnis des Vergleichs auswirkt. Weitere Informationen zum Vergleichen von zwei Werten finden Sie im Abschnitt [Tests für Gleichheit](#Equality) <xref:System.Double> .  
  
     Sie können auch die <xref:System.Double.IsNaN%2A> Methoden, <xref:System.Double.IsInfinity%2A> , <xref:System.Double.IsPositiveInfinity%2A> und <xref:System.Double.IsNegativeInfinity%2A> zum Testen auf diese speziellen Werte aufzurufen.  
  
-   **Mathematische Vorgänge**. Allgemeine arithmetische Operationen, z. b. Addition, Subtraktion, Multiplikation und Division, werden von sprach Compilern und Common Intermediate Language-Anweisungen (CIL) anstelle von <xref:System.Double> Methoden implementiert. Wenn einer der Operanden in einer mathematischen Operation ein numerischer Typ ist, der nicht eine ist <xref:System.Double> , wird er <xref:System.Double> vor dem Ausführen des Vorgangs in eine konvertiert. Das Ergebnis des Vorgangs ist auch ein- <xref:System.Double> Wert.  
  
     Andere mathematische Vorgänge können durch Aufrufen von `static` ( `Shared` in Visual Basic)-Methoden in der-Klasse ausgeführt werden <xref:System.Math?displayProperty=nameWithType> . Sie enthält zusätzliche Methoden, die häufig für Arithmetik verwendet werden (z. b. <xref:System.Math.Abs%2A?displayProperty=nameWithType> , <xref:System.Math.Sign%2A?displayProperty=nameWithType> und <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> ), Geometrie (z. b. <xref:System.Math.Cos%2A?displayProperty=nameWithType> und <xref:System.Math.Sin%2A?displayProperty=nameWithType> ) und ein Kalkül (z <xref:System.Math.Log%2A?displayProperty=nameWithType> . b.).  
  
     Sie können auch die einzelnen Bits in einem <xref:System.Double> Wert bearbeiten. Die <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> -Methode behält <xref:System.Double> das Bitmuster eines Werts in einer 64-Bit-Ganzzahl bei. Die- <xref:System.BitConverter.GetBytes%28System.Double%29?displayProperty=nameWithType> Methode gibt das Bitmuster in einem Bytearray zurück.  
  
-   **Rundung**. Die Rundung wird häufig als Technik zum Verringern der Auswirkung von Unterschieden zwischen Werten verwendet, die durch Probleme mit der Gleit Komma Darstellung und-Genauigkeit verursacht werden. Sie können einen Wert Runden, <xref:System.Double> indem Sie die- <xref:System.Math.Round%2A?displayProperty=nameWithType> Methode aufrufen.  
  
-   **Formatierung**. Sie können einen <xref:System.Double> Wert in seine Zeichen folgen Darstellung konvertieren, indem Sie die- <xref:System.Double.ToString%2A> Methode aufrufen oder die Funktion für die kombinierte Formatierung verwenden. Informationen dazu, wie Format Zeichenfolgen die Zeichen folgen Darstellung von Gleit Komma Werten steuern, finden Sie in den Themen [Standard Format](/dotnet/standard/base-types/standard-numeric-format-strings) Zeichenfolgen für Zahlen und [benutzerdefinierte Zahlenformat](/dotnet/standard/base-types/custom-numeric-format-strings) Zeichenfolgen.  
  
-   Zeichen folgen werden **verarbeitet.** Sie können die Zeichen folgen Darstellung eines Gleit Komma Werts in einen-Wert konvertieren, <xref:System.Double> indem Sie entweder die-oder die- <xref:System.Double.Parse%2A> Methode aufrufen <xref:System.Double.TryParse%2A> . Wenn der Analyse Vorgang fehlschlägt, löst die <xref:System.Double.Parse%2A> Methode eine Ausnahme aus, während die <xref:System.Double.TryParse%2A> Methode zurückgibt `false` .  
  
-   **Typkonvertierung**. Die- <xref:System.Double> Struktur stellt eine explizite Schnittstellen Implementierung für die- <xref:System.IConvertible> Schnittstelle bereit, die die Konvertierung zwischen zwei Datentypen vom Typ Standard .NET Framework unterstützt. Sprach Compiler unterstützen auch die implizite Konvertierung von Werten aller anderen numerischen Standardtypen in- <xref:System.Double> Werte. Die Konvertierung eines Werts eines beliebigen standardmäßigen numerischen Typs in eine <xref:System.Double> ist eine erweiternde Konvertierung, die den Benutzer eines Umwandlungs Operators oder einer Konvertierungsmethode nicht erfordert.  
  
     Allerdings kann das Konvertieren von <xref:System.Int64> -und- <xref:System.Single> Werten zu einem Genauigkeits Verlust führen. In der folgenden Tabelle sind die Unterschiede in der Genauigkeit für die einzelnen Typen aufgeführt:  
  
    |Typ|Maximale Genauigkeit|Interne Genauigkeit|  
    |----------|-----------------------|------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int64>|19 Dezimalziffern|19 Dezimalziffern|  
    |<xref:System.Single>|7 Dezimalziffern|9 Dezimalziffern|  
  
     Das Problem der Genauigkeit wirkt sich am häufigsten <xref:System.Single> auf Werte aus, die in-Werte konvertiert werden <xref:System.Double> . Im folgenden Beispiel sind zwei Werte, die von identischen Divisions Vorgängen erzeugt werden, ungleich, da einer der-Werte ein Gleit Komma Wert mit einfacher Genauigkeit ist, der in eine konvertiert wird <xref:System.Double> .  
  
     [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
     [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung von veranschaulicht <xref:System.Double> :  
  
 [!code-cpp[Double Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#1)]
 [!code-csharp[Double Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#1)]
 [!code-vb[Double Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Alle Member dieses Typs sind Thread sicher. Member, die scheinbar den Instanzzustand ändern, geben tatsächlich eine neue Instanz zurück, die mit dem neuen Wert initialisiert wurde. Wie bei jedem anderen Typ muss das Lesen und Schreiben in eine freigegebene Variable, die eine Instanz dieses Typs enthält, durch eine Sperre geschützt werden, um die Thread Sicherheit zu gewährleisten.</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Single" />
    <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/windowsforms-formatting-utility-cs/">Beispiel: .NET Core-Hilfsprogramm zur Formatierung von WinForms (C#)</related>
    <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/windowsforms-formatting-utility-vb/">Beispiel: .NET Core-Hilfsprogramm zur Formatierung von WinForms (Visual Basic)</related>
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt oder einem <see cref="T:System.Double" />-Objekt und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert des angegebenen Objekts bzw. des <see cref="T:System.Double" />-Objekts ist oder mit diesem übereinstimmt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Double) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(double value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : double -&gt; int&#xA;override this.CompareTo : double -&gt; int" Usage="double.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="value">Eine Gleitkommazahl mit doppelter Genauigkeit, mit der der Vergleich erfolgen soll.</param>
        <summary>Vergleicht diese Instanz mit einer angegebenen Gleitkommazahl mit doppelter Genauigkeit und gibt eine Ganzzahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert der angegebenen Gleitkommazahl mit doppelter Genauigkeit ist oder mit dieser übereinstimmt.</summary>
        <returns>Eine Zahl mit Vorzeichen, die das Verhältnis zwischen dem Wert dieser Instanz und <paramref name="value" /> angibt.  
  
 <list type="table"><listheader><term> Rückgabewert 
 </term><description> BESCHREIBUNG 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Diese Instanz ist kleiner als <paramref name="value" />, oder diese Instanz ist keine Zahl (<see cref="F:System.Double.NaN" />), und <paramref name="value" /> ist eine Zahl.  
  
 </description></item><item><term> Zero 
 </term><description> Diese Instanz ist gleich <paramref name="value" />, oder diese Instanz und <paramref name="value" /> sind keine Zahl (<see cref="F:System.Double.NaN" />), <see cref="F:System.Double.PositiveInfinity" /> oder <see cref="F:System.Double.NegativeInfinity" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Diese Instanz ist größer als <paramref name="value" />, oder diese Instanz ist eine Zahl, und <paramref name="value" /> ist keine Zahl (<see cref="F:System.Double.NaN" />).  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Werte müssen identisch sein, damit Sie als gleich betrachtet werden. Insbesondere wenn Gleit Komma Werte von mehreren mathematischen Operationen abhängen, ist es üblich, dass Sie Genauigkeit verlieren und ihre Werte nahezu identisch sind, mit Ausnahme der am wenigsten signifikanten Ziffern. Aus diesem Grund mag der Rückgabewert der <xref:System.Double.CompareTo%2A> Methode zu Zeiten überraschend erscheinen. Beispielsweise sollte die Multiplikation mit einem bestimmten Wert, gefolgt von der Division durch denselben Wert, den ursprünglichen Wert ergeben. Im folgenden Beispiel erweist sich der berechnete Wert jedoch als größer als der ursprüngliche Wert. Wenn alle signifikanten Ziffern der beiden Werte mithilfe der [standardmäßigen numerischen Format Zeichenfolge](/dotnet/standard/base-types/standard-numeric-format-strings) "R" angezeigt werden, wird angegeben, dass der berechnete Wert vom ursprünglichen Wert in den geringsten Ziffern abweicht. Informationen zur Behandlung solcher Vergleiche finden Sie im Abschnitt "Hinweise" der- <xref:System.Double.Equals%28System.Double%29> Methode.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto2.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto2.vb" id="Snippet1":::
 
 Diese Methode implementiert die <xref:System.IComparable%601?displayProperty=nameWithType> -Schnittstelle und führt eine etwas bessere Leistung als die- <xref:System.Double.CompareTo%2A?displayProperty=nameWithType> Methode aus, da der-Parameter nicht in ein-Objekt konvertiert werden muss `value` .  
  
 Beachten Sie, dass ein Objekt, dessen Wert <xref:System.Double.NaN> nicht gleich einem anderen Objekt ist, dessen Wert ist <xref:System.Double.NaN> (selbst), erfordert, <xref:System.IComparable%601> dass die-Schnittstelle `A.CompareTo(A)` NULL zurückgibt.  
  
## <a name="widening-conversions"></a>Erweiterungskonvertierungen  
 Abhängig von ihrer Programmiersprache kann es möglich sein, eine Methode zu codieren, <xref:System.Double.CompareTo%2A> bei der der Parametertyp weniger Bits (ist schmaler) als der Instanztyp aufweist. Dies ist möglich, weil einige Programmiersprachen eine implizite erweiternde Konvertierung durchführen, die den Parameter als Typ mit so vielen Bits wie die Instanz darstellt.  
  
 Angenommen, der Instanztyp ist, <xref:System.Double> und der Parametertyp ist <xref:System.Int32> . Der Microsoft c#-Compiler generiert Anweisungen, um den Wert des-Parameters als <xref:System.Double> -Objekt darzustellen, und generiert dann eine-Methode, die <xref:System.Double.CompareTo%28System.Double%29?displayProperty=nameWithType> die Werte der-Instanz und die erweiterte Darstellung des-Parameters vergleicht.  
  
 Überprüfen Sie die Dokumentation der Programmiersprache, um zu bestimmen, ob der Compiler implizite erweiternde Konvertierungen numerischer Typen durchführt. Weitere Informationen finden Sie im Thema [Typkonvertierungs Tabellen](/dotnet/standard/base-types/conversion-tables) .  
  
## <a name="precision-in-comparisons"></a>Genauigkeit in vergleichen  
 Die Genauigkeit von Gleit Komma Zahlen jenseits der dokumentierten Genauigkeit ist spezifisch für die Implementierung und die Version der .NET Framework. Folglich kann sich ein Vergleich zweier bestimmter Zahlen zwischen den Versionen der .NET Framework ändern, da sich die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden generische und nicht generische Versionen der- <xref:System.Double.CompareTo%2A> Methode für verschiedene Wert-und Verweis Typen veranschaulicht.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp" id="Snippet1":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="double.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">Ein Vergleichsobjekt oder <see langword="null" />.</param>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert des angegebenen Objekts ist oder mit diesem übereinstimmt.</summary>
        <returns>Eine Zahl mit Vorzeichen, die das Verhältnis zwischen dem Wert dieser Instanz und <paramref name="value" /> angibt.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Beschreibung 
 </description></listheader><item><term> Eine negative ganze Zahl 
 </term><description> Diese Instanz ist kleiner als <paramref name="value" />, oder diese Instanz ist keine Zahl (<see cref="F:System.Double.NaN" />), und <paramref name="value" /> ist eine Zahl.  
  
 </description></item><item><term> Zero 
 </term><description> Diese Instanz ist gleich <paramref name="value" />, oder diese Instanz und <paramref name="value" /> sind beide <see langword="Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" /> oder <see cref="F:System.Double.NegativeInfinity" />.</description></item><item><term> Eine positive ganze Zahl 
 </term><description> Diese Instanz ist größer als <paramref name="value" />, oder diese Instanz ist eine Zahl, und <paramref name="value" /> ist keine Zahl (<see cref="F:System.Double.NaN" />), oder <paramref name="value" /> ist <see langword="null" />.</description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der- `value` Parameter muss `null` oder eine Instanz von sein `Double` . andernfalls wird eine Ausnahme ausgelöst. Jede Instanz von gilt <xref:System.Double> unabhängig von ihrem Wert als größer als `null` .  
  
 Werte müssen identisch sein, damit Sie als gleich betrachtet werden. Insbesondere wenn Gleit Komma Werte von mehreren mathematischen Operationen abhängen, ist es üblich, dass Sie Genauigkeit verlieren und ihre Werte nahezu identisch sind, mit Ausnahme der am wenigsten signifikanten Ziffern. Aus diesem Grund mag der Rückgabewert der <xref:System.Double.CompareTo%2A> Methode zu Zeiten überraschend erscheinen. Beispielsweise sollte die Multiplikation mit einem bestimmten Wert, gefolgt von der Division durch denselben Wert, den ursprünglichen Wert ergeben. Im folgenden Beispiel erweist sich der berechnete Wert jedoch als größer als der ursprüngliche Wert. Wenn alle signifikanten Ziffern der beiden Werte mithilfe der [standardmäßigen numerischen Format Zeichenfolge](/dotnet/standard/base-types/standard-numeric-format-strings) "R" angezeigt werden, wird angegeben, dass der berechnete Wert vom ursprünglichen Wert in den geringsten Ziffern abweicht. Informationen zur Behandlung solcher Vergleiche finden Sie im Abschnitt "Hinweise" der- <xref:System.Double.Equals%28System.Double%29> Methode.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto3.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto3.vb" id="Snippet2":::

 Diese Methode wird zur Unterstützung der- <xref:System.IComparable> Schnittstelle implementiert. Beachten Sie, dass <xref:System.Double.NaN> die-Schnittstelle, obwohl nicht als gleichwertig angesehen wird <xref:System.Double.NaN> (selbst), <xref:System.IComparable> erfordert, dass 0 (null) `A.CompareTo(A)` zurückgibt.  
  
## <a name="precision-in-comparisons"></a>Genauigkeit in vergleichen  
 Die Genauigkeit von Gleit Komma Zahlen jenseits der dokumentierten Genauigkeit ist spezifisch für die Implementierung und die Version der .NET Framework. Folglich kann sich ein Vergleich zweier bestimmter Zahlen zwischen den Versionen der .NET Framework ändern, da sich die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung von `CompareTo` im Kontext von veranschaulicht `Double` .  
  
 [!code-cpp[System.Double#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#16)]
 [!code-csharp[System.Double#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#16)]
 [!code-vb[System.Double#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="value" /> ist keine <see cref="T:System.Double" />.</exception>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 Epsilon = float64(4.94065645841247E-324)" />
      <MemberSignature Language="DocId" Value="F:System.Double.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Double  = 4.94065645841247E-324" />
      <MemberSignature Language="C++ CLI" Value="public: double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="F#" Value="val mutable Epsilon : double" Usage="System.double.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>4.94065645841247E-324</MemberValue>
      <Docs>
        <summary>Stellt den kleinsten positiven <see cref="T:System.Double" />-Wert dar, der größer als 0 (null) ist. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert der- <xref:System.Double.Epsilon> Eigenschaft gibt den kleinsten positiven <xref:System.Double> Wert an, der bei numerischen Vorgängen oder Vergleichen von Bedeutung ist, wenn der Wert der- <xref:System.Double> Instanz 0 (null) ist. Der folgende Code zeigt z. b., dass NULL und <xref:System.Double.Epsilon> als ungleich Werte angesehen werden, wohingegen NULL und die Hälfte des Werts von <xref:System.Double.Epsilon> als gleich betrachtet werden.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon.cs" interactive="try-dotnet" id="Snippet5":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon.vb" id="Snippet5"::: 
  
 Genauer gesehen besteht das Gleit Komma Format aus einem Vorzeichen, einer 52-Bit-Mantisse oder signifikanund einem 11-Bit-Exponenten. Wie das folgende Beispiel zeigt, hat null einen Exponenten von-1022 und eine Mantisse von 0. <xref:System.Double.Epsilon> hat einen Exponenten von-1022 und eine Mantisse von 1. Dies bedeutet, dass <xref:System.Double.Epsilon> der kleinste positive <xref:System.Double> Wert größer als 0 (null) ist und den kleinsten möglichen Wert und das kleinste mögliche Inkrement für einen darstellt, <xref:System.Double> dessen Exponent-1022 ist.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon1.cs" interactive="try-dotnet" id="Snippet6":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon1.vb" id="Snippet6":::
  
 Die <xref:System.Double.Epsilon> -Eigenschaft ist jedoch kein allgemeines Maß der Genauigkeit des <xref:System.Double> -Typs. Sie gilt nur für <xref:System.Double> -Instanzen, die den Wert 0 (null) oder einen Exponenten von-1022 aufweisen.  
  
> [!NOTE]
>  Der Wert der- <xref:System.Double.Epsilon> Eigenschaft entspricht nicht dem Computer Epsilon, der die obere Grenze des relativen Fehlers aufgrund der Rundung in der Gleit Komma Arithmetik darstellt.  
  
 Der Wert dieser Konstante ist 94065645841247E e-324.  
  
 Zwei scheinbar äquivalente Gleit Komma Zahlen können aufgrund von Unterschieden in den geringsten Ziffern nicht gleich sein. Beispielsweise vergleicht der c#-Ausdruck, `(double)1/3 == (double)0.33333` , nicht gleich, da der Divisions Vorgang auf der linken Seite eine maximale Genauigkeit aufweist, während die Konstante auf der rechten Seite nur für die angegebenen Ziffern präzise ist. Wenn Sie einen benutzerdefinierten Algorithmus erstellen, der bestimmt, ob zwei Gleit Komma Zahlen als gleich betrachtet werden können, wird nicht empfohlen, dass Sie den Algorithmus auf dem Wert der Konstante basieren, <xref:System.Double.Epsilon> um die akzeptable absolute Differenz Spanne für die beiden Werte festzulegen, die als gleich betrachtet werden sollen.  (In der Regel ist dieser Unterschieds Unterschied oft größer als <xref:System.Double.Epsilon> .) Weitere Informationen zum Vergleichen von zwei Gleit Komma Werten mit doppelter Genauigkeit finden Sie unter <xref:System.Double> und <xref:System.Double.Equals%28System.Double%29> .  
  
## <a name="platform-notes"></a>Hinweise zur Plattform  
 Auf ARM-Systemen ist der Wert der <xref:System.Double.Epsilon> Konstante zu klein, um erkannt zu werden, sodass er 0 (null) entspricht. Sie können stattdessen einen alternativen Epsilon-Wert definieren, der 2.2250738585072014 e-308 gleich ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei Instanzen der <see cref="T:System.Double" />-Struktur denselben Wert darstellen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (double obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float64 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(double obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : double -&gt; bool" Usage="double.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="obj">Ein mit dieser Instanz zu vergleichendes <see cref="T:System.Double" />-Objekt.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz und ein angegebenes <see cref="T:System.Double" />-Objekt den gleichen Wert darstellen.</summary>
        <returns><see langword="true" />, wenn <paramref name="obj" /> gleich dieser Instanz ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode implementiert die <xref:System.IEquatable%601?displayProperty=nameWithType> -Schnittstelle und führt etwas besser <xref:System.Double.Equals%2A> aus, als dass der-Parameter nicht `obj` in ein-Objekt konvertiert werden muss.  
  
## <a name="widening-conversions"></a>Erweiterungskonvertierungen  
 Abhängig von ihrer Programmiersprache kann es möglich sein, eine Methode zu codieren, <xref:System.Double.Equals%2A> bei der der Parametertyp weniger Bits (ist schmaler) als der Instanztyp aufweist. Dies ist möglich, weil einige Programmiersprachen eine implizite erweiternde Konvertierung durchführen, die den Parameter als Typ mit so vielen Bits wie die Instanz darstellt.  
  
 Angenommen, der Instanztyp ist, <xref:System.Double> und der Parametertyp ist <xref:System.Int32> . Der Microsoft c#-Compiler generiert Anweisungen, um den Wert des-Parameters als <xref:System.Double> -Objekt darzustellen, und generiert dann eine-Methode, die <xref:System.Double.Equals%28System.Double%29?displayProperty=nameWithType> die Werte der-Instanz und die erweiterte Darstellung des-Parameters vergleicht.  
  
 Überprüfen Sie die Dokumentation der Programmiersprache, um zu bestimmen, ob der Compiler implizite erweiternde Konvertierungen numerischer Typen durchführt. Weitere Informationen finden Sie im Thema [Typkonvertierungs Tabellen](/dotnet/standard/base-types/conversion-tables) .  
  
## <a name="precision-in-comparisons"></a>Genauigkeit in vergleichen  
 Die- <xref:System.Double.Equals%2A> Methode sollte mit Bedacht verwendet werden, da zwei scheinbar äquivalente Werte aufgrund der unterschiedlichen Genauigkeit der beiden Werte ungleich sein können. Im folgenden Beispiel wird berichtet, dass der <xref:System.Double> Wert. 333333 und der <xref:System.Double> von Division 1 durch 3 zurückgegebene Wert ungleich sind.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb" id="Snippet1":::
  
 Anstatt Vergleich, Gleichheit, eine Technik wird eine akzeptable relative Rand Unterschied zwischen zwei Werten definieren (z. B. 001 % einer der Werte). Wenn der absolute Wert des Unterschieds zwischen den beiden Werten kleiner oder gleich diesem Rand ist, ist der Unterschied wahrscheinlich auf Unterschiede bei der Genauigkeit zurückzuführen, und daher sind die Werte wahrscheinlich gleich. Im folgenden Beispiel wird dieses Verfahren zum Vergleichen von. 33333 und 1/3 verwendet, die zwei Werte, die <xref:System.Double> im vorherigen Codebeispiel als ungleich festgestellt wurden. In diesem Fall sind die Werte gleich.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb" id="Snippet2":::
  
> [!NOTE]
>  Da <xref:System.Double.Epsilon> den minimalen Ausdruck eines positiven Werts definiert, dessen Bereich nahe 0 (null) ist, muss der Rand der Differenz zwischen zwei ähnlichen Werten größer als sein <xref:System.Double.Epsilon> . In der Regel ist es oft größer als <xref:System.Double.Epsilon> . Aus diesem Grund wird empfohlen, <xref:System.Double.Epsilon> beim Vergleichen <xref:System.Double> von Werten auf Gleichheit nicht zu verwenden.  
  
 Eine zweite Methode besteht darin, den Unterschied zwischen zwei Gleit Komma Zahlen mit einem absoluten Wert zu vergleichen. Wenn die Differenz kleiner oder gleich dem absoluten Wert ist, sind die Zahlen gleich. Wenn Sie größer ist, sind die Zahlen nicht gleich. Eine Alternative besteht darin, willkürlich einen absoluten Wert auszuwählen. Dies ist jedoch problematisch, da eine akzeptable Differenz Spanne von der Größe der Werte abhängig ist <xref:System.Double> . Eine zweite Alternative nutzt eine Entwurfs Funktion des Gleit Komma Formats: der Unterschied zwischen der ganzzahligen Darstellung von zwei Gleit Komma Werten gibt die Anzahl möglicher Gleit Komma Werte an, die Sie trennt. Beispielsweise ist der Unterschied zwischen 0,0 und <xref:System.Double.Epsilon> 1, da <xref:System.Double.Epsilon> der kleinste darstellbare Wert ist, wenn Sie mit einem- <xref:System.Double> Wert gleich 0 (null) arbeiten. Im folgenden Beispiel wird diese Technik zum Vergleichen von. 33333 und 1/3 verwendet, bei denen es sich um die beiden Werte handelt, <xref:System.Double> die im vorherigen Codebeispiel mit der- <xref:System.Double.Equals%28System.Double%29> Methode ungleich gefunden wurden. Beachten Sie, dass in diesem Beispiel die-Methode verwendet wird <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> , um einen Gleit Komma Wert mit doppelter Genauigkeit in seine ganzzahlige Darstellung zu konvertieren.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsabs1.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsabs1.vb" id="Snippet1"::: 
  
 Die Genauigkeit von Gleit Komma Zahlen jenseits der dokumentierten Genauigkeit ist spezifisch für die Implementierung und die Version der .NET Framework. Folglich kann sich ein Vergleich zweier bestimmter Zahlen zwischen den Versionen der .NET Framework ändern, da sich die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
 Wenn zwei <xref:System.Double.NaN?displayProperty=nameWithType> Werte auf Gleichheit getestet werden, indem die- <xref:System.Double.Equals%2A> Methode aufgerufen wird, gibt die Methode zurück `true` . Wenn jedoch zwei <xref:System.Double.NaN> Werte mit dem Gleichheits Operator auf Gleichheit getestet werden, gibt der Operator zurück `false` . Wenn Sie bestimmen möchten, ob der Wert einer <xref:System.Double> keine Zahl (NaN) ist, besteht eine Alternative darin, die-Methode aufzurufen <xref:System.Double.IsNaN%2A> .  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Die Auflösung der compilerüberladung kann einen offensichtlichen Unterschied im Verhalten der beiden <see cref="M:System.Double.Equals(System.Object)" /> Methoden Überladungen berücksichtigen. Wenn eine implizite Konvertierung zwischen dem <paramref name="obj" /> -Argument und einem <see cref="T:System.Double" /> -Argument definiert wird und das-Argument nicht als typisiert ist <see cref="T:System.Object" /> , können Compiler eine implizite Konvertierung durchführen und die-Methode aufzurufen <see cref="M:System.Double.Equals(System.Double)" /> . Andernfalls wird die- <see cref="M:System.Double.Equals(System.Object)" /> Methode aufgerufen, die immer zurückgibt, <see langword="false" /> Wenn das <paramref name="obj" /> Argument kein <see cref="T:System.Double" /> Wert ist. Das folgende Beispiel veranschaulicht den Unterschied im Verhalten zwischen den zwei Methoden Überladungen. Bei allen primitiven numerischen Typen mit Ausnahme von <see cref="T:System.Decimal" /> und in c# gibt der erste Vergleich zurück, <see langword="true" /> da der Compiler automatisch eine erweiternde Konvertierung ausführt und die- <see cref="M:System.Double.Equals(System.Double)" /> Methode aufruft, während der zweite Vergleich zurückgibt, <see langword="false" /> da der Compiler die- <see cref="M:System.Double.Equals(System.Object)" /> Methode aufruft.  
  
::: Code language = "CSharp" Source = "~/Samples/Snippets/CSharp/VS_Snippets_CLR_System/System.Double.Equals/CS/equalsoverl.cs" Interactive = "try-dotnet" ID = "Snippet2":::::: Code language = "vb" Source = "~/Samples/Snippets/VisualBasic/VS_Snippets_CLR_System/System.Double.Equals/VB/equalsoverl.vb" ID = "Snippet2"::</para></block>
        <altmember cref="M:System.Double.Equals(System.Object)" />
        <altmember cref="Overload:System.Double.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="double.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Ein Objekt, das mit dieser Instanz verglichen werden soll.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob diese Instanz gleich einem angegebenen Objekt ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="obj" /> eine Instanz von <see cref="T:System.Double" /> ist, deren Wert gleich dem Wert dieser Instanz ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Double.Equals%2A> Methode sollte mit Bedacht verwendet werden, da zwei scheinbar äquivalente Werte aufgrund der unterschiedlichen Genauigkeit der beiden Werte ungleich sein können. Im folgenden Beispiel wird berichtet, dass der <xref:System.Double> Wert. 3333 und der, der durch Division von <xref:System.Double> 1 durch 3 zurückgegeben wurde, ungleich sind.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs" interactive="try-dotnet-method" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb" id="Snippet3":::
  
 Alternativen zum Aufrufen der- <xref:System.Double.Equals%2A> Methode finden Sie in der Dokumentation für die-Überladung <xref:System.Double.Equals%28System.Double%29> .  
  
> [!NOTE]
>  Da <xref:System.Double.Epsilon> den minimalen Ausdruck eines positiven Werts definiert, dessen Bereich nahe 0 (null) ist, muss der Rand der Differenz zwischen zwei ähnlichen Werten größer als sein <xref:System.Double.Epsilon> . In der Regel ist es oft größer als <xref:System.Double.Epsilon> .  
  
 Die Genauigkeit von Gleit Komma Zahlen jenseits der dokumentierten Genauigkeit ist spezifisch für die Implementierung und die Version der .NET Framework. Folglich kann sich ein Vergleich zweier bestimmter Zahlen zwischen den Versionen der .NET Framework ändern, da sich die Genauigkeit der internen Darstellung der Zahlen ändern kann.  
  
 Wenn zwei <xref:System.Double.NaN?displayProperty=nameWithType> Werte auf Gleichheit getestet werden, indem die- <xref:System.Double.Equals%2A> Methode aufgerufen wird, gibt die Methode zurück `true` . Wenn jedoch zwei <xref:System.Double.NaN> Werte mit dem Gleichheits Operator auf Gleichheit getestet werden, gibt der Operator zurück `false` . Wenn Sie bestimmen möchten, ob der Wert einer <xref:System.Double> keine Zahl (NaN) ist, besteht eine Alternative darin, die-Methode aufzurufen <xref:System.Double.IsNaN%2A> .  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Die Auflösung der compilerüberladung kann einen offensichtlichen Unterschied im Verhalten der beiden <see cref="M:System.Double.Equals(System.Object)" /> Methoden Überladungen berücksichtigen. Wenn eine implizite Konvertierung zwischen dem <paramref name="obj" /> -Argument und einem <see cref="T:System.Double" /> -Argument definiert wird und das-Argument nicht als typisiert ist <see cref="T:System.Object" /> , können Compiler eine implizite Konvertierung durchführen und die-Methode aufzurufen <see cref="M:System.Double.Equals(System.Double)" /> . Andernfalls wird die- <see cref="M:System.Double.Equals(System.Object)" /> Methode aufgerufen, die immer zurückgibt, <see langword="false" /> Wenn das <paramref name="obj" /> Argument kein <see cref="T:System.Double" /> Wert ist. Das folgende Beispiel veranschaulicht den Unterschied im Verhalten zwischen den zwei Methoden Überladungen. Bei allen primitiven numerischen Typen mit Ausnahme von <see cref="T:System.Decimal" /> und in c# gibt der erste Vergleich zurück, <see langword="true" /> da der Compiler automatisch eine erweiternde Konvertierung ausführt und die- <see cref="M:System.Double.Equals(System.Double)" /> Methode aufruft, während der zweite Vergleich zurückgibt, <see langword="false" /> da der Compiler die- <see cref="M:System.Double.Equals(System.Object)" /> Methode aufruft.  
  
::: Code language = "CSharp" Source = "~/Samples/Snippets/CSharp/VS_Snippets_CLR_System/System.Double.Equals/CS/equalsoverl.cs" Interactive = "try-dotnet" ID = "Snippet2":::::: Code language = "vb" Source = "~/Samples/Snippets/VisualBasic/VS_Snippets_CLR_System/System.Double.Equals/VB/equalsoverl.vb" ID = "Snippet2"::</para></block>
        <altmember cref="M:System.Double.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="double.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für diese Instanz zurück.</summary>
        <returns>Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="double.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den <see cref="T:System.TypeCode" /> für den Werttyp <see cref="T:System.Double" /> zurück.</summary>
        <returns>Die Enumerationskonstante <see cref="F:System.TypeCode.Double" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsFinite(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(double d);" />
      <MemberSignature Language="F#" Value="static member IsFinite : double -&gt; bool" Usage="System.double.IsFinite d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="d">Eine Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Diese Methode bestimmt, ob der Wert endlich ist (Null, subnormal oder normal).</summary>
        <returns><see langword="true" />, wenn der Wert endlich ist (Null, subnormal oder normal); sonst <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : double -&gt; bool" Usage="System.double.IsInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Eine Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der Wert der angegebenen Zahl -unendlich oder +unendlich ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="d" /> entweder <see cref="F:System.Double.PositiveInfinity" /> oder <see cref="F:System.Double.NegativeInfinity" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gleit Komma Operationen geben <xref:System.Double.PositiveInfinity> oder zurück <xref:System.Double.NegativeInfinity> , um eine Überlauf Bedingung zu signalisieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung von veranschaulicht <xref:System.Double.IsInfinity%2A> :  
  
 [!code-cpp[System.Double#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#11)]
 [!code-csharp[System.Double#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#11)]
 [!code-vb[System.Double#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNaN(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(double d);" />
      <MemberSignature Language="F#" Value="static member IsNaN : double -&gt; bool" Usage="System.double.IsNaN d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Eine Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der angegebene Wert keine Zahl ist (<see cref="F:System.Double.NaN" />).</summary>
        <returns><see langword="true" />, wenn <paramref name="d" /><see cref="F:System.Double.NaN" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gleit Komma Vorgänge geben zurück, <xref:System.Double.NaN> um zu signalisieren, dass das Ergebnis des Vorgangs nicht definiert ist. Beispielsweise führt die Division von 0,0 durch 0,0 zu <xref:System.Double.NaN> .  
  
> [!NOTE]
>  <xref:System.Double.IsNaN%2A> Gibt zurück, `false` Wenn ein <xref:System.Double> Wert entweder <xref:System.Double.PositiveInfinity> oder ist <xref:System.Double.NegativeInfinity> . Um diese Werte zu testen, verwenden Sie <xref:System.Double.IsInfinity%2A> die <xref:System.Double.IsPositiveInfinity%2A> Methoden, und <xref:System.Double.IsNegativeInfinity%2A> .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung von veranschaulicht <xref:System.Double.IsNaN%2A> :  
  
 [!code-cpp[System.Double#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#8)]
 [!code-csharp[System.Double#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#8)]
 [!code-vb[System.Double#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Double.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (double d);" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float64 d) cil managed" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegative(System.Double)" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (d As Double) As Boolean" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(double d);" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberSignature Language="F#" Value="static member IsNegative : double -&gt; bool" Usage="System.double.IsNegative d" FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType FrameworkAlternate="net-5.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.1">System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="d">Eine Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Bestimmt, ob der angegebene Wert negativ ist.</summary>
        <returns><see langword="true" />, wenn der Wert negativ ist; sonst <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegativeInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : double -&gt; bool" Usage="System.double.IsNegativeInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Eine Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die angegebene Zahl minus unendlich ergibt.</summary>
        <returns><see langword="true" />, wenn <paramref name="d" /><see cref="F:System.Double.NegativeInfinity" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gleit Komma Vorgänge geben zurück <xref:System.Double.NegativeInfinity> , um eine Überlauf Bedingung zu signalisieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung von veranschaulicht <xref:System.Double.IsNegativeInfinity%2A> :  
  
 [!code-cpp[System.Double#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#13)]
 [!code-csharp[System.Double#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#13)]
 [!code-vb[System.Double#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#13)]  
[!code-cpp[System.Double#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#4)]
[!code-csharp[System.Double#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#4)]
[!code-vb[System.Double#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#4)]  
[!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
[!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
[!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(double d);" />
      <MemberSignature Language="F#" Value="static member IsNormal : double -&gt; bool" Usage="System.double.IsNormal d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="d">Eine Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Bestimmt, ob der angegebene Wert normal ist.</summary>
        <returns><see langword="true" />, wenn der Wert normal ist; sonst <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsPositiveInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : double -&gt; bool" Usage="System.double.IsPositiveInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Eine Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die angegebene Zahl plus unendlich ergibt.</summary>
        <returns><see langword="true" />, wenn <paramref name="d" /><see cref="F:System.Double.PositiveInfinity" /> ergibt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Gleit Komma Vorgänge geben zurück <xref:System.Double.PositiveInfinity> , um eine Überlauf Bedingung zu signalisieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung von veranschaulicht <xref:System.Double.IsPositiveInfinity%2A> :  
  
 [!code-cpp[System.Double#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#12)]
 [!code-csharp[System.Double#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#12)]
 [!code-vb[System.Double#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsSubnormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(double d);" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : double -&gt; bool" Usage="System.double.IsSubnormal d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="d">Eine Gleitkommazahl mit doppelter Genauigkeit.</param>
        <summary>Bestimmt, ob der angegebene Wert subnormal ist.</summary>
        <returns><see langword="true" />, wenn der Wert subnormal ist; sonst <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const double MaxValue = 1.7976931348623157E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MaxValue = float64(1.7976931348623157E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Double  = 1.7976931348623157E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MaxValue = 1.7976931348623157E+308;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : double" Usage="System.double.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>1.7976931348623157E+308</MemberValue>
      <Docs>
        <summary>Stellt den größtmöglichen Wert von <see cref="T:System.Double" /> dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstante ist positiv 1.7976931348623157 e + 308.  
  
 Das Ergebnis eines Vorgangs, der überschreitet, <xref:System.Double.MaxValue?displayProperty=nameWithType> ist <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> . Im folgenden Beispiel werden <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> Ergebnisse aus Additions-, Multiplikations-und exponentiations Vorgängen ausgegeben, wenn das Ergebnis überschreitet <xref:System.Double.MaxValue?displayProperty=nameWithType> .  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.maxvalue/cs/maxvalueex.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.maxvalue/vb/maxvalueex.vb" id="Snippet1":::
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung von veranschaulicht <xref:System.Double.MaxValue?displayProperty=nameWithType> :  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const double MinValue = -1.7976931348623157E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MinValue = float64(-1.7976931348623157E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Double  = -1.7976931348623157E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MinValue = -1.7976931348623157E+308;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : double" Usage="System.double.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-1.7976931348623157E+308</MemberValue>
      <Docs>
        <summary>Stellt den kleinstmöglichen Wert von <see cref="T:System.Double" /> dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstante ist negativ 1.7976931348623157 e + 308.  
  
 Das Ergebnis eines Vorgangs, der kleiner als <xref:System.Double.MinValue?displayProperty=nameWithType> ist <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> . Im folgenden Beispiel werden <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> Ergebnisse aus Subtraktions-und Multiplikations Vorgängen ausgegeben, wenn das Ergebnis kleiner als ist <xref:System.Double.MinValue?displayProperty=nameWithType> .  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.minvalue/cs/minvalueex.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.minvalue/vb/minvalueex.vb" id="Snippet1":::
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung von veranschaulicht <xref:System.Double.MinValue?displayProperty=nameWithType> :  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp" id="Snippet2":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb" id="Snippet2"::: 

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const double NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NaN = float64(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Double  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: double NaN = NaN;" />
      <MemberSignature Language="F#" Value="val mutable NaN : double" Usage="System.double.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>Stellt einen Wert dar, der keine Zahl ist (<see langword="NaN" />). Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Methode oder ein Operator gibt zurück, <xref:System.Double.NaN> Wenn das Ergebnis eines Vorgangs nicht definiert ist. Das Ergebnis der Division von NULL durch Null ist beispielsweise <xref:System.Double.NaN> , wie im folgenden Beispiel gezeigt. (Beachten Sie jedoch, dass die Aufteilung einer Zahl ungleich NULL durch Null entweder oder zurückgibt <xref:System.Double.PositiveInfinity> <xref:System.Double.NegativeInfinity> , abhängig vom Vorzeichen des Divisors.)  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb" id="Snippet1"::: 
  
 Außerdem gibt ein Methodenaufrufe mit einem <xref:System.Double.NaN> Wert oder einem Vorgang für einen <xref:System.Double.NaN> Wert zurück <xref:System.Double.NaN> , wie im folgenden Beispiel gezeigt.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb" id="Snippet2"::: 
  
 Verwenden Sie die- <xref:System.Double.IsNaN%2A> Methode, um zu bestimmen, ob ein Wert keine Zahl ist. Der- <xref:System.Double.op_Equality%2A> Operator betrachtet zwei Werte, die ungleich zueinander sind <xref:System.Double.NaN> . Im Allgemeinen können <xref:System.Double> Operatoren nicht zum Vergleichen <xref:System.Double.NaN?displayProperty=nameWithType> mit anderen Werten verwendet werden <xref:System.Double> , obwohl Vergleichsmethoden (z <xref:System.Double.Equals%2A> . b. und <xref:System.Double.CompareTo%2A> ) möglich sind. Das folgende Beispiel veranschaulicht den Unterschied im Verhalten zwischen <xref:System.Double> Vergleichs Operatoren und Methoden.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/double.nan4.cs" interactive="try-dotnet" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/double.nan4.vb" id="Snippet4":::
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung von <xref:System.Double.NaN> veranschaulicht:  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp" id="Snippet7":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs" interactive="try-dotnet-method" id="Snippet7":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb" id="Snippet7"::: 
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNaN(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NegativeInfinity = float64(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Double  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="F#" Value="val mutable NegativeInfinity : double" Usage="System.double.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>Stellt minus unendlich dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstante ist das Ergebnis der Division einer negativen Zahl durch 0 (null).  
  
 Diese Konstante wird zurückgegeben, wenn das Ergebnis eines Vorgangs kleiner als ist <xref:System.Double.MinValue?displayProperty=nameWithType> .  
  
 Verwenden <xref:System.Double.IsNegativeInfinity%2A> Sie, um zu bestimmen, ob ein Wert minus unendlich ergibt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung von veranschaulicht <xref:System.Double.NegativeInfinity> :  
  
 [!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
 [!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
 [!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Equality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : double * double -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei angegebene <see cref="T:System.Double" />-Werte gleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Double.op_Equality%2A> Methode definiert den Gleichheits Operator für- <xref:System.Double> Werte.  
  
 Wenn zwei <xref:System.Double.NaN?displayProperty=nameWithType> Werte mit dem Gleichheits Operator auf Gleichheit getestet werden, ist das Ergebnis `false` . zwei <xref:System.Double.NaN?displayProperty=nameWithType> Werte werden nicht als gleich betrachtet. Wenn Sie durch Aufrufen der-Methode auf Gleichheit geprüft werden <xref:System.Double.Equals%2A> , ist das Ergebnis `true` .  Wenn Sie bestimmen möchten, ob der Wert einer <xref:System.Double> keine Zahl (NaN) ist, besteht eine Alternative darin, die-Methode aufzurufen <xref:System.Double.IsNaN%2A> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : double * double -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Double" />-Wert größer als ein anderer angegebener <see cref="T:System.Double" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.op_GreaterThan%2A> -Methode definiert den Vorgang des Operators "größer als" für- <xref:System.Double> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : double * double -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Double" />-Wert größer oder gleich einem anderen angegebenen <see cref="T:System.Double" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> größer oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.op_GreaterThanOrEqual%2A> -Methode definiert den Vorgang des größer-als-oder-gleich-Operators für- <xref:System.Double> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Inequality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : double * double -&gt; bool" Usage="System.double.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei angegebene <see cref="T:System.Double" />-Werte gleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Double.op_Inequality%2A> Methode definiert den Ungleichheits Operator für- <xref:System.Double> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : double * double -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Double" />-Wert größer als ein anderer angegebener <see cref="T:System.Double" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Double.op_LessThan%2A> Methode definiert den Vorgang des less-than-Operators für- <xref:System.Double> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : double * double -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener <see cref="T:System.Double" /> -Wert kleiner oder gleich einem anderen angegebenen <see cref="T:System.Double" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Double.op_LessThanOrEqual%2A> -Methode definiert den Vorgang des less-than-or-equal-Operators für- <xref:System.Double> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in die entsprechende Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <altmember cref="Overload:System.Double.TryParse" />
        <remarks>In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <see cref="F:System.Double.PositiveInfinity" /> oder entsprechend <see cref="F:System.Double.NegativeInfinity" /> der IEEE 754-Spezifikation gerundet. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.</remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; double" Usage="System.double.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in die entsprechende Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit doppelter Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <xref:System.Double.PositiveInfinity> oder entsprechend <xref:System.Double.NegativeInfinity> der IEEE 754-Spezifikation gerundet. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.

 Der `s` -Parameter kann die aktuelle Kultur <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType> , <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType> , <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> oder eine Zeichenfolge der folgenden Form enthalten:  
  
 [*WS*] [*Sign*] [ganzzahlige*Ziffern*[*,*]] ganzzahlige *Ziffern*[*.* [*Bruch Ziffern*]] [E [*Sign*]*exponentialziffern*] [*WS*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen.|  
|*sign*|Ein negatives Vorzeichen Symbol (-) oder ein positives Vorzeichen Symbol (+). Es kann nur ein führendes Vorzeichen verwendet werden.|  
|*ganzzahlige Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Ausführungen ganzzahliger *Ziffern* können durch ein Gruppen Trennzeichen partitioniert werden. In einigen Kulturen werden z. b. durch Kommas (,) Gruppen von Tausenden voneinander getrennt. Das *integrale Ziffern* Element kann nicht vorhanden sein, wenn die Zeichenfolge das Dezimal *stellen Element enthält* .|  
|,|Ein kulturspezifisches Tausender Trennzeichen.|  
|.|Ein kulturspezifisches Dezimaltrennzeichen.|  
|*Bruch Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den Bruch Teil der Zahl angeben.|  
|E|Das Zeichen "e" oder "e", das angibt, dass der Wert in exponentieller Notation (Scientific) dargestellt wird.|  
|*exponentielle Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die einen Exponenten angeben.|  
  
 Der `s` -Parameter wird mit einer Kombination der <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> -und- <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flags interpretiert. Dies bedeutet, dass leer-und Tausender Trennzeichen zulässig sind, z. b. bei Währungs Symbolen. Um eine präzisere Kontrolle darüber zu erhalten, welche Stilelemente in zulässig sind `s` , damit der Analyse Vorgang erfolgreich ist, können Sie die- <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> Methode oder die- <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode auf  
  
 Der- `s` Parameter wird mit den Formatierungsinformationen in einem- <xref:System.Globalization.NumberFormatInfo> Objekt interpretiert, das für die aktuelle Thread Kultur initialisiert wird. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Um eine Zeichenfolge mit den Formatierungsinformationen einer anderen Kultur zu analysieren, können Sie die- <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> oder- <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methode verwenden.  
  
 Wenn Sie der-Methode eine Zeichenfolge übergeben, die <xref:System.Double.Parse%2A?displayProperty=nameWithType> durch den Aufruf der-Methode erstellt wird <xref:System.Double.ToString%2A?displayProperty=nameWithType> , wird normalerweise der ursprüngliche <xref:System.Double> Wert zurückgegeben. Bei .NET Framework und .net Core 2,2 und früheren Versionen sind die Werte jedoch möglicherweise aufgrund eines Genauigkeits Verlusts nicht gleich. Außerdem kann bei dem Versuch, die Zeichen folgen Darstellung von oder zu analysieren, ein <xref:System.Double.MinValue?displayProperty=nameWithType> <xref:System.Double.MaxValue?displayProperty=nameWithType> Roundtrip nicht durchführt werden. Auf .NET Framework und .net Core 2,2 und früheren Versionen wird eine ausgelöst <xref:System.OverflowException> . Dies wird im folgenden Beispiel veranschaulicht. 
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs" interactive="try-dotnet-method" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb" id="Snippet3":::

Bei .NET Framework und .net Core 2,2 und früheren Versionen löst `s` die-Methode eine aus, wenn außerhalb des gültigen Bereichs des- <xref:System.Double> Datentyps liegt <xref:System.Double.Parse%28System.String%29> <xref:System.OverflowException> .

Unter .net Core 3,0 und höheren Versionen wird keine Ausnahme ausgelöst, wenn `s` außerhalb des gültigen Bereichs des- <xref:System.Double> Datentyps liegt. In den meisten Fällen gibt die-Methode <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder zurück <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> . Allerdings gibt es eine kleine Menge von Werten, die als näher an den maximalen oder minimalen Werten von <xref:System.Double> als positiv oder minus unendlich angesehen werden. In diesen Fällen gibt die Methode <xref:System.Double.MaxValue?displayProperty=nameWithType> oder zurück <xref:System.Double.MinValue?displayProperty=nameWithType> .

Wenn im-Parameter während eines Analyse Vorgangs ein Trennzeichen gefunden wird `s` und die entsprechende Währungs-oder Zahlen Dezimal-und Gruppen Trennzeichen identisch sind, geht der Analyse Vorgang davon aus, dass es sich bei dem Trennzeichen um ein Dezimaltrennzeichen und nicht um ein Gruppen Trennzeichen handelt. Weitere Informationen zu Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A> , <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A> , <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A> .     
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Double.Parse%28System.String%29>-Methode veranschaulicht.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp" id="Snippet5":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs" id="Snippet5":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb" id="Snippet5":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> stellt keine Zahl in einem gültigen Format dar.</exception>
        <exception cref="T:System.OverflowException">Nur .NET Framework und .NET Core 2.2 und frühere Versionen: <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Double.MinValue" /> oder größer als <see cref="F:System.Double.MaxValue" /> ist.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="M:System.Double.TryParse(System.String,System.Double@)" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-numeric">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; double" Usage="System.double.Parse (s, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die in <paramref name="s" /> vorhanden sein können. Ein häufig anzugebender Wert ist eine Kombination von <see cref="F:System.Globalization.NumberStyles.Float" /> und <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Format in die entsprechende Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit doppelter Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <xref:System.Double.PositiveInfinity> oder entsprechend <xref:System.Double.NegativeInfinity> der IEEE 754-Spezifikation gerundet. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.

 Der- `style` Parameter definiert die Stilelemente (z. b. Leerzeichen, Tausender Trennzeichen und Währungssymbole), die im-Parameter zulässig sind, damit der Analyse Vorgang erfolgreich ausgeführt werden kann `s` . Dabei muss es sich um eine Kombination von Bitflags aus der- <xref:System.Globalization.NumberStyles> Enumeration handeln. Die folgenden Member <xref:System.Globalization.NumberStyles> werden nicht unterstützt:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Der `s` -Parameter kann die-,-oder-Zeichen der aktuellen Kultur enthalten <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType> <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType> <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> . Abhängig vom Wert von `style` kann auch das folgende Format annehmen:  
  
 [*WS*] [ *$* ] [*Sign*] [*integrale Ziffern*[*,*]] ganzzahlige*Ziffern*[*.* [*Bruch Ziffern*]] [E [*Sign*]*exponentialziffern*] [*WS*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen. Leerräume können am Anfang von angezeigt `s` `style` werden, wenn das <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> -Flag enthält, und es kann am Ende von angezeigt werden, `s` Wenn `style` das- <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> Flag enthält.|  
|$|Ein kulturspezifisches Währungssymbol. Die Position in der Zeichenfolge wird durch die <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> -Eigenschaft und die-Eigenschaft <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> der aktuellen Kultur definiert. Das Währungssymbol der aktuellen Kultur kann in angezeigt `s` werden, wenn `style` das- <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> Flag enthält.|  
|*sign*|Ein negatives Vorzeichen Symbol (-) oder ein positives Vorzeichen Symbol (+). Das Vorzeichen kann am Anfang von angezeigt `s` `style` werden, wenn das <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> -Flag enthält, und es kann am Ende von angezeigt werden, `s` Wenn `style` das- <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> Flag enthält. Klammern können in verwendet werden `s` , um einen negativen Wert anzugeben, wenn `style` das- <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> Flag einschließt.|  
|*ganzzahlige Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Das *integrale Ziffern* Element kann nicht vorhanden sein, wenn die Zeichenfolge das Dezimal *stellen Element enthält* .|  
|,|Ein kulturspezifisches Gruppen Trennzeichen. Das Gruppen Trennzeichen der aktuellen Kultur kann in angezeigt `s` werden, wenn `style` das- <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flag enthält.|  
|.|Ein kulturspezifisches Dezimaltrennzeichen. Das Dezimaltrennzeichen der aktuellen Kultur kann in auftreten, `s` Wenn `style` das- <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag enthält.|  
|*Bruch Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den Bruch Teil der Zahl angeben. Bruch Ziffern können in auftreten, `s` Wenn `style` das- <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag enthält.|  
|E|Das Zeichen "e" oder "e", das angibt, dass der Wert in exponentieller Notation (Scientific) dargestellt wird. Der- `s` Parameter kann eine Zahl in Exponentialnotation darstellen, wenn `style` das- <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Flag enthält.|  
|*exponentielle Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die einen Exponenten angeben.|  
  
> [!NOTE]
> Alle abschließenden NUL-Zeichen (U + 0000) in `s` werden vom Analyse-Vorgang unabhängig vom Wert des `style` Arguments ignoriert.

 Eine Zeichenfolge, die nur Ziffern (die dem Format entspricht) entspricht, <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> wird immer erfolgreich analysiert, wenn Sie sich im Bereich des <xref:System.Double> Typs befindet. Die übrigen Member <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> steuern Elemente, die in der Eingabe Zeichenfolge vorhanden sein können, aber nicht in der Eingabe Zeichenfolge vorhanden sein müssen. In der folgenden Tabelle wird angegeben <xref:System.Globalization.NumberStyles> , wie die einzelnen Flags die Elemente beeinflussen, die möglicherweise in vorhanden sind `s` .  
  
|NumberStyles-Wert|In zugelassene Elemente `s` zusätzlich zu Ziffern|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Nur das ganzzahlige *Ziffern* Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Die Dezimaltrennzeichen (*.*) und die Elemente der *Bruch Ziffern* .|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das Zeichen "e" oder "e", das die Exponentialschreibweise angibt. Dieses Flag allein unterstützt Werte in der Form *Ziffern*E*Ziffern*. zusätzliche Flags sind erforderlich, um Zeichen folgen mit solchen Elementen wie positive oder negative Vorzeichen und Dezimaltrennzeichen erfolgreich zu analysieren.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Das *WS* -Element am Anfang von `s` .|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Das *WS* -Element am Ende von `s` .|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Das *Sign* -Element am Anfang von `s` .|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Das *Sign* -Element am Ende von `s` .|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Das *Vorzeichen* Element in der Form von Klammern, das den numerischen Wert einschließt.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das Tausender Trennzeichen (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Currency ($)-Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle-Elemente. Es ist jedoch nicht möglich, `s` eine hexadezimale Zahl oder eine Zahl in Exponentialnotation darzustellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Das *WS* -Element am Anfang oder Ende von `s` *signiert* am Anfang von `s` und dem Dezimaltrennzeichen (.). Der- `s` Parameter kann auch die Exponentialnotation verwenden.|  
|<xref:System.Globalization.NumberStyles.Number>|Die `ws` `sign` Elemente,, Tausender Trennzeichen (,) und Dezimaltrennzeichen (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Alle-Elemente. `s`Eine hexadezimale Zahl kann jedoch nicht dargestellt werden.|  
  
 Der- `s` Parameter wird mithilfe der Formatierungsinformationen in einem- <xref:System.Globalization.NumberFormatInfo> Objekt analysiert, das für die aktuelle System Kultur initialisiert wird. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>.  
  
 Wenn Sie der-Methode eine Zeichenfolge übergeben, die <xref:System.Double.Parse%2A?displayProperty=nameWithType> durch den Aufruf der-Methode erstellt wird <xref:System.Double.ToString%2A?displayProperty=nameWithType> , wird normalerweise der ursprüngliche <xref:System.Double> Wert zurückgegeben. Aufgrund eines Genauigkeits Verlusts sind die Werte jedoch möglicherweise nicht gleich. Außerdem kann bei dem Versuch, die Zeichen folgen Darstellung von oder zu analysieren, ein <xref:System.Double.MinValue?displayProperty=nameWithType> <xref:System.Double.MaxValue?displayProperty=nameWithType> Roundtrip nicht durchführt werden. Auf .NET Framework und .net Core 2,2 und früheren Versionen wird eine ausgelöst <xref:System.OverflowException> . In .net Core 3,0 und höheren Versionen wird zurückgegeben, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> Wenn Sie versuchen, zu analysieren <xref:System.Double.MinValue?displayProperty=nameWithtype> oder <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> zu analysieren <xref:System.Double.MaxValue?displayProperty=nameWithtype> . Dies wird im folgenden Beispiel veranschaulicht. 
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs" interactive="try-dotnet-method" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb" id="Snippet3":::

Bei .NET Framework und .net Core 2,2 und früheren Versionen löst `s` die-Methode eine aus, wenn außerhalb des gültigen Bereichs des- <xref:System.Double> Datentyps liegt <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> <xref:System.OverflowException> .

Unter .net Core 3,0 und höheren Versionen wird keine Ausnahme ausgelöst, wenn `s` außerhalb des gültigen Bereichs des- <xref:System.Double> Datentyps liegt. In den meisten Fällen gibt die- <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> Methode <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder zurück <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> . Allerdings gibt es eine kleine Menge von Werten, die als näher an den maximalen oder minimalen Werten von <xref:System.Double> als positiv oder minus unendlich angesehen werden. In diesen Fällen gibt die Methode <xref:System.Double.MaxValue?displayProperty=nameWithType> oder zurück <xref:System.Double.MinValue?displayProperty=nameWithType> .

Wenn im-Parameter während eines Analyse Vorgangs ein Trennzeichen gefunden wird `s` und die entsprechende Währungs-oder Zahlen Dezimal-und Gruppen Trennzeichen identisch sind, geht der Analyse Vorgang davon aus, dass es sich bei dem Trennzeichen um ein Dezimaltrennzeichen und nicht um ein Gruppen Trennzeichen handelt. Weitere Informationen zu Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A> , <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A> , <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A> .   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> -Methode verwendet, um die Zeichen folgen Darstellungen von <xref:System.Double> Werten mit der Kultur "en-US" zu analysieren.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse.cs" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> stellt keine Zahl in einem gültigen Format dar.</exception>
        <exception cref="T:System.OverflowException">Nur .NET Framework und .NET Core 2.2 und früheren Versionen: <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Double.MinValue" /> oder größer als <see cref="F:System.Double.MaxValue" /> ist.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder - 
 <paramref name="style" /> enthält den <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Wert.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-numeric">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, IFormatProvider provider);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; double" Usage="System.double.Parse (s, provider)" />
      <MemberSignature Language="C#" Value="public static double Parse (string s, IFormatProvider? provider);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="s" /> bereitstellt.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem bestimmten kulturspezifischen Format in die entsprechende Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit doppelter Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <xref:System.Double.PositiveInfinity> oder entsprechend <xref:System.Double.NegativeInfinity> der IEEE 754-Spezifikation gerundet. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.

 Diese Überladung der- <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> Methode wird normalerweise verwendet, um Text zu konvertieren, der auf verschiedene Weise in einen-Wert formatiert werden kann <xref:System.Double> . Beispielsweise kann es verwendet werden, um den Text, der von einem Benutzer eingegeben wurde, in ein HTML-Textfeld in einen numerischen Wert zu konvertieren.  
  
 Der `s` -Parameter wird mit einer Kombination der <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> -und- <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flags interpretiert. Der- `s` Parameter kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType> , <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType> oder <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> für die Kultur enthalten, die von angegeben `provider` wird, oder er kann eine Zeichenfolge in der Form enthalten:  
  
 [*WS*] [*Sign*] ganzzahlige *Ziffern*[*.* [*Bruch Ziffern*]] [E [*Sign*]*exponentialziffern*] [*WS*]  
  
 Optionale Elemente werden in eckige Klammern ([und]) eingeschlossen. Elemente, die den Begriff "Ziffern" enthalten, bestehen aus einer Reihe von numerischen Zeichen zwischen 0 und 9.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen.|  
|*sign*|Ein negatives Vorzeichen Symbol (-) oder ein positives Vorzeichen Symbol (+).|  
|*ganzzahlige Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Ausführungen ganzzahliger *Ziffern* können durch ein Gruppen Trennzeichen partitioniert werden. In einigen Kulturen werden z. b. durch Kommas (,) Gruppen von Tausenden voneinander getrennt. Das *integrale Ziffern* Element kann nicht vorhanden sein, wenn die Zeichenfolge das Dezimal *stellen Element enthält* .|  
|.|Ein kulturspezifisches Dezimaltrennzeichen.|  
|*Bruch Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den Bruch Teil der Zahl angeben.|  
|E|Das Zeichen "e" oder "e", das angibt, dass der Wert in exponentieller Notation (Scientific) dargestellt wird.|  
|*exponentielle Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die einen Exponenten angeben.|  
  
 Weitere Informationen zu numerischen Formaten finden Sie im Thema [Formatierungs Typen](/dotnet/standard/base-types/formatting-types) .  
  
 Der- `provider` Parameter ist eine- <xref:System.IFormatProvider> Implementierung, deren- <xref:System.IFormatProvider.GetFormat%2A> Methode ein <xref:System.Globalization.NumberFormatInfo> -Objekt zurückgibt, das kulturspezifische Informationen zum Interpretieren des Formats von bereitstellt `s` . Normalerweise handelt es sich um ein- <xref:System.Globalization.NumberFormatInfo> oder- <xref:System.Globalization.CultureInfo> Objekt. Wenn `provider` ist `null` oder <xref:System.Globalization.NumberFormatInfo> nicht abgerufen werden kann, werden die Formatierungsinformationen für die aktuelle System Kultur verwendet.  
  
 Wenn Sie der-Methode eine Zeichenfolge übergeben, die <xref:System.Double.Parse%2A?displayProperty=nameWithType> durch den Aufruf der-Methode erstellt wird <xref:System.Double.ToString%2A?displayProperty=nameWithType> , wird normalerweise der ursprüngliche <xref:System.Double> Wert zurückgegeben. Aufgrund eines Genauigkeits Verlusts sind die Werte jedoch möglicherweise nicht gleich. Außerdem kann bei dem Versuch, die Zeichen folgen Darstellung von oder zu analysieren, ein <xref:System.Double.MinValue?displayProperty=nameWithType> <xref:System.Double.MaxValue?displayProperty=nameWithType> Roundtrip nicht durchführt werden. Auf .NET Framework und .net Core 2,2 und früheren Versionen wird eine ausgelöst <xref:System.OverflowException> . In .net Core 3,0 und höheren Versionen wird zurückgegeben, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> Wenn Sie versuchen, zu analysieren <xref:System.Double.MinValue?displayProperty=nameWithtype> oder <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> zu analysieren <xref:System.Double.MaxValue?displayProperty=nameWithtype> . Dies wird im folgenden Beispiel veranschaulicht.
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs" interactive="try-dotnet-method" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb" id="Snippet3":::

Bei .NET Framework und .net Core 2,2 und früheren Versionen löst `s` die-Methode eine aus, wenn außerhalb des gültigen Bereichs des- <xref:System.Double> Datentyps liegt <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> <xref:System.OverflowException> .

Unter .net Core 3,0 und höheren Versionen wird keine Ausnahme ausgelöst, wenn `s` außerhalb des gültigen Bereichs des- <xref:System.Double> Datentyps liegt. In den meisten Fällen gibt die- <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> Methode <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder zurück <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> . Allerdings gibt es eine kleine Menge von Werten, die als näher an den maximalen oder minimalen Werten von <xref:System.Double> als positiv oder minus unendlich angesehen werden. In diesen Fällen gibt die Methode <xref:System.Double.MaxValue?displayProperty=nameWithType> oder zurück <xref:System.Double.MinValue?displayProperty=nameWithType> .

Wenn im-Parameter während eines Analyse Vorgangs ein Trennzeichen gefunden wird `s` und die entsprechende Währungs-oder Zahlen Dezimal-und Gruppen Trennzeichen identisch sind, geht der Analyse Vorgang davon aus, dass es sich bei dem Trennzeichen um ein Dezimaltrennzeichen und nicht um ein Gruppen Trennzeichen handelt. Weitere Informationen zu Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A> , <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A> , <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A> .  
 
## Examples  
 Das folgende Beispiel ist der Button Click-Ereignishandler eines Webformulars. Dabei wird das von der-Eigenschaft zurückgegebene Array verwendet <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> , um das Gebiets Schema des Benutzers zu bestimmen. Anschließend wird ein-Objekt instanziiert <xref:System.Globalization.CultureInfo> , das diesem Gebiets Schema entspricht. Das <xref:System.Globalization.NumberFormatInfo> -Objekt, das zu diesem Objekt gehört, <xref:System.Globalization.CultureInfo> wird dann an die <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> -Methode weitergegeben, um die Eingabe des Benutzers in einen-Wert zu konvertieren <xref:System.Double> .  
  
 [!code-csharp[ParseMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#2)]
 [!code-vb[ParseMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> stellt keine Zahl in einem gültigen Format dar.</exception>
        <exception cref="T:System.OverflowException">Nur .NET Framework und .NET Core 2.2 und frühere Versionen: <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Double.MinValue" /> oder größer als <see cref="F:System.Double.MaxValue" /> ist.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-numeric">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider? provider = default);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = Nothing) As Double" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; double" Usage="System.double.Parse (s, style, provider)" />
      <MemberSignature Language="C#" Value="public static double Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = default);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenspanne, die die zu konvertierende Zahl enthält</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die in <paramref name="s" /> vorhanden sein können.  Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="s" /> bereitstellt.</param>
        <summary>Konvertiert eine Zeichenspanne mit der Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit doppelter Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <xref:System.Double.PositiveInfinity> oder entsprechend <xref:System.Double.NegativeInfinity> der IEEE 754-Spezifikation gerundet. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.

Wenn `s` außerhalb des Gültigkeits Bereichs des <xref:System.Double> -Datentyps liegt, gibt die Methode zurück, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> Wenn `s` kleiner als ist <xref:System.Double.MinValue?displayProperty=nameWithType> und <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> Wenn `s` größer als ist <xref:System.Double.MaxValue?displayProperty=nameWithType> .

         ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="s" /> stellt keinen numerischen Wert dar.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder - 
 <paramref name="style" /> ist der <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; double" Usage="System.double.Parse (s, style, provider)" />
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style, IFormatProvider? provider);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die in <paramref name="s" /> vorhanden sein können. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="s" /> bereitstellt.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende Gleitkommazahl mit doppelter Genauigkeit.</summary>
        <returns>Eine Gleitkommazahl mit doppelter Genauigkeit, die dem numerischen Wert oder Symbol in <paramref name="s" /> entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <xref:System.Double.PositiveInfinity> oder entsprechend <xref:System.Double.NegativeInfinity> der IEEE 754-Spezifikation gerundet. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.

 Der- `style` Parameter definiert die Stilelemente (z. b. Leerzeichen, Tausender Trennzeichen und Währungssymbole), die im-Parameter zulässig sind, damit der Analyse Vorgang erfolgreich ausgeführt werden kann `s` . Dabei muss es sich um eine Kombination von Bitflags aus der- <xref:System.Globalization.NumberStyles> Enumeration handeln. Die folgenden Member <xref:System.Globalization.NumberStyles> werden nicht unterstützt:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 Der- `s` Parameter kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType> , <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType> oder <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> für die Kultur enthalten, die durch angegeben wird `provider` . Abhängig vom Wert von `style` kann auch das folgende Format annehmen:  
  
 [*WS*] [ *$* ] [*Sign*] [*integrale Ziffern*,] ganzzahlige*Ziffern*[. [ *Bruch Ziffern*]] [E [*Sign*]*exponentialziffern*] [*WS*]  
  
 In eckige Klammern ([und]) eineckige Elemente sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen. Leerräume können am Anfang von angezeigt `s` `style` werden, wenn das <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> -Flag enthält, und es kann am Ende von angezeigt werden, `s` Wenn `style` das- <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> Flag enthält.|  
|$|Ein kulturspezifisches Währungssymbol. Die Position in der Zeichenfolge wird durch die <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> -Eigenschaft und die-Eigenschaft <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> der aktuellen Kultur definiert. Das Währungssymbol der aktuellen Kultur kann in angezeigt `s` werden, wenn `style` das- <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> Flag enthält.|  
|*sign*|Ein negatives Vorzeichen Symbol (-) oder ein positives Vorzeichen Symbol (+). Das Vorzeichen kann am Anfang von angezeigt `s` `style` werden, wenn das <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> -Flag enthält, und es kann am Ende von angezeigt werden, `s` Wenn `style` das- <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> Flag enthält. Klammern können in verwendet werden `s` , um einen negativen Wert anzugeben, wenn `style` das- <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> Flag einschließt.|  
|*ganzzahlige Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Das *integrale Ziffern* Element kann nicht vorhanden sein, wenn die Zeichenfolge das Dezimal *stellen Element enthält* .|  
|,|Ein kulturspezifisches Gruppen Trennzeichen. Das Gruppen Trennzeichen der aktuellen Kultur kann in angezeigt `s` werden, wenn `style` das- <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flag enthält.|  
|.|Ein kulturspezifisches Dezimaltrennzeichen. Das Dezimaltrennzeichen der aktuellen Kultur kann in auftreten, `s` Wenn `style` das- <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag enthält.|  
|*Bruch Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den Bruch Teil der Zahl angeben. Bruch Ziffern können in auftreten, `s` Wenn `style` das- <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag enthält.|  
|E|Das Zeichen "e" oder "e", das angibt, dass der Wert in exponentieller Notation (Scientific) dargestellt wird. Der- `s` Parameter kann eine Zahl in Exponentialnotation darstellen, wenn `style` das- <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Flag enthält.|  
|*exponentielle Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die einen Exponenten angeben.|  
  
> [!NOTE]
> Alle abschließenden NUL-Zeichen (U + 0000) in `s` werden vom Analyse-Vorgang unabhängig vom Wert des `style` Arguments ignoriert.

 Eine Zeichenfolge, die nur Ziffern (die dem Format entspricht) entspricht, <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> wird immer erfolgreich analysiert, wenn Sie sich im Bereich des <xref:System.Double> Typs befindet. Die übrigen Member <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> steuern Elemente, die in der Eingabe Zeichenfolge vorhanden sein können, aber nicht in der Eingabe Zeichenfolge vorhanden sein müssen. In der folgenden Tabelle wird angegeben <xref:System.Globalization.NumberStyles> , wie die einzelnen Flags die Elemente beeinflussen, die möglicherweise in vorhanden sind `s` .  
  
|NumberStyles-Wert|In zugelassene Elemente `s` zusätzlich zu Ziffern|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Nur das ganzzahlige *Ziffern* Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Die Dezimaltrennzeichen (*.*) und die Elemente der *Bruch Ziffern* .|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das Zeichen "e" oder "e", das die Exponentialschreibweise angibt. Dieses Flag allein unterstützt Werte in der Form *Ziffern*E*Ziffern*. zusätzliche Flags sind erforderlich, um Zeichen folgen mit solchen Elementen wie positive oder negative Vorzeichen und Dezimaltrennzeichen erfolgreich zu analysieren.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Das *WS* -Element am Anfang von `s` .|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Das *WS* -Element am Ende von `s` .|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Das *Sign* -Element am Anfang von `s` .|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Das *Sign* -Element am Ende von `s` .|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Das *Vorzeichen* Element in der Form von Klammern, das den numerischen Wert einschließt.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das Tausender Trennzeichen (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Currency ($)-Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle-Elemente. Es ist jedoch nicht möglich, `s` eine hexadezimale Zahl oder eine Zahl in Exponentialnotation darzustellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Das *WS* -Element am Anfang oder Ende von `s` *signiert* am Anfang von `s` und dem Dezimaltrennzeichen (.). Der- `s` Parameter kann auch die Exponentialnotation verwenden.|  
|<xref:System.Globalization.NumberStyles.Number>|Die `ws` `sign` Elemente,, Tausender Trennzeichen (,) und Dezimaltrennzeichen (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Alle-Elemente. `s`Eine hexadezimale Zahl kann jedoch nicht dargestellt werden.|  
  
 Der- `provider` Parameter ist eine- <xref:System.IFormatProvider> Implementierung, deren- <xref:System.IFormatProvider.GetFormat%2A> Methode ein <xref:System.Globalization.NumberFormatInfo> -Objekt zurückgibt, das kulturspezifische Informationen zum Interpretieren des Formats von bereitstellt `s` . Normalerweise handelt es sich um ein- <xref:System.Globalization.NumberFormatInfo> oder- <xref:System.Globalization.CultureInfo> Objekt. Wenn `provider` ist `null` oder <xref:System.Globalization.NumberFormatInfo> nicht abgerufen werden kann, werden die Formatierungsinformationen für die aktuelle System Kultur verwendet.  
  
 Wenn Sie der-Methode eine Zeichenfolge übergeben, die <xref:System.Double.Parse%2A?displayProperty=nameWithType> durch den Aufruf der-Methode erstellt wird <xref:System.Double.ToString%2A?displayProperty=nameWithType> , wird normalerweise der ursprüngliche <xref:System.Double> Wert zurückgegeben. Aufgrund eines Genauigkeits Verlusts sind die Werte jedoch möglicherweise nicht gleich. Außerdem kann bei dem Versuch, die Zeichen folgen Darstellung von oder zu analysieren, ein <xref:System.Double.MinValue?displayProperty=nameWithtype> <xref:System.Double.MaxValue?displayProperty=nameWithType> Roundtrip nicht durchführt werden. Auf .NET Framework und .net Core 2,2 und früheren Versionen wird eine ausgelöst <xref:System.OverflowException> . In .net Core 3,0 und höheren Versionen wird zurückgegeben, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> Wenn Sie versuchen, zu analysieren <xref:System.Double.MinValue?displayProperty=nameWithtype> oder <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> zu analysieren <xref:System.Double.MaxValue?displayProperty=nameWithtype> . Dies wird im folgenden Beispiel veranschaulicht.   
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs" interactive="try-dotnet-method" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb" id="Snippet3":::

Bei .NET Framework und .net Core 2,2 und früheren Versionen löst `s` die-Methode eine aus, wenn außerhalb des gültigen Bereichs des- <xref:System.Double> Datentyps liegt <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> <xref:System.OverflowException> .

Unter .net Core 3,0 und höheren Versionen wird keine Ausnahme ausgelöst, wenn `s` außerhalb des gültigen Bereichs des- <xref:System.Double> Datentyps liegt. In den meisten Fällen gibt die- <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> Methode <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder zurück <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> . Allerdings gibt es eine kleine Menge von Werten, die als näher an den maximalen oder minimalen Werten von <xref:System.Double> als positiv oder minus unendlich angesehen werden. In diesen Fällen gibt die Methode <xref:System.Double.MaxValue?displayProperty=nameWithType> oder zurück <xref:System.Double.MinValue?displayProperty=nameWithType> .

Wenn im-Parameter während eines Analyse Vorgangs ein Trennzeichen gefunden wird `s` und die entsprechende Währungs-oder Zahlen Dezimal-und Gruppen Trennzeichen identisch sind, geht der Analyse Vorgang davon aus, dass es sich bei dem Trennzeichen um ein Dezimaltrennzeichen und nicht um ein Gruppen Trennzeichen handelt. Weitere Informationen zu Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A> , <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A> , <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A> .  

## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die-Methode verwendet wird <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> , um einem-Objekt mehrere Zeichen folgen Darstellungen von Temperaturwerten zuzuweisen `Temperature` .  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse3.cs" interactive="try-dotnet" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse3.vb" id="Snippet2":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="s" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="s" /> stellt keinen numerischen Wert dar.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder - 
 <paramref name="style" /> ist der <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Wert.</exception>
        <exception cref="T:System.OverflowException">Nur .NET Framework und .NET Core 2.2 und frühere Versionen: <paramref name="s" /> stellt eine Zahl dar, die kleiner als <see cref="F:System.Double.MinValue" /> oder größer als <see cref="F:System.Double.MaxValue" /> ist.</exception>
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-numeric">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const double PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 PositiveInfinity = float64(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Double  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double PositiveInfinity = Infinity;" />
      <MemberSignature Language="F#" Value="val mutable PositiveInfinity : double" Usage="System.double.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>Stellt plus unendlich dar. Dieses Feld ist konstant.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Konstante ist das Ergebnis der Division einer positiven Zahl durch 0 (null).  
  
 Diese Konstante wird zurückgegeben, wenn das Ergebnis eines Vorgangs größer als ist <xref:System.Double.MaxValue?displayProperty=nameWithType> .  
  
 Verwenden <xref:System.Double.IsPositiveInfinity%2A> Sie, um zu bestimmen, ob ein Wert als positiv unendlich ausgewertet wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung von veranschaulicht <xref:System.Double.PositiveInfinity> :  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp" id="Snippet10":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs" interactive="try-dotnet-method" id="Snippet10":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb" id="Snippet10":::
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberSignature Language="F#" Value="abstract member System.IComparable.CompareTo : obj -&gt; int&#xA;override this.System.IComparable.CompareTo : obj -&gt; int" Usage="double.System.IComparable.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="value">Das zu vergleichende Objekt.</param>
        <summary>Vergleicht die aktuelle Instanz mit einem anderen Objekt vom selben Typ und gibt eine ganze Zahl zurück, die angibt, ob die aktuelle Instanz in der Sortierreihenfolge vor oder nach dem anderen Objekt oder an derselben Position auftritt.</summary>
        <returns>Ein Wert, der die relative Reihenfolge der verglichenen Objekte angibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IComparable>-Schnittstelle umgewandelt wird.

Der Rückgabewert hat folgende Bedeutung:

| Wert             | Bedeutung                                                                 |
|-------------------|-------------------------------------------------------------------------|
| Kleiner als 0 (null)    | Diese Instanz befindet sich in der Sortierreihenfolge vor `value`.                       |
| Zero              | Diese Instanz tritt in der Sortierreihenfolge an der gleichen Position wie `value` auf. |
| Größer als 0 (null) | Diese Instanz folgt in der Sortierreihenfolge auf `value`.                        |

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.GetTypeCode : unit -&gt; TypeCode&#xA;override this.System.IConvertible.GetTypeCode : unit -&gt; TypeCode" Usage="double.System.IConvertible.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den <see cref="T:System.TypeCode" /> für diese Instanz zurück.</summary>
        <returns>Die Enumerationskonstante, die den <see cref="T:System.TypeCode" /> des Klassen- oder Werttyps darstellt, der diese Schnittstelle implementiert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToBoolean : IFormatProvider -&gt; bool&#xA;override this.System.IConvertible.ToBoolean : IFormatProvider -&gt; bool" Usage="double.System.IConvertible.ToBoolean provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns><see langword="true" />, wenn der Wert der aktuellen Instanz nicht 0 (null) ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die-Methode aufzurufen <xref:System.Convert.ToBoolean%28System.Double%29?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToByte : IFormatProvider -&gt; byte&#xA;override this.System.IConvertible.ToByte : IFormatProvider -&gt; byte" Usage="double.System.IConvertible.ToByte provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Byte" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die-Methode aufzurufen <xref:System.Convert.ToByte%28System.Double%29?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToChar : IFormatProvider -&gt; char&#xA;override this.System.IConvertible.ToChar : IFormatProvider -&gt; char" Usage="double.System.IConvertible.ToChar provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Diese Konvertierung wird nicht unterstützt. Bei dem Versuch der Verwendung dieser Methode wird eine <see cref="T:System.InvalidCastException" /> ausgelöst.</summary>
        <returns>Diese Konvertierung wird nicht unterstützt. Es wird kein Wert zurückgegeben.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In allen Fällen.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDateTime : IFormatProvider -&gt; DateTime&#xA;override this.System.IConvertible.ToDateTime : IFormatProvider -&gt; DateTime" Usage="double.System.IConvertible.ToDateTime provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Diese Konvertierung wird nicht unterstützt. Bei dem Versuch der Verwendung dieser Methode wird eine <see cref="T:System.InvalidCastException" /> ausgelöst.</summary>
        <returns>Diese Konvertierung wird nicht unterstützt. Es wird kein Wert zurückgegeben.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">In allen Fällen.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDecimal : IFormatProvider -&gt; decimal&#xA;override this.System.IConvertible.ToDecimal : IFormatProvider -&gt; decimal" Usage="double.System.IConvertible.ToDecimal provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Decimal" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die-Methode aufzurufen <xref:System.Convert.ToDecimal%28System.Double%29?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToDouble : IFormatProvider -&gt; double&#xA;override this.System.IConvertible.ToDouble : IFormatProvider -&gt; double" Usage="double.System.IConvertible.ToDouble provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Der unveränderte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt16 : IFormatProvider -&gt; int16&#xA;override this.System.IConvertible.ToInt16 : IFormatProvider -&gt; int16" Usage="double.System.IConvertible.ToInt16 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int16" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die-Methode aufzurufen <xref:System.Convert.ToInt16%28System.Double%29?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt32 : IFormatProvider -&gt; int&#xA;override this.System.IConvertible.ToInt32 : IFormatProvider -&gt; int" Usage="double.System.IConvertible.ToInt32 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int32" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die-Methode aufzurufen <xref:System.Convert.ToInt32%28System.Double%29?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToInt64 : IFormatProvider -&gt; int64&#xA;override this.System.IConvertible.ToInt64 : IFormatProvider -&gt; int64" Usage="double.System.IConvertible.ToInt64 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Int64" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die-Methode aufzurufen <xref:System.Convert.ToInt64%28System.Double%29?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToSByte : IFormatProvider -&gt; sbyte&#xA;override this.System.IConvertible.ToSByte : IFormatProvider -&gt; sbyte" Usage="double.System.IConvertible.ToSByte provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.SByte" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die-Methode aufzurufen <xref:System.Convert.ToSByte%28System.Double%29?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToSingle : IFormatProvider -&gt; single&#xA;override this.System.IConvertible.ToSingle : IFormatProvider -&gt; single" Usage="double.System.IConvertible.ToSingle provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.Single" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die-Methode aufzurufen <xref:System.Convert.ToSingle%28System.Double%29?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToType (type As Type, provider As IFormatProvider) As Object Implements IConvertible.ToType" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToType : Type * IFormatProvider -&gt; obj&#xA;override this.System.IConvertible.ToType : Type * IFormatProvider -&gt; obj" Usage="double.System.IConvertible.ToType (type, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, in den dieser <see cref="T:System.Double" />-Wert konvertiert werden soll.</param>
        <param name="provider">Eine <see cref="T:System.IFormatProvider" />-Implementierung, die kulturspezifische Informationen zum Format des zurückgegebenen Werts bereitstellt.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Der in <paramref name="type" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die `static` - `Shared` Methode (in Visual Basic) aufzurufen <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt16 : IFormatProvider -&gt; uint16&#xA;override this.System.IConvertible.ToUInt16 : IFormatProvider -&gt; uint16" Usage="double.System.IConvertible.ToUInt16 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt16" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die-Methode aufzurufen <xref:System.Convert.ToUInt16%28System.Double%29?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt32 : IFormatProvider -&gt; uint32&#xA;override this.System.IConvertible.ToUInt32 : IFormatProvider -&gt; uint32" Usage="double.System.IConvertible.ToUInt32 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt32" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die-Methode aufzurufen <xref:System.Convert.ToUInt32%28System.Double%29?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberSignature Language="F#" Value="abstract member System.IConvertible.ToUInt64 : IFormatProvider -&gt; uint64&#xA;override this.System.IConvertible.ToUInt64 : IFormatProvider -&gt; uint64" Usage="double.System.IConvertible.ToUInt64 provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="provider">Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Eine Beschreibung dieses Elements finden Sie unter <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Der in ein <see cref="T:System.UInt64" /> konvertierte Wert der aktuellen Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Er kann nur verwendet werden, wenn die <xref:System.Double>-Instanz in eine <xref:System.IConvertible>-Schnittstelle umgewandelt wird. Die empfohlene Alternative besteht darin, die-Methode aufzurufen <xref:System.Convert.ToUInt64%28System.Double%29?displayProperty=nameWithType> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert den Wert dieser Instanz in die entsprechende Zeichenfolgendarstellung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="double.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert den Wert dieser Instanz in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Double.ToString> Methode formatiert einen <xref:System.Double> Wert im Standardformat ("G" oder allgemein) der aktuellen Kultur. Wenn Sie ein anderes Format, eine andere Genauigkeit oder Kultur angeben möchten, verwenden Sie die anderen über Ladungen der- <xref:System.Double.ToString%2A> Methode wie folgt:  
  
|So verwenden Sie das Format|Für Kultur|Verwenden der Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Ein bestimmtes Format oder eine bestimmte Genauigkeit|Standard Kultur (aktuell)|<xref:System.Double.ToString%28System.String%29>|  
|Ein bestimmtes Format oder eine bestimmte Genauigkeit|Eine bestimmte Kultur|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der Rückgabewert kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> , <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> , <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> oder eine Zeichenfolge der folgenden Form sein:  
  
 [Sign] ganzzahlige Ziffern [. [ Bruch Ziffern]] [E [Sign] exponentialziffern]  
  
 Optionale Elemente werden in eckige Klammern ([und]) eingeschlossen. Elemente, die den Begriff "Ziffern" enthalten, bestehen aus einer Reihe von numerischen Zeichen zwischen 0 und 9. Die in der folgenden Tabelle aufgeführten Elemente werden unterstützt.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*sign*|Ein negatives Vorzeichen-oder positives Vorzeichen Symbol.|  
|*ganzzahlige Ziffern*|Eine Reihe von Ziffern, die den ganzzahligen Teil der Zahl angibt. Ganzzahlige Ziffern können nicht vorhanden sein, wenn es sich um Bruch Ziffern handelt.|  
|'*.*'|Ein kulturspezifisches Dezimaltrennzeichen.|  
|*Bruch Ziffern*|Eine Reihe von Ziffern, die den Bruch Teil der Zahl angibt.|  
|"*E*"|Ein Großbuchstabe "E", der die exponentielle (wissenschaftliche) Notation angibt.|  
|*exponentielle Ziffern*|Eine Reihe von Ziffern, die einen Exponenten angeben.|  
  
 Einige Beispiele für den Rückgabewert sind "100", "-123.456.789", "123,45 e + 6", "500", "3,1416", "600", "-0,123" und "-Infinity".  
  
 Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Formatierungs Themen ausführlicher beschrieben wird:  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard mäßige Zahlenformat](/dotnet/standard/base-types/standard-numeric-format-strings) Zeichenfolgen und [benutzerdefinierte Zahlenformat](/dotnet/standard/base-types/custom-numeric-format-strings)Zeichenfolgen.  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatieren von Typen](/dotnet/standard/base-types/formatting-types).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die-Standard <xref:System.Double.ToString?displayProperty=nameWithType> Methode verwendet, um die Zeichen folgen Darstellungen einer Reihe von <xref:System.Double> Werten anzuzeigen.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs" interactive="try-dotnet-method" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb" id="Snippet1":::
  
 Im folgenden Beispiel wird die Verwendung von veranschaulicht <xref:System.Double.ToString%2A> .  
  
 [!code-cpp[System.Double#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#3)]
 [!code-csharp[System.Double#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#3)]
 [!code-vb[System.Double#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">Formatieren von Typen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="double.ToString provider" />
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider? provider);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" FrameworkAlternate="netstandard-1.0;netstandard-1.1;netstandard-1.2" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz unter Berücksichtigung der angegebenen kulturabhängigen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Double.ToString%28System.IFormatProvider%29> Methode formatiert einen <xref:System.Double> Wert im Standardformat ("G" oder allgemein) einer angegebenen Kultur. Wenn Sie ein anderes Format oder eine andere Kultur angeben möchten, verwenden Sie die anderen über Ladungen der- <xref:System.Double.ToString%2A> Methode wie folgt:  
  
|So verwenden Sie das Format|Für Kultur|Verwenden der Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Standard (aktuell)|<xref:System.Double.ToString>|  
|Ein bestimmtes Format oder eine bestimmte Genauigkeit|Standard Kultur (aktuell)|<xref:System.Double.ToString%28System.String%29>|  
|Ein bestimmtes Format oder eine bestimmte Genauigkeit|Eine bestimmte Kultur|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der Rückgabewert kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> , <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> , <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> oder eine Zeichenfolge der folgenden Form sein:  
  
 [Sign] ganzzahlige Ziffern [. [ Bruch Ziffern]] [E [Sign] exponentialziffern]  
  
 Optionale Elemente werden in eckige Klammern ([und]) eingeschlossen. Elemente, die den Begriff "Ziffern" enthalten, bestehen aus einer Reihe von numerischen Zeichen zwischen 0 und 9. Die in der folgenden Tabelle aufgeführten Elemente werden unterstützt.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*sign*|Ein negatives Vorzeichen-oder positives Vorzeichen Symbol.|  
|*ganzzahlige Ziffern*|Eine Reihe von Ziffern, die den ganzzahligen Teil der Zahl angibt. Ganzzahlige Ziffern können nicht vorhanden sein, wenn es sich um Bruch Ziffern handelt.|  
|'*.*'|Ein kulturspezifisches Dezimaltrennzeichen.|  
|*Bruch Ziffern*|Eine Reihe von Ziffern, die den Bruch Teil der Zahl angibt.|  
|"*E*"|Ein Großbuchstabe "E", der die exponentielle (wissenschaftliche) Notation angibt.|  
|*exponentielle Ziffern*|Eine Reihe von Ziffern, die einen Exponenten angeben.|  
  
 Einige Beispiele für den Rückgabewert sind "100", "-123.456.789", "123,45 e + 6", "500", "3,1416", "600", "-0,123" und "-Infinity".  
  
 Diese Instanz ist mit dem allgemeinen numerischen Format Bezeichner ("G") formatiert.  
  
 Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Formatierungs Themen ausführlicher beschrieben wird:  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard mäßige Zahlenformat](/dotnet/standard/base-types/standard-numeric-format-strings) Zeichenfolgen und [benutzerdefinierte Zahlenformat](/dotnet/standard/base-types/custom-numeric-format-strings)Zeichenfolgen.  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatieren von Typen](/dotnet/standard/base-types/formatting-types).  
  
 Der- `provider` Parameter ist eine <xref:System.IFormatProvider> Implementierung, deren- <xref:System.IFormatProvider.GetFormat%2A> Methode ein-Objekt zurückgibt <xref:System.Globalization.NumberFormatInfo> . In der Regel `provider` ist ein- <xref:System.Globalization.CultureInfo> Objekt oder ein- <xref:System.Globalization.NumberFormatInfo> Objekt. Der- `provider` Parameter liefert kulturspezifische Informationen, die bei der Formatierung verwendet werden. Wenn `provider` `null` den Wert hat, wird der Rückgabewert mit dem- <xref:System.Globalization.NumberFormatInfo> Objekt für die aktuelle Kultur formatiert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Zeichen folgen Darstellung von zwei <xref:System.Double> Werten mithilfe von-Objekten angezeigt, die <xref:System.Globalization.CultureInfo> verschiedene Kulturen darstellen.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb" id="Snippet2":::  
  
 Das folgende Beispiel veranschaulicht die Verwendung von <xref:System.Double.ToString%2A> , wobei ein <xref:System.String> und ein <xref:System.IFormatProvider> als Parameter verwendet werden.  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">Formatieren von Typen in .NET</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="double.ToString format" />
      <MemberSignature Language="C#" Value="public string ToString (string? format);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Eine numerische Formatierungszeichenfolge.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz in die entsprechende Zeichenfolgendarstellung unter Berücksichtigung des angegebenen Formats.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Double.ToString%28System.String%29> Methode formatiert einen <xref:System.Double> Wert in einem angegebenen Format unter Verwendung der Konventionen der aktuellen Kultur. Wenn Sie ein anderes Format oder eine andere Kultur angeben möchten, verwenden Sie die anderen über Ladungen der- <xref:System.Double.ToString%2A> Methode wie folgt:  
  
|So verwenden Sie das Format|Für Kultur|Verwenden der Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Standard Kultur (aktuell)|<xref:System.Double.ToString>|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Ein bestimmtes Format oder eine bestimmte Genauigkeit|Eine bestimmte Kultur|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der Rückgabewert kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> , <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> , <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> oder die Zeichen folgen Darstellung einer Zahl sein, wie von angegeben `format` .  
  
 Der `format` -Parameter kann ein beliebiger gültiger numerischer Standardformat Bezeichner mit Ausnahme von D und X sowie eine beliebige Kombination von benutzerdefinierten numerischen Format Bezeichnern sein. Wenn `format` `null` oder eine leere Zeichenfolge ist, wird der Rückgabewert mit dem allgemeinen numerischen Format Bezeichner ("G") formatiert.  
  
 Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Formatierungs Themen ausführlicher beschrieben wird:  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard mäßige Zahlenformat](/dotnet/standard/base-types/standard-numeric-format-strings) Zeichenfolgen und [benutzerdefinierte Zahlenformat](/dotnet/standard/base-types/custom-numeric-format-strings)Zeichenfolgen.  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatieren von Typen](/dotnet/standard/base-types/formatting-types).  
  
 Standardmäßig enthält der Rückgabewert nur 15 Dezimalstellen, obwohl intern ein Maximum von 17 Ziffern beibehalten wird. Wenn der Wert dieser Instanz größer als 15 Ziffern ist, wird <xref:System.Double.ToString%2A> <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> oder <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> anstelle der erwarteten Zahl zurückgegeben. Wenn Sie mehr Genauigkeit benötigen, geben Sie `format` mit der Format Spezifikation "G17" an, die immer 17 Ziffern der Genauigkeit zurückgibt, oder "R", die 15 Ziffern zurückgibt, wenn die Zahl mit dieser Genauigkeit oder 17 Ziffern dargestellt werden kann, wenn die Zahl nur mit maximaler Genauigkeit dargestellt werden kann.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein numerischer Wert definiert und als Währungswert formatiert, indem die standardmäßige numerische Format Zeichenfolge "C" und ein numerischer Wert für drei Dezimalstellen mit der standardmäßigen numerischen Format Zeichenfolge "N" verwendet wird. Die Ergebnis Zeichenfolgen werden anhand der Konventionen der Kultur "en-US" formatiert. Weitere Informationen zu numerischen Format Zeichenfolgen finden Sie unter [Standard mäßige Zahlenformat](/dotnet/standard/base-types/standard-numeric-format-strings) Zeichenfolgen und [benutzerdefinierte Zahlenformat](/dotnet/standard/base-types/custom-numeric-format-strings)Zeichenfolgen.  
  
 [!code-csharp[System.Double.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString7.cs#7)]
 [!code-vb[System.Double.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString7.vb#7)]  
  
 Im folgenden Beispiel werden mehrere <xref:System.Double> Werte mit den unterstützten numerischen Standardformat Bezeichnerzeichen und drei benutzerdefinierten numerischen Format Zeichenfolgen angezeigt. Eine dieser benutzerdefinierten Format Zeichenfolgen veranschaulicht, wie ein <xref:System.Single> Wert mit führenden Nullen aufgefüllt wird. Außerdem verwendet das Beispiel genauigkeitsspezifizierer mit jedem Standardformat Bezeichner mit Ausnahme von "R". Die Werte der genauigkeitsspezifizierer liegen zwischen 0 und 3. Zum Konvertieren der numerischen Werte in Zeichen folgen verwendet das Beispiel die Formatierungs Konventionen der Kultur "en-US".  
  
 [!code-cpp[System.Double.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Double.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Double.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist ungültig.</exception>
        <block subset="none" type="usage"><para>In einigen Fällen werden <see cref="T:System.Double" />-Werte, die mit der Standardformatzeichenfolge für Zahlen "R" formatiert sind, nicht erfolgreich zurückkonvertiert, wenn sie mit dem <see langword="/platform:x64" />- oder dem <see langword="/platform:anycpu" />-Parameter kompiliert wurden und auf 64-Bit-Systemen ausgeführt werden. Um dieses Problem zu umgehen, formatieren Sie <see cref="T:System.Double" />-Werte mit der Standardformatzeichenfolge für Zahlen "G17". Im folgenden Beispiel wird die Formatzeichenfolge "R" mit einem <see cref="T:System.Double" />-Wert verwendet, der nicht erfolgreich zurückkonvertiert wird, und es wird die Formatzeichenfolge "G17" verwendet, um erfolgreich in den ursprünglichen Wert zurückzukonvertieren.  
  
::: Code language = "CSharp" Source = "~/Samples/Snippets/CSharp/VS_Snippets_CLR_System/System. Double. ToString/CS/roundtripex2. cs "Interactive =" try-dotnet "ID =" Snippet6 ":::::: Code language =" vb "Source =" ~/Samples/Snippets/VisualBasic/VS_Snippets_CLR_System/System. Double. ToString/VB/roundtripex2. vb "ID =" Snippet6 ":::</para></block>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">Formatieren von Typen in .NET</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="/dotnet/standard/base-types/how-to-pad-a-number-with-leading-zeros">Gewusst wie: Auffüllen einer Zahl mit führenden Nullen</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="double.ToString (format, provider)" />
      <MemberSignature Language="C#" Value="public string? ToString (string format, IFormatProvider provider);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Eine numerische Formatierungszeichenfolge.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert dieser Instanz unter Verwendung des angegebenen Formats und der angegebenen kulturabhängigen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des Werts dieser Instanz entsprechend den Angaben von <paramref name="format" /> und <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29> Methode formatiert einen <xref:System.Double> Wert in einem angegebenen Format einer angegebenen Kultur. Wenn Sie ein anderes Format oder eine andere Kultur angeben möchten, verwenden Sie die anderen über Ladungen der- <xref:System.Double.ToString%2A> Methode wie folgt:  
  
|So verwenden Sie das Format|Für Kultur|Verwenden der Überladung|  
|-------------------|-----------------|----------------------|  
|Standardformat ("G")|Standard Kultur (aktuell)|<xref:System.Double.ToString>|  
|Standardformat ("G")|Eine bestimmte Kultur|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Ein bestimmtes Format oder eine bestimmte Genauigkeit|Standard Kultur (aktuell)|<xref:System.Double.ToString%28System.String%29>|  
  
 Der Rückgabewert kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> , <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> , <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> oder die Zeichen folgen Darstellung einer Zahl sein, wie von angegeben `format` .  
  
 Der `format` -Parameter kann ein beliebiger gültiger numerischer Standardformat Bezeichner mit Ausnahme von D und X sowie eine beliebige Kombination von benutzerdefinierten numerischen Format Bezeichnern sein. Wenn `format` `null` oder eine leere Zeichenfolge ist, wird der Rückgabewert für diese Instanz mit dem allgemeinen numerischen Format Bezeichner ("G") formatiert.  
  
 Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Formatierungs Themen ausführlicher beschrieben wird:  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard mäßige Zahlenformat](/dotnet/standard/base-types/standard-numeric-format-strings) Zeichenfolgen und [benutzerdefinierte Zahlenformat](/dotnet/standard/base-types/custom-numeric-format-strings)Zeichenfolgen.  
  
-   Weitere Informationen zur Formatierung finden Sie unter [Formatieren von Typen](/dotnet/standard/base-types/formatting-types).  
  
 Der- `provider` Parameter ist eine <xref:System.IFormatProvider> Implementierung, deren- <xref:System.IFormatProvider.GetFormat%2A> Methode ein-Objekt zurückgibt <xref:System.Globalization.NumberFormatInfo> . In der Regel `provider` ist ein- <xref:System.Globalization.CultureInfo> Objekt oder ein- <xref:System.Globalization.NumberFormatInfo> Objekt. Der- `provider` Parameter liefert kulturspezifische Informationen, die bei der Formatierung verwendet werden. Wenn `provider` `null` den Wert hat, wird der Rückgabewert mit dem- <xref:System.Globalization.NumberFormatInfo> Objekt für die aktuelle Kultur formatiert.  
  
 Standardmäßig enthält der Rückgabewert nur 15 Dezimalstellen, obwohl intern ein Maximum von 17 Ziffern beibehalten wird. Wenn der Wert dieser Instanz größer als 15 Ziffern ist, wird <xref:System.Double.ToString%2A> <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> oder <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> anstelle der erwarteten Zahl zurückgegeben. Wenn Sie mehr Genauigkeit benötigen, geben Sie `format` mit der Format Spezifikation "G17" an, die immer 17 Ziffern der Genauigkeit zurückgibt, oder "R", die 15 Ziffern zurückgibt, wenn die Zahl mit dieser Genauigkeit oder 17 Ziffern dargestellt werden kann, wenn die Zahl nur mit maximaler Genauigkeit dargestellt werden kann.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.Double> Wert mit jedem der unterstützten numerischen Standardformat Bearbeiter für verschiedene Kulturen angezeigt.  
  
 :::code language="cpp" source="~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring1.cpp" id="Snippet4":::
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs" interactive="try-dotnet-method" id="Snippet4":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb" id="Snippet4":::
  
 Das folgende Beispiel veranschaulicht die Verwendung von <xref:System.Double.ToString%2A> , wobei ein <xref:System.String> und ein <xref:System.IFormatProvider> als Parameter verwendet werden.  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>In einigen Fällen werden <see cref="T:System.Double" />-Werte, die mit der Standardformatzeichenfolge für Zahlen "R" formatiert sind, nicht erfolgreich zurückkonvertiert, wenn sie mit dem <see langword="/platform:x64" />- oder dem <see langword="/platform:anycpu" />-Parameter kompiliert wurden und auf 64-Bit-Systemen ausgeführt werden. Um dieses Problem zu umgehen, formatieren Sie <see cref="T:System.Double" />-Werte mit der Standardformatzeichenfolge für Zahlen "G17". Im folgenden Beispiel wird die Formatzeichenfolge "R" mit einem <see cref="T:System.Double" />-Wert verwendet, der nicht erfolgreich zurückkonvertiert wird, und es wird die Formatzeichenfolge "G17" verwendet, um erfolgreich in den ursprünglichen Wert zurückzukonvertieren.  
  
::: Code language = "CSharp" Source = "~/Samples/Snippets/CSharp/VS_Snippets_CLR_System/System. Double. ToString/CS/roundtripex1. cs "Interactive =" try-dotnet "ID =" Snippet5 ":::::: Code language =" vb "Source =" ~/Samples/Snippets/VisualBasic/VS_Snippets_CLR_System/System. Double. ToString/VB/roundtripex1. vb "ID =" Snippet5 ":::</para></block>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <related type="Article" href="/dotnet/standard/base-types/formatting-types">Formatieren von Typen in .NET</related>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
        <related type="Article" href="/dotnet/standard/base-types/how-to-pad-a-number-with-leading-zeros">Gewusst wie: Auffüllen einer Zahl mit führenden Nullen</related>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/windowsforms-formatting-utility-cs/">Beispiel: .NET Core-Hilfsprogramm zur Formatierung von WinForms (C#)</related>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/windowsforms-formatting-utility-vb/">Beispiel: .NET Core-Hilfsprogramm zur Formatierung von WinForms (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default, IFormatProvider? provider = default);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = Nothing, Optional provider As IFormatProvider = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="double.TryFormat (destination, charsWritten, format, provider)" />
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default, IFormatProvider provider = default);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination">Wenn diese Methode zurückgegeben wird, wird der Wert dieser Instanz als Zeichenspanne formatiert.</param>
        <param name="charsWritten">Nach Ausführung dieser Methode die Anzahl der in <paramref name="destination" /> geschriebenen Zeichen.</param>
        <param name="format">Eine Zeichenspanne, die eine standardmäßige oder benutzerdefinierte Formatzeichenfolge darstellt, die das akzeptable Format für <paramref name="destination" /> definiert.</param>
        <param name="provider">Ein optionales Objekt, das kulturspezifische Formatierungsinformationen für <paramref name="destination" /> bereitstellt.</param>
        <summary>Versucht, den Wert der aktuellen Doppelinstanz in die angegebene Zeichenspanne zu formatieren.</summary>
        <returns><see langword="true" />, wenn die Formatierung erfolgreich war, andernfalls <see langword="false" /></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in die entsprechende Gleitkommazahl mit doppelter Genauigkeit. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <remarks>In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <see cref="F:System.Double.PositiveInfinity" /> oder entsprechend <see cref="F:System.Double.NegativeInfinity" /> der IEEE 754-Spezifikation gerundet. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.</remarks>
        <altmember cref="Overload:System.Double.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * double -&gt; bool" Usage="System.double.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.Double" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenspanne, die die Zeichenfolgendarstellung der zu konvertierenden Zahl enthält.</param>
        <param name="result">Diese Methode gibt bei erfolgreicher Konvertierung die Gleitkommazahl mit doppelter Genauigkeit zurück, die dem numerischen Wert oder dem im <paramref name="s" />-Parameter enthaltenen Symbol entspricht, oder 0 (null), wenn die Konvertierung fehlgeschlagen ist. Die Konvertierung schlägt fehl, wenn der <paramref name="s" />-Parameter gleich <see langword="null" /> oder leer ist oder nicht in einem Format vorliegt, das mit <paramref name="style" /> kompatibel ist. Die Konvertierung schlägt auch fehl, wenn <paramref name="style" /> keine gültige Kombination von enumerierten <see cref="T:System.Globalization.NumberStyles" />-Konstanten ist. Wenn <paramref name="s" /> eine gültige Zahl kleiner als <see cref="F:System.Double.MinValue" /> ist, ist <paramref name="result" /> gleich <see cref="F:System.Double.NegativeInfinity" />. Wenn <paramref name="s" /> eine gültige Zahl größer als <see cref="F:System.Double.MaxValue" /> ist, ist <paramref name="result" /> gleich <see cref="F:System.Double.PositiveInfinity" />. Dieser Parameter wird nicht initialisiert übergeben. Jeder Wert, der ursprünglich im bereitgestellten <paramref name="result" /> überschrieben werden.</param>
        <summary>Konvertiert die Spannendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende Gleitkommazahl mit doppelter Genauigkeit. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns><see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <see cref="F:System.Double.PositiveInfinity" /> oder entsprechend <see cref="F:System.Double.NegativeInfinity" /> der IEEE 754-Spezifikation gerundet. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * double -&gt; bool" Usage="System.double.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="result" Type="System.Double" RefType="out" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die die zu konvertierende Zahl enthält.</param>
        <param name="result">Wenn diese Methode zurückgegeben wird, enthält sie bei erfolgreicher Konvertierung eine Gleitkommazahl mit doppelter Genauigkeit, die dem <paramref name="s" />-Parameter entspricht, oder 0 (null), wenn die Konvertierung fehlgeschlagen ist. Die Konvertierung schlägt fehl, wenn der <paramref name="s" />-Parameter <see langword="null" />, <see cref="F:System.String.Empty" /> oder keine Zahl im gültigen Format ist. Außerdem schlägt sie in .NET Framework und .NET Core 2.2 und früheren Versionen fehl, wenn <paramref name="s" /> eine Zahl kleiner als <see cref="F:System.Double.MinValue" /> oder größer als <see cref="F:System.Double.MaxValue" /> darstellt. Dieser Parameter wird nicht initialisiert übergeben. Jeder Wert, der ursprünglich im bereitgestellten <paramref name="result" /> überschrieben werden.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in die entsprechende Gleitkommazahl mit doppelter Genauigkeit. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns><see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <xref:System.Double.PositiveInfinity> oder entsprechend <xref:System.Double.NegativeInfinity> der IEEE 754-Spezifikation gerundet. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.

 Diese Überladung unterscheidet sich von der- <xref:System.Double.Parse%28System.String%29?displayProperty=nameWithType> Methode, indem ein boolescher Wert zurückgegeben wird, der angibt, ob der Analyse Vorgang erfolgreich war, anstatt den analysierten numerischen Wert zurückzugeben. Es entfällt, dass die Ausnahmebehandlung verwendet werden muss, um ein <xref:System.FormatException> im Ereignis zu testen, das `s` ungültig ist und nicht erfolgreich analysiert werden kann.  
  
 Der `s` -Parameter kann die aktuelle Kultur <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType> , <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType> , <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> (der Zeichen folgen Vergleich unter Beachtung der Groß-/Kleinschreibung) oder eine Zeichenfolge in der Form enthalten:  
  
 Gefangener Gebärden [integrale Ziffern,] ganzzahlige Ziffern [. [ Bruch Ziffern]] [e [Sign] exponentialziffern] [WS]  
  
 Elemente in eckigen Klammern sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Eine Reihe von Leerzeichen.|  
|*sign*|Ein negatives Vorzeichen-oder positives Vorzeichen Symbol.|  
|*ganzzahlige Ziffern*|Eine Reihe von numerischen Zeichen im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Ganzzahlige Ziffern können nicht vorhanden sein, wenn es sich um Bruch Ziffern handelt.|  
|*,*|Ein kulturspezifisches Gruppen Trennzeichen.|  
|*.*|Ein kulturspezifisches Dezimaltrennzeichen.|  
|*Bruch Ziffern*|Eine Reihe von numerischen Zeichen im Bereich von 0 bis 9, die den Bruchteil der Zahl angeben.|  
|*E*|Ein Großbuchstabe oder ein Kleinbuchstabe "e", der die exponentielle (wissenschaftliche) Notation angibt.|  
|*exponentielle Ziffern*|Eine Reihe von numerischen Zeichen im Bereich von 0 bis 9, die einen Exponenten angeben.|  
  
 Weitere Informationen zu numerischen Formaten finden Sie unter [Formatieren von Typen](/dotnet/standard/base-types/formatting-types).  
  
 Der `s` -Parameter wird mit einer Kombination der <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> -und- <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flags interpretiert. Dies bedeutet, dass Leerzeichen und Tausender Trennzeichen zulässig sind, aber Währungssymbole nicht. `s`Verwenden Sie die-Methoden Überladung, um die Elemente explizit zu definieren (z. b. Währungssymbole, Tausende Trennzeichen und Leerzeichen), die in vorhanden sein können <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> .  
  
 Der- `s` Parameter wird mithilfe der Formatierungsinformationen in einem- <xref:System.Globalization.NumberFormatInfo> Objekt analysiert, das für die aktuelle System Kultur initialisiert wird. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Verwenden Sie die-Methoden Überladung, um eine Zeichenfolge mit den Formatierungsinformationen einer anderen angegebenen Kultur zu analysieren <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> .  
  
 Wenn Sie der-Methode eine Zeichenfolge übergeben, die <xref:System.Double.TryParse%2A?displayProperty=nameWithType> durch den Aufruf der-Methode erstellt wird <xref:System.Double.ToString%2A?displayProperty=nameWithType> , wird normalerweise der ursprüngliche <xref:System.Double> Wert zurückgegeben. Aufgrund eines Genauigkeits Verlusts sind die Werte jedoch möglicherweise nicht gleich. Außerdem kann bei dem Versuch, die Zeichen folgen Darstellung von oder zu analysieren, ein <xref:System.Double.MinValue?displayProperty=nameWithType> <xref:System.Double.MaxValue?displayProperty=nameWithType> Roundtrip nicht durchführt werden. Auf .NET Framework und .net Core 2,2 und früheren Versionen wird eine ausgelöst <xref:System.OverflowException> . In .net Core 3,0 und höheren Versionen wird zurückgegeben, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> Wenn Sie versuchen, zu analysieren <xref:System.Double.MinValue?displayProperty=nameWithtype> oder <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> zu analysieren <xref:System.Double.MaxValue?displayProperty=nameWithtype> . Dies wird im folgenden Beispiel veranschaulicht. 
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb" id="Snippet3":::

Bei .NET Framework und .net Core 2,2 und früheren Versionen löst `s` die-Methode eine aus, wenn außerhalb des gültigen Bereichs des- <xref:System.Double> Datentyps liegt <xref:System.Double.TryParse%28System.String%2CSystem.Double%40%29> <xref:System.OverflowException> .

Unter .net Core 3,0 und höheren Versionen wird keine Ausnahme ausgelöst, wenn `s` außerhalb des gültigen Bereichs des- <xref:System.Double> Datentyps liegt. In den meisten Fällen berechnet die- <xref:System.Double.TryParse%28System.String%2CSystem.Double%40%29> Methode das Ergebnis von <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> . Allerdings gibt es eine kleine Menge von Werten, die als näher an den maximalen oder minimalen Werten von <xref:System.Double> als positiv oder minus unendlich angesehen werden. In diesen Fällen berechnet die-Methode das Ergebnis von <xref:System.Double.MaxValue?displayProperty=nameWithType> oder <xref:System.Double.MinValue?displayProperty=nameWithType> .

Wenn im-Parameter während eines Analyse Vorgangs ein Trennzeichen gefunden wird `s` und die Dezimal-und Gruppen Trennzeichen identisch sind, geht der Analyse Vorgang davon aus, dass das Trennzeichen anstelle eines Gruppen Trennzeichens ein Dezimaltrennzeichen ist. Weitere Informationen zu Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A> , <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A> , <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A> .  
  
## Examples  
 Im folgenden Beispiel wird die- <xref:System.Double.TryParse%28System.String%2CSystem.Double%40%29> Methode verwendet, um die Zeichen folgen Darstellungen numerischer Werte in-Werte zu konvertieren <xref:System.Double> . Dabei wird davon ausgegangen, dass "en-US" die aktuelle Kultur ist.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse1a.cs" interactive="try-dotnet" id="Snippet1":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse1a.vb" id="Snippet1":::
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-numeric">Analysieren numerischer Zeichenfolgen in .NET</related>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/windowsforms-formatting-utility-cs/">Beispiel: .NET Core-Hilfsprogramm zur Formatierung von WinForms (C#)</related>
        <related type="ExternalDocumentation" href="https://docs.microsoft.com/samples/dotnet/samples/windowsforms-formatting-utility-vb/">Beispiel: .NET Core-Hilfsprogramm zur Formatierung von WinForms (Visual Basic)</related>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider? provider, out double result);" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider * double -&gt; bool" Usage="System.double.TryParse (s, style, provider, result)" />
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" FrameworkAlternate="netcore-2.1;netcore-2.2;netstandard-2.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.Double" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="s">Eine schreibgeschützte Zeichenspanne, die die zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination von <see cref="T:System.Globalization.NumberStyles" />-Werten, die das zulässige Format von <paramref name="s" /> angibt. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="s" /> bereitstellt.</param>
        <param name="result">Diese Methode gibt bei erfolgreicher Konvertierung eine Gleitkommazahl mit doppelter Genauigkeit zurück, die dem numerischen Wert oder dem im <paramref name="s" />-Parameter enthaltenen Symbol entspricht, oder 0 (null), wenn die Konvertierung fehlgeschlagen ist. Die Konvertierung schlägt fehl, wenn der Parameter <paramref name="s" /><see langword="null" /> oder eine leere Zeichenspanne ist oder nicht in einem Format vorliegt, das mit <paramref name="style" /> kompatibel ist. Wenn <paramref name="s" /> eine gültige Zahl kleiner als <see cref="F:System.Double.MinValue" /> ist, ist <paramref name="result" /> gleich <see cref="F:System.Double.NegativeInfinity" />. Wenn <paramref name="s" /> eine gültige Zahl größer als <see cref="F:System.Double.MaxValue" /> ist, ist <paramref name="result" /> gleich <see cref="F:System.Double.PositiveInfinity" />. Dieser Parameter wird nicht initialisiert übergeben. Jeder Wert, der ursprünglich im bereitgestellten <paramref name="result" /> überschrieben werden.</param>
        <summary>Konvertiert eine Zeichenspanne mit der Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende Gleitkommazahl mit doppelter Genauigkeit. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns><see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <see cref="F:System.Double.PositiveInfinity" /> oder entsprechend <see cref="F:System.Double.NegativeInfinity" /> der IEEE 754-Spezifikation gerundet. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider * double -&gt; bool" Usage="System.double.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Security.SecuritySafeCritical]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Security.SecuritySafeCritical&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Double" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Eine Zeichenfolge, die die zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination von <see cref="T:System.Globalization.NumberStyles" />-Werten, die das zulässige Format von <paramref name="s" /> angibt. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Float" /> in Kombination mit <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Eine <see cref="T:System.IFormatProvider" />-Schnittstelle, die kulturspezifische Formatierungsinformationen zu <paramref name="s" /> bereitstellt.</param>
        <param name="result">Diese Methode gibt bei erfolgreicher Konvertierung eine Gleitkommazahl mit doppelter Genauigkeit zurück, die dem numerischen Wert oder dem im <paramref name="s" />-Parameter enthaltenen Symbol entspricht, oder 0 (null), wenn die Konvertierung fehlgeschlagen ist. Die Konvertierung kann nicht durchgeführt werden, wenn der <paramref name="s" />-Parameter <see langword="null" /> oder <see cref="F:System.String.Empty" /> ist, kein mit <paramref name="style" /> kompatibles Format aufweist oder <paramref name="style" /> keine gültige Kombination von <see cref="T:System.Globalization.NumberStyles" />-Enumerationskonstanten ist. Außerdem schlägt sie in .NET Framework oder .NET Core 2.2 und früheren Versionen fehl, wenn <paramref name="s" /> eine Zahl kleiner als <see cref="F:System.SByte.MinValue" /> oder größer als <see cref="F:System.SByte.MaxValue" /> darstellt. Dieser Parameter wird nicht initialisiert übergeben. Jeder Wert, der ursprünglich im bereitgestellten <paramref name="result" /> überschrieben werden.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und einem kulturspezifischen Format in die entsprechende Gleitkommazahl mit doppelter Genauigkeit. Ein Rückgabewert gibt an, ob die Konvertierung erfolgreich war oder nicht.</summary>
        <returns><see langword="true" />, wenn <paramref name="s" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In .net Core 3,0 und höher werden Werte, die zu groß für die Darstellung sind, auf <xref:System.Double.PositiveInfinity> oder entsprechend <xref:System.Double.NegativeInfinity> der IEEE 754-Spezifikation gerundet. In früheren Versionen, einschließlich .NET Framework, führte das Auswerten eines Werts, der zu groß für die Darstellung war, zu einem Fehler.

 Die-Methode <xref:System.Double.TryParse%2A> ähnelt der- <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> Methode, außer diese Methode löst keine Ausnahme aus, wenn bei der Konvertierung ein Fehler auftritt. Wenn die Konvertierung erfolgreich ist, ist der Rückgabewert, `true` und der- `result` Parameter wird auf das Ergebnis der Konvertierung festgelegt. Wenn die Konvertierung fehlschlägt, ist der Rückgabewert, `false` und der- `result` Parameter wird auf 0 (null) festgelegt. Dadurch ist es nicht mehr erforderlich, die Ausnahmebehandlung zu verwenden, um ein <xref:System.FormatException> im Ereignis zu testen, das `s` ungültig ist und nicht erfolgreich analysiert werden kann.  
  
 Der- `style` Parameter definiert das zulässige Format des- `s` Parameters, damit der Analyse Vorgang erfolgreich ausgeführt wird. Dabei muss es sich um eine Kombination von Bitflags aus der- <xref:System.Globalization.NumberStyles> Enumeration handeln. Die folgenden Member <xref:System.Globalization.NumberStyles> werden nicht unterstützt:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 Der- `s` Parameter kann <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType> , <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType> oder <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> für die Kultur enthalten, die durch angegeben wird `provider` . Außerdem kann der-Parameter abhängig vom Wert von `style` `s` die folgenden Elemente enthalten:  
  
 Gefangener [$] Gebärden [ganzzahlige Ziffern,] ganzzahlige Ziffern [. Bruch Ziffern] [e [Sign] exponentialziffern] [WS]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum. Leerraum kann am Anfang von angezeigt `s` werden, wenn `style` das- <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> Flag enthält. Sie kann am Ende von angezeigt `s` werden, wenn `style` das- <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> Flag enthält.|  
|*$*|Ein kulturspezifisches Währungssymbol. Die Position in der Zeichenfolge wird durch die-Eigenschaft oder die-Eigenschaft <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> des von der- <xref:System.Globalization.NumberFormatInfo> <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> Methode des-Parameters zurückgegebenen-Objekts definiert `provider` . Das Währungssymbol kann in angezeigt `s` werden, wenn `style` das- <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> Flag enthält.|  
|*sign*|Ein optionales Vorzeichen. Das Vorzeichen kann am Anfang von angezeigt `s` `style` werden, wenn das <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> -Flag enthält, und es kann am Ende von angezeigt werden, `s` Wenn `style` das- <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> Flag enthält. Klammern können in verwendet werden `s` , um einen negativen Wert anzugeben, wenn `style` das- <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> Flag einschließt.|  
|*ganzzahlige Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den ganzzahligen Teil der Zahl angeben. Ganzzahlige Ziffern können nicht vorhanden sein, wenn es sich um Bruch Ziffern handelt.|  
|*,*|Ein kulturspezifisches Tausender Trennzeichen. Das Tausender Trennzeichen der aktuellen Kultur kann in auftreten, `s` Wenn `style` das- <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flag enthält.|  
|*.*|Ein kulturspezifisches Dezimaltrennzeichen. Das Dezimaltrennzeichen der aktuellen Kultur kann in auftreten, `s` Wenn `style` das- <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag enthält.|  
|*Bruch Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die den Bruch Teil der Zahl angeben. Bruch Ziffern können in auftreten, `s` Wenn `style` das- <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag enthält.|  
|*e*|Das e-oder e-Zeichen, das angibt, dass `s` eine Zahl mit exponentieller Notation darstellen kann. Der- `s` Parameter kann eine Zahl in Exponentialnotation darstellen, wenn style das- <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Flag enthält.|  
|*exponentielle Ziffern*|Eine Reihe von Ziffern im Bereich von 0 bis 9, die einen Exponenten angeben.|  
  
> [!NOTE]
> Alle abschließenden NUL-Zeichen (U + 0000) in `s` werden vom Analyse-Vorgang unabhängig vom Wert des `style` Arguments ignoriert.

 Eine Zeichenfolge, die nur Ziffern (die dem Format entspricht) entspricht, <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> wird immer erfolgreich analysiert, wenn Sie sich im Bereich des <xref:System.Double> Typs befindet. Die übrigen Member <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> steuern Elemente, die möglicherweise nicht in der Eingabe Zeichenfolge vorhanden sind, jedoch nicht erforderlich sind. In der folgenden Tabelle wird angegeben <xref:System.Globalization.NumberStyles> , wie die einzelnen Flags die Elemente beeinflussen, die möglicherweise in vorhanden sind `s` .  
  
|NumberStyles-Wert|In s zulässige Elemente zusätzlich zu Ziffern|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Nur das ganzzahlige *Ziffern* Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Das Sprachelement *.* und *Bruch Ziffern* Elemente.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Der- `s` Parameter kann auch die Exponentialnotation verwenden. Dieses Flag allein unterstützt Werte in der Form ganzzahlige *Ziffern*E*exponentialziffern*. zusätzliche Flags sind erforderlich, um Zeichen folgen in Exponentialnotation mit solchen Elementen wie positive oder negative Vorzeichen und Dezimaltrennzeichen erfolgreich zu analysieren.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Das *WS* -Element am Anfang von `s` .|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Das *WS* -Element am Ende von `s` .|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Das *Sign* -Element am Anfang von `s` .|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Das *Sign* -Element am Ende von `s` .|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Das *Vorzeichen* Element in der Form von Klammern, das den numerischen Wert einschließt.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das *-* Element.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das *$* Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle Der- `s` Parameter kann keine hexadezimal Zahl oder eine Zahl in Exponentialnotation darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Das *WS* -Element am Anfang oder Ende von `s` *signiert* am Anfang von `s` und *.* Tick. Der- `s` Parameter kann auch die Exponentialnotation verwenden.|  
|<xref:System.Globalization.NumberStyles.Number>|Die `ws` `sign` Elemente,, Tausender Trennzeichen (*,)* und Dezimaltrennzeichen (*.*).|  
|<xref:System.Globalization.NumberStyles.Any>|Alle Stile, außer `s` können keine hexadezimal Zahl darstellen.|  
  
 Der- `provider` Parameter ist eine- <xref:System.IFormatProvider> Implementierung, z <xref:System.Globalization.NumberFormatInfo> . b. ein-oder- <xref:System.Globalization.CultureInfo> Objekt. Der- `provider` Parameter liefert kulturspezifische Informationen, die beim Parsen verwendet werden. Wenn `provider` ist `null` oder kein- <xref:System.Globalization.NumberFormatInfo> Objekt abgerufen werden kann, werden die Formatinformationen für die aktuelle Kultur verwendet.  
  
 Die Konvertierung schlägt fehl, wenn der- `s` Parameter `null` ein numerischer Wert ist oder kein numerischer Wert ist, der- `provider` Parameter kein- <xref:System.Globalization.NumberFormatInfo> Objekt ergibt, oder der- `style` Parameter keine Kombination von Bitflags aus der- <xref:System.Globalization.NumberStyles> Enumeration ist.  
  
 Wenn Sie der-Methode eine Zeichenfolge übergeben, die <xref:System.Double.TryParse%2A?displayProperty=nameWithType> durch den Aufruf der-Methode erstellt wird <xref:System.Double.ToString%2A?displayProperty=nameWithType> , wird normalerweise der ursprüngliche <xref:System.Double> Wert zurückgegeben. Aufgrund eines Genauigkeits Verlusts sind die Werte jedoch möglicherweise nicht gleich. Außerdem kann bei dem Versuch, die Zeichen folgen Darstellung von oder zu analysieren, ein <xref:System.Double.MinValue?displayProperty=nameWithType> <xref:System.Double.MaxValue?displayProperty=nameWithType> Roundtrip nicht durchführt werden. Auf .NET Framework und .net Core 2,2 und früheren Versionen wird eine ausgelöst <xref:System.OverflowException> . In .net Core 3,0 und höheren Versionen wird zurückgegeben, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> Wenn Sie versuchen, zu analysieren <xref:System.Double.MinValue?displayProperty=nameWithtype> oder <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> zu analysieren <xref:System.Double.MaxValue?displayProperty=nameWithtype> . Dies wird im folgenden Beispiel veranschaulicht.
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs" interactive="try-dotnet" id="Snippet3":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb" id="Snippet3":::

Bei .NET Framework und .net Core 2,2 und früheren Versionen löst `s` die-Methode eine aus, wenn außerhalb des gültigen Bereichs des- <xref:System.Double> Datentyps liegt <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> <xref:System.OverflowException> .

Unter .net Core 3,0 und höheren Versionen wird keine Ausnahme ausgelöst, wenn `s` außerhalb des gültigen Bereichs des- <xref:System.Double> Datentyps liegt. In den meisten Fällen berechnet die- <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> Methode das Ergebnis von <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> . Allerdings gibt es eine kleine Menge von Werten, die als näher an den maximalen oder minimalen Werten von <xref:System.Double> als positiv oder minus unendlich angesehen werden. In diesen Fällen berechnet die-Methode das Ergebnis von <xref:System.Double.MaxValue?displayProperty=nameWithType> oder <xref:System.Double.MinValue?displayProperty=nameWithType> .

 Wenn im-Parameter während eines Analyse Vorgangs ein Trennzeichen gefunden wird `s` und die entsprechende Währungs-oder Zahlen Dezimal-und Gruppen Trennzeichen identisch sind, geht der Analyse Vorgang davon aus, dass es sich bei dem Trennzeichen um ein Dezimaltrennzeichen und nicht um ein Gruppen Trennzeichen handelt. Weitere Informationen zu Trennzeichen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A> , <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A> , <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A> und <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A> .   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die- <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> Methode verwendet wird, um die Zeichen folgen Darstellung von Zahlen zu analysieren, die einen bestimmten Stil aufweisen und mit den Konventionen einer bestimmten Kultur formatiert werden.  
  
 :::code language="csharp" source="~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/TryParse1.cs" interactive="try-dotnet-method" id="Snippet2":::
 :::code language="vb" source="~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/TryParse1.vb" id="Snippet2":::
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder - 
 <paramref name="style" /> enthält den <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Wert.</exception>
        <altmember cref="M:System.Double.ToString" />
        <related type="Article" href="/dotnet/standard/base-types/parsing-numeric">Analysieren numerischer Zeichenfolgen in .NET</related>
      </Docs>
    </Member>
  </Members>
</Type>
