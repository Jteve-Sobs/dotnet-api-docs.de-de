<Type Name="Type" FullName="System.Type">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="a40925048dd06746d1e1cda2a76aa4ecaae1b916" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30731514" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="2da29-101">Stellt Typdeklarationen dar: Klassentypen, Schnittstellentypen, Arraytypen, Werttypen, Enumerationstypen, Typparameter, generische Typdefinitionen und offen oder geschlossen konstruierte generische Typen.</span>
      <span class="sxs-lookup">
        <span data-stu-id="2da29-101">Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-102">`Type` Stellt den Stamm der <xref:System.Reflection> Funktionalität und ist die primäre Methode Zugriff auf Metadaten.</span><span class="sxs-lookup"><span data-stu-id="2da29-102">`Type` is the root of the <xref:System.Reflection> functionality and is the primary way to access metadata.</span></span> <span data-ttu-id="2da29-103">Verwenden Sie die Elemente der <xref:System.Type> beim Abrufen von Informationen über die Typdeklaration, über die Elemente eines Typs (z. B. die Konstruktoren, Methoden, Felder, Eigenschaften und Ereignisse einer Klasse), sowie das Modul und die Assembly, in der die Klasse bereitgestellt wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-103">Use the members of <xref:System.Type> to get information about a type declaration, about the members of a type (such as the constructors, methods, fields, properties, and events of a class), as well as the module and the assembly in which the class is deployed.</span></span>  
  
 <span data-ttu-id="2da29-104">Es sind keine Berechtigungen erforderlich, damit der Code die Reflexion zum Abrufen von Informationen zu Typen und Member, unabhängig von deren Zugriffsebenen verwenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-104">No permissions are required for code to use reflection to get information about types and their members, regardless of their access levels.</span></span> <span data-ttu-id="2da29-105">Es sind keine Berechtigungen erforderlich, damit Code Reflektion verwenden, um Zugriff auf öffentliche Member oder andere Elemente, deren Zugriffsebenen sie während der normalen Kompilierung sichtbar wäre.</span><span class="sxs-lookup"><span data-stu-id="2da29-105">No permissions are required for code to use reflection to access public members, or other members whose access levels would make them visible during normal compilation.</span></span> <span data-ttu-id="2da29-106">Damit Ihr Code auch mithilfe der Reflektion, um auf Member zuzugreifen, die normalerweise nicht zugegriffen werden kann, z. B. private oder interne Methoden werden, oder geschützte Felder eines Typs kann die Klasse erbt nicht, der Code benötigen jedoch <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="2da29-106">However, in order for your code to use reflection to access members that would normally be inaccessible, such as private or internal methods, or protected fields of a type your class does not inherit, your code must have <xref:System.Security.Permissions.ReflectionPermission>.</span></span> <span data-ttu-id="2da29-107">Finden Sie unter [Sicherheitsüberlegungen für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="2da29-107">See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span>  
  
 <span data-ttu-id="2da29-108">`Type` ist eine abstrakte Basisklasse, die mehrere Implementierungen ermöglicht.</span><span class="sxs-lookup"><span data-stu-id="2da29-108">`Type` is an abstract base class that allows multiple implementations.</span></span> <span data-ttu-id="2da29-109">Das System wird immer die abgeleitete Klasse bereitstellen `RuntimeType`.</span><span class="sxs-lookup"><span data-stu-id="2da29-109">The system will always provide the derived class `RuntimeType`.</span></span> <span data-ttu-id="2da29-110">In der Reflektion werden alle Klassen, die mit dem Wort Runtime ab nur einmal pro Objekt in der System- und Unterstützung Vergleichsvorgängen erstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-110">In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-111">Multithreading Szenarien nicht sperren <xref:System.Type> Objekte zum Synchronisieren des Zugriffs auf `static` Daten.</span><span class="sxs-lookup"><span data-stu-id="2da29-111">In multithreading scenarios, do not lock <xref:System.Type> objects in order to synchronize access to `static` data.</span></span> <span data-ttu-id="2da29-112">Anderer Code, über den Sie keine Kontrolle haben kann möglicherweise auch Ihr Klassentyp gesperrt.</span><span class="sxs-lookup"><span data-stu-id="2da29-112">Other code, over which you have no control, might also lock your class type.</span></span> <span data-ttu-id="2da29-113">Dies kann zu einem Deadlock führen.</span><span class="sxs-lookup"><span data-stu-id="2da29-113">This might result in a deadlock.</span></span> <span data-ttu-id="2da29-114">Synchronisieren Sie den Zugriff auf statische Daten stattdessen durch Sperren eines privaten `static` Objekt.</span><span class="sxs-lookup"><span data-stu-id="2da29-114">Instead, synchronize access to static data by locking a private `static` object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-115">Eine abgeleitete Klasse kann geschützte Member der Basisklassen des aufrufenden Codes zugreifen.</span><span class="sxs-lookup"><span data-stu-id="2da29-115">A derived class can access protected members of the calling code's base classes.</span></span> <span data-ttu-id="2da29-116">Darüber hinaus wird der Zugriff auf Assemblymember der Assembly des aufrufenden Codes zugelassen.</span><span class="sxs-lookup"><span data-stu-id="2da29-116">Also, access is allowed to assembly members of the calling code's assembly.</span></span> <span data-ttu-id="2da29-117">Wenn es im Code früh gebundene Zugriff zulässig ist er in der Regel auch in spät gebundenem Code zulässig.</span><span class="sxs-lookup"><span data-stu-id="2da29-117">As a rule, if you are allowed access in early-bound code, then you are also allowed access in late-bound code.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-118">Schnittstellen, die das Erweitern von anderen Schnittstellen erben nicht die Methoden, die in die erweiterten Schnittstellen definiert.</span><span class="sxs-lookup"><span data-stu-id="2da29-118">Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.</span></span>  
  
 <span data-ttu-id="2da29-119">In diesem Abschnitt</span><span class="sxs-lookup"><span data-stu-id="2da29-119">In this section:</span></span>  
  
 <span data-ttu-id="2da29-120">[Welche Typen stellt ein Objekt vom Typ dar?](#WhatTypes) </span><span class="sxs-lookup"><span data-stu-id="2da29-120">[What types does a Type object represent?](#WhatTypes) </span></span>  
 <span data-ttu-id="2da29-121">[Ein Objekt vom Typ abrufen](#Retrieve) </span><span class="sxs-lookup"><span data-stu-id="2da29-121">[Retrieving a Type object](#Retrieve) </span></span>  
 [<span data-ttu-id="2da29-122">Vergleichen von Objekten auf Gleichheit</span><span class="sxs-lookup"><span data-stu-id="2da29-122">Comparing type objects for equality</span></span>](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a><span data-ttu-id="2da29-123">Welche Typen stellt ein Objekt vom Typ dar?</span><span class="sxs-lookup"><span data-stu-id="2da29-123">What types does a Type object represent?</span></span>  
 <span data-ttu-id="2da29-124">Diese Klasse ist threadsicher. eine Instanz dieses Typs können mehrere Threads gleichzeitig gelesen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-124">This class is thread safe; multiple threads can concurrently read from an instance of this type.</span></span> <span data-ttu-id="2da29-125">Eine Instanz von der <xref:System.Type> -Klasse kann eines der folgenden Typen darstellen:</span><span class="sxs-lookup"><span data-stu-id="2da29-125">An instance of the <xref:System.Type> class can represent any of the following types:</span></span>  
  
-   <span data-ttu-id="2da29-126">Klassen</span><span class="sxs-lookup"><span data-stu-id="2da29-126">Classes</span></span>  
  
-   <span data-ttu-id="2da29-127">Werttypen</span><span class="sxs-lookup"><span data-stu-id="2da29-127">Value types</span></span>  
  
-   <span data-ttu-id="2da29-128">Arrays</span><span class="sxs-lookup"><span data-stu-id="2da29-128">Arrays</span></span>  
  
-   <span data-ttu-id="2da29-129">Schnittstellen</span><span class="sxs-lookup"><span data-stu-id="2da29-129">Interfaces</span></span>  
  
-   <span data-ttu-id="2da29-130">Enumerationen</span><span class="sxs-lookup"><span data-stu-id="2da29-130">Enumerations</span></span>  
  
-   <span data-ttu-id="2da29-131">Delegaten</span><span class="sxs-lookup"><span data-stu-id="2da29-131">Delegates</span></span>  
  
-   <span data-ttu-id="2da29-132">Konstruierte generische Typen und generische Typdefinitionen</span><span class="sxs-lookup"><span data-stu-id="2da29-132">Constructed generic types and generic type definitions</span></span>  
  
-   <span data-ttu-id="2da29-133">Typargumenten Sie und Typparametern Sie konstruierte generische Typen, generische Typdefinitionen und generischen Methodendefinitionen</span><span class="sxs-lookup"><span data-stu-id="2da29-133">Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions</span></span>  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a><span data-ttu-id="2da29-134">Ein Objekt vom Typ abrufen</span><span class="sxs-lookup"><span data-stu-id="2da29-134">Retrieving a Type object</span></span>  
 <span data-ttu-id="2da29-135">Die <xref:System.Type> Objekt zugewiesen ist, mit einem bestimmten Typ kann auf folgende Weise abgerufen werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-135">The <xref:System.Type> object associated with a particular type can be obtained in the following ways:</span></span>  
  
-   <span data-ttu-id="2da29-136">Die Instanz <xref:System.Object.GetType%2A?displayProperty=nameWithType> Methode gibt ein <xref:System.Type> -Objekt, das den Typ einer Instanz darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-136">The instance <xref:System.Object.GetType%2A?displayProperty=nameWithType> method returns a <xref:System.Type> object that represents the type of an instance.</span></span> <span data-ttu-id="2da29-137">Da alle verwaltete Typen abgeleitet sein <xref:System.Object>die <xref:System.Object.GetType%2A> für eine Instanz eines beliebigen Typs können Methoden aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-137">Because all managed types derive from <xref:System.Object>, the <xref:System.Object.GetType%2A> method can be called on an instance of any type.</span></span>  
  
     <span data-ttu-id="2da29-138">Im folgenden Beispiel wird die <xref:System.Object.GetType%2A?displayProperty=nameWithType> Methode, um den Laufzeittyp der einzelnen Objekte in einem Objektarray festzulegen.</span><span class="sxs-lookup"><span data-stu-id="2da29-138">The following example calls the <xref:System.Object.GetType%2A?displayProperty=nameWithType> method to determine the runtime type of each object in an object array.</span></span>  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   <span data-ttu-id="2da29-139">Die statische <xref:System.Type.GetType%2A?displayProperty=nameWithType> -Methoden zurückgeben einer <xref:System.Type> -Objekt, das einen durch den vollqualifizierten Namen angegebenen Typ darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-139">The static <xref:System.Type.GetType%2A?displayProperty=nameWithType> methods return a <xref:System.Type> object that represents a type specified by its fully qualified name.</span></span>  
  
-   <span data-ttu-id="2da29-140">Die <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, und <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> -Methoden zurückgeben `Type` Objekte, die in einem Modul definierten Typen darstellen.</span><span class="sxs-lookup"><span data-stu-id="2da29-140">The <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> methods return `Type` objects that represent the types defined in a module.</span></span> <span data-ttu-id="2da29-141">Die erste Methode verwendet werden kann, zum Abrufen eines Arrays von <xref:System.Type> Objekte für alle öffentlichen und privaten Typen, die in einem Modul definiert.</span><span class="sxs-lookup"><span data-stu-id="2da29-141">The first method can be used to obtain an array of <xref:System.Type> objects for all the public and private types defined in a module.</span></span> <span data-ttu-id="2da29-142">(Sie erhalten eine Instanz von `Module` über die <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> oder <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> -Methode, oder über die <xref:System.Type.Module%2A?displayProperty=nameWithType> Eigenschaft.)</span><span class="sxs-lookup"><span data-stu-id="2da29-142">(You can obtain an instance of `Module` through the <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> method, or through the <xref:System.Type.Module%2A?displayProperty=nameWithType> property.)</span></span>  
  
-   <span data-ttu-id="2da29-143">Die <xref:System.Reflection.Assembly?displayProperty=nameWithType> Objekt enthält eine Reihe von Methoden zum Abrufen der Klassen in einer Assembly, einschließlich definiert <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, und <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-143">The <xref:System.Reflection.Assembly?displayProperty=nameWithType> object contains a number of methods to retrieve the classes defined in an assembly, including <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="2da29-144">Die <xref:System.Type.FindInterfaces%2A> Methode gibt eine gefilterte Liste von Schnittstellentypen, die von einem Typ unterstützt.</span><span class="sxs-lookup"><span data-stu-id="2da29-144">The <xref:System.Type.FindInterfaces%2A> method returns a filtered list of interface types supported by a type.</span></span>  
  
-   <span data-ttu-id="2da29-145">Die <xref:System.Type.GetElementType%2A> Methode gibt ein `Type` Objekt, das das Element darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-145">The <xref:System.Type.GetElementType%2A> method returns a `Type` object that represents the element.</span></span>  
  
-   <span data-ttu-id="2da29-146">Die <xref:System.Type.GetInterfaces%2A> und <xref:System.Type.GetInterface%2A> -Methoden zurückgeben <xref:System.Type> Objekte, die von einem Typ unterstützten Schnittstellentypen darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-146">The <xref:System.Type.GetInterfaces%2A> and <xref:System.Type.GetInterface%2A> methods return <xref:System.Type> objects representing the interface types supported by a type.</span></span>  
  
-   <span data-ttu-id="2da29-147">Die <xref:System.Type.GetTypeArray%2A> Methode gibt ein Array von <xref:System.Type> Objekten, die von einer beliebigen Gruppe von Objekten angegebenen Typen darstellen.</span><span class="sxs-lookup"><span data-stu-id="2da29-147">The <xref:System.Type.GetTypeArray%2A> method returns an array of <xref:System.Type> objects representing the types specified by an arbitrary set of objects.</span></span> <span data-ttu-id="2da29-148">Die Objekte sind mit einem Array des Typs angegeben <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="2da29-148">The objects are specified with an array of type <xref:System.Object>.</span></span>  
  
-   <span data-ttu-id="2da29-149">Die <xref:System.Type.GetTypeFromProgID%2A> und <xref:System.Type.GetTypeFromCLSID%2A> Methoden für COM-Interoperabilität bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-149">The <xref:System.Type.GetTypeFromProgID%2A> and <xref:System.Type.GetTypeFromCLSID%2A> methods are provided for COM interoperability.</span></span> <span data-ttu-id="2da29-150">Diese Zurückgeben einer <xref:System.Type> Objekt, das den vom angegebenen Typ darstellt eine `ProgID` oder `CLSID`.</span><span class="sxs-lookup"><span data-stu-id="2da29-150">They return a <xref:System.Type> object that represents the type specified by a `ProgID` or `CLSID`.</span></span>  
  
-   <span data-ttu-id="2da29-151">Die <xref:System.Type.GetTypeFromHandle%2A> Methode wird bereitgestellt, für die Interoperabilität.</span><span class="sxs-lookup"><span data-stu-id="2da29-151">The <xref:System.Type.GetTypeFromHandle%2A> method is provided for interoperability.</span></span> <span data-ttu-id="2da29-152">Es gibt eine `Type` Objekt, das durch ein Klassenhandle angegebenen Typ darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-152">It returns a `Type` object that represents the type specified by a class handle.</span></span>  
  
-   <span data-ttu-id="2da29-153">Die C#- `typeof` -Operator, der C++ `typeid` Operator und die Visual Basic `GetType` Operator erhalten die `Type` Objekt für einen Typ.</span><span class="sxs-lookup"><span data-stu-id="2da29-153">The C# `typeof` operator, the C++ `typeid` operator, and the Visual Basic `GetType` operator obtain the `Type` object for a type.</span></span>  
  
-   <span data-ttu-id="2da29-154">Die <xref:System.Type.MakeGenericType%2A> Methode gibt ein <xref:System.Type> Objekt einen konstruierten generischen Typ, der einen offenen konstruierten Typ ist, darstellt, seine <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft gibt `true`, und einem geschlossenen konstruierten Typ andernfalls.</span><span class="sxs-lookup"><span data-stu-id="2da29-154">The <xref:System.Type.MakeGenericType%2A> method returns a <xref:System.Type> object representing a constructed generic type, which is an open constructed type if its <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, and a closed constructed type otherwise.</span></span> <span data-ttu-id="2da29-155">Ein generischer Typ kann instanziiert werden, nur dann, wenn er geschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="2da29-155">A generic type can be instantiated only if it is closed.</span></span>  
  
-   <span data-ttu-id="2da29-156">Die <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, und <xref:System.Type.MakeByRefType%2A> -Methoden zurückgeben <xref:System.Type> Objekte, die, die ein Array des angegebenen Typs, der einen Zeiger auf einen angegebenen Typ und den Typ des Verweisparameters darstellen (`ref` in c# `ByRef`in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-156">The <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, and <xref:System.Type.MakeByRefType%2A> methods return <xref:System.Type> objects that represent, respectively, an array of a specified type, a pointer to a specified type, and the type of a reference parameter (`ref` in C#, `ByRef` in Visual Basic).</span></span>  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a><span data-ttu-id="2da29-157">Vergleichen von Objekten auf Gleichheit</span><span class="sxs-lookup"><span data-stu-id="2da29-157">Comparing type objects for equality</span></span>  
 <span data-ttu-id="2da29-158">Ein <xref:System.Type> -Objekt, stellt ein Typ eindeutig ist, d. h. zwei <xref:System.Type> Objektverweise auf dasselbe Objekt verweisen, wenn sie denselben Typ darstellen.</span><span class="sxs-lookup"><span data-stu-id="2da29-158">A <xref:System.Type> object that represents a type is unique; that is, two <xref:System.Type> object references refer to the same object if and only if they represent the same type.</span></span> <span data-ttu-id="2da29-159">Dies ermöglicht den Vergleich von <xref:System.Type> Objekte mithilfe von Verweisgleichheit.</span><span class="sxs-lookup"><span data-stu-id="2da29-159">This allows for comparison of <xref:System.Type> objects using reference equality.</span></span> <span data-ttu-id="2da29-160">Das folgende Beispiel vergleicht die <xref:System.Type> Objekte, die als von ganzzahligen Werten Zahl, um zu bestimmen, ob sie vom selben Typ sind.</span><span class="sxs-lookup"><span data-stu-id="2da29-160">The following example compares the <xref:System.Type> objects that represent a number of integer values to determine whether they are of the same type.</span></span>  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 <span data-ttu-id="2da29-161">Das folgende Beispiel zeigt einige repräsentative Features von <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="2da29-161">The following  example shows a few representative features of <xref:System.Type>.</span></span> <span data-ttu-id="2da29-162">Die C#- `typeof` Operator (`GetType` Operator in Visual Basic `typeid` -Operator in Visual C++) Dient zum Abrufen einer <xref:System.Type> Objekt darstellt <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="2da29-162">The C# `typeof` operator (`GetType` operator in Visual Basic, `typeid` operator in Visual C++) is used to get a <xref:System.Type> object representing <xref:System.String>.</span></span> <span data-ttu-id="2da29-163">Aus diesem <xref:System.Type> -Objekt, das <xref:System.Type.GetMethod%2A> Methode zum Abrufen einer <xref:System.Reflection.MethodInfo> darstellt der <xref:System.String.Substring%2A> Überladung mit einer Anfangsposition und einer Länge.</span><span class="sxs-lookup"><span data-stu-id="2da29-163">From this <xref:System.Type> object, the <xref:System.Type.GetMethod%2A> method is used to get a <xref:System.Reflection.MethodInfo> representing the <xref:System.String.Substring%2A> overload that takes a starting location and a length.</span></span>  
  
 <span data-ttu-id="2da29-164">Um die Überladungssignatur zu identifizieren, das Codebeispiel erstellt ein temporäres Array mit zwei <xref:System.Type> Objekte darstellt `int` (`Integer` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-164">To identify the overload signature, the code example creates a temporary array containing two <xref:System.Type> objects representing `int` (`Integer` in Visual Basic).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-165">Um genau zu sein, das Array enthält zwei Verweise auf die Instanz von <xref:System.Type> darstellt, die `int` in der aktuellen Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="2da29-165">To be precise, the array contains two references to the instance of <xref:System.Type> that represents `int` in the current application domain.</span></span> <span data-ttu-id="2da29-166">Für jeden Typ, es ist nur eine Instanz des <xref:System.Type> pro Anwendungsdomäne.</span><span class="sxs-lookup"><span data-stu-id="2da29-166">For any type, there is only one instance of <xref:System.Type> per application domain.</span></span>  
  
 <span data-ttu-id="2da29-167">Das Codebeispiel verwendet die <xref:System.Reflection.MethodInfo> zum Aufrufen der <xref:System.String.Substring%2A> -Methode mit der Zeichenfolge "Hello, World!", und das Ergebnis wird angezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-167">The code example uses the <xref:System.Reflection.MethodInfo> to invoke the <xref:System.String.Substring%2A> method on the string "Hello, World!", and displays the result.</span></span>  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="2da29-168">Dieser Typ ist threadsicher.</span>
      <span class="sxs-lookup">
        <span data-stu-id="2da29-168">This type is thread safe.</span>
      </span>
    </threadsafe>
    <block subset="none" type="overrides">
      <para>
        <span data-ttu-id="2da29-169">Beim Erben von <see langword="Type" />, müssen Sie die folgenden Member überschreiben:</span>
        <span class="sxs-lookup">
          <span data-stu-id="2da29-169">When you inherit from <see langword="Type" />, you must override the following members:</span>
        </span>  
  
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <span data-ttu-id="2da29-170"><see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /> ,</span><span class="sxs-lookup"><span data-stu-id="2da29-170"><see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /> ,</span></span>  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para>
    </block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-171">Initialisiert eine neue Instanz der <see cref="T:System.Type" />-Klasse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-171">Initializes a new instance of the <see cref="T:System.Type" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-172">Dieser Konstruktor wird von abgeleiteten Klassen aufgerufen, während der Erstellung von Type-Objekten.</span><span class="sxs-lookup"><span data-stu-id="2da29-172">This constructor is invoked by derived classes during the construction of type objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-173">Ruft die <see cref="T:System.Reflection.Assembly" /> ab, in der der Typ deklariert ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-173">Gets the <see cref="T:System.Reflection.Assembly" /> in which the type is declared.</span>
          </span>
          <span data-ttu-id="2da29-174">Ruft bei generischen Typen die <see cref="T:System.Reflection.Assembly" /> ab, in der der generische Typ definiert ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-174">For generic types, gets the <see cref="T:System.Reflection.Assembly" /> in which the generic type is defined.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-175">Eine <see cref="T:System.Reflection.Assembly" />-Instanz, die die Assembly mit dem aktuellen Typ beschreibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-175">An <see cref="T:System.Reflection.Assembly" /> instance that describes the assembly containing the current type.</span>
          </span>
          <span data-ttu-id="2da29-176">Bei generischen Typen beschreibt die Instanz die Assembly, die die generische Typdefinition enthält, nicht die Assembly, in der ein bestimmter konstruierter Typ erstellt und verwendet wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-176">For generic types, the instance describes the assembly that contains the generic type definition, not the assembly that creates and uses a particular constructed type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-177">Wenn die aktuelle <xref:System.Type> Objekt einen konstruierten generischen Typ darstellt, gibt diese Eigenschaft die Assembly, die generische Typdefinition enthält.</span><span class="sxs-lookup"><span data-stu-id="2da29-177">If the current <xref:System.Type> object represents a constructed generic type, this property returns the assembly that contains the generic type definition.</span></span> <span data-ttu-id="2da29-178">Nehmen wir beispielsweise an, die Sie erstellen eine Assembly mit dem Namen MyGenerics.dll, die die generische Typdefinition enthält `MyGenericStack<T>` (`MyGenericStack(Of T)` in Visual Basic `generic<T> ref class MyGenericStack` in C++).</span><span class="sxs-lookup"><span data-stu-id="2da29-178">For example, suppose you create an assembly named MyGenerics.dll that contains the generic type definition `MyGenericStack<T>` (`MyGenericStack(Of T)` in Visual Basic, `generic<T> ref class MyGenericStack` in C++).</span></span> <span data-ttu-id="2da29-179">Bei der Erstellung einer Instanz von `MyGenericStack<int>` (`MyGenericStack(Of Integer)` in Visual Basic) in einer anderen Assembly die <xref:System.Type.Assembly%2A> -Eigenschaft für den konstruierten Typ gibt eine <xref:System.Reflection.Assembly> -Objekt, das MyGenerics.dll darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-179">If you create an instance of `MyGenericStack<int>` (`MyGenericStack(Of Integer)` in Visual Basic) in another assembly, the <xref:System.Type.Assembly%2A> property for the constructed type returns an <xref:System.Reflection.Assembly> object that represents MyGenerics.dll.</span></span>  
  
 <span data-ttu-id="2da29-180">Auf ähnliche Weise, wenn die aktuelle <xref:System.Type> Objekt stellt einen nicht zugewiesenen generischen Parameter `T`, diese Eigenschaft gibt die Assembly, die den generischen Typ enthält, definiert `T`.</span><span class="sxs-lookup"><span data-stu-id="2da29-180">Similarly, if the current <xref:System.Type> object represents an unassigned generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.</span></span>  
  
 <span data-ttu-id="2da29-181">Wenn die <xref:System.Type.Assembly%2A?displayProperty=nameWithType> Eigenschaft nicht auf eine bestimmte Implementierung der .NET, z. B. .NET Core oder universellen Windows-Plattform verfügbar ist, verwenden Sie die <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> Eigenschaft stattdessen.</span><span class="sxs-lookup"><span data-stu-id="2da29-181">If the <xref:System.Type.Assembly%2A?displayProperty=nameWithType> property is not available on a particular .NET implementation, such as .NET Core or the Universal Windows Platform, use the <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> property instead.</span></span>      
  
 <span data-ttu-id="2da29-182">Diese Eigenschaft ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="2da29-182">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-183">Das folgende Beispiel zeigt den Assemblynamen, die die Klasse zugeordnet und der vollqualifizierte Name des Typs.</span><span class="sxs-lookup"><span data-stu-id="2da29-183">The following example displays the assembly name associated with the class and the fully qualified name of the type.</span></span>  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-184">Ruft den durch die Assembly qualifizierten Namen des Typs ab, der den Namen der Assembly enthält, aus der der <see cref="T:System.Type" /> geladen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-184">Gets the assembly-qualified name of the type, which includes the name of the assembly from which this <see cref="T:System.Type" /> object was loaded.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-185">Der durch die Assembly qualifizierte Name des <see cref="T:System.Type" />, der den Namen der Assembly enthält, aus der der <see cref="T:System.Type" /> geladen wurde, oder <see langword="null" />, wenn die aktuelle Instanz einen generischen Typparameter darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-185">The assembly-qualified name of the <see cref="T:System.Type" />, which includes the name of the assembly from which the <see cref="T:System.Type" /> was loaded, or <see langword="null" /> if the current instance represents a generic type parameter.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-186">Die Assembly qualifizierte Name eines Typs besteht aus den Typnamen, einschließlich des Namespaces, gefolgt von einem Komma, gefolgt von den Anzeigenamen der Assembly.</span><span class="sxs-lookup"><span data-stu-id="2da29-186">The assembly-qualified name of a type consists of the type name, including its namespace, followed by a comma, followed by the display name of the assembly.</span></span> <span data-ttu-id="2da29-187">Der Anzeigename einer Assembly abgerufen wird, mit der <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-187">The display name of an assembly is obtained using the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-188">In .NET Framework, Version 2.0 Prozessorarchitektur Assemblyidentität hinzugefügt und kann als Teil der Assembly-Zeichenfolgen angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-188">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="2da29-189">Z. B. "ProcessorArchitecture = Msil".</span><span class="sxs-lookup"><span data-stu-id="2da29-189">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="2da29-190">Ist jedoch nicht in die zurückgegebene Zeichenfolge enthalten die <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaft, aus Gründen der Kompatibilität.</span><span class="sxs-lookup"><span data-stu-id="2da29-190">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="2da29-191">Siehe <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-191">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="2da29-192">Alle Compiler, die die common Language Runtime unterstützen, geben den einfachen Namen einer geschachtelten Klasse und Reflektion erstellt einen ergänzten Namen bei einer Abfrage in Übereinstimmung mit den folgenden Konventionen.</span><span class="sxs-lookup"><span data-stu-id="2da29-192">All compilers that support the common language runtime emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
|<span data-ttu-id="2da29-193">Trennzeichen</span><span class="sxs-lookup"><span data-stu-id="2da29-193">Delimiter</span></span>|<span data-ttu-id="2da29-194">Bedeutung</span><span class="sxs-lookup"><span data-stu-id="2da29-194">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="2da29-195">Umgekehrter Schrägstrich (\\)</span><span class="sxs-lookup"><span data-stu-id="2da29-195">Backslash (\\)</span></span>|<span data-ttu-id="2da29-196">Escape-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="2da29-196">Escape character.</span></span>|  
|<span data-ttu-id="2da29-197">Komma (,)</span><span class="sxs-lookup"><span data-stu-id="2da29-197">Comma (,)</span></span>|<span data-ttu-id="2da29-198">Ist der Name der Assembly vorangestellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-198">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="2da29-199">Pluszeichen (+)</span><span class="sxs-lookup"><span data-stu-id="2da29-199">Plus sign (+)</span></span>|<span data-ttu-id="2da29-200">Ist eine geschachtelte Klasse vorangestellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-200">Precedes a nested class.</span></span>|  
|<span data-ttu-id="2da29-201">Punkt (.)</span><span class="sxs-lookup"><span data-stu-id="2da29-201">Period (.)</span></span>|<span data-ttu-id="2da29-202">Gibt die Namespacebezeichner.</span><span class="sxs-lookup"><span data-stu-id="2da29-202">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="2da29-203">Klammern ([])</span><span class="sxs-lookup"><span data-stu-id="2da29-203">Brackets ([])</span></span>|<span data-ttu-id="2da29-204">Nach einem Typnamen gibt Sie ein Array dieses Typs an.</span><span class="sxs-lookup"><span data-stu-id="2da29-204">After a type name, denotes an array of that type.</span></span><br /><br /> <span data-ttu-id="2da29-205">- oder - </span><span class="sxs-lookup"><span data-stu-id="2da29-205">-or-</span></span><br /><br /> <span data-ttu-id="2da29-206">Für einen generischen Typ umschließt die Liste der generischen Typargumente.</span><span class="sxs-lookup"><span data-stu-id="2da29-206">For a generic type, encloses the generic type argument list.</span></span><br /><br /> <span data-ttu-id="2da29-207">- oder - </span><span class="sxs-lookup"><span data-stu-id="2da29-207">-or-</span></span><br /><br /> <span data-ttu-id="2da29-208">In einer Liste der Typargumente schließt eine Assembly qualifizierten Typnamen.</span><span class="sxs-lookup"><span data-stu-id="2da29-208">Within a type argument list, encloses an assembly-qualified type.</span></span>|  
  
 <span data-ttu-id="2da29-209">Beispielsweise kann die Assembly qualifizierte Name für eine Klasse wie folgt aussehen:</span><span class="sxs-lookup"><span data-stu-id="2da29-209">For example, the assembly-qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 <span data-ttu-id="2da29-210">Wenn der Namespace enthalten ein Pluszeichen (+), z. B. TopNamespace.Sub, würde das Pluszeichen (+) ein Escapezeichen vorangestellt werden (\\) zu verhindern, dass er als schachteln Trennzeichen interpretiert wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-210">If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="2da29-211">Diese Zeichenfolge würde wie folgt Reflektionsausgabe:</span><span class="sxs-lookup"><span data-stu-id="2da29-211">Reflection would emit this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 <span data-ttu-id="2da29-212">Ein "++" wird "\\+\\+", und ein "\\"wird"\\\\".</span><span class="sxs-lookup"><span data-stu-id="2da29-212">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="2da29-213">Dieser qualifizierte Name kann beibehalten und später zum Laden der <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="2da29-213">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="2da29-214">Suchen und Laden einer <xref:System.Type>, verwenden Sie <xref:System.Type.GetType%2A> entweder mit dem Typ oder einen Namen geben nur mit der Assembly qualifizierten Typnamen.</span><span class="sxs-lookup"><span data-stu-id="2da29-214">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="2da29-215"><xref:System.Type.GetType%2A> mit dem Namen nur sieht für den <xref:System.Type> in der Assembly des Aufrufers, und klicken Sie dann in der System-Assembly.</span><span class="sxs-lookup"><span data-stu-id="2da29-215"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="2da29-216"><xref:System.Type.GetType%2A> mit der Assembly qualifizierten Typnamen für sieht die <xref:System.Type> in jeder beliebigen Assembly.</span><span class="sxs-lookup"><span data-stu-id="2da29-216"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="2da29-217">Geben Sie die Namen eventuell nachfolgende Zeichen, die zusätzliche über den Typ Informationen, z. B., ob der Typ ein Verweistyp, ein Zeigertyp oder ein Arraytyp ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-217">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="2da29-218">Verwenden Sie zum Abrufen der Typname ohne diese nachfolgenden Zeichen `t.GetElementType().ToString()`, wobei `t` ist der Typ.</span><span class="sxs-lookup"><span data-stu-id="2da29-218">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="2da29-219">Leerzeichen sind in allen Komponenten von Typnamen mit Ausnahme der Assemblyname relevant.</span><span class="sxs-lookup"><span data-stu-id="2da29-219">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="2da29-220">In der Assemblyname Leerzeichen vor dem Trennzeichen "," relevant sind, aber nach dem Trennzeichen "," Leerzeichen werden ignoriert.</span><span class="sxs-lookup"><span data-stu-id="2da29-220">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="2da29-221">Generische Argumente von generischen Typen werden selbst durch Name der Assembly gekennzeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-221">Generic arguments of generic types are themselves qualified by assembly name.</span></span> <span data-ttu-id="2da29-222">Beispielsweise ist in der Assembly qualifizierte Typname für `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic), `int` wird erweitert, um die Assembly qualifizierten Typnamen für <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="2da29-222">For example, in the assembly-qualified type name for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic), `int` is expanded to the assembly-qualified type name for <xref:System.Int32>.</span></span>  
  
 <span data-ttu-id="2da29-223">Wenn die aktuelle <xref:System.Type> -Objekt einen generischen Parameter darstellt, gibt diese Eigenschaft zurück `null`.</span><span class="sxs-lookup"><span data-stu-id="2da29-223">If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-224">Das folgende Beispiel zeigt den Assemblynamen, die die Klasse zugeordnet und der vollqualifizierte Name des Typs.</span><span class="sxs-lookup"><span data-stu-id="2da29-224">The following example displays the assembly name associated with the class and the fully qualified name of the type.</span></span>  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 <span data-ttu-id="2da29-225">Das folgende Beispiel vergleicht die zurückgegebene Zeichenfolgen die <xref:System.Type.ToString%2A> Methode und die `Name`, <xref:System.Type.FullName%2A>, und <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="2da29-225">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-226">Ruft die dem <see cref="T:System.Type" /> zugeordneten Attribute ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-226">Gets the attributes associated with the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-227">Ein <see cref="T:System.Reflection.TypeAttributes" />-Objekt, das die Attributgruppe von <see cref="T:System.Type" /> darstellt. Falls <see cref="T:System.Type" /> jedoch einen generischen Typparameter darstellt, ist der Wert nicht festgelegt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-227">A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />, unless the <see cref="T:System.Type" /> represents a generic type parameter, in which case the value is unspecified.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-228">Einige Member der <xref:System.Reflection.TypeAttributes> Enumeration sind Masken, die eine Gruppe von Werten darstellen.</span><span class="sxs-lookup"><span data-stu-id="2da29-228">Some members of the <xref:System.Reflection.TypeAttributes> enumeration are masks that represent a group of values.</span></span> <span data-ttu-id="2da29-229">Jede Gruppe enthält ein Element, dessen zugrunde liegenden Wert 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-229">Each group includes one member whose underlying value is zero.</span></span> <span data-ttu-id="2da29-230">Z. B. den zugrunde liegenden Wert von der <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> Element in der <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Gruppe ist 0 (null), ist die <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> Element in der <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> Gruppe.</span><span class="sxs-lookup"><span data-stu-id="2da29-230">For example, the underlying value of the <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> member in the <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> group is zero, as is the <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> member in the <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> group.</span></span> <span data-ttu-id="2da29-231">Aus diesem Grund müssen Sie die Maske verwenden, bevor Sie für diese Werte testen.</span><span class="sxs-lookup"><span data-stu-id="2da29-231">Because of this, you must use the mask before testing for those values.</span></span> <span data-ttu-id="2da29-232">Dies wird im Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="2da29-232">The example provides an illustration.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="2da29-233">Für die meisten Zwecke Eigenschaften wie <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, und <xref:System.Type.IsSpecialName%2A> sind einfacher zu verwenden als Attribute des Typs.</span><span class="sxs-lookup"><span data-stu-id="2da29-233">For most purposes, properties like <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, and <xref:System.Type.IsSpecialName%2A> are easier to use than type attributes.</span></span>  
  
 <span data-ttu-id="2da29-234">Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gibt die Attribute der generischen Typdefinition.</span><span class="sxs-lookup"><span data-stu-id="2da29-234">If the current <xref:System.Type> represents a constructed generic type, this property returns the attributes of the generic type definition.</span></span> <span data-ttu-id="2da29-235">Z. B. die Attribute, die für die zurückgegebenen `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic) sind die Attribute des `MyGenericClass<T>` (`MyGenericClass(Of T)` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-235">For example, the attributes returned for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic) are the attributes of `MyGenericClass<T>` (`MyGenericClass(Of T)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="2da29-236">Wenn die aktuelle <xref:System.Type> einen generischen Typparameter darstellt – d. h. wenn die <xref:System.Type.IsGenericParameter%2A> -Eigenschaft gibt `true` – die <xref:System.Reflection.TypeAttributes> von dieser Eigenschaft zurückgegebene Wert ist nicht angegeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-236">If the current <xref:System.Type> represents a generic type parameter — that is, if the <xref:System.Type.IsGenericParameter%2A> property returns `true` — the <xref:System.Reflection.TypeAttributes> value returned by this property is unspecified.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-237">Das folgende Beispiel verwenden bewirkt, dassdie <xref:System.Type.Attributes%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-237">The following example usesthe <xref:System.Type.Attributes%2A> property.</span></span>  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-238">Ruft den Typ ab, von dem der aktuelle <see cref="T:System.Type" /> direkt vererbt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-238">Gets the type from which the current <see cref="T:System.Type" /> directly inherits.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-239">Der <see cref="T:System.Type" />, von dem der aktuelle <see cref="T:System.Type" /> direkt erbt, oder <see langword="null" />, wenn der aktuelle <see langword="Type" /> die <see cref="T:System.Object" />-Klasse oder eine Schnittstelle darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-239">The <see cref="T:System.Type" /> from which the current <see cref="T:System.Type" /> directly inherits, or <see langword="null" /> if the current <see langword="Type" /> represents the <see cref="T:System.Object" /> class or an interface.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-240">Der Basistyp ist der Typ, von dem der aktuelle Typ direkt erbt.</span><span class="sxs-lookup"><span data-stu-id="2da29-240">The base type is the type from which the current type directly inherits.</span></span> <span data-ttu-id="2da29-241"><xref:System.Object> ist die einzige Art, die aus diesem Grund keinen Basistyp `null` wird zurückgegeben, als der Basistyp des <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="2da29-241"><xref:System.Object> is the only type that does not have a base type, therefore `null` is returned as the base type of <xref:System.Object>.</span></span>  
  
 <span data-ttu-id="2da29-242">Schnittstellen werden von keinem oder mehreren Basisschnittstellen erben. Diese Eigenschaft daher gibt `null` Wenn die `Type` Objekt stellt eine Schnittstelle dar.</span><span class="sxs-lookup"><span data-stu-id="2da29-242">Interfaces inherit from zero or more base interfaces; therefore, this property returns `null` if the `Type` object represents an interface.</span></span> <span data-ttu-id="2da29-243">Die Basisschnittstellen können bestimmt werden, mit <xref:System.Type.GetInterfaces%2A> oder <xref:System.Type.FindInterfaces%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-243">The base interfaces can be determined with <xref:System.Type.GetInterfaces%2A> or <xref:System.Type.FindInterfaces%2A>.</span></span>  
  
 <span data-ttu-id="2da29-244">Wenn die aktuelle <xref:System.Type> einen konstruierter generischen Typ darstellt, die der Basistyp Version stellt die generische Argumente.</span><span class="sxs-lookup"><span data-stu-id="2da29-244">If the current <xref:System.Type> represents a constructed generic type, the base type reflects the generic arguments.</span></span> <span data-ttu-id="2da29-245">Betrachten Sie beispielsweise die folgenden Deklarationen:</span><span class="sxs-lookup"><span data-stu-id="2da29-245">For example, consider the following declarations:</span></span>  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="2da29-246">Für den konstruierten Typ `C<int>` (`C(Of Integer)` in Visual Basic), wird die <xref:System.Type.BaseType%2A> -Eigenschaft gibt `B<int>`.</span><span class="sxs-lookup"><span data-stu-id="2da29-246">For the constructed type `C<int>` (`C(Of Integer)` in Visual Basic), the <xref:System.Type.BaseType%2A> property returns `B<int>`.</span></span>  
  
 <span data-ttu-id="2da29-247">Wenn die aktuelle <xref:System.Type> stellt einen Typparameter einer generischen Typdefinition <xref:System.Type.BaseType%2A> gibt die Class-Einschränkung, d. h. die Klasse, die die Typparameter erben muss.</span><span class="sxs-lookup"><span data-stu-id="2da29-247">If the current <xref:System.Type> represents a type parameter of a generic type definition, <xref:System.Type.BaseType%2A> returns the class constraint, that is, the class the type parameter must inherit.</span></span> <span data-ttu-id="2da29-248">Es ist keine klasseneinschränkung <xref:System.Type.BaseType%2A> gibt <xref:System.Object?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-248">If there is no class constraint, <xref:System.Type.BaseType%2A> returns <xref:System.Object?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="2da29-249">Diese Eigenschaft ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="2da29-249">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-250">Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Type.BaseType%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-250">The following example demonstrates using the <xref:System.Type.BaseType%2A> property.</span></span>  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 <span data-ttu-id="2da29-251">Im folgenden Beispiel wird die Rekursion zum Auflisten der vollständige Vererbungshierarchie jede Klasse in einer Assembly gefunden.</span><span class="sxs-lookup"><span data-stu-id="2da29-251">The following example uses recursion to list the complete inheritance hierarchy of each class found in an assembly.</span></span> <span data-ttu-id="2da29-252">Im Beispiel definiert eine Klasse namens `C` abgeleitet, die eine Klasse namens `B`, das wiederum leitet sich von einer Klasse mit dem Namen `A`.</span><span class="sxs-lookup"><span data-stu-id="2da29-252">The example defines a class named `C` that derives from a class named `B`, which, in turn, derives from a class named `A`.</span></span>  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-253">Ruft einen Wert ab, der angibt, ob das aktuelle <see cref="T:System.Type" />-Objekt über Typparameter verfügt, die nicht durch bestimmte Typen ersetzt wurden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-253">Gets a value indicating whether the current <see cref="T:System.Type" /> object has type parameters that have not been replaced by specific types.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-254">
            <see langword="true" />, wenn das <see cref="T:System.Type" />-Objekt selbst ein generischer Parametertyp ist oder über Typparameter verfügt, für die keine bestimmten Typen angegeben wurden, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-254">
              <see langword="true" /> if the <see cref="T:System.Type" /> object is itself a generic type parameter or has type parameters for which specific types have not been supplied; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-255">Um eine Instanz eines Typs zu erstellen, muss keine generischen Typdefinitionen oder offen konstruierte Typen in den Typargumenten des Typs selbst und alle einschließenden generischen Typen und Elemente des Typs vorhanden sein.</span><span class="sxs-lookup"><span data-stu-id="2da29-255">In order to create an instance of a type, there must be no generic type definitions or open constructed types in the type arguments of the type itself, in any enclosing generic types, or in any elements of the type.</span></span> <span data-ttu-id="2da29-256">Anders ausgedrückt: Dies ist bei überprüft rekursiv, der Typ darf keine generische Typparameter.</span><span class="sxs-lookup"><span data-stu-id="2da29-256">Another way of saying this is that when examined recursively, the type must contain no generic type parameters.</span></span>  
  
 <span data-ttu-id="2da29-257">Da Typen beliebig komplex sein können, ist dieser Feststellung schwierig.</span><span class="sxs-lookup"><span data-stu-id="2da29-257">Since types can be arbitrarily complex, making this determination is difficult.</span></span> <span data-ttu-id="2da29-258">Der Einfachheit halber und reduziert die Wahrscheinlichkeit des Fehlers, der <xref:System.Type.ContainsGenericParameters%2A> Eigenschaft bietet eine standardmöglichkeit zum unterscheiden von geschlossener konstruierter Typen, die instanziiert werden kann, und offen konstruierte Typen, die nicht.</span><span class="sxs-lookup"><span data-stu-id="2da29-258">For convenience and to reduce the chance of error, the <xref:System.Type.ContainsGenericParameters%2A> property provides a standard way to distinguish between closed constructed types, which can be instantiated, and open constructed types, which cannot.</span></span> <span data-ttu-id="2da29-259">Wenn die <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft gibt `true`, der Typ kann nicht instanziiert werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-259">If the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, the type cannot be instantiated.</span></span>  
  
 <span data-ttu-id="2da29-260">Die <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft sucht rekursiv für Typparameter angegeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-260">The <xref:System.Type.ContainsGenericParameters%2A> property searches recursively for type parameters.</span></span> <span data-ttu-id="2da29-261">Es gibt z. B. `true` für ein Array, dessen Elemente sind `A<T>` (`A(Of T)` in Visual Basic), auch wenn das Array selbst nicht generisch ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-261">For example, it returns `true` for an array whose elements are type `A<T>` (`A(Of T)` in Visual Basic), even though the array is not itself generic.</span></span> <span data-ttu-id="2da29-262">Vergleichen Sie dies mit dem Verhalten von der <xref:System.Type.IsGenericType%2A> Eigenschaft, die zurückgibt `false` für Arrays.</span><span class="sxs-lookup"><span data-stu-id="2da29-262">Contrast this with the behavior of the <xref:System.Type.IsGenericType%2A> property, which returns `false` for arrays.</span></span>  
  
 <span data-ttu-id="2da29-263">Für eine Gruppe von Beispielklassen und eine Tabelle, die Werte der <xref:System.Type.ContainsGenericParameters%2A> Eigenschaft finden Sie unter <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-263">For a set of example classes and a table showing the values of the <xref:System.Type.ContainsGenericParameters%2A> property, see <xref:System.Type.IsGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-264">Im folgenden Beispiel wird eine generische Klasse mit zwei Typparametern und definiert dann eine zweite generische Klasse, die von der ersten Klasse abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-264">The following example defines a generic class with two type parameters and then defines a second generic class that derives from the first class.</span></span> <span data-ttu-id="2da29-265">Die Basis der abgeleiteten Klasse verfügt über zwei Typargumente: Erstens <xref:System.Int32> und das zweite ist ein Typparameter des abgeleiteten Typs.</span><span class="sxs-lookup"><span data-stu-id="2da29-265">The derived class's base class has two type arguments: the first is <xref:System.Int32> and the second is a type parameter of the derived type.</span></span> <span data-ttu-id="2da29-266">Das Beispiel zeigt Informationen zu diesen generischen Klassen, von gemeldeten einschließlich die Positionen der <xref:System.Type.GenericParameterPosition%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-266">The example displays information about these generic classes, including the positions reported by the <xref:System.Type.GenericParameterPosition%2A> property.</span></span>  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-267">Ruft eine <see cref="T:System.Reflection.MethodBase" /> ab, die die deklarierende Methode darstellt, wenn der aktuelle <see cref="T:System.Type" /> einen Typparameter einer generischen Methode darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-267">Gets a <see cref="T:System.Reflection.MethodBase" /> that represents the declaring method, if the current <see cref="T:System.Type" /> represents a type parameter of a generic method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-268">Wenn der aktuelle <see cref="T:System.Type" /> einen Typparameter einer generischen Methode darstellt, eine <see cref="T:System.Reflection.MethodBase" />, die die deklarierende Methode darstellt, andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-268">If the current <see cref="T:System.Type" /> represents a type parameter of a generic method, a <see cref="T:System.Reflection.MethodBase" /> that represents declaring method; otherwise, <see langword="null" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-269">Die deklarierende Methode ist eine generische Methodendefinition.</span><span class="sxs-lookup"><span data-stu-id="2da29-269">The declaring method is a generic method definition.</span></span> <span data-ttu-id="2da29-270">D. h. wenn <xref:System.Type.DeclaringMethod%2A> keinen zurückgibt `null`, klicken Sie dann `DeclaringMethod.IsGenericMethodDefinition` gibt `true`.</span><span class="sxs-lookup"><span data-stu-id="2da29-270">That is, if <xref:System.Type.DeclaringMethod%2A> does not return `null`, then `DeclaringMethod.IsGenericMethodDefinition` returns `true`.</span></span>  
  
 <span data-ttu-id="2da29-271">Die <xref:System.Type.DeclaringType%2A> und <xref:System.Type.DeclaringMethod%2A> Eigenschaften zu identifizieren, die generische Typdefinition oder generische Methodendefinition, die in der der generische Typparameter ursprünglich definiert wurde:</span><span class="sxs-lookup"><span data-stu-id="2da29-271">The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:</span></span>  
  
-   <span data-ttu-id="2da29-272">Wenn die <xref:System.Type.DeclaringMethod%2A> Eigenschaft gibt eine <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.MethodInfo> stellt eine generische Methodendefinition und der aktuelle <xref:System.Type> -Objekt einen Typparameter der generischen Methodendefinition darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-272">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="2da29-273">Wenn die <xref:System.Type.DeclaringMethod%2A> -Eigenschaft gibt `null`, und klicken Sie dann die <xref:System.Type.DeclaringType%2A> -Eigenschaft gibt immer eine <xref:System.Type> Objekt, das eine generische Typdefinition ist, und das aktuelle darstellt <xref:System.Type> Objekt einen Typparameter eines generischen Typs darstellt Definition.</span><span class="sxs-lookup"><span data-stu-id="2da29-273">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
-   <span data-ttu-id="2da29-274">Abrufen der <xref:System.Type.DeclaringMethod%2A> Eigenschaft für einen Typ, dessen <xref:System.Type.IsGenericParameter%2A> Eigenschaft `false` löst eine <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="2da29-274">Getting the <xref:System.Type.DeclaringMethod%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="2da29-275">Die <xref:System.Reflection.MethodBase> der zurückgegeben wird, indem die <xref:System.Type.DeclaringMethod%2A> Eigenschaft ist entweder eine <xref:System.Reflection.MethodInfo> im Fall einer generischen Methode oder eine <xref:System.Reflection.ConstructorInfo> bei einem generischen Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="2da29-275">The <xref:System.Reflection.MethodBase> that is returned by the <xref:System.Type.DeclaringMethod%2A> property is either a <xref:System.Reflection.MethodInfo> in the case of a generic method, or a <xref:System.Reflection.ConstructorInfo> in the case of a generic constructor.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-276">In .NET Framework, Version 2.0 sind generische Konstruktoren nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="2da29-276">In the .NET Framework version 2.0, generic constructors are not supported.</span></span>  
  
 <span data-ttu-id="2da29-277">Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-277">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-278">Das folgende Codebeispiel definiert eine Klasse, die eine generische Methode und weist ein Type-Argument an die Methode aufruft, die sich ergebende konstruierte generische Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-278">The following code example defines a class that has a generic method, assigns a type argument to the method, and invokes the resulting constructed generic method.</span></span> <span data-ttu-id="2da29-279">Es zeigt auch Informationen zur Definition der generischen Methode und die konstruierte Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-279">It also displays information about the generic method definition and the constructed method.</span></span> <span data-ttu-id="2da29-280">Beim Anzeigen von Informationen über die Typparameter der generischen Methodendefinition, in der `DisplayGenericMethodInfo` -Methode der Beispielcode zeigt den Wert von der <xref:System.Type.DeclaringMethod%2A> -Eigenschaft für generische Typparameter der Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-280">When displaying information about the type parameters of the generic method definition, in the `DisplayGenericMethodInfo` method, the example code shows the value of the <xref:System.Type.DeclaringMethod%2A> property for the method's generic type parameter.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-281">Ruft den Typ ab, der den aktuellen geschachtelten oder generischen Typparameter deklariert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-281">Gets the type that declares the current nested type or generic type parameter.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-282">Ein <see cref="T:System.Type" />-Objekt, das den einschließenden Typ darstellt, wenn es sich bei dem aktuellen Typ um einen geschachtelten Typ handelt. Die generische Typdefinition, wenn es sich bei dem aktuellen Typ um einen Typparameter eines generischen Typs handelt. Der Typ, der die generische Methode deklariert, wenn es sich bei dem aktuellen Typ um einen Typparameter einer generischen Methode handelt. Andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-282">A <see cref="T:System.Type" /> object representing the enclosing type, if the current type is a nested type; or the generic type definition, if the current type is a type parameter of a generic type; or the type that declares the generic method, if the current type is a type parameter of a generic method; otherwise, <see langword="null" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-283">Wenn die aktuelle <xref:System.Type> -Objekt einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft die generische Typdefinition.</span><span class="sxs-lookup"><span data-stu-id="2da29-283">If the current <xref:System.Type> object represents a type parameter of a generic type, this property returns the generic type definition.</span></span>  
  
 <span data-ttu-id="2da29-284">Wenn die aktuelle <xref:System.Type> -Objekt einen Typparameter einer generischen Methode darstellt, gibt diese Eigenschaft den Typ, die generischen Methodendefinition enthält.</span><span class="sxs-lookup"><span data-stu-id="2da29-284">If the current <xref:System.Type> object represents a type parameter of a generic method, this property returns the type that contains the generic method definition.</span></span> <span data-ttu-id="2da29-285">Wenn der Typ generisch ist, wird die generische Typdefinition zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-285">If the type is generic, the generic type definition is returned.</span></span> <span data-ttu-id="2da29-286">Der folgende Code gibt also die generische Typdefinition von der <xref:System.Collections.Generic.List%601> generische Klasse, die enthält die <xref:System.Collections.Generic.List%601.ConvertAll%2A> generische Methode:</span><span class="sxs-lookup"><span data-stu-id="2da29-286">That is, the following code returns the generic type definition of the <xref:System.Collections.Generic.List%601> generic class, which contains the <xref:System.Collections.Generic.List%601.ConvertAll%2A> generic method:</span></span>  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="2da29-287">Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, die <xref:System.Type.DeclaringType%2A> und <xref:System.Type.DeclaringMethod%2A> Eigenschaften zu identifizieren, die generische Typdefinition oder generische Methodendefinition, in dem der generische Typparameter, ursprünglich definiert wurde:</span><span class="sxs-lookup"><span data-stu-id="2da29-287">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, the <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:</span></span>  
  
-   <span data-ttu-id="2da29-288">Wenn die <xref:System.Type.DeclaringMethod%2A> Eigenschaft gibt eine <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.MethodInfo> stellt eine generische Methodendefinition und der aktuelle <xref:System.Type> -Objekt einen Typparameter der generischen Methodendefinition darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-288">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="2da29-289">Wenn die <xref:System.Type.DeclaringMethod%2A> -Eigenschaft gibt `null`, und klicken Sie dann die <xref:System.Type.DeclaringType%2A> -Eigenschaft gibt immer eine <xref:System.Type> Objekt, das eine generische Typdefinition ist, und das aktuelle darstellt <xref:System.Type> Objekt einen Typparameter eines generischen Typs darstellt Definition.</span><span class="sxs-lookup"><span data-stu-id="2da29-289">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
-   <span data-ttu-id="2da29-290">Abrufen der <xref:System.Type.DeclaringType%2A> Eigenschaft für einen Typ, dessen <xref:System.Type.IsGenericParameter%2A> Eigenschaft `false` löst eine <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="2da29-290">Getting the <xref:System.Type.DeclaringType%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-291">In diesem Beispiel wird den deklarierenden Typ von einer Methode in einer abgeleiteten Klasse angezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-291">This example displays the declaring type of a method in a derived class.</span></span>  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-292">Ruft einen Verweis auf den Standardbinder ab, der interne Regeln für die Auswahl der passenden Member implementiert, die von <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> aufgerufen werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-292">Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-293">Ein Verweis auf den vom System verwendeten Standardbinder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-293">A reference to the default binder used by the system.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-294">Der Standardbinder bereitgestellt, mit der common Language Runtime ist außer den speziellen Umständen anwendbar.</span><span class="sxs-lookup"><span data-stu-id="2da29-294">The default binder provided with the common language runtime is applicable in all but the most specialized circumstances.</span></span> <span data-ttu-id="2da29-295">Wenn Sie benötigen einen Binder, mit denen folgt Regeln, die von den von der angegebenen Standardbinder unterscheiden definiert einen abgeleiteten Typ aus der <xref:System.Reflection.Binder> Klasse, und übergeben Sie eine Instanz dieses Typs unter Verwendung der `binder` Parameter eines der <xref:System.Type.InvokeMember%2A> Überladungen.</span><span class="sxs-lookup"><span data-stu-id="2da29-295">If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <xref:System.Reflection.Binder> class and pass an instance of that type using the `binder` parameter of one of the <xref:System.Type.InvokeMember%2A> overloads.</span></span>  
  
 <span data-ttu-id="2da29-296">Reflektion modelliert die Zugriffsregeln des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="2da29-296">Reflection models the accessibility rules of the common type system.</span></span> <span data-ttu-id="2da29-297">Z. B. wenn der Aufrufer in der gleichen Assembly befindet, benötigt der Aufrufer keine besondere Berechtigungen für interne Member.</span><span class="sxs-lookup"><span data-stu-id="2da29-297">For example, if the caller is in the same assembly, the caller does not need special permissions for internal members.</span></span> <span data-ttu-id="2da29-298">Andernfalls muss der Aufrufer <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="2da29-298">Otherwise, the caller needs <xref:System.Security.Permissions.ReflectionPermission>.</span></span> <span data-ttu-id="2da29-299">Dies ist konsistent mit der Suche nach Membern, die geschützt werden, private und usw. ein.</span><span class="sxs-lookup"><span data-stu-id="2da29-299">This is consistent with lookup of members that are protected, private, and so on.</span></span>  
  
 <span data-ttu-id="2da29-300">Im Allgemeinen gilt <xref:System.Reflection.Binder.ChangeType%2A> sollten ausführen, nur erweiternde Konvertierungen, die keine Daten verloren gehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-300">The general principle is that <xref:System.Reflection.Binder.ChangeType%2A> should perform only widening conversions, which never lose data.</span></span> <span data-ttu-id="2da29-301">Ein Beispiel für eine erweiternde Konvertierung ist eine Umwandlung einer 32-Bit-Ganzzahl mit Vorzeichen in einen Wert einer 64-Bit-Ganzzahl mit Vorzeichen.</span><span class="sxs-lookup"><span data-stu-id="2da29-301">An example of a widening conversion is converting a value that is a 32-bit signed integer to a value that is a 64-bit signed integer.</span></span> <span data-ttu-id="2da29-302">Dies ist von der eine einschränkende Konvertierung unterschieden, die Daten verloren gehen können.</span><span class="sxs-lookup"><span data-stu-id="2da29-302">This is distinguished from a narrowing conversion, which may lose data.</span></span> <span data-ttu-id="2da29-303">Ein Beispiel für eine einschränkende Konvertierung ist eine 64-Bit-Ganzzahl mit Vorzeichen in eine 32-Bit-Ganzzahl mit Vorzeichen konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-303">An example of a narrowing conversion is converting a 64-bit signed integer to a 32-bit signed integer.</span></span>  
  
 <span data-ttu-id="2da29-304">Die folgende Tabelle enthält die Konvertierungen, die von der Standardbinder unterstützt.</span><span class="sxs-lookup"><span data-stu-id="2da29-304">The following table lists the conversions supported by the default binder.</span></span>  
  
|<span data-ttu-id="2da29-305">Quelltyp</span><span class="sxs-lookup"><span data-stu-id="2da29-305">Source Type</span></span>|<span data-ttu-id="2da29-306">Zieltyp</span><span class="sxs-lookup"><span data-stu-id="2da29-306">Target Type</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="2da29-307">Beliebiger Typ</span><span class="sxs-lookup"><span data-stu-id="2da29-307">Any type</span></span>|<span data-ttu-id="2da29-308">Der Basistyp.</span><span class="sxs-lookup"><span data-stu-id="2da29-308">Its base type.</span></span>|  
|<span data-ttu-id="2da29-309">Beliebiger Typ</span><span class="sxs-lookup"><span data-stu-id="2da29-309">Any type</span></span>|<span data-ttu-id="2da29-310">Die Schnittstelle implementiert.</span><span class="sxs-lookup"><span data-stu-id="2da29-310">The interface it implements.</span></span>|  
|<span data-ttu-id="2da29-311">Char</span><span class="sxs-lookup"><span data-stu-id="2da29-311">Char</span></span>|<span data-ttu-id="2da29-312">Unt16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="2da29-312">Unt16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="2da29-313">Byte</span><span class="sxs-lookup"><span data-stu-id="2da29-313">Byte</span></span>|<span data-ttu-id="2da29-314">Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="2da29-314">Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="2da29-315">SByte</span><span class="sxs-lookup"><span data-stu-id="2da29-315">SByte</span></span>|<span data-ttu-id="2da29-316">Int16, Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="2da29-316">Int16, Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="2da29-317">UInt16</span><span class="sxs-lookup"><span data-stu-id="2da29-317">UInt16</span></span>|<span data-ttu-id="2da29-318">UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="2da29-318">UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="2da29-319">Int16</span><span class="sxs-lookup"><span data-stu-id="2da29-319">Int16</span></span>|<span data-ttu-id="2da29-320">Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="2da29-320">Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="2da29-321">UInt32</span><span class="sxs-lookup"><span data-stu-id="2da29-321">UInt32</span></span>|<span data-ttu-id="2da29-322">UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="2da29-322">UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="2da29-323">Int32</span><span class="sxs-lookup"><span data-stu-id="2da29-323">Int32</span></span>|<span data-ttu-id="2da29-324">Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="2da29-324">Int64, Single, Double</span></span>|  
|<span data-ttu-id="2da29-325">UInt64</span><span class="sxs-lookup"><span data-stu-id="2da29-325">UInt64</span></span>|<span data-ttu-id="2da29-326">Single, Double</span><span class="sxs-lookup"><span data-stu-id="2da29-326">Single, Double</span></span>|  
|<span data-ttu-id="2da29-327">Int64</span><span class="sxs-lookup"><span data-stu-id="2da29-327">Int64</span></span>|<span data-ttu-id="2da29-328">Single, Double</span><span class="sxs-lookup"><span data-stu-id="2da29-328">Single, Double</span></span>|  
|<span data-ttu-id="2da29-329">Single</span><span class="sxs-lookup"><span data-stu-id="2da29-329">Single</span></span>|<span data-ttu-id="2da29-330">Double</span><span class="sxs-lookup"><span data-stu-id="2da29-330">Double</span></span>|  
|<span data-ttu-id="2da29-331">Ohne Verweis</span><span class="sxs-lookup"><span data-stu-id="2da29-331">Non-reference</span></span>|<span data-ttu-id="2da29-332">Per-Verweis.</span><span class="sxs-lookup"><span data-stu-id="2da29-332">By-reference.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="2da29-333">Im folgenden Beispiel wird den Standardbinder aus der `DefaultBinder` -Eigenschaft, und ruft Sie ein Mitglied MyClass durch Übergeben der `DefaultBinder` Wert als Parameter an <xref:System.Type.InvokeMember%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-333">The following example gets the default binder from the `DefaultBinder` property, and invokes a member of MyClass by passing the `DefaultBinder` value as a parameter to <xref:System.Type.InvokeMember%2A>.</span></span>  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-334">Trennt Namen im Namespace des <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-334">Separates names in the namespace of the <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="2da29-335">Dieses Feld ist schreibgeschützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-335">This field is read-only.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-336">Stellt ein leeres Array vom <see cref="T:System.Type" />-Typ dar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-336">Represents an empty array of type <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="2da29-337">Dieses Feld ist schreibgeschützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-337">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="2da29-338">Das folgende Codebeispiel zeigt die `EmptyTypes` Feld verwendet wird, in einem von der `GetConstructor` Methoden zum Abrufen eines Konstruktors, der keine Parameter akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="2da29-338">The following code example shows the `EmptyTypes` field used in one of the `GetConstructor` methods to get a constructor that takes no parameters.</span></span>  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-339">Bestimmt, ob der zugrunde liegende Systemtyp des aktuellen <see cref="T:System.Type" /> mit dem zugrunde liegende Systemtyp des angegebenen <see cref="T:System.Object" /> oder <see cref="T:System.Type" /> übereinstimmt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-339">Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Object" /> or <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="2da29-340">Das Objekt, dessen zugrunde liegender Systemtyp mit dem zugrunde liegenden Systemtyp des aktuellen <see cref="T:System.Type" /> verglichen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-340">The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="2da29-341">
            <c>o</c> muss in ein Objekt vom Typ <see cref="T:System.Type" /> umgewandelt oder konvertiert werden können, damit der Vergleich erfolgreich durchgeführt werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-341">For the comparison to succeed, <c>o</c> must be able to be cast or converted to an object of type   <see cref="T:System.Type" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-342">Bestimmt, ob der zugrunde liegende Systemtyp des aktuellen <see cref="T:System.Type" />-Objekts mit dem zugrunde liegenden Systemtyp des angegebenen <see cref="T:System.Object" />-Objekts übereinstimmt</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-342">Determines if the underlying system type of the current <see cref="T:System.Type" /> object is the same as the underlying system type of the specified <see cref="T:System.Object" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-343">
            <see langword="true" />, wenn der zugrunde liegende Systemtyp von <paramref name="o" /> mit dem zugrunde liegenden Systemtyp des aktuellen <see cref="T:System.Type" /> übereinstimmt, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-343">
              <see langword="true" /> if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="2da29-344">Diese Methode gibt auch <see langword="false" /> zurück, wenn:</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-344">This method also returns <see langword="false" /> if: .</span>
          </span>  
  
-   <span data-ttu-id="2da29-345"><paramref name="o" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="2da29-345"><paramref name="o" /> is <see langword="null" />.</span></span>  
  
-   <span data-ttu-id="2da29-346"><paramref name="o" /> nicht in ein <see cref="T:System.Type" />-Objekt umgewandelt oder konvertiert werden kann.</span><span class="sxs-lookup"><span data-stu-id="2da29-346"><paramref name="o" /> cannot be cast or converted to a <see cref="T:System.Type" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-347">Diese Methode überschreibt <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-347">This method overrides <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2da29-348">Seinem Schattenwurf `o` auf ein Objekt des Typs <xref:System.Type> und ruft die <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-348">It casts `o` to an object of type <xref:System.Type> and calls the <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-349">Im folgenden Beispiel wird <xref:System.Type.Equals%28System.Object%29> verschiedenen vergleichen <xref:System.Type> Objektinstanzen mit verschiedenen <xref:System.Object> Instanzen.</span><span class="sxs-lookup"><span data-stu-id="2da29-349">The following example uses <xref:System.Type.Equals%28System.Object%29> to compare various <xref:System.Type> object instances with various <xref:System.Object> instances.</span></span>  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 <span data-ttu-id="2da29-350">Zwei Dinge sind besonders erwähnenswert zum Beispiel:</span><span class="sxs-lookup"><span data-stu-id="2da29-350">Two things are particularly worth noting about the example:</span></span>  
  
-   <span data-ttu-id="2da29-351">Beim Vergleich von einer <xref:System.Type> -Objekt, das eine ganze Zahl mit darstellt eine <xref:System.Reflection.TypeInfo> -Objekt, das eine ganze Zahl zurückgegeben darstellt `true` da <xref:System.Reflection.TypeInfo> stammt aus <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="2da29-351">The comparison of a <xref:System.Type> object that represents an integer with a <xref:System.Reflection.TypeInfo> object that represents an integer return `true` because <xref:System.Reflection.TypeInfo> is derived from <xref:System.Type>.</span></span>  
  
-   <span data-ttu-id="2da29-352">Beim Vergleich von einer <xref:System.Type> Objekt, das darstellt eine <xref:System.Collections.Generic.IList%601> Objekt (ein offener generischer Typ) mit einer `List(Of String)` -Objekt (einen geschlossenen generischen Typs) zurückgibt `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-352">The comparison of a  <xref:System.Type> object that represents a <xref:System.Collections.Generic.IList%601> object (an open generic type) with a `List(Of String)` object (a closed generic type) returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="2da29-353">Das Objekt, dessen zugrunde liegender Systemtyp mit dem zugrunde liegenden Systemtyp des aktuellen <see cref="T:System.Type" /> verglichen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-353">The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-354">Bestimmt, ob der zugrunde liegende Systemtyp des aktuellen <see cref="T:System.Type" /> mit dem zugrunde liegenden Systemtyp des angegebenen <see cref="T:System.Type" /> übereinstimmt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-354">Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-355">
            <see langword="true" />, wenn der zugrunde liegende Systemtyp von <paramref name="o" /> mit dem zugrunde liegenden Systemtyp des aktuellen <see cref="T:System.Type" /> übereinstimmt, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-355">
              <see langword="true" /> if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="2da29-356">Im folgenden Beispiel wird `Equals` , zwei Typen verglichen werden soll.</span><span class="sxs-lookup"><span data-stu-id="2da29-356">The following example uses `Equals` to compare two types.</span></span>  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-357">Stellt den für Attribute verwendeten Memberfilter dar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-357">Represents the member filter used on attributes.</span>
          </span>
          <span data-ttu-id="2da29-358">Dieses Feld ist schreibgeschützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-358">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-359">Dieses Feld enthält einen Verweis auf den Delegaten verwendet werden, indem Sie die <xref:System.Type.FindMembers%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-359">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="2da29-360">Von diesem Delegaten gekapselte Methode akzeptiert zwei Parameter: das erste ist ein <xref:System.Reflection.MemberInfo> Objekt und das zweite ist ein `Object`.</span><span class="sxs-lookup"><span data-stu-id="2da29-360">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="2da29-361">Die Methode bestimmt, ob die `MemberInfo` Objekt übereinstimmt, die vom angegebenen Kriterien die `Object`.</span><span class="sxs-lookup"><span data-stu-id="2da29-361">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="2da29-362">Die `Object` möglicherweise den Wert eines der Felder in den Klassen zugeordnet <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, oder <xref:System.Reflection.MethodImplAttributes>.</span><span class="sxs-lookup"><span data-stu-id="2da29-362">The `Object` may be assigned the value of any one of the fields on the classes <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, or <xref:System.Reflection.MethodImplAttributes>.</span></span>  
  
 <span data-ttu-id="2da29-363">Z. B. die `Object` kann der Wert eines Felds aus zugewiesen werden `FieldAttributes` wie "Public".</span><span class="sxs-lookup"><span data-stu-id="2da29-363">For example, the `Object` can be assigned the value of a field from `FieldAttributes` such as Public.</span></span> <span data-ttu-id="2da29-364">In diesem Fall, wenn die `FilterAttribute` Delegat aufgerufen wird, wird zurückgegeben, die `true` nur, wenn die Methode über dargestellt die `MemberInfo` Objekt mit dem öffentlichen Feldattribut in den Metadaten ergänzt wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-364">In that case, when the `FilterAttribute` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object is decorated with the public field attribute in metadata.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-365">Im folgenden Beispiel wird die `FilterAttribute` delegieren, übergibt sie als Parameter an die <xref:System.Type.FindMembers%2A> -Methode, und zeigt die angegebenen Elemente und ihre Attribute.</span><span class="sxs-lookup"><span data-stu-id="2da29-365">The following example gets the `FilterAttribute` delegate, passes it as a parameter to the <xref:System.Type.FindMembers%2A> method, and displays the specified members and their attributes.</span></span>  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-366">Stellt den für Namen verwendeten Memberfilter mit Beachtung der Groß-/Kleinschreibung dar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-366">Represents the case-sensitive member filter used on names.</span>
          </span>
          <span data-ttu-id="2da29-367">Dieses Feld ist schreibgeschützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-367">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-368">Dieses Feld enthält einen Verweis auf den Delegaten verwendet werden, indem Sie die <xref:System.Type.FindMembers%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-368">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="2da29-369">Von diesem Delegaten gekapselte Methode akzeptiert zwei Parameter: das erste ist ein <xref:System.Reflection.MemberInfo> Objekt und das zweite ist ein `Object`.</span><span class="sxs-lookup"><span data-stu-id="2da29-369">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="2da29-370">Die Methode bestimmt, ob die `MemberInfo` Objekt übereinstimmt, die vom angegebenen Kriterien die `Object`.</span><span class="sxs-lookup"><span data-stu-id="2da29-370">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="2da29-371">Die `Object` ist einen Zeichenfolgenwert, darunter ein nachstehender möglicherweise zugewiesen "\*" Platzhalterzeichen.</span><span class="sxs-lookup"><span data-stu-id="2da29-371">The `Object` is assigned a string value, which may include a trailing "\*" wildcard character.</span></span> <span data-ttu-id="2da29-372">Nur Ende Zeichenfolge mit Platzhalterzeichen werden unterstützt.</span><span class="sxs-lookup"><span data-stu-id="2da29-372">Only wildcard end string matching is supported.</span></span>  
  
 <span data-ttu-id="2da29-373">Z. B. die `Object` kann den Wert "Byte \*" zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-373">For example, the `Object` may be assigned the value "Byte\*".</span></span> <span data-ttu-id="2da29-374">In diesem Fall, wenn die `FilterName` Delegat aufgerufen wird, wird zurückgegeben, die `true` nur, wenn die Methode über dargestellt die `MemberInfo` Objekt verfügt über einen Namen, die mit "Byte" beginnt.</span><span class="sxs-lookup"><span data-stu-id="2da29-374">In that case, when the `FilterName` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object has a name that begins with "Byte".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-375">Im folgenden Codebeispiel ruft die zugeordneten die benutzerdefinierten Methoden `Application` Typ.</span><span class="sxs-lookup"><span data-stu-id="2da29-375">The following code example gets the methods associated with the user-defined `Application` type.</span></span>  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-376">Stellt den für Namen verwendeten Memberfilter ohne Beachtung der Groß-/Kleinschreibung dar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-376">Represents the case-insensitive member filter used on names.</span>
          </span>
          <span data-ttu-id="2da29-377">Dieses Feld ist schreibgeschützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-377">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-378">Dieses Feld enthält einen Verweis auf den Delegaten verwendet werden, indem Sie die <xref:System.Type.FindMembers%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-378">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="2da29-379">Von diesem Delegaten gekapselte Methode akzeptiert zwei Parameter: das erste ist ein <xref:System.Reflection.MemberInfo> Objekt und das zweite ist ein `Object`.</span><span class="sxs-lookup"><span data-stu-id="2da29-379">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="2da29-380">Die Methode bestimmt, ob die `MemberInfo` Objekt übereinstimmt, die vom angegebenen Kriterien die `Object`.</span><span class="sxs-lookup"><span data-stu-id="2da29-380">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="2da29-381">Die `Object` ist einen Zeichenfolgenwert, darunter ein nachstehender möglicherweise zugewiesen "\*" Platzhalterzeichen.</span><span class="sxs-lookup"><span data-stu-id="2da29-381">The `Object` is assigned a string value, which may include a trailing "\*" wildcard character.</span></span> <span data-ttu-id="2da29-382">Nur Ende Zeichenfolge mit Platzhalterzeichen werden unterstützt.</span><span class="sxs-lookup"><span data-stu-id="2da29-382">Only wildcard end string matching is supported.</span></span>  
  
 <span data-ttu-id="2da29-383">Z. B. die `Object` kann den Wert "ByTe \*" zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-383">For example, the `Object` may be assigned the value "ByTe\*".</span></span> <span data-ttu-id="2da29-384">In diesem Fall, wenn die `FilterName` Delegat wird aufgerufen, es wird nur dann true zurück, wenn die Methode von dargestellt die `MemberInfo` Objekt besitzt einen Namen, die mit "Byte", ignorieren Groß-/Kleinschreibung beginnt.</span><span class="sxs-lookup"><span data-stu-id="2da29-384">In that case, when the `FilterName` delegate is invoked, it will return true only if the method represented by the `MemberInfo` object has a name that begins with "byte", ignoring case.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-385">Im folgenden Beispiel wird die `MemberFilter` delegieren, übergibt sie als Parameter an die <xref:System.Type.FindMembers%2A> -Methode, und zeigt die Methoden und deren Attribute von der `String` -Klasse, die mit dem Buchstaben "c", die Groß-/Kleinschreibung Basiseigenschaft beginnen.</span><span class="sxs-lookup"><span data-stu-id="2da29-385">The following example gets the `MemberFilter` delegate, passes it as a parameter to the <xref:System.Type.FindMembers%2A> method, and displays the methods and their attributes of the `String` class that begin with the letter "c", disregarding the case.</span></span>  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter">
          <span data-ttu-id="2da29-386">Der Delegat, der die Schnittstellen anhand der Kriterien <c>filterCriteria</c> vergleicht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-386">The delegate that compares the interfaces against <c>filterCriteria</c>.</span>
          </span>
        </param>
        <param name="filterCriteria">
          <span data-ttu-id="2da29-387">Die Suchkriterien, die bestimmen, ob eine Schnittstelle in das zurückgegebene Array aufgenommen wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-387">The search criteria that determines whether an interface should be included in the returned array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-388">Gibt ein Array von <see cref="T:System.Type" />-Objekten zurück, die eine gefilterte Liste von Schnittstellen darstellen, die vom aktuellen <see cref="T:System.Type" /> implementiert oder geerbt wurden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-388">Returns an array of <see cref="T:System.Type" /> objects representing a filtered list of interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-389">Ein Array von <see cref="T:System.Type" />-Objekten, die eine gefilterte Liste von Schnittstellen darstellt, die durch den aktuellen <see cref="T:System.Type" /> implementiert oder geerbt wurden, oder ein leeres Array vom Typ <see cref="T:System.Type" />, wenn der aktuelle <see cref="T:System.Type" /> keine dem Filter entsprechenden Schnittstellen implementiert oder erbt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-389">An array of <see cref="T:System.Type" /> objects representing a filtered list of the interfaces implemented or inherited by the current <see cref="T:System.Type" />, or an empty array of type <see cref="T:System.Type" /> if no interfaces matching the filter are implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-390">Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-390">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="2da29-391">Die <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> und <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> Delegaten angegeben wird, indem Sie die <xref:System.Reflection.Module?displayProperty=nameWithType> Klasse kann auch verwendet werden, und in anstelle der der <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> delegieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-391">The <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> and <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> delegates supplied by the <xref:System.Reflection.Module?displayProperty=nameWithType> class may also be used, in lieu of the <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> delegate.</span></span>  
  
 <span data-ttu-id="2da29-392">Alle von dieser Klasse implementierten Schnittstellen werden während der Suche berücksichtigt, ob von einer Basisklasse oder von der Klasse selbst deklariert.</span><span class="sxs-lookup"><span data-stu-id="2da29-392">All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.</span></span>  
  
 <span data-ttu-id="2da29-393">Diese Methode sucht in der Basisklasse-Hierarchie, die Rückgabe aller der entsprechenden Schnittstellen, die jede Klasse, sowie alle entsprechenden implementiert Schnittstellen für jede von diesen Schnittstellen implementiert (d. h. der transitive Abschluss von übereinstimmenden Schnittstellen wird zurückgegeben).</span><span class="sxs-lookup"><span data-stu-id="2da29-393">This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned).</span></span> <span data-ttu-id="2da29-394">Es sind keine doppelten Schnittstellen zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-394">No duplicate interfaces are returned.</span></span>  
  
 <span data-ttu-id="2da29-395">Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, <xref:System.Type.FindInterfaces%2A> sucht alle Schnittstellen, die in die Einschränkungen für den Typparameter deklariert, und alle Schnittstellen geerbt wird, über die Schnittstellen in der die Einschränkungen deklariert.</span><span class="sxs-lookup"><span data-stu-id="2da29-395">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, <xref:System.Type.FindInterfaces%2A> searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints.</span></span> <span data-ttu-id="2da29-396">Wenn die aktuelle <xref:System.Type> stellt ein Typargument eines generischen Typs <xref:System.Type.FindInterfaces%2A> sucht alle Schnittstellen, die durch den Typ implementiert, und zwar unabhängig davon, ob sie Einschränkungen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="2da29-396">If the current <xref:System.Type> represents a type argument of a generic type, <xref:System.Type.FindInterfaces%2A> searches all the interfaces implemented by the type, whether or not they match constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-397"><xref:System.Type.FindInterfaces%2A> können generische Schnittstellen, auch auf Typen zurückgeben, die nicht generische sind.</span><span class="sxs-lookup"><span data-stu-id="2da29-397"><xref:System.Type.FindInterfaces%2A> can return generic interfaces, even on types that are not generic.</span></span> <span data-ttu-id="2da29-398">Beispielsweise kann ein nicht generischer Typ implementieren `IEnumerable<int>` (`IEnumerable(Of Integer)` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-398">For example, a nongeneric type might implement `IEnumerable<int>` (`IEnumerable(Of Integer)` in Visual Basic).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-399">Das folgende Beispiel sucht die angegebene Schnittstelle implementiert oder geerbt werden, durch den angegebenen Typ und zeigt dann die Schnittstellennamen.</span><span class="sxs-lookup"><span data-stu-id="2da29-399">The following example finds the specified interface implemented or inherited by the specified type, and then displays the interface names.</span></span>  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-400">
            <paramref name="filter" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-400">
              <paramref name="filter" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="2da29-401">Ein statischer Initialisierer wird aufgerufen und löst eine Ausnahme aus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-401">A static initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType">
          <span data-ttu-id="2da29-402">Ein Objekt, das den Typ der gesuchten Member angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-402">An object that indicates the type of member to search for.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="2da29-403">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-403">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="2da29-404">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-404">-or-</span>
          </span>
          <span data-ttu-id="2da29-405">0 (null), damit <see langword="null" /> zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-405">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="filter">
          <span data-ttu-id="2da29-406">Der Delegat, der die Vergleiche durchführt. Der Rückgabewert ist <see langword="true" />, wenn der gerade betrachtete Member den <c>filterCriteria</c> entspricht, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-406">The delegate that does the comparisons, returning <see langword="true" /> if the member currently being inspected matches the <c>filterCriteria</c> and <see langword="false" /> otherwise.</span>
          </span>
          <span data-ttu-id="2da29-407">Sie können die Delegaten <see langword="FilterAttribute" />, <see langword="FilterName" /> und <see langword="FilterNameIgnoreCase" /> dieser Klasse verwenden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-407">You can use the <see langword="FilterAttribute" />, <see langword="FilterName" />, and <see langword="FilterNameIgnoreCase" /> delegates supplied by this class.</span>
          </span>
          <span data-ttu-id="2da29-408">Der erste Delegat verwendet als Suchkriterien die Felder von <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> und <see langword="MethodImplAttributes" />, die anderen beiden Delegaten verwenden <see langword="String" />-Objekte als Suchkriterien.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-408">The first uses the fields of <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, and <see langword="MethodImplAttributes" /> as search criteria, and the other two delegates use <see langword="String" /> objects as the search criteria.</span>
          </span>
        </param>
        <param name="filterCriteria">
          <span data-ttu-id="2da29-409">Die Suchkriterien, die bestimmen, ob ein Member im Array von <see langword="MemberInfo" />-Objekten zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-409">The search criteria that determines whether a member is returned in the array of <see langword="MemberInfo" /> objects.</span>
          </span>
          <span data-ttu-id="2da29-410">Die Felder von <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> und <see langword="MethodImplAttributes" /> können zusammen mit dem <see langword="FilterAttribute" />-Delegaten dieser Klasse verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-410">The fields of <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, and <see langword="MethodImplAttributes" /> can be used in conjunction with the <see langword="FilterAttribute" /> delegate supplied by this class.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-411">Gibt ein gefiltertes Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten mit dem angegebenen Membertyp zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-411">Returns a filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-412">Ein gefiltertes Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten vom angegebenen Membertyp.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-412">A filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</span>
          </span>
          <span data-ttu-id="2da29-413">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-413">-or-</span>
          </span>
          <span data-ttu-id="2da29-414">Ein leeres Array vom <see cref="T:System.Reflection.MemberInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine den Filterkriterien entsprechenden Member vom <paramref name="memberType" />-Typ besitzt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-414">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have members of type <paramref name="memberType" /> that match the filter criteria.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-415">Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-415">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="2da29-416">Member enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.</span><span class="sxs-lookup"><span data-stu-id="2da29-416">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="2da29-417">Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Member in die Suche einbezogen werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-417">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="2da29-418">Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-418">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="2da29-419">Geben Sie `BindingFlags.Instance` Instanzmember in die Suche eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="2da29-419">Specify `BindingFlags.Instance` to include instance members in the search.</span></span>  
  
-   <span data-ttu-id="2da29-420">Geben Sie `BindingFlags.Static` auf statische Member in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-420">Specify `BindingFlags.Static` to include static members in the search.</span></span>  
  
-   <span data-ttu-id="2da29-421">Geben Sie `BindingFlags.Public` auf öffentliche Member in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-421">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="2da29-422">Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Member (d. h. private, interne und geschützte Member) in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-422">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
 <span data-ttu-id="2da29-423">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</span><span class="sxs-lookup"><span data-stu-id="2da29-423">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="2da29-424">`BindingFlags.DeclaredOnly` Suche nur die deklarierten Member der <xref:System.Type>, nicht die Elemente, die nur geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-424">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="2da29-425">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-425">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="2da29-426">Gültige Werte für <xref:System.Type.MemberType%2A> im definiert <xref:System.Reflection.MemberInfo>.</span><span class="sxs-lookup"><span data-stu-id="2da29-426">Valid values for <xref:System.Type.MemberType%2A> are defined in <xref:System.Reflection.MemberInfo>.</span></span> <span data-ttu-id="2da29-427">Wenn keine solchen Member gefunden werden, wird ein leeres Array zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-427">If no such members are found, an empty array is returned.</span></span>  
  
 <span data-ttu-id="2da29-428">Um die klasseninitialisierung (".cctor"), die mit dieser Methode zu erhalten, müssen Sie angeben <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-428">To get the class initializer (.cctor) using this method, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="2da29-429">Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-429">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="2da29-430">Wenn die aktuelle <xref:System.Type> stellt einen Typparameter einer generischen Typ- oder Methodendefinition, <xref:System.Type.FindMembers%2A> verarbeitet alle Member deklariert, indem der Class-Einschränkung und die schnittstelleneinschränkungen des Typparameters.</span><span class="sxs-lookup"><span data-stu-id="2da29-430">If the current <xref:System.Type> represents a type parameter of a generic type or generic method, <xref:System.Type.FindMembers%2A> processes any members declared by the class constraint and the interface constraints of the type parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-431">Das folgende Beispiel findet alle Elemente in einer Klasse, die die angegebenen Suchkriterien entsprechen, und zeigt dann die übereinstimmenden Elemente.</span><span class="sxs-lookup"><span data-stu-id="2da29-431">The following example finds all the members in a class that match the specified search criteria, and then displays the matched members.</span></span>  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-432">
            <paramref name="filter" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-432">
              <paramref name="filter" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-433">Ruft den voll vollqualifizierten Namen des Typs ab. Dies beinhaltet den Namespace, nicht jedoch die Assembly.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-433">Gets the fully qualified name of the type, including its namespace but not its assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-434">Der vollqualifizierte Name des Typs, einschließlich des Namespace, jedoch ausschließlich der Assembly, oder <see langword="null" />, wenn die aktuelle Instanz einen auf einem Typparameter basierenden generischen Typparameter, Arraytyp, Zeigertyp oder <see langword="byref" />-Typ oder einen generischen Typ darstellt, der keine generische Typdefinition ist, jedoch nicht aufgelöste Typparameter enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-434">The fully qualified name of the type, including its namespace but not its assembly; or <see langword="null" /> if the current instance represents a generic type parameter, an array type, pointer type, or <see langword="byref" /> type based on a type parameter, or a generic type that is not a generic type definition but contains unresolved type parameters.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-435">Z. B. den vollqualifizierten Namen des der <xref:System.String> ist `System.String`.</span><span class="sxs-lookup"><span data-stu-id="2da29-435">For example, the fully qualified name of the <xref:System.String> type is `System.String`.</span></span> <span data-ttu-id="2da29-436">Vergleichen Sie dies mit der Assembly qualifizierte Name zurückgegeben werden, indem Sie die <xref:System.Type.AssemblyQualifiedName%2A> -Eigenschaft, die den vollständigen Namen sowie den vollen Assemblynamens besteht.</span><span class="sxs-lookup"><span data-stu-id="2da29-436">Contrast this with the assembly-qualified name returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, which consists of the full name plus the full assembly name.</span></span>  
  
 <span data-ttu-id="2da29-437">Wenn der aktuelle Typ einen geschlossenen generischen Typ darstellt, die Typargumente in der Zeichenfolge zurückgegeben, durch die <xref:System.Type.FullName%2A> Eigenschaft sind, obwohl die Darstellung des generischen Typparameters selbst nicht von seiner voll qualifiziert wird anhand des Assemblynamens vollständige qualifiziert der Name der Assembly.</span><span class="sxs-lookup"><span data-stu-id="2da29-437">If the current type represents a closed generic type, the type arguments in the string returned by the <xref:System.Type.FullName%2A> property are qualified by their full assembly name, even though the string representation of the generic type itself is not qualified by its full assembly name.</span></span> <span data-ttu-id="2da29-438">Das folgende Beispiel veranschaulicht den Unterschied in der FullName-Eigenschaft für einen Typ, der generische Typdefinition darstellt, und eine, die einen geschlossenen generischen Typs darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-438">The following example illustrates the difference in the FullName property for a type that represents generic type definition and one that represents a closed generic type.</span></span>  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 <span data-ttu-id="2da29-439">Diese Eigenschaft gibt `null` wenn:</span><span class="sxs-lookup"><span data-stu-id="2da29-439">This property returns `null` if:</span></span>  
  
-   <span data-ttu-id="2da29-440">Die aktuelle <xref:System.Type> -Objekt einen Typparameter eines generischen Typs darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-440">The current <xref:System.Type> object represents a type parameter of a generic type.</span></span>  
  
     <span data-ttu-id="2da29-441">Das folgende Beispiel ruft die Typparameter der <xref:System.Nullable%601> Typ und die Versuche zum Anzeigen seiner <xref:System.Type.FullName%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-441">The following example retrieves the type parameter of the <xref:System.Nullable%601> type and attempts to display its <xref:System.Type.FullName%2A> property.</span></span>  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   <span data-ttu-id="2da29-442">Die aktuelle <xref:System.Type> Objekt stellt einen Arraytyp, ein Zeigertyp oder ein `byref` Typ, der einen generischen Typparameter basiert.</span><span class="sxs-lookup"><span data-stu-id="2da29-442">The current <xref:System.Type> object represents an array type, a pointer  type, or a `byref` type that is based on a generic type parameter.</span></span>  
  
     <span data-ttu-id="2da29-443">Das folgende Beispiel definiert einen generischen Typ `Generictype1<T>`, mit drei Methoden: `Display(T[])`, der übergeben wird, ein Array vom Typ T enthalten ist `HandleT(T)`, die ein Objekt auf T übergeben wird und `ChangeValue(ref T)`, die ein T-Objekt als Verweis übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-443">The following example defines a generic type, `Generictype1<T>`, with three methods: `Display(T[])`, which is passed an array of type T; `HandleT(T)`, which is passed a T object; and `ChangeValue(ref T)`, which is passed a T object by reference.</span></span> <span data-ttu-id="2da29-444">Da (c# und Visual Basic nicht als Zeiger in T definieren zulässt, führen Sie die `HandleT` -Methode aufrufen, müssen die <xref:System.Type.MakePointerType%2A> Methode auf die <xref:System.Type> Objekt, das Parametertyp der Methode, um einen Zeiger auf einen generischen Typ erstellen darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-444">Because C# and Visual Basic do not allow us to define T as a pointer in the `HandleT` method, we have to call the <xref:System.Type.MakePointerType%2A> method on the <xref:System.Type> object that represents the method's parameter type to create a pointer to a generic type.</span></span> <span data-ttu-id="2da29-445">Die Ausgabe des Beispiels zeigt, dass in allen drei Fällen die <xref:System.Type.FullName%2A> Eigenschaft ist `null`.</span><span class="sxs-lookup"><span data-stu-id="2da29-445">The output from the example shows that in all three cases, the <xref:System.Type.FullName%2A> property is `null`.</span></span>  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   <span data-ttu-id="2da29-446">Der aktuelle Typ enthält generische Typparameter, die nicht durch bestimmte Typen ersetzt wurden (d. h. die <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft gibt `true`), ist jedoch keine generische Typdefinition (, also die <xref:System.Type.IsGenericTypeDefinition%2A> Eigenschaft gibt `false`</span><span class="sxs-lookup"><span data-stu-id="2da29-446">The current type contains generic type parameters that have not been replaced by specific types (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`), but the type is not a generic type definition (that is, the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `false`</span></span>  
  
     <span data-ttu-id="2da29-447">Im folgenden Beispiel `Derived<T>` erbt von `Base<T>`.</span><span class="sxs-lookup"><span data-stu-id="2da29-447">In the following example, `Derived<T>` inherits from `Base<T>`.</span></span> <span data-ttu-id="2da29-448">Die <xref:System.Type.BaseType%2A> Eigenschaft ruft die <xref:System.Type> Objekt, das den Basistyp des darstellt `Derived<T>`, und die zugehörige <xref:System.Type.FullName%2A> -Eigenschaft gibt `null`.</span><span class="sxs-lookup"><span data-stu-id="2da29-448">The <xref:System.Type.BaseType%2A> property obtains the  <xref:System.Type> object that represents the base type of `Derived<T>`, and its <xref:System.Type.FullName%2A> property returns `null`.</span></span>  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     <span data-ttu-id="2da29-449">Zum Abrufen einer <xref:System.Type.FullName%2A> , die sich nicht `null`, können Sie die <xref:System.Type.GetGenericTypeDefinition%2A> Methode, um die generische Typdefinition abzurufen, wie im Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="2da29-449">To get a <xref:System.Type.FullName%2A> that is not `null`, you can use the <xref:System.Type.GetGenericTypeDefinition%2A> method to get the generic type definition, as the example illustrates.</span></span>  
  
 <span data-ttu-id="2da29-450">Diese Eigenschaft ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="2da29-450">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-451">Das folgende Beispiel zeigt den vollständigen Namen des angegebenen Typs.</span><span class="sxs-lookup"><span data-stu-id="2da29-451">The following example displays the full name of the specified type.</span></span>  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 <span data-ttu-id="2da29-452">Das folgende Beispiel vergleicht die zurückgegebene Zeichenfolgen die <xref:System.Type.ToString%2A> Methode und die `Name`, <xref:System.Type.FullName%2A>, und <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="2da29-452">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-453">Ruft eine Kombination von <see cref="T:System.Reflection.GenericParameterAttributes" />-Flags ab, die die Kovarianz und die speziellen Einschränkungen des aktuellen generischen Typparameters beschreiben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-453">Gets a combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> flags that describe the covariance and special constraints of the current generic type parameter.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-454">Eine bitweise Kombination von <see cref="T:System.Reflection.GenericParameterAttributes" />-Werten, die die Kovarianz und die speziellen Einschränkungen des aktuellen generischen Typparameters beschreiben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-454">A bitwise combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> values that describes the covariance and special constraints of the current generic type parameter.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-455">Der Wert dieser Eigenschaft enthält Flags, die beschreiben, ob der aktuelle generische Typparameter kovariant ist und die Flags, die besonderen Einschränkungen beschreiben.</span><span class="sxs-lookup"><span data-stu-id="2da29-455">The value of this property contains flags that describe whether the current generic type parameter is covariant, and flags that describe any special constraints.</span></span> <span data-ttu-id="2da29-456">Verwenden Sie die <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> Wert, der die Kovarianzflags auswählen, und Verwenden der <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> Wert, der die Einschränkungsflags auswählen.</span><span class="sxs-lookup"><span data-stu-id="2da29-456">Use the <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> value to select the covariance flags, and use the <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> value to select the constraint flags.</span></span>  
  
 <span data-ttu-id="2da29-457">Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-457">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-458">Das folgende Codebeispiel definiert einen generischen Typ `Test` mit zwei Typparametern, die verschiedene Einschränkungen aufweisen.</span><span class="sxs-lookup"><span data-stu-id="2da29-458">The following code example defines a generic type `Test` with two type parameters that have different constraints.</span></span> <span data-ttu-id="2da29-459">Wenn das Programm ausgeführt wird, die Einschränkungen werden untersucht, mit der <xref:System.Type.GenericParameterAttributes%2A> Eigenschaft und die <xref:System.Type.GetGenericParameterConstraints%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-459">When the program executes, the constraints are examined using the <xref:System.Type.GenericParameterAttributes%2A> property and the <xref:System.Type.GetGenericParameterConstraints%2A> method.</span></span>  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="2da29-460">Das aktuelle <see cref="T:System.Type" />-Objekt ist kein generischer Typparameter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-460">The current <see cref="T:System.Type" /> object is not a generic type parameter.</span>
          </span>
          <span data-ttu-id="2da29-461">Das bedeutet, dass die <see cref="P:System.Type.IsGenericParameter" />-Eigenschaft <see langword="false" /> zurückgibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-461">That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2da29-462">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-462">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-463">Ruft die Position des Typparameters in der Typparameterliste des generischen Typs oder der Methode ab, der bzw. die den Parameter deklariert hat, wenn das <see cref="T:System.Type" />-Objekt einen Typparameter eines generischen Typs oder einer generischen Methode darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-463">Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <see cref="T:System.Type" /> object represents a type parameter of a generic type or a generic method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-464">Die Position eines Typparameters in der Typparameterliste des generischen Typs oder der generischen Methode, der bzw. die den Parameter definiert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-464">The position of a type parameter in the type parameter list of the generic type or method that defines the parameter.</span>
          </span>
          <span data-ttu-id="2da29-465">Die Positionsnummern beginnen mit 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-465">Position numbers begin at 0.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-466">Die <xref:System.Type.GenericParameterPosition%2A> -Eigenschaft gibt die Position eines Typparameters in der Parameterliste von der generischen Typ- oder Methodendefinition, in dem der Typparameter ursprünglich definiert wurde.</span><span class="sxs-lookup"><span data-stu-id="2da29-466">The <xref:System.Type.GenericParameterPosition%2A> property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined.</span></span> <span data-ttu-id="2da29-467">Die <xref:System.Type.DeclaringType%2A> und <xref:System.Type.DeclaringMethod%2A> Eigenschaften identifizieren den generischen Typ- oder Methodendefinition:</span><span class="sxs-lookup"><span data-stu-id="2da29-467">The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type or method definition:</span></span>  
  
-   <span data-ttu-id="2da29-468">Wenn die <xref:System.Type.DeclaringMethod%2A> Eigenschaft gibt eine <xref:System.Reflection.MethodInfo>, <xref:System.Reflection.MethodInfo> stellt eine generische Methodendefinition und der aktuelle <xref:System.Type> -Objekt einen Typparameter der generischen Methodendefinition darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-468">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="2da29-469">Wenn die <xref:System.Type.DeclaringMethod%2A> -Eigenschaft gibt `null`, und klicken Sie dann die <xref:System.Type.DeclaringType%2A> -Eigenschaft gibt immer eine <xref:System.Type> Objekt, das eine generische Typdefinition ist, und das aktuelle darstellt <xref:System.Type> Objekt einen Typparameter eines generischen Typs darstellt Definition.</span><span class="sxs-lookup"><span data-stu-id="2da29-469">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
 <span data-ttu-id="2da29-470">Angeben des richtigen Kontexts für den Wert von der <xref:System.Type.GenericParameterPosition%2A> -Eigenschaft, es ist notwendig, identifizieren Sie die generischen Typ oder Methode, die ein Typparameter gehört.</span><span class="sxs-lookup"><span data-stu-id="2da29-470">To provide the correct context for the value of the <xref:System.Type.GenericParameterPosition%2A> property, it is necessary to identify the generic type or method a type parameter belongs to.</span></span> <span data-ttu-id="2da29-471">Betrachten Sie beispielsweise den Rückgabewert der aufgerufenen generischen Methode `GetSomething` in den folgenden Code:</span><span class="sxs-lookup"><span data-stu-id="2da29-471">For example, consider the return value of the generic method `GetSomething` in the following code:</span></span>  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 <span data-ttu-id="2da29-472">Der zurückgegebene Typ `GetSomething` richtet sich nach der angegebenen Klasse Typargumente `A` und `GetSomething` selbst.</span><span class="sxs-lookup"><span data-stu-id="2da29-472">The type returned by `GetSomething` depends on the type arguments supplied to class `A` and to `GetSomething` itself.</span></span> <span data-ttu-id="2da29-473">Sie erhalten eine <xref:System.Reflection.MethodInfo> für `GetSomething`, und von dem Sie den Rückgabetyp erhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-473">You can obtain a <xref:System.Reflection.MethodInfo> for `GetSomething`, and from that you can obtain the return type.</span></span> <span data-ttu-id="2da29-474">Wenn Sie die Typparameter des Rückgabetyps, untersuchen <xref:System.Type.GenericParameterPosition%2A> für beide 0 zurück.</span><span class="sxs-lookup"><span data-stu-id="2da29-474">When you examine the type parameters of the return type, <xref:System.Type.GenericParameterPosition%2A> returns 0 for both.</span></span> <span data-ttu-id="2da29-475">Die Position des `V` ist 0, da `V` ist der erste Typparameter in der Typparameterliste für die Klasse `A`.</span><span class="sxs-lookup"><span data-stu-id="2da29-475">The position of `V` is 0 because `V` is the first type parameter in the type parameter list for class `A`.</span></span> <span data-ttu-id="2da29-476">Die Position des `X` ist 0, da `X` ist der erste Typparameter in der Typparameterliste für `GetSomething`.</span><span class="sxs-lookup"><span data-stu-id="2da29-476">The position of `X` is 0 because `X` is the first type parameter in the type parameter list for `GetSomething`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-477">Aufrufen der <xref:System.Type.GenericParameterPosition%2A> -Eigenschaft löst eine Ausnahme aus, wenn die aktuelle <xref:System.Type> stellt keinen Parameters für einen Typ dar.</span><span class="sxs-lookup"><span data-stu-id="2da29-477">Calling the <xref:System.Type.GenericParameterPosition%2A> property causes an exception if the current <xref:System.Type> does not represent a type parameter.</span></span> <span data-ttu-id="2da29-478">Verwenden Sie bei der Überprüfung die Typargumente einer offenen konstruierten Typ müssen die <xref:System.Type.IsGenericParameter%2A> Eigenschaft anzuweisen, die Typparameter und welche Typen sind.</span><span class="sxs-lookup"><span data-stu-id="2da29-478">When you examine the type arguments of an open constructed type, use the <xref:System.Type.IsGenericParameter%2A> property to tell which are type parameters and which are types.</span></span> <span data-ttu-id="2da29-479">Die <xref:System.Type.IsGenericParameter%2A> -Eigenschaft gibt `true` für einen Typparameter, können Sie anschließend die <xref:System.Type.GenericParameterPosition%2A> Methode, um seine Position abrufen und Verwenden der <xref:System.Type.DeclaringMethod%2A> und <xref:System.Type.DeclaringType%2A> Eigenschaften bestimmen die generische Methode oder die Typdefinition, der ihn definiert .</span><span class="sxs-lookup"><span data-stu-id="2da29-479">The <xref:System.Type.IsGenericParameter%2A> property returns `true` for a type parameter; you can then use the <xref:System.Type.GenericParameterPosition%2A> method to obtain its position and use the <xref:System.Type.DeclaringMethod%2A> and <xref:System.Type.DeclaringType%2A> properties to determine the generic method or type definition that defines it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-480">Im folgenden Beispiel wird eine generische Klasse mit zwei Typparametern und definiert eine zweite generische Klasse, die von der ersten Klasse abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-480">The following example defines a generic class with two type parameters and defines a second generic class that derives from the first class.</span></span> <span data-ttu-id="2da29-481">Die Basis der abgeleiteten Klasse verfügt über zwei Typargumente: Erstens <xref:System.Int32>, und die zweite ist ein Typparameter des abgeleiteten Typs.</span><span class="sxs-lookup"><span data-stu-id="2da29-481">The derived class's base class has two type arguments: the first is <xref:System.Int32>, and the second is a type parameter of the derived type.</span></span> <span data-ttu-id="2da29-482">Das Beispiel zeigt Informationen zu diesen generischen Klassen, von gemeldeten einschließlich die Positionen der <xref:System.Type.GenericParameterPosition%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-482">The example displays information about these generic classes, including the positions reported by the <xref:System.Type.GenericParameterPosition%2A> property.</span></span>  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="2da29-483">Der aktuelle Typ stellt keinen Typparameter dar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-483">The current type does not represent a type parameter.</span>
          </span>
          <span data-ttu-id="2da29-484">Das heißt, <see cref="P:System.Type.IsGenericParameter" /> gibt <see langword="false" /> zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-484">That is, <see cref="P:System.Type.IsGenericParameter" /> returns <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-485">Ruft ein Array von generischen Typargumenten für diesen Typ ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-485">Gets an array of the generic type arguments for this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-486">Ein Array von generischen Typargumenten für diesen Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-486">An array of the generic type arguments for this type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-487">Diese Eigenschaft ruft nur die generischen Typargumente an. d. h. Typen, die für die generischen Typparameter des aktuellen Typs angegeben wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-487">This property gets only the generic type arguments; that is, the types that have been specified for the generic type parameters of the current type.</span></span> <span data-ttu-id="2da29-488">Wenn der aktuelle Typ eine generische Typdefinition ist, gibt diese Eigenschaft ein leeres Array zurück.</span><span class="sxs-lookup"><span data-stu-id="2da29-488">If the current type is a generic type definition, this property returns an empty array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-489">Wenn ein generischer Typ in einer generischen Methode oder einem anderen generischen Typ verwendet wird, möglicherweise einige seiner generische Typargumente generischen Typparameter von einschließenden Methode oder Typ.</span><span class="sxs-lookup"><span data-stu-id="2da29-489">If a generic type is used in a generic method or in another generic type, some of its generic type arguments might be generic type parameters of the enclosing method or type.</span></span>  
  
 <span data-ttu-id="2da29-490">Um die generischen Typparameter eines Typs ab, das eine generische Typdefinition darstellt, verwenden Sie die <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-490">To get the generic type parameters of a type that represents a generic type definition, use the <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="2da29-491">Zum Abrufen einer <xref:System.Reflection.TypeInfo> -Objekt für die aktuelle <xref:System.Type> -Objekts die <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> Erweiterungsmethode.</span><span class="sxs-lookup"><span data-stu-id="2da29-491">To get a <xref:System.Reflection.TypeInfo> object for the current <xref:System.Type> object, use the <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> extension method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-492">Ruft die Anzahl der Dimensionen eines Arrays ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-492">Gets the number of dimensions in an array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-493">Eine Ganzzahl, die die Anzahl der Dimensionen im aktuellen Typ darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-493">An integer that contains the number of dimensions in the current type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="2da29-494">Das folgende Beispiel zeigt die Anzahl der Dimensionen in einem Array.</span><span class="sxs-lookup"><span data-stu-id="2da29-494">The following example displays the number of dimensions in an array.</span></span>  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2da29-495">Die Funktionalität dieser Methode wird in der Basisklasse nicht unterstützt und muss stattdessen in einer abgeleiteten Klasse implementiert werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-495">The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-496">Der aktuelle Typ ist kein Array.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-496">The current type is not an array.</span>
          </span>
        </exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-497">Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.Attributes" />-Eigenschaft und ruft eine Bitmaske ab, die die <see cref="T:System.Type" /> zugeordneten Attribute anzeigt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-497">When overridden in a derived class, implements the <see cref="P:System.Type.Attributes" /> property and gets a bitmask indicating the attributes associated with the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-498">Ein <see cref="T:System.Reflection.TypeAttributes" />-Objekt, das die Attributgruppe von <see cref="T:System.Type" /> darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-498">A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-499">Ruft einen bestimmten Konstruktor des aktuellen <see cref="T:System.Type" /> ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-499">Gets a specific constructor of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types">
          <span data-ttu-id="2da29-500">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter des abzurufenden Konstruktors darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-500">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the desired constructor.</span>
          </span>
          <span data-ttu-id="2da29-501">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-501">-or-</span>
          </span>
          <span data-ttu-id="2da29-502">Ein leeres Array von <see cref="T:System.Type" />-Objekten zum Abrufen eines Konstruktors ohne Parameter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-502">An empty array of <see cref="T:System.Type" /> objects, to get a constructor that takes no parameters.</span>
          </span>
          <span data-ttu-id="2da29-503">Das <see langword="static" />-Feld <see cref="F:System.Type.EmptyTypes" /> stellt ein entsprechendes leeres Array bereit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-503">Such an empty array is provided by the <see langword="static" /> field <see cref="F:System.Type.EmptyTypes" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-504">Sucht einen öffentlichen Instanzkonstruktor, dessen Parameter den Typen im angegebenen Array entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-504">Searches for a public instance constructor whose parameters match the types in the specified array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-505">Ein Objekt, das den öffentlichen Instanzkonstruktor darstellt, dessen Parameter den Typen im Parametertyparray entsprechen, sofern gefunden, andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-505">An object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-506">Diese methodenüberladung sucht nach öffentlichen Instanzkonstruktoren und kann nicht verwendet werden, um ein Klasseninitialisierer (".cctor") zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-506">This method overload looks for public instance constructors and cannot be used to obtain a class initializer (.cctor).</span></span> <span data-ttu-id="2da29-507">Um ein Klasseninitialisierer zu erhalten, verwenden Sie eine Überladung mit <xref:System.Reflection.BindingFlags>, und geben Sie <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-507">To get a class initializer, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="2da29-508">Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-508">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="2da29-509">Wenn der angeforderte Konstruktor nicht öffentlich ist, gibt diese Methode `null`.</span><span class="sxs-lookup"><span data-stu-id="2da29-509">If the requested constructor is non-public, this method returns `null`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-510">Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden.</span><span class="sxs-lookup"><span data-stu-id="2da29-510">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="2da29-511">Sie können nur Parameter auslassen, aufrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-511">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="2da29-512">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.ConstructorInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-512">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="2da29-513">Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Methode gibt immer `null`.</span><span class="sxs-lookup"><span data-stu-id="2da29-513">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-514">Das folgende Beispiel ruft den Typ der `MyClass`, ruft der <xref:System.Reflection.ConstructorInfo> -Objekt und zeigt die Signatur des Konstruktors.</span><span class="sxs-lookup"><span data-stu-id="2da29-514">The following example obtains the type of `MyClass`, gets the <xref:System.Reflection.ConstructorInfo> object, and displays the constructor signature.</span></span>  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-515">
            <paramref name="types" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-515">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2da29-516">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-516">-or-</span>
          </span>
          <span data-ttu-id="2da29-517">Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-517">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-518">
            <paramref name="types" /> ist mehrdimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-518">
              <paramref name="types" /> is multidimensional.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="2da29-519">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-519">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="2da29-520">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-520">-or-</span>
          </span>
          <span data-ttu-id="2da29-521">0 (null), damit <see langword="null" /> zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-521">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="2da29-522">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-522">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="2da29-523">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-523">-or-</span>
          </span>
          <span data-ttu-id="2da29-524">Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-524">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="2da29-525">Ein Array von <see cref="T:System.Type" />-Objekten, das Anzahl, Reihenfolge und Typ der Parameter des abzurufenden Konstruktors darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-525">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span>
          </span>
          <span data-ttu-id="2da29-526">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-526">-or-</span>
          </span>
          <span data-ttu-id="2da29-527">Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen eines Konstruktors, der keine Parameter akzeptiert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-527">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span>
          </span>
          <span data-ttu-id="2da29-528">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-528">-or-</span>
          </span>
          <span data-ttu-id="2da29-529">
            <see cref="F:System.Type.EmptyTypes" />
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-529">
              <see cref="F:System.Type.EmptyTypes" />.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="2da29-530">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im Parametertyparray zugeordnet sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-530">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the parameter type array.</span>
          </span>
          <span data-ttu-id="2da29-531">Der Standardbinder verarbeitet diesen Parameter nicht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-531">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-532">Sucht einen Konstruktor, dessen Parameter unter Verwendung der angegebenen Bindungseinschränkungen den angegebenen Argumenttypen und -modifizierern entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-532">Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-533">Ein <see cref="T:System.Reflection.ConstructorInfo" />-Objekt, das den Konstruktor darstellt, der den angegebenen Anforderungen entspricht, oder <see langword="null" />, wenn kein entsprechender Konstruktor gefunden wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-533">A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-534">Wenn eine genaue Übereinstimmung nicht vorhanden ist, die `binder` wird versucht, die im angegebenen Parametertypen zu konvertieren die `types` Array um eine Übereinstimmung zu aktivieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-534">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="2da29-535">Wenn die `binder` kann eine Übereinstimmung, wählen Sie dann `null` zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-535">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="2da29-536">Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Konstruktoren in die Suche einbezogen werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-536">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="2da29-537">Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-537">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="2da29-538">Geben Sie `BindingFlags.Public` öffentliche Konstruktoren in die Suche eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="2da29-538">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="2da29-539">Geben Sie `BindingFlags.NonPublic` nicht öffentlichen Konstruktoren (d. h. private, interne und geschützte Konstruktoren) in die Suche eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="2da29-539">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="2da29-540">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-540">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="2da29-541">Um die klasseninitialisierung (".cctor"), die Verwendung dieser methodenüberladung zu erhalten, müssen Sie angeben <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-541">To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="2da29-542">Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-542">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-543">Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden.</span><span class="sxs-lookup"><span data-stu-id="2da29-543">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="2da29-544">Sie können nur Parameter auslassen, aufrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-544">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="2da29-545">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.ConstructorInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-545">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="2da29-546">Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Methode gibt immer `null`.</span><span class="sxs-lookup"><span data-stu-id="2da29-546">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-547">Das folgende Programm ruft den Typ der `MyClass1` -Klasse ruft die <xref:System.Reflection.ConstructorInfo> -Objekt den angegebenen Bindungsflags und zeigt die Signatur des Konstruktors.</span><span class="sxs-lookup"><span data-stu-id="2da29-547">The following program obtains the type of `MyClass1` class, gets the <xref:System.Reflection.ConstructorInfo> object matching the specified binding flags, and displays the signature of the constructor.</span></span>  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-548">
            <paramref name="types" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-548">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2da29-549">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-549">-or-</span>
          </span>
          <span data-ttu-id="2da29-550">Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-550">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-551">
            <paramref name="types" /> ist mehrdimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-551">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="2da29-552">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-552">-or-</span>
          </span>
          <span data-ttu-id="2da29-553">
            <paramref name="modifiers" /> ist mehrdimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-553">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="2da29-554">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-554">-or-</span>
          </span>
          <span data-ttu-id="2da29-555">
            <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-555">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="2da29-556">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-556">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="2da29-557">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-557">-or-</span>
          </span>
          <span data-ttu-id="2da29-558">0 (null), damit <see langword="null" /> zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-558">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="2da29-559">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-559">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="2da29-560">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-560">-or-</span>
          </span>
          <span data-ttu-id="2da29-561">Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-561">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="2da29-562">Das Objekt, das die Regeln für die Reihenfolge und das Layout von Argumenten, die Art der Übergabe des Rückgabewerts, die für Argumente zu verwendenden Register und die Art der Stapelbereinigung angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-562">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="2da29-563">Ein Array von <see cref="T:System.Type" />-Objekten, das Anzahl, Reihenfolge und Typ der Parameter des abzurufenden Konstruktors darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-563">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span>
          </span>
          <span data-ttu-id="2da29-564">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-564">-or-</span>
          </span>
          <span data-ttu-id="2da29-565">Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen eines Konstruktors, der keine Parameter akzeptiert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-565">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="2da29-566">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <c>types</c>-Array zugeordnet sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-566">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="2da29-567">Der Standardbinder verarbeitet diesen Parameter nicht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-567">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-568">Sucht einen Konstruktor, dessen Parameter den angegebenen Argumenttypen und -modifizierern entsprechen, und berücksichtigt dabei die angegebenen Bindungseinschränkungen und die angegebene Aufrufkonvention.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-568">Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-569">Ein Objekt, das den Konstruktor darstellt, der den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-569">An object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-570">Obwohl der Standardbinder nicht verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="2da29-570">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="2da29-571">`ParameterModifier` wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.</span><span class="sxs-lookup"><span data-stu-id="2da29-571">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="2da29-572">Wenn eine genaue Übereinstimmung nicht vorhanden ist, die `binder` wird versucht, die im angegebenen Parametertypen zu konvertieren die `types` Array um eine Übereinstimmung zu aktivieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-572">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="2da29-573">Wenn die `binder` kann eine Übereinstimmung, wählen Sie dann `null` zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-573">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="2da29-574">Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Konstruktoren in die Suche einbezogen werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-574">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="2da29-575">Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-575">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="2da29-576">Geben Sie `BindingFlags.Public` öffentliche Konstruktoren in die Suche eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="2da29-576">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="2da29-577">Geben Sie `BindingFlags.NonPublic` nicht öffentlichen Konstruktoren (d. h. private, interne und geschützte Konstruktoren) in die Suche eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="2da29-577">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="2da29-578">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-578">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="2da29-579">Um die klasseninitialisierung (".cctor"), die mit dieser Methode zu erhalten, müssen Sie angeben <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-579">To get the class initializer (.cctor) using this method, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="2da29-580">Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-580">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="2da29-581">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-581">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="2da29-582">Memberart</span><span class="sxs-lookup"><span data-stu-id="2da29-582">Member Type</span></span>|<span data-ttu-id="2da29-583">Statisch</span><span class="sxs-lookup"><span data-stu-id="2da29-583">Static</span></span>|<span data-ttu-id="2da29-584">Nicht statische</span><span class="sxs-lookup"><span data-stu-id="2da29-584">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="2da29-585">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="2da29-585">Constructor</span></span>|<span data-ttu-id="2da29-586">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-586">No</span></span>|<span data-ttu-id="2da29-587">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-587">No</span></span>|  
|<span data-ttu-id="2da29-588">Feld</span><span class="sxs-lookup"><span data-stu-id="2da29-588">Field</span></span>|<span data-ttu-id="2da29-589">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-589">No</span></span>|<span data-ttu-id="2da29-590">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-590">Yes.</span></span> <span data-ttu-id="2da29-591">Ein Feld ist immer nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-591">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-592">event</span><span class="sxs-lookup"><span data-stu-id="2da29-592">Event</span></span>|<span data-ttu-id="2da29-593">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-593">Not applicable</span></span>|<span data-ttu-id="2da29-594">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-594">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-595">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-595">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-596">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-596">See note 2 below.</span></span>|  
|<span data-ttu-id="2da29-597">Methode</span><span class="sxs-lookup"><span data-stu-id="2da29-597">Method</span></span>|<span data-ttu-id="2da29-598">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-598">No</span></span>|<span data-ttu-id="2da29-599">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-599">Yes.</span></span> <span data-ttu-id="2da29-600">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-600">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-601">Geschachtelten Typs</span><span class="sxs-lookup"><span data-stu-id="2da29-601">Nested Type</span></span>|<span data-ttu-id="2da29-602">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-602">No</span></span>|<span data-ttu-id="2da29-603">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-603">No</span></span>|  
|<span data-ttu-id="2da29-604">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="2da29-604">Property</span></span>|<span data-ttu-id="2da29-605">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-605">Not applicable</span></span>|<span data-ttu-id="2da29-606">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-606">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-607">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-607">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-608">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-608">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="2da29-609">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-609">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="2da29-610">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="2da29-610">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="2da29-611">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-611">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-612">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-612">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="2da29-613">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="2da29-613">Custom attributes are not part of the common type system.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-614">Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden.</span><span class="sxs-lookup"><span data-stu-id="2da29-614">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="2da29-615">Sie können nur Parameter auslassen, aufrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-615">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="2da29-616">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.ConstructorInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-616">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="2da29-617">Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Methode gibt immer `null`.</span><span class="sxs-lookup"><span data-stu-id="2da29-617">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-618">Das folgende Beispiel ruft den Typ der `MyClass1`, ruft der <xref:System.Reflection.ConstructorInfo> Objekt, das den angegebenen Bindungsflags entspricht, und zeigt die Signatur des Konstruktors.</span><span class="sxs-lookup"><span data-stu-id="2da29-618">The following example obtains the type of `MyClass1`, gets the <xref:System.Reflection.ConstructorInfo> object that matches the specified binding flags, and displays the constructor signature.</span></span>  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-619">
            <paramref name="types" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-619">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2da29-620">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-620">-or-</span>
          </span>
          <span data-ttu-id="2da29-621">Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-621">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-622">
            <paramref name="types" /> ist mehrdimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-622">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="2da29-623">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-623">-or-</span>
          </span>
          <span data-ttu-id="2da29-624">
            <paramref name="modifiers" /> ist mehrdimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-624">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="2da29-625">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-625">-or-</span>
          </span>
          <span data-ttu-id="2da29-626">
            <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-626">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="2da29-627">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-627">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="2da29-628">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-628">-or-</span>
          </span>
          <span data-ttu-id="2da29-629">0 (null), damit <see langword="null" /> zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-629">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="2da29-630">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-630">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="2da29-631">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-631">-or-</span>
          </span>
          <span data-ttu-id="2da29-632">Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-632">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="2da29-633">Das Objekt, das die Regeln für die Reihenfolge und das Layout von Argumenten, die Art der Übergabe des Rückgabewerts, die für Argumente zu verwendenden Register und die Art der Stapelbereinigung angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-633">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="2da29-634">Ein Array von <see cref="T:System.Type" />-Objekten, das Anzahl, Reihenfolge und Typ der Parameter des abzurufenden Konstruktors darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-634">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span>
          </span>
          <span data-ttu-id="2da29-635">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-635">-or-</span>
          </span>
          <span data-ttu-id="2da29-636">Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen eines Konstruktors, der keine Parameter akzeptiert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-636">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="2da29-637">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <c>types</c>-Array zugeordnet sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-637">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="2da29-638">Der Standardbinder verarbeitet diesen Parameter nicht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-638">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-639">Sucht beim Überschreiben in einer abgeleiteten Klasse, unter Verwendung der angegebenen Bindungseinschränkungen und der angegebenen Aufrufkonvention, nach einem Konstruktor, dessen Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-639">When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-640">Ein <see cref="T:System.Reflection.ConstructorInfo" />-Objekt, das den Konstruktor darstellt, der den angegebenen Anforderungen entspricht, oder <see langword="null" />, wenn kein entsprechender Konstruktor gefunden wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-640">A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-641">Obwohl der Standardbinder nicht verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="2da29-641">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="2da29-642">`ParameterModifier` wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.</span><span class="sxs-lookup"><span data-stu-id="2da29-642">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="2da29-643">Wenn eine genaue Übereinstimmung nicht vorhanden ist, die `binder` wird versucht, die im angegebenen Parametertypen zu konvertieren die `types` Array um eine Übereinstimmung zu aktivieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-643">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="2da29-644">Wenn die `binder` kann eine Übereinstimmung, wählen Sie dann `null` zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-644">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="2da29-645">Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Konstruktoren in die Suche einbezogen werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-645">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="2da29-646">Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-646">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="2da29-647">Geben Sie `BindingFlags.Public` öffentliche Konstruktoren in die Suche eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="2da29-647">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="2da29-648">Geben Sie `BindingFlags.NonPublic` nicht öffentlichen Konstruktoren (d. h. private, interne und geschützte Konstruktoren) in die Suche eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="2da29-648">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="2da29-649">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-649">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="2da29-650">Diese Methode implementiert <xref:System.Type.GetConstructor%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-650">This method implements <xref:System.Type.GetConstructor%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-651">
            <paramref name="types" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-651">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2da29-652">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-652">-or-</span>
          </span>
          <span data-ttu-id="2da29-653">Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-653">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-654">
            <paramref name="types" /> ist mehrdimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-654">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="2da29-655">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-655">-or-</span>
          </span>
          <span data-ttu-id="2da29-656">
            <paramref name="modifiers" /> ist mehrdimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-656">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="2da29-657">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-657">-or-</span>
          </span>
          <span data-ttu-id="2da29-658">
            <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-658">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2da29-659">Der aktuelle Typ ist ein <see cref="T:System.Reflection.Emit.TypeBuilder" /> oder ein <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-659">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-660">Ruft die Konstruktoren des aktuellen <see cref="T:System.Type" /> ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-660">Gets the constructors of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-661">Gibt alle öffentlichen Konstruktoren zurück, die für den aktuellen <see cref="T:System.Type" /> definiert sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-661">Returns all the public constructors defined for the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-662">Ein Array von <see cref="T:System.Reflection.ConstructorInfo" /> -Objekten, die alle für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Instanzkonstruktoren mit Ausnahme des Typinitialisierers (statischer Konstruktor) darstellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-662">An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all the public instance constructors defined for the current <see cref="T:System.Type" />, but not including the type initializer (static constructor).</span>
          </span>
          <span data-ttu-id="2da29-663">Wenn für den aktuellen <see cref="T:System.Type" /> keine öffentlichen Instanzkonstruktoren definiert sind oder der aktuelle <see cref="T:System.Type" /> einen Typparameter einer generischen Typ- oder Methodendefinition darstellt, wird ein leeres Array vom Typ <see cref="T:System.Reflection.ConstructorInfo" /> zurückgegeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-663">If no public instance constructors are defined for the current <see cref="T:System.Type" />, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> is returned.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-664">Die <xref:System.Type.GetConstructors%2A> Methode gibt keinen Konstruktoren in einer bestimmten Reihenfolge, z. B. die Reihenfolge der Deklaration zurück.</span><span class="sxs-lookup"><span data-stu-id="2da29-664">The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order.</span></span> <span data-ttu-id="2da29-665">Code muss nicht abhängig von der Reihenfolge, in der Konstruktoren zurückgegeben werden, da, bei der Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="2da29-665">Your code must not depend on the order in which constructors are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="2da29-666">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-666">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="2da29-667">Memberart</span><span class="sxs-lookup"><span data-stu-id="2da29-667">Member Type</span></span>|<span data-ttu-id="2da29-668">Statisch</span><span class="sxs-lookup"><span data-stu-id="2da29-668">Static</span></span>|<span data-ttu-id="2da29-669">Nicht statische</span><span class="sxs-lookup"><span data-stu-id="2da29-669">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="2da29-670">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="2da29-670">Constructor</span></span>|<span data-ttu-id="2da29-671">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-671">No</span></span>|<span data-ttu-id="2da29-672">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-672">No</span></span>|  
|<span data-ttu-id="2da29-673">Feld</span><span class="sxs-lookup"><span data-stu-id="2da29-673">Field</span></span>|<span data-ttu-id="2da29-674">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-674">No</span></span>|<span data-ttu-id="2da29-675">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-675">Yes.</span></span> <span data-ttu-id="2da29-676">Ein Feld ist immer nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-676">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-677">event</span><span class="sxs-lookup"><span data-stu-id="2da29-677">Event</span></span>|<span data-ttu-id="2da29-678">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-678">Not applicable</span></span>|<span data-ttu-id="2da29-679">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-679">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-680">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-680">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-681">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-681">See note 2 below.</span></span>|  
|<span data-ttu-id="2da29-682">Methode</span><span class="sxs-lookup"><span data-stu-id="2da29-682">Method</span></span>|<span data-ttu-id="2da29-683">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-683">No</span></span>|<span data-ttu-id="2da29-684">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-684">Yes.</span></span> <span data-ttu-id="2da29-685">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-685">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-686">Geschachtelten Typs</span><span class="sxs-lookup"><span data-stu-id="2da29-686">Nested Type</span></span>|<span data-ttu-id="2da29-687">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-687">No</span></span>|<span data-ttu-id="2da29-688">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-688">No</span></span>|  
|<span data-ttu-id="2da29-689">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="2da29-689">Property</span></span>|<span data-ttu-id="2da29-690">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-690">Not applicable</span></span>|<span data-ttu-id="2da29-691">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-691">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-692">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-692">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-693">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-693">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="2da29-694">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-694">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="2da29-695">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="2da29-695">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="2da29-696">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-696">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-697">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-697">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="2da29-698">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="2da29-698">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="2da29-699">Diese methodenüberladung Ruft die <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> -methodenüberladung mit <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-699">This method overload calls the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="2da29-700">Es findet keine Klasseninitialisierer (".cctor").</span><span class="sxs-lookup"><span data-stu-id="2da29-700">It will not find class initializers (.cctor).</span></span> <span data-ttu-id="2da29-701">Um Klasseninitialisierer zu ermitteln, verwenden Sie eine Überladung mit <xref:System.Reflection.BindingFlags>, und geben Sie <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-701">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="2da29-702">Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-702">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="2da29-703">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.ConstructorInfo> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-703">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="2da29-704">Z. B. Wenn Klasse `C<T>` verfügt über einen Konstruktor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic) wird beim Aufrufen <xref:System.Type.GetConstructors%2A> auf `C<int>` gibt eine <xref:System.Reflection.ConstructorInfo> darstellt, die `C(int t1)` in c# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-704">For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="2da29-705">Wenn die aktuelle <xref:System.Type> stellt einen generischen Typparameter der <xref:System.Type.GetConstructors%2A> Methode ein leeres Array zurück.</span><span class="sxs-lookup"><span data-stu-id="2da29-705">If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-706">Dieses Beispiel zeigt die Ausgabe der <xref:System.Type.GetConstructors%2A> Überladen von einer Klasse, die zwei Instanzkonstruktoren und einen statischen Konstruktor verfügt.</span><span class="sxs-lookup"><span data-stu-id="2da29-706">This example shows the output of the <xref:System.Type.GetConstructors%2A> overload from a class that has two instance constructors and one static constructor.</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 <span data-ttu-id="2da29-707">Die Ausgabe dieses Codes lautet:</span><span class="sxs-lookup"><span data-stu-id="2da29-707">The output of this code is:</span></span>  
  
 <span data-ttu-id="2da29-708">2</span><span class="sxs-lookup"><span data-stu-id="2da29-708">2</span></span>  
  
 <span data-ttu-id="2da29-709">False</span><span class="sxs-lookup"><span data-stu-id="2da29-709">False</span></span>  
  
 <span data-ttu-id="2da29-710">False</span><span class="sxs-lookup"><span data-stu-id="2da29-710">False</span></span>  
  
 <span data-ttu-id="2da29-711">Da die <xref:System.Type.GetConstructors> Überladung verwendet nur <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> und <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, der statische Konstruktor ist weder gezählt, indem die `for` Ausdruck noch ausgewertet, indem `IsStatic`.</span><span class="sxs-lookup"><span data-stu-id="2da29-711">Because the <xref:System.Type.GetConstructors> overload uses only <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, the static constructor is neither counted by the `for` expression nor evaluated by `IsStatic`.</span></span>  
  
 <span data-ttu-id="2da29-712">Um statische Konstruktoren zu ermitteln, verwenden Sie die <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> überladen, und übergeben Sie die Kombination (logische `OR`) des <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, wie im folgenden Codebeispiel wird gezeigt:</span><span class="sxs-lookup"><span data-stu-id="2da29-712">To find static constructors, use the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> overload, and pass the combination (logical `OR`) of <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, as shown in the following code example:</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="2da29-713">Jetzt ist die Ausgabe:</span><span class="sxs-lookup"><span data-stu-id="2da29-713">Now the output is:</span></span>  
  
 <span data-ttu-id="2da29-714">3</span><span class="sxs-lookup"><span data-stu-id="2da29-714">3</span></span>  
  
 <span data-ttu-id="2da29-715">False</span><span class="sxs-lookup"><span data-stu-id="2da29-715">False</span></span>  
  
 <span data-ttu-id="2da29-716">True</span><span class="sxs-lookup"><span data-stu-id="2da29-716">True</span></span>  
  
 <span data-ttu-id="2da29-717">False</span><span class="sxs-lookup"><span data-stu-id="2da29-717">False</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="2da29-718">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-718">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="2da29-719">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-719">-or-</span>
          </span>
          <span data-ttu-id="2da29-720">0 (null), damit <see langword="null" /> zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-720">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-721">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen <see cref="T:System.Type" /> die für den aktuellen <see langword="BindingFlags" /> definierten Konstruktoren.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-721">When overridden in a derived class, searches for the constructors defined for the current <see cref="T:System.Type" />, using the specified <see langword="BindingFlags" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-722">Ein Array von <see cref="T:System.Reflection.ConstructorInfo" />-Objekten, die sämtliche für den aktuellen <see cref="T:System.Type" /> definierten Konstruktoren, einschließlich eines ggf. definierten Typinitialisierers, darstellen, die den angegebenen Bindungseinschränkungen entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-722">An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all constructors defined for the current <see cref="T:System.Type" /> that match the specified binding constraints, including the type initializer if it is defined.</span>
          </span>
          <span data-ttu-id="2da29-723">Gibt ein leeres Array vom Typ <see cref="T:System.Reflection.ConstructorInfo" /> zurück, wenn für den aktuellen <see cref="T:System.Type" /> keine Konstruktoren definiert sind, keiner der definierten Konstruktoren den Bindungseinschränkungen entspricht oder der aktuelle <see cref="T:System.Type" /> einen Typparameter einer generischen Typ- oder Methodendefinition darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-723">Returns an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> if no constructors are defined for the current <see cref="T:System.Type" />, if none of the defined constructors match the binding constraints, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-724">Die <xref:System.Type.GetConstructors%2A> Methode gibt keinen Konstruktoren in einer bestimmten Reihenfolge, z. B. die Reihenfolge der Deklaration zurück.</span><span class="sxs-lookup"><span data-stu-id="2da29-724">The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order.</span></span> <span data-ttu-id="2da29-725">Code muss nicht abhängig von der Reihenfolge, in der Konstruktoren zurückgegeben werden, da, bei der Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="2da29-725">Your code must not depend on the order in which constructors are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="2da29-726">`bindingAttr` kann verwendet werden, um anzugeben, ob nur öffentliche oder öffentlichen und nicht öffentlichen Konstruktoren zurück.</span><span class="sxs-lookup"><span data-stu-id="2da29-726">`bindingAttr` can be used to specify whether to return only public constructors or both public and non-public constructors.</span></span>  
  
 <span data-ttu-id="2da29-727">Wenn eine genaue Übereinstimmung nicht vorhanden ist, die `binder` wird versucht, die im angegebenen Parametertypen zu konvertieren die `types` Array um eine Übereinstimmung zu aktivieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-727">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="2da29-728">Wenn die `binder` kann eine Übereinstimmung, wählen Sie dann `null` zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-728">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="2da29-729">Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Konstruktoren in die Suche einbezogen werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-729">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="2da29-730">Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-730">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="2da29-731">Geben Sie `BindingFlags.Public` öffentliche Konstruktoren in die Suche eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="2da29-731">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="2da29-732">Geben Sie `BindingFlags.NonPublic` nicht öffentlichen Konstruktoren (d. h. private, interne und geschützte Konstruktoren) in die Suche eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="2da29-732">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span> <span data-ttu-id="2da29-733">Konstruktoren von Basisklassen werden nicht zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-733">Constructors of base classes are not returned.</span></span>  
  
 <span data-ttu-id="2da29-734">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-734">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="2da29-735">Um die klasseninitialisierung (".cctor"), die Verwendung dieser methodenüberladung zu erhalten, müssen Sie angeben <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-735">To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="2da29-736">Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-736">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="2da29-737">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.ConstructorInfo> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-737">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="2da29-738">Z. B. Wenn Klasse `C<T>` verfügt über einen Konstruktor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic) wird beim Aufrufen <xref:System.Type.GetConstructors%2A> auf `C<int>` gibt eine <xref:System.Reflection.ConstructorInfo> darstellt, die `C(int t1)` in c# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-738">For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="2da29-739">Wenn die aktuelle <xref:System.Type> stellt einen generischen Typparameter der <xref:System.Type.GetConstructors%2A> Methode ein leeres Array zurück.</span><span class="sxs-lookup"><span data-stu-id="2da29-739">If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-740">Dieses Beispiel zeigt die Ausgabe der <xref:System.Type.GetConstructors> Überladen von einer Klasse, die zwei Instanzkonstruktoren und einen statischen Konstruktor verfügt.</span><span class="sxs-lookup"><span data-stu-id="2da29-740">This example shows the output of the <xref:System.Type.GetConstructors> overload from a class that has two instance constructors and one static constructor.</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 <span data-ttu-id="2da29-741">Die Ausgabe dieses Codes lautet:</span><span class="sxs-lookup"><span data-stu-id="2da29-741">The output of this code is:</span></span>  
  
 <span data-ttu-id="2da29-742">2</span><span class="sxs-lookup"><span data-stu-id="2da29-742">2</span></span>  
  
 <span data-ttu-id="2da29-743">False</span><span class="sxs-lookup"><span data-stu-id="2da29-743">False</span></span>  
  
 <span data-ttu-id="2da29-744">False</span><span class="sxs-lookup"><span data-stu-id="2da29-744">False</span></span>  
  
 <span data-ttu-id="2da29-745">Da die <xref:System.Type.GetConstructors%2A> Überladung verwendet nur <xref:System.Reflection.BindingFlags.Public> und <xref:System.Reflection.BindingFlags.Instance>, der statische Konstruktor ist weder gezählt, indem die `for` Ausdruck noch ausgewertet, indem `IsStatic`.</span><span class="sxs-lookup"><span data-stu-id="2da29-745">Because the <xref:System.Type.GetConstructors%2A> overload uses only <xref:System.Reflection.BindingFlags.Public> and <xref:System.Reflection.BindingFlags.Instance>, the static constructor is neither counted by the `for` expression nor evaluated by `IsStatic`.</span></span>  
  
 <span data-ttu-id="2da29-746">Um statische Konstruktoren zu ermitteln, verwenden Sie die <xref:System.Type.GetConstructors%2A> überladen, und übergeben sie die Kombination (logisches OR) von <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, wie im folgenden Codebeispiel gezeigt:</span><span class="sxs-lookup"><span data-stu-id="2da29-746">To find static constructors, use the <xref:System.Type.GetConstructors%2A> overload, and pass it the combination (logical OR) of <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, as shown in the following code example:</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="2da29-747">Jetzt ist die Ausgabe:</span><span class="sxs-lookup"><span data-stu-id="2da29-747">Now the output is:</span></span>  
  
 <span data-ttu-id="2da29-748">3</span><span class="sxs-lookup"><span data-stu-id="2da29-748">3</span></span>  
  
 <span data-ttu-id="2da29-749">False</span><span class="sxs-lookup"><span data-stu-id="2da29-749">False</span></span>  
  
 <span data-ttu-id="2da29-750">True</span><span class="sxs-lookup"><span data-stu-id="2da29-750">True</span></span>  
  
 <span data-ttu-id="2da29-751">False</span><span class="sxs-lookup"><span data-stu-id="2da29-751">False</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-752">Sucht nach den für den aktuellen <see cref="T:System.Type" /> definierten Membern, deren <see cref="T:System.Reflection.DefaultMemberAttribute" /> festgelegt ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-752">Searches for the members defined for the current <see cref="T:System.Type" /> whose <see cref="T:System.Reflection.DefaultMemberAttribute" /> is set.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-753">Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die alle Standardmember des aktuellen <see cref="T:System.Type" /> darstellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-753">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all default members of the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="2da29-754">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-754">-or-</span>
          </span>
          <span data-ttu-id="2da29-755">Ein leeres Array vom <see cref="T:System.Reflection.MemberInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine Standardmember besitzt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-755">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have default members.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-756">Die <xref:System.Type.GetDefaultMembers%2A> Methode gibt keinen zurück Mitglieder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</span><span class="sxs-lookup"><span data-stu-id="2da29-756">The <xref:System.Type.GetDefaultMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="2da29-757">Der Code muss nicht richten sich nach der Reihenfolge, in der Elemente zurückgegeben werden, da, bei der Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="2da29-757">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="2da29-758">Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-758">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="2da29-759">Member enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.</span><span class="sxs-lookup"><span data-stu-id="2da29-759">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="2da29-760">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-760">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="2da29-761">Memberart</span><span class="sxs-lookup"><span data-stu-id="2da29-761">Member Type</span></span>|<span data-ttu-id="2da29-762">Statisch</span><span class="sxs-lookup"><span data-stu-id="2da29-762">Static</span></span>|<span data-ttu-id="2da29-763">Nicht statische</span><span class="sxs-lookup"><span data-stu-id="2da29-763">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="2da29-764">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="2da29-764">Constructor</span></span>|<span data-ttu-id="2da29-765">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-765">No</span></span>|<span data-ttu-id="2da29-766">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-766">No</span></span>|  
|<span data-ttu-id="2da29-767">Feld</span><span class="sxs-lookup"><span data-stu-id="2da29-767">Field</span></span>|<span data-ttu-id="2da29-768">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-768">No</span></span>|<span data-ttu-id="2da29-769">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-769">Yes.</span></span> <span data-ttu-id="2da29-770">Ein Feld ist immer nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-770">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-771">event</span><span class="sxs-lookup"><span data-stu-id="2da29-771">Event</span></span>|<span data-ttu-id="2da29-772">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-772">Not applicable</span></span>|<span data-ttu-id="2da29-773">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-773">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-774">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-774">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-775">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-775">See note 2 below.</span></span>|  
|<span data-ttu-id="2da29-776">Methode</span><span class="sxs-lookup"><span data-stu-id="2da29-776">Method</span></span>|<span data-ttu-id="2da29-777">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-777">No</span></span>|<span data-ttu-id="2da29-778">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-778">Yes.</span></span> <span data-ttu-id="2da29-779">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-779">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-780">Geschachtelten Typs</span><span class="sxs-lookup"><span data-stu-id="2da29-780">Nested Type</span></span>|<span data-ttu-id="2da29-781">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-781">No</span></span>|<span data-ttu-id="2da29-782">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-782">No</span></span>|  
|<span data-ttu-id="2da29-783">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="2da29-783">Property</span></span>|<span data-ttu-id="2da29-784">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-784">Not applicable</span></span>|<span data-ttu-id="2da29-785">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-785">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-786">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-786">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-787">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-787">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="2da29-788">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-788">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="2da29-789">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="2da29-789">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="2da29-790">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-790">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-791">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-791">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="2da29-792">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="2da29-792">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="2da29-793">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MemberInfo> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-793">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="2da29-794">Z. B. Wenn Klasse `C<T>` verfügt über eine Eigenschaft `P` zurückgibt `T`Aufrufen <xref:System.Type.GetDefaultMembers%2A> auf `C<int>` gibt `int P` in c# (`Property P As Integer` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-794">For example, if class `C<T>` has a property `P` that returns `T`, calling <xref:System.Type.GetDefaultMembers%2A> on `C<int>` returns `int P` in C# (`Property P As Integer` in Visual Basic).</span></span>  
  
 <span data-ttu-id="2da29-795">Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Mitglieder der Class-Einschränkung oder die Elemente der <xref:System.Object> Wenn ohne klasseneinschränkung ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-795">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-796">Das folgende Beispiel ruft Informationen über das Element der `MyClass` und die Standardelemente angezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-796">The following example obtains the default member information of `MyClass` and displays the default members.</span></span>  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-797">Gibt beim Überschreiben in einer abgeleiteten Klasse den <see cref="T:System.Type" /> des Objekts zurück, das der aktuelle Array-, Zeiger- oder Verweistyp einschließt bzw. auf das er verweist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-797">When overridden in a derived class, returns the <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer or reference type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-798">Der <see cref="T:System.Type" /> des eingeschlossenen Objekts bzw. des Objekts, auf das durch den aktuellen Array-, Zeiger- oder Verweistyp verwiesen wird, oder <see langword="null" />, wenn der aktuelle <see cref="T:System.Type" /> kein Array oder Zeiger ist, nicht als Verweis übergeben wurde oder einen generischen Typ oder Typparameter einer generischen Typ- oder Methodendefinition darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-798">The <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer, or reference type, or <see langword="null" /> if the current <see cref="T:System.Type" /> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-799">Diese Methode gibt `null` für die <xref:System.Array> Klasse.</span><span class="sxs-lookup"><span data-stu-id="2da29-799">This method returns `null` for the <xref:System.Array> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-800">Das folgende Beispiel veranschaulicht die Verwendung der `GetElementType` Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-800">The following example demonstrates using the `GetElementType` method.</span></span>  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="2da29-801">Der Wert, dessen Name abgerufen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-801">The value whose name is to be retrieved.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-802">Gibt den Namen der Konstanten für den aktuellen Enumerationstyp zurück, die den angegebenen Wert aufweist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-802">Returns the name of the constant that has the specified value, for the current enumeration type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-803">Der Name des Members des aktuellen Enumerationstyps, der über den angegebenen Wert verfügt, oder<see langword="null" />, wenn keine solche Konstante gefunden wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-803">The name of the member of the current enumeration type that has the specified value, or <see langword="null" /> if no such constant is found.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-804">Der aktuelle Typ ist keine Enumeration.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-804">The current type is not an enumeration.</span>
          </span>
          <span data-ttu-id="2da29-805">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-805">-or-</span>
          </span>
          <span data-ttu-id="2da29-806">
            <paramref name="value" /> ist weder vom aktuellen Typ noch er hat den gleichen zugrunde liegenden Typ wie der aktuelle Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-806">
              <paramref name="value" /> is neither of the current type nor does it have the same underlying type as the current type.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-807">
            <paramref name="value" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-807">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-808">Gibt die Namen der Member des aktuellen Enumerationstyps zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-808">Returns the names of the members of the current enumeration type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-809">Ein Array, das die Namen der Member der Enumeration enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-809">An array that contains the names of the members of the enumeration.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-810">Die Elemente des Arrays Rückgabewert sind nach den Binärwerten (d. h. aus den Werten ohne Vorzeichen) der Enumerationskonstanten sortiert.</span><span class="sxs-lookup"><span data-stu-id="2da29-810">The elements of the return value array are sorted by the binary values (that is, the unsigned values) of the enumerated constants.</span></span> <span data-ttu-id="2da29-811">Wenn das Array Enumerationskonstanten mit demselben Wert enthält, ist die Reihenfolge der entsprechenden Namen nicht angegeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-811">If the array contains enumerated constants with the same value, the order of their corresponding names is unspecified.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-812">Der aktuelle Typ ist keine Enumeration.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-812">The current type is not an enumeration.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-813">Gibt den zugrunde liegenden Typ des aktuellen Enumerationstyps zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-813">Returns the underlying type of the current enumeration type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-814">Der zugrunde liegende Typ der aktuellen Enumeration.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-814">The underlying type of the current enumeration.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-815">Standardmäßig ist der zugrunde liegende Typ einer Enumeration in c# und Visual Basic <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="2da29-815">By default, the underlying type of an enumeration in C# and Visual Basic is <xref:System.Int32>.</span></span> <span data-ttu-id="2da29-816">Andere ganzzahlige Typen können angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-816">Other integer types can be specified.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-817">Der aktuelle Typ ist keine Enumeration.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-817">The current type is not an enumeration.</span>
          </span>
          <span data-ttu-id="2da29-818">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-818">-or-</span>
          </span>
          <span data-ttu-id="2da29-819">Der Enumerationstyp ist ungültig, da er mehr als ein Instanzfeld enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-819">The enumeration type is not valid, because it contains more than one instance field.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-820">Gibt ein Array mit den Werten der Konstanten im aktuellen Enumerationstyp zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-820">Returns an array of the values of the constants in the current enumeration type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-821">Ein Array, das die Werte enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-821">An array that contains the values.</span>
          </span>
          <span data-ttu-id="2da29-822">Die Elemente des Arrays sind nach den Binärwerten (den Werten ohne Vorzeichen) der Enumerationskonstanten sortiert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-822">The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-823">Der aktuelle Typ ist keine Enumeration.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-823">The current type is not an enumeration.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-824">Ruft ein bestimmtes Ereignis ab, das vom aktuellen <see cref="T:System.Type" /> deklariert oder geerbt wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-824">Gets a specific event declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-825">Die Zeichenfolge, die den Namen eines vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten Ereignisses enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-825">The string containing the name of an event that is declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-826">Gibt das <see cref="T:System.Reflection.EventInfo" />-Objekt zurück, das das angegebene öffentliche Ereignis darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-826">Returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified public event.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-827">Das Objekt, das das angegebene vom aktuellen <see cref="T:System.Type" /> deklarierte oder geerbte öffentliche Ereignis darstellt, sofern gefunden, andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-827">The object representing the specified public event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-828">Ein Ereignis ist Reflektion als öffentlich betrachtet, wenn sie verfügt über mindestens eine Methode oder Accessor, der öffentlich ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-828">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="2da29-829">Andernfalls wird das Ereignis als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-829">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="2da29-830">Die Suche nach `name` Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="2da29-830">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="2da29-831">Die Suche enthält öffentliche statisch und öffentlich Instanz Ereignisse.</span><span class="sxs-lookup"><span data-stu-id="2da29-831">The search includes public static and public instance events.</span></span>  
  
 <span data-ttu-id="2da29-832">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-832">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="2da29-833">Memberart</span><span class="sxs-lookup"><span data-stu-id="2da29-833">Member Type</span></span>|<span data-ttu-id="2da29-834">Statisch</span><span class="sxs-lookup"><span data-stu-id="2da29-834">Static</span></span>|<span data-ttu-id="2da29-835">Nicht statische</span><span class="sxs-lookup"><span data-stu-id="2da29-835">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="2da29-836">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="2da29-836">Constructor</span></span>|<span data-ttu-id="2da29-837">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-837">No</span></span>|<span data-ttu-id="2da29-838">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-838">No</span></span>|  
|<span data-ttu-id="2da29-839">Feld</span><span class="sxs-lookup"><span data-stu-id="2da29-839">Field</span></span>|<span data-ttu-id="2da29-840">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-840">No</span></span>|<span data-ttu-id="2da29-841">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-841">Yes.</span></span> <span data-ttu-id="2da29-842">Ein Feld ist immer nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-842">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-843">event</span><span class="sxs-lookup"><span data-stu-id="2da29-843">Event</span></span>|<span data-ttu-id="2da29-844">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-844">Not applicable</span></span>|<span data-ttu-id="2da29-845">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-845">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-846">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-846">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-847">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-847">See note 2 below.</span></span>|  
|<span data-ttu-id="2da29-848">Methode</span><span class="sxs-lookup"><span data-stu-id="2da29-848">Method</span></span>|<span data-ttu-id="2da29-849">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-849">No</span></span>|<span data-ttu-id="2da29-850">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-850">Yes.</span></span> <span data-ttu-id="2da29-851">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-851">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-852">Geschachtelten Typs</span><span class="sxs-lookup"><span data-stu-id="2da29-852">Nested Type</span></span>|<span data-ttu-id="2da29-853">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-853">No</span></span>|<span data-ttu-id="2da29-854">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-854">No</span></span>|  
|<span data-ttu-id="2da29-855">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="2da29-855">Property</span></span>|<span data-ttu-id="2da29-856">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-856">Not applicable</span></span>|<span data-ttu-id="2da29-857">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-857">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-858">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-858">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-859">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-859">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="2da29-860">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-860">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="2da29-861">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="2da29-861">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="2da29-862">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-862">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-863">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-863">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="2da29-864">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="2da29-864">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="2da29-865">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.EventInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-865">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-866">Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Ereignisse der Class-Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="2da29-866">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-867">Das folgende Beispiel erstellt ein <xref:System.Reflection.EventInfo> -Objekt und ruft das Ereignis für eine Schaltfläche für das angegebene Ereignis ab.</span><span class="sxs-lookup"><span data-stu-id="2da29-867">The following example creates an <xref:System.Reflection.EventInfo> object and gets the event for a button class for the specified event.</span></span>  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-868">
            <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-868">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-869">Die Zeichenfolge, die den Namen eines vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten Ereignisses enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-869">The string containing the name of an event which is declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="2da29-870">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-870">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="2da29-871">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-871">-or-</span>
          </span>
          <span data-ttu-id="2da29-872">0 (null), damit <see langword="null" /> zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-872">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-873">Gibt beim Überschreiben in einer abgeleiteten Klasse das <see cref="T:System.Reflection.EventInfo" />-Objekt zurück, das das angegebene Ereignis unter Verwendung der angegebenen Bindungseinschränkungen darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-873">When overridden in a derived class, returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified event, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-874">Das Objekt, das das angegebene vom aktuellen <see cref="T:System.Type" /> deklarierte oder geerbte Ereignis darstellt, sofern gefunden, andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-874">The object representing the specified event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-875">Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Ereignisse in die Suche einbezogen werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-875">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:</span></span>  
  
-   <span data-ttu-id="2da29-876">Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-876">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="2da29-877">Geben Sie `BindingFlags.Public` öffentlichen Ereignisse in die Suche eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="2da29-877">Specify `BindingFlags.Public` to include public events in the search.</span></span>  
  
-   <span data-ttu-id="2da29-878">Geben Sie `BindingFlags.NonPublic` an nicht öffentlichen Ereignisse (d. h. private, interne und geschützte) in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-878">Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search.</span></span>  
  
-   <span data-ttu-id="2da29-879">Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="2da29-879">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="2da29-880">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</span><span class="sxs-lookup"><span data-stu-id="2da29-880">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="2da29-881">`BindingFlags.IgnoreCase` um die Groß-/Kleinschreibung ignorieren `name`.</span><span class="sxs-lookup"><span data-stu-id="2da29-881">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="2da29-882">`BindingFlags.DeclaredOnly` Suchen Sie nur die Ereignisse, die deklariert wird, auf die <xref:System.Type>, nicht die Ereignisse, die nur geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-882">`BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.</span></span>  
  
 <span data-ttu-id="2da29-883">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-883">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="2da29-884">Ein Ereignis ist Reflektion als öffentlich betrachtet, wenn sie verfügt über mindestens eine Methode oder Accessor, der öffentlich ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-884">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="2da29-885">Andernfalls wird das Ereignis als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-885">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="2da29-886">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.EventInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-886">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-887">Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Ereignisse der Class-Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="2da29-887">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-888">Im folgenden Codebeispiel wird mit der <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> Methode, um einen Typ für einen öffentlichen oder nicht öffentlichen-Ereignis mit dem Namen "Klicken Sie auf" suchen, die nicht `static` (`Shared` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-888">The following code example uses the <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> method to search a type for a public or non-public event named "Click" that is not `static` (`Shared` in Visual Basic).</span></span>  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-889">
            <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-889">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-890">Ruft die vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten Ereignisse ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-890">Gets the events that are declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-891">Gibt sämtliche vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten öffentlichen Ereignisse zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-891">Returns all the public events that are declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-892">Gibt ein Array von <see cref="T:System.Reflection.EventInfo" />-Objekten zurück, die sämtliche vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten öffentlichen Ereignisse darstellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-892">An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all the public events which are declared or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="2da29-893">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-893">-or-</span>
          </span>
          <span data-ttu-id="2da29-894">Ein leeres Array vom <see cref="T:System.Reflection.EventInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine öffentlichen Ereignisse besitzt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-894">An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have public events.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-895">Ein Ereignis ist Reflektion als öffentlich betrachtet, wenn sie verfügt über mindestens eine Methode oder Accessor, der öffentlich ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-895">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="2da29-896">Andernfalls wird das Ereignis als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-896">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="2da29-897">Die <xref:System.Type.GetEvents%2A> Methode gibt keinen zurück Ereignisse in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</span><span class="sxs-lookup"><span data-stu-id="2da29-897">The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="2da29-898">Der Code muss nicht richten sich nach der Reihenfolge, in der Ereignisse zurückgegeben werden, da, bei der Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="2da29-898">Your code must not depend on the order in which events are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="2da29-899">Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-899">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="2da29-900">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-900">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="2da29-901">Memberart</span><span class="sxs-lookup"><span data-stu-id="2da29-901">Member Type</span></span>|<span data-ttu-id="2da29-902">Statisch</span><span class="sxs-lookup"><span data-stu-id="2da29-902">Static</span></span>|<span data-ttu-id="2da29-903">Nicht statische</span><span class="sxs-lookup"><span data-stu-id="2da29-903">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="2da29-904">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="2da29-904">Constructor</span></span>|<span data-ttu-id="2da29-905">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-905">No</span></span>|<span data-ttu-id="2da29-906">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-906">No</span></span>|  
|<span data-ttu-id="2da29-907">Feld</span><span class="sxs-lookup"><span data-stu-id="2da29-907">Field</span></span>|<span data-ttu-id="2da29-908">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-908">No</span></span>|<span data-ttu-id="2da29-909">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-909">Yes.</span></span> <span data-ttu-id="2da29-910">Ein Feld ist immer nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-910">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-911">event</span><span class="sxs-lookup"><span data-stu-id="2da29-911">Event</span></span>|<span data-ttu-id="2da29-912">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-912">Not applicable</span></span>|<span data-ttu-id="2da29-913">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-913">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-914">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-914">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-915">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-915">See note 2 below.</span></span>|  
|<span data-ttu-id="2da29-916">Methode</span><span class="sxs-lookup"><span data-stu-id="2da29-916">Method</span></span>|<span data-ttu-id="2da29-917">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-917">No</span></span>|<span data-ttu-id="2da29-918">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-918">Yes.</span></span> <span data-ttu-id="2da29-919">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-919">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-920">Geschachtelten Typs</span><span class="sxs-lookup"><span data-stu-id="2da29-920">Nested Type</span></span>|<span data-ttu-id="2da29-921">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-921">No</span></span>|<span data-ttu-id="2da29-922">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-922">No</span></span>|  
|<span data-ttu-id="2da29-923">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="2da29-923">Property</span></span>|<span data-ttu-id="2da29-924">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-924">Not applicable</span></span>|<span data-ttu-id="2da29-925">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-925">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-926">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-926">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-927">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-927">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="2da29-928">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-928">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="2da29-929">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="2da29-929">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="2da29-930">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-930">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-931">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-931">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="2da29-932">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="2da29-932">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="2da29-933">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.EventInfo> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-933">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-934">Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Ereignisse der Class-Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="2da29-934">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-935">Im folgende Beispiel ruft ein Array von <xref:System.Reflection.EventInfo> Objekte, ruft die Ereignisse für eine `Button` Klasse, und die Ereignisnamen angezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-935">The following example obtains an array of <xref:System.Reflection.EventInfo> objects, gets all the events for a `Button` class, and displays the event names.</span></span> <span data-ttu-id="2da29-936">Um die Visual Basic-Beispiel zu kompilieren, verwenden Sie die folgende Befehlszeile ein:</span><span class="sxs-lookup"><span data-stu-id="2da29-936">To compile the Visual Basic example, use the following command line:</span></span>  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="2da29-937">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-937">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="2da29-938">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-938">-or-</span>
          </span>
          <span data-ttu-id="2da29-939">0 (null), damit <see langword="null" /> zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-939">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-940">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen nach vom aktuellen <see cref="T:System.Type" /> definierten oder geerbten Ereignissen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-940">When overridden in a derived class, searches for events that are declared or inherited by the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-941">Ein Array von <see cref="T:System.Reflection.EventInfo" />-Objekten, die sämtliche vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten Ereignisse darstellen, die den angegebenen Bindungseinschränkungen entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-941">An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all events that are declared or inherited by the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="2da29-942">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-942">-or-</span>
          </span>
          <span data-ttu-id="2da29-943">Ein leeres Array vom <see cref="T:System.Reflection.EventInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine Ereignisse besitzt oder keines der Ereignisse den Bindungseinschränkungen entspricht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-943">An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have events, or if none of the events match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-944">Die <xref:System.Type.GetEvents%2A> Methode gibt keinen zurück Ereignisse in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</span><span class="sxs-lookup"><span data-stu-id="2da29-944">The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="2da29-945">Der Code muss nicht richten sich nach der Reihenfolge, in der Ereignisse zurückgegeben werden, da, bei der Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="2da29-945">Your code must not depend on the order in which events are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="2da29-946">Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Ereignisse in die Suche einbezogen werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-946">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:</span></span>  
  
-   <span data-ttu-id="2da29-947">Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-947">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="2da29-948">Geben Sie `BindingFlags.Public` öffentlichen Ereignisse in die Suche eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="2da29-948">Specify `BindingFlags.Public` to include public events in the search.</span></span>  
  
-   <span data-ttu-id="2da29-949">Geben Sie `BindingFlags.NonPublic` an nicht öffentlichen Ereignisse (d. h. private, interne und geschützte) in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-949">Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search.</span></span> <span data-ttu-id="2da29-950">Nur geschützte und interne Ereignisse für Basisklassen werden zurückgegeben. Private Ereignisse für Basisklassen werden nicht zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-950">Only protected and internal events on base classes are returned; private events on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="2da29-951">Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="2da29-951">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="2da29-952">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</span><span class="sxs-lookup"><span data-stu-id="2da29-952">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="2da29-953">`BindingFlags.DeclaredOnly` Suchen Sie nur die Ereignisse, die deklariert wird, auf die <xref:System.Type>, nicht die Ereignisse, die nur geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-953">`BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.</span></span>  
  
 <span data-ttu-id="2da29-954">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-954">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="2da29-955">Ein Ereignis ist Reflektion als öffentlich betrachtet, wenn sie verfügt über mindestens eine Methode oder Accessor, der öffentlich ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-955">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="2da29-956">Andernfalls wird das Ereignis als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-956">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="2da29-957">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.EventInfo> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-957">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-958">Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Ereignisse der Class-Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="2da29-958">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-959">Im folgende Beispiel ruft ein Array von <xref:System.Reflection.EventInfo> Objekte, die den angegebenen Bindungsflags übereinstimmen Ruft alle Ereignisse für eine `Button` Klasse, und die Ereignisnamen angezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-959">The following example obtains an array of <xref:System.Reflection.EventInfo> objects that match the specified binding flags, gets all the events for a `Button` class, and displays the event names.</span></span> <span data-ttu-id="2da29-960">Um die Visual Basic-Beispiel zu kompilieren, verwenden Sie die folgende Befehlszeile ein:</span><span class="sxs-lookup"><span data-stu-id="2da29-960">To compile the Visual Basic example, use the following command line:</span></span>  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-961">Ruft ein bestimmtes Feld des aktuellen <see cref="T:System.Type" /> ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-961">Gets a specific field of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-962">Die Zeichenfolge, die den Namen des abzurufenden Datenfelds enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-962">The string containing the name of the data field to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-963">Sucht das öffentliche Feld mit dem angegebenen Namen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-963">Searches for the public field with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-964">Ein Objekt, das das öffentliche Feld mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-964">An object representing the public field with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-965">Die Suche nach `name` Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="2da29-965">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="2da29-966">Die Suche enthält öffentliche statisch und öffentlich Instanzfelder.</span><span class="sxs-lookup"><span data-stu-id="2da29-966">The search includes public static and public instance fields.</span></span>  
  
 <span data-ttu-id="2da29-967">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.FieldInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-967">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-968">Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Felder der Class-Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="2da29-968">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-969">Im folgenden Beispiel wird die `Type` -Objekt für die angegebene Klasse, erhält der <xref:System.Reflection.FieldInfo> Objekt für das Feld und der Wert des Felds angezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-969">The following example gets the `Type` object for the specified class, obtains the <xref:System.Reflection.FieldInfo> object for the field, and displays the value of the field.</span></span>  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-970">
            <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-970">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2da29-971">Dieses <see cref="T:System.Type" />-Objekt ist ein <see cref="T:System.Reflection.Emit.TypeBuilder" />, dessen <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />-Methode noch nicht aufgerufen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-971">This <see cref="T:System.Type" /> object is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> whose <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method has not yet been called.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-972">Die Zeichenfolge, die den Namen des abzurufenden Datenfelds enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-972">The string containing the name of the data field to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="2da29-973">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-973">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="2da29-974">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-974">-or-</span>
          </span>
          <span data-ttu-id="2da29-975">0 (null), damit <see langword="null" /> zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-975">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-976">Sucht das angegebene Feld unter Verwendung der angegebenen Bindungseinschränkungen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-976">Searches for the specified field, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-977">Ein Objekt, das das Feld darstellt, das den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-977">An object representing the field that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-978">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-978">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="2da29-979">Memberart</span><span class="sxs-lookup"><span data-stu-id="2da29-979">Member Type</span></span>|<span data-ttu-id="2da29-980">Statisch</span><span class="sxs-lookup"><span data-stu-id="2da29-980">Static</span></span>|<span data-ttu-id="2da29-981">Nicht statische</span><span class="sxs-lookup"><span data-stu-id="2da29-981">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="2da29-982">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="2da29-982">Constructor</span></span>|<span data-ttu-id="2da29-983">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-983">No</span></span>|<span data-ttu-id="2da29-984">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-984">No</span></span>|  
|<span data-ttu-id="2da29-985">Feld</span><span class="sxs-lookup"><span data-stu-id="2da29-985">Field</span></span>|<span data-ttu-id="2da29-986">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-986">No</span></span>|<span data-ttu-id="2da29-987">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-987">Yes.</span></span> <span data-ttu-id="2da29-988">Ein Feld ist immer nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-988">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-989">event</span><span class="sxs-lookup"><span data-stu-id="2da29-989">Event</span></span>|<span data-ttu-id="2da29-990">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-990">Not applicable</span></span>|<span data-ttu-id="2da29-991">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-991">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-992">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-992">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-993">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-993">See note 2 below.</span></span>|  
|<span data-ttu-id="2da29-994">Methode</span><span class="sxs-lookup"><span data-stu-id="2da29-994">Method</span></span>|<span data-ttu-id="2da29-995">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-995">No</span></span>|<span data-ttu-id="2da29-996">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-996">Yes.</span></span> <span data-ttu-id="2da29-997">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-997">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-998">Geschachtelten Typs</span><span class="sxs-lookup"><span data-stu-id="2da29-998">Nested Type</span></span>|<span data-ttu-id="2da29-999">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-999">No</span></span>|<span data-ttu-id="2da29-1000">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1000">No</span></span>|  
|<span data-ttu-id="2da29-1001">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="2da29-1001">Property</span></span>|<span data-ttu-id="2da29-1002">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-1002">Not applicable</span></span>|<span data-ttu-id="2da29-1003">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-1003">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-1004">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1004">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-1005">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1005">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="2da29-1006">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-1006">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="2da29-1007">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="2da29-1007">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="2da29-1008">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1008">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-1009">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1009">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="2da29-1010">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="2da29-1010">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="2da29-1011">Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Felder in die Suche einbezogen werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-1011">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:</span></span>  
  
-   <span data-ttu-id="2da29-1012">Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1012">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="2da29-1013">Geben Sie `BindingFlags.Public` öffentliche Felder in die Suche eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1013">Specify `BindingFlags.Public` to include public fields in the search.</span></span>  
  
-   <span data-ttu-id="2da29-1014">Geben Sie `BindingFlags.NonPublic` nicht öffentlichen Felder (d. h. private, interne und geschützte Felder) in die Suche eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1014">Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search.</span></span>  
  
-   <span data-ttu-id="2da29-1015">Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1015">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="2da29-1016">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</span><span class="sxs-lookup"><span data-stu-id="2da29-1016">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="2da29-1017">`BindingFlags.IgnoreCase` um die Groß-/Kleinschreibung ignorieren `name`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1017">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="2da29-1018">`BindingFlags.DeclaredOnly` Suchen Sie nur die Felder, die deklariert wird, auf die <xref:System.Type>, nicht nach Feldern, die nur geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1018">`BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.</span></span>  
  
 <span data-ttu-id="2da29-1019">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1019">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="2da29-1020">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.FieldInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1020">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-1021">Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Felder der Class-Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="2da29-1021">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1022">Im folgenden Beispiel wird die `Type` -Objekt für die angegebene Klasse, erhält der <xref:System.Reflection.FieldInfo> Objekt für das Feld, das den angegebenen Bindungsflags entspricht, und zeigt den Wert des Felds.</span><span class="sxs-lookup"><span data-stu-id="2da29-1022">The following example gets the `Type` object for the specified class, obtains the <xref:System.Reflection.FieldInfo> object for the field that matches the specified binding flags, and displays the value of the field.</span></span>  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-1023">
            <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1023">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-1024">Ruft die Felder des aktuellen <see cref="T:System.Type" /> ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1024">Gets the fields of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-1025">Gibt sämtliche öffentlichen Felder des aktuellen <see cref="T:System.Type" /> zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1025">Returns all the public fields of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1026">Ein Array von <see cref="T:System.Reflection.FieldInfo" />-Objekten, die alle für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Felder darstellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1026">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all the public fields defined for the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="2da29-1027">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1027">-or-</span>
          </span>
          <span data-ttu-id="2da29-1028">Ein leeres Array vom <see cref="T:System.Reflection.FieldInfo" />-Typ, wenn für den aktuellen <see cref="T:System.Type" /> keine öffentlichen Felder definiert sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1028">An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no public fields are defined for the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1029">Die <xref:System.Type.GetFields%2A> Methode gibt keinen zurück Felder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</span><span class="sxs-lookup"><span data-stu-id="2da29-1029">The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="2da29-1030">Der Code muss nicht richten sich nach der Reihenfolge, in der Felder zurückgegeben werden, da, bei der Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="2da29-1030">Your code must not depend on the order in which fields are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="2da29-1031">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-1031">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="2da29-1032">Memberart</span><span class="sxs-lookup"><span data-stu-id="2da29-1032">Member Type</span></span>|<span data-ttu-id="2da29-1033">Statisch</span><span class="sxs-lookup"><span data-stu-id="2da29-1033">Static</span></span>|<span data-ttu-id="2da29-1034">Nicht statische</span><span class="sxs-lookup"><span data-stu-id="2da29-1034">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="2da29-1035">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="2da29-1035">Constructor</span></span>|<span data-ttu-id="2da29-1036">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1036">No</span></span>|<span data-ttu-id="2da29-1037">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1037">No</span></span>|  
|<span data-ttu-id="2da29-1038">Feld</span><span class="sxs-lookup"><span data-stu-id="2da29-1038">Field</span></span>|<span data-ttu-id="2da29-1039">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1039">No</span></span>|<span data-ttu-id="2da29-1040">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-1040">Yes.</span></span> <span data-ttu-id="2da29-1041">Ein Feld ist immer nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1041">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-1042">event</span><span class="sxs-lookup"><span data-stu-id="2da29-1042">Event</span></span>|<span data-ttu-id="2da29-1043">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-1043">Not applicable</span></span>|<span data-ttu-id="2da29-1044">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-1044">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-1045">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1045">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-1046">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1046">See note 2 below.</span></span>|  
|<span data-ttu-id="2da29-1047">Methode</span><span class="sxs-lookup"><span data-stu-id="2da29-1047">Method</span></span>|<span data-ttu-id="2da29-1048">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1048">No</span></span>|<span data-ttu-id="2da29-1049">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-1049">Yes.</span></span> <span data-ttu-id="2da29-1050">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1050">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-1051">Geschachtelten Typs</span><span class="sxs-lookup"><span data-stu-id="2da29-1051">Nested Type</span></span>|<span data-ttu-id="2da29-1052">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1052">No</span></span>|<span data-ttu-id="2da29-1053">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1053">No</span></span>|  
|<span data-ttu-id="2da29-1054">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="2da29-1054">Property</span></span>|<span data-ttu-id="2da29-1055">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-1055">Not applicable</span></span>|<span data-ttu-id="2da29-1056">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-1056">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-1057">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1057">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-1058">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1058">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="2da29-1059">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-1059">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="2da29-1060">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="2da29-1060">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="2da29-1061">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1061">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-1062">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1062">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="2da29-1063">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="2da29-1063">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="2da29-1064">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.FieldInfo> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1064">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-1065">Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition diese Methode sucht die öffentlichen Felder von der Class-Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="2da29-1065">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1066">Das folgende Beispiel veranschaulicht die Verwendung von der `GetFields()` Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-1066">The following example shows a use of the `GetFields()` method.</span></span>  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="2da29-1067">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1067">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="2da29-1068">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1068">-or-</span>
          </span>
          <span data-ttu-id="2da29-1069">0 (null), damit <see langword="null" /> zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1069">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-1070">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die für den aktuellen <see cref="T:System.Type" /> definierten Felder.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1070">When overridden in a derived class, searches for the fields defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1071">Ein Array von <see cref="T:System.Reflection.FieldInfo" />-Objekten, die sämtliche für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Felder darstellen, die den angegebenen Bindungseinschränkungen entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1071">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all fields defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="2da29-1072">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1072">-or-</span>
          </span>
          <span data-ttu-id="2da29-1073">Ein leeres Array vom <see cref="T:System.Reflection.FieldInfo" />-Typ, wenn für den aktuellen <see cref="T:System.Type" /> keine Felder definiert sind oder keines der definierten Felder den Bindungseinschränkungen entspricht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1073">An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no fields are defined for the current <see cref="T:System.Type" />, or if none of the defined fields match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1074">Die <xref:System.Type.GetFields%2A> Methode gibt keinen zurück Felder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</span><span class="sxs-lookup"><span data-stu-id="2da29-1074">The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="2da29-1075">Der Code muss nicht richten sich nach der Reihenfolge, in der Felder zurückgegeben werden, da, bei der Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="2da29-1075">Your code must not depend on the order in which fields are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="2da29-1076">Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Felder in die Suche einbezogen werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-1076">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:</span></span>  
  
-   <span data-ttu-id="2da29-1077">Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1077">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="2da29-1078">Geben Sie `BindingFlags.Public` öffentliche Felder in die Suche eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1078">Specify `BindingFlags.Public` to include public fields in the search.</span></span>  
  
-   <span data-ttu-id="2da29-1079">Geben Sie `BindingFlags.NonPublic` nicht öffentlichen Felder (d. h. private, interne und geschützte Felder) in die Suche eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1079">Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search.</span></span> <span data-ttu-id="2da29-1080">Nur geschützte und interne Felder für Basisklassen werden zurückgegeben. private Felder für Basisklassen werden nicht zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-1080">Only protected and internal fields on base classes are returned; private fields on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="2da29-1081">Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1081">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="2da29-1082">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</span><span class="sxs-lookup"><span data-stu-id="2da29-1082">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="2da29-1083">`BindingFlags.DeclaredOnly` Suchen Sie nur die Felder, die deklariert wird, auf die <xref:System.Type>, nicht nach Feldern, die nur geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1083">`BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.</span></span>  
  
 <span data-ttu-id="2da29-1084">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1084">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="2da29-1085">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.FieldInfo> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1085">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-1086">Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition diese Methode sucht die öffentlichen Felder von der Class-Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="2da29-1086">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1087">Das folgende Beispiel veranschaulicht die Verwendung von der `GetFields(BindingFlags)` Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-1087">The following example shows a use of the `GetFields(BindingFlags)` method.</span></span>  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-1088">Gibt ein Array von <see cref="T:System.Type" />-Objekten zurück, die die Typargumente eines geschlossenen generischen Typs oder die Typparameter einer generischen Typdefinition darstellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1088">Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a closed generic type or the type parameters of a generic type definition.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1089">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typargumente eines generischen Typs darstellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1089">An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic type.</span>
          </span>
          <span data-ttu-id="2da29-1090">Gibt ein leeres Array zurück, wenn der aktuelle Typ kein generischer Typ ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1090">Returns an empty array if the current type is not a generic type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1091">Die Elemente des Arrays werden in der Reihenfolge zurückgegeben, in denen sie in der Liste der Typargumente für den generischen Typ angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1091">The array elements are returned in the order in which they appear in the list of type arguments for the generic type.</span></span>  
  
-   <span data-ttu-id="2da29-1092">Wenn der aktuelle Typ ein geschlossen konstruierter Typ ist (d. h. die <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft gibt `false`), das zurückgegebene Array die <xref:System.Type.GetGenericArguments%2A> Methode enthält die Typen, die die generischen Typparameter der generischen Typdefinition zugewiesen wurden .</span><span class="sxs-lookup"><span data-stu-id="2da29-1092">If the current type is a closed constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Type.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic type definition.</span></span>  
  
-   <span data-ttu-id="2da29-1093">Wenn der aktuelle Typ eine generische Typdefinition ist, enthält das Array die Typparameter an.</span><span class="sxs-lookup"><span data-stu-id="2da29-1093">If the current type is a generic type definition, the array contains the type parameters.</span></span>  
  
-   <span data-ttu-id="2da29-1094">Wenn der aktuelle Typ ein offener konstruierten Typ ist (d. h. die <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft gibt `true`) in denen bestimmten Typen nicht für alle Typparameter und die Typparameter von einschließenden generischen Typen oder Methoden zugewiesen wurden, enthält das Array Typen und Typparametern.</span><span class="sxs-lookup"><span data-stu-id="2da29-1094">If the current type is an open constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`) in which specific types have not been assigned to all of the type parameters and type parameters of enclosing generic types or methods, the array contains both types and type parameters.</span></span> <span data-ttu-id="2da29-1095">Verwenden der <xref:System.Type.IsGenericParameter%2A> Eigenschaft, um Sie voneinander zu unterscheiden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1095">Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart.</span></span> <span data-ttu-id="2da29-1096">Eine Demonstration dieses Szenarios, finden Sie im Codebeispiel für die <xref:System.Type.ContainsGenericParameters%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-1096">For a demonstration of this scenario, see the code example for the <xref:System.Type.ContainsGenericParameters%2A> property.</span></span>  
  
 <span data-ttu-id="2da29-1097">Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1097">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1098">Im folgenden Codebeispiel wird mit der <xref:System.Type.GetGenericArguments%2A> Methode, um die Typargumente eines konstruierten Typs und die Typparameter der generischen Typdefinition anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1098">The following code example uses the <xref:System.Type.GetGenericArguments%2A> method to display the type arguments of a constructed type and the type parameters of its generic type definition.</span></span>  
  
 <span data-ttu-id="2da29-1099">Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <xref:System.Type.IsGenericTypeDefinition%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-1099">This code example is part of a larger example provided for the <xref:System.Type.IsGenericTypeDefinition%2A> property.</span></span> <span data-ttu-id="2da29-1100">Siehe das größere Beispiel für die Ausgabe des Beispiels.</span><span class="sxs-lookup"><span data-stu-id="2da29-1100">See the larger example for sample output.</span></span>  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2da29-1101">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1101">The invoked method is not supported in the base class.</span>
          </span>
          <span data-ttu-id="2da29-1102">Abgeleitete Klassen müssen eine Implementation angeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1102">Derived classes must provide an implementation.</span>
          </span>
        </exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-1103">Gibt ein Array von <see cref="T:System.Type" />-Objekten zurück, die die Einschränkungen für den aktuellen generischen Typparameter darstellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1103">Returns an array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1104">Ein Array von <see cref="T:System.Type" />-Objekten, die die Einschränkungen für den aktuellen generischen Typparameter darstellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1104">An array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1105">Jede Einschränkung für einen generischen Typparameter wird als eine <xref:System.Type> Objekt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1105">Each constraint on a generic type parameter is expressed as a <xref:System.Type> object.</span></span> <span data-ttu-id="2da29-1106">Verwenden der <xref:System.Type.IsClass%2A> -Eigenschaft können Sie bestimmen, ob eine Einschränkung der base Class-Einschränkung ist; wenn die Eigenschaft zurückgibt `false`, die Einschränkung ist eine schnittstelleneinschränkung.</span><span class="sxs-lookup"><span data-stu-id="2da29-1106">Use the <xref:System.Type.IsClass%2A> property to determine whether a constraint is the base class constraint; if the property returns `false`, the constraint is an interface constraint.</span></span> <span data-ttu-id="2da29-1107">Wenn ein Typparameter ohne klasseneinschränkung und keine schnittstelleneinschränkungen verfügt, wird ein leeres Array zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-1107">If a type parameter has no class constraint and no interface constraints, an empty array is returned.</span></span>  
  
 <span data-ttu-id="2da29-1108">Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1108">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1109">Das folgende Codebeispiel definiert einen generischen Typ `Test` mit zwei Typparametern, die verschiedene Einschränkungen aufweisen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1109">The following code example defines a generic type `Test` with two type parameters that have different constraints.</span></span> <span data-ttu-id="2da29-1110">Wenn das Programm ausgeführt wird, die Einschränkungen werden untersucht, mit der <xref:System.Type.GenericParameterAttributes%2A> Eigenschaft und die <xref:System.Type.GetGenericParameterConstraints%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-1110">When the program executes, the constraints are examined using the <xref:System.Type.GenericParameterAttributes%2A> property and the <xref:System.Type.GetGenericParameterConstraints%2A> method.</span></span>  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="2da29-1111">Das aktuelle <see cref="T:System.Type" />-Objekt ist kein generischer Typparameter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1111">The current <see cref="T:System.Type" /> object is not a generic type parameter.</span>
          </span>
          <span data-ttu-id="2da29-1112">Das bedeutet, dass die <see cref="P:System.Type.IsGenericParameter" />-Eigenschaft <see langword="false" /> zurückgibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1112">That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</span>
          </span>
        </exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-1113">Gibt ein <see cref="T:System.Type" />-Objekt zurück, das eine generische Typdefinition darstellt, aus der der aktuelle generische Typ konstruiert werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1113">Returns a <see cref="T:System.Type" /> object that represents a generic type definition from which the current generic type can be constructed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1114">Ein <see cref="T:System.Type" />-Objekt, das einen generischen Typ darstellt, aus dem der aktuelle Typ konstruiert werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1114">A <see cref="T:System.Type" /> object representing a generic type from which the current type can be constructed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1115">Eine generische Typdefinition ist eine Vorlage aus der anderen Typen konstruiert werden können.</span><span class="sxs-lookup"><span data-stu-id="2da29-1115">A generic type definition is a template from which other types can be constructed.</span></span> <span data-ttu-id="2da29-1116">Z. B. von der generischen Typdefinition `G<T>` (ausgedrückt in C#-Syntax; `G(Of T)` in Visual Basic oder `generic <typename T> ref class G` in C++) können Sie erstellen und instanziieren Sie den Typ `G<int>` (`G(Of Integer)` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-1116">For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic).</span></span> <span data-ttu-id="2da29-1117">Erhält eine <xref:System.Type> Objekt, das dies darstellt konstruierter Typ, der <xref:System.Type.GetGenericTypeDefinition%2A> Methodenrückgabe die generische Typdefinition.</span><span class="sxs-lookup"><span data-stu-id="2da29-1117">Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the generic type definition.</span></span>  
  
 <span data-ttu-id="2da29-1118">Wenn zwei konstruierte Typen aus der gleichen generischen Typdefinition erstellt werden, verwenden Sie die gleichen Typargumente, die <xref:System.Type.GetGenericTypeDefinition%2A> Methodenrückgabe identisch <xref:System.Type> Objekt für beide Typen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1118">If two constructed types are created from the same generic type definition, using the same type arguments, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the same <xref:System.Type> object for both types.</span></span>  
  
 <span data-ttu-id="2da29-1119">Beim Aufrufen der <xref:System.Type.GetGenericTypeDefinition%2A> Methode auf eine <xref:System.Type> Objekt, das bereits eine generische Typdefinition darstellt gibt das aktuelle <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1119">If you call the <xref:System.Type.GetGenericTypeDefinition%2A> method on a <xref:System.Type> object that already represents a generic type definition, it returns the current <xref:System.Type>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="2da29-1120">Ein Array von generischen Typen ist nicht selbst generisch.</span><span class="sxs-lookup"><span data-stu-id="2da29-1120">An array of generic types is not itself generic.</span></span> <span data-ttu-id="2da29-1121">In der C#-Code `A<int>[] v;` oder Visual Basic-Code `Dim v() As A(Of Integer)`, den Typ der Variable `v` ist nicht generisch.</span><span class="sxs-lookup"><span data-stu-id="2da29-1121">In the C# code `A<int>[] v;` or the Visual Basic code `Dim v() As A(Of Integer)`, the type of variable `v` is not generic.</span></span> <span data-ttu-id="2da29-1122">Verwendung <xref:System.Type.IsGenericType%2A> zu bestimmen, ob ein Typ generisch ist, vor dem Aufruf ist <xref:System.Type.GetGenericTypeDefinition%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1122">Use <xref:System.Type.IsGenericType%2A> to determine whether a type is generic before calling <xref:System.Type.GetGenericTypeDefinition%2A>.</span></span>  
  
 <span data-ttu-id="2da29-1123">Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1123">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1124">Das folgende Codebeispiel erstellt eine Instanz eines konstruierten Typs mithilfe des normalen instanzerstellung und verwendet dann die <xref:System.Type.GetType%2A> und <xref:System.Type.GetGenericTypeDefinition%2A> Methoden zum Abrufen von den konstruierten Typ und die generische Typdefinition.</span><span class="sxs-lookup"><span data-stu-id="2da29-1124">The following code example creates an instance of a constructed type by using ordinary instance creation and then uses the <xref:System.Type.GetType%2A> and <xref:System.Type.GetGenericTypeDefinition%2A> methods to retrieve the constructed type and the generic type definition.</span></span> <span data-ttu-id="2da29-1125">Dieses Beispiel verwendet die generische <xref:System.Collections.Generic.Dictionary%602> Typ, der den konstruierten Typ darstellt eine <xref:System.Collections.Generic.Dictionary%602> von `Test` Objekte mit Zeichenfolgenschlüssel.</span><span class="sxs-lookup"><span data-stu-id="2da29-1125">This example uses the generic <xref:System.Collections.Generic.Dictionary%602> type; the constructed type represents a <xref:System.Collections.Generic.Dictionary%602> of `Test` objects with string keys.</span></span>  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="2da29-1126">Der aktuelle Typ ist kein generischer Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1126">The current type is not a generic type.</span>
          </span>
          <span data-ttu-id="2da29-1127">Das heißt, <see cref="P:System.Type.IsGenericType" /> gibt <see langword="false" /> zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1127">That is, <see cref="P:System.Type.IsGenericType" /> returns <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2da29-1128">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1128">The invoked method is not supported in the base class.</span>
          </span>
          <span data-ttu-id="2da29-1129">Abgeleitete Klassen müssen eine Implementation angeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1129">Derived classes must provide an implementation.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-1130">Gibt den Hashcode für diese Instanz zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1130">Returns the hash code for this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1131">Der Hashcode für diese Instanz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1131">The hash code for this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1132">Diese Methode überschreibt <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1132">This method overrides <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1133">Das folgende Beispiel zeigt den Hashcode für die `System.Windows.Forms.Button` Klasse.</span><span class="sxs-lookup"><span data-stu-id="2da29-1133">The following example displays the hash code of the `System.Windows.Forms.Button` class.</span></span>  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-1134">Ruft eine bestimmte Schnittstelle ab, die vom aktuellen <see cref="T:System.Type" /> implementiert oder geerbt wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1134">Gets a specific interface implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-1135">Die Zeichenfolge, die den Namen der abzurufenden Schnittstelle enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1135">The string containing the name of the interface to get.</span>
          </span>
          <span data-ttu-id="2da29-1136">Bei generischen Schnittstellen ist dies der ergänzte Name.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1136">For generic interfaces, this is the mangled name.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-1137">Sucht die Schnittstelle mit dem angegebenen Namen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1137">Searches for the interface with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1138">Ein Objekt, das die vom aktuellen <see cref="T:System.Type" /> implementierte oder geerbte Schnittstelle mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1138">An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1139">Die Suche nach `name` Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="2da29-1139">The search for `name` is case-sensitive.</span></span>  
  
 <span data-ttu-id="2da29-1140">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Type> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1140">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-1141">Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht das schnittstelleneinschränkungen und alle Schnittstellen, die von der Klasse oder Schnittstelle Einschränkungen geerbt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1141">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-1142">Bei generischen Schnittstellen die `name` Parameter ist der ergänzte Name, endend mit einem Gravis-Akzent (\`) und die Anzahl von Typparametern.</span><span class="sxs-lookup"><span data-stu-id="2da29-1142">For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\`) and the number of type parameters.</span></span> <span data-ttu-id="2da29-1143">Dies gilt für generische Schnittstellendefinitionen und konstruierte generische Schnittstellen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1143">This is true for both generic interface definitions and constructed generic interfaces.</span></span> <span data-ttu-id="2da29-1144">Z. B. mithilfe der Softwareoption `IExample<T>` (`IExample(Of T)` in Visual Basic) oder `IExample<string>` (`IExample(Of String)` in Visual Basic), suchen Sie nach ``"IExample`1"``.</span><span class="sxs-lookup"><span data-stu-id="2da29-1144">For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for ``"IExample`1"``.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1145">Im folgenden Codebeispiel wird mit der <xref:System.Type.GetInterface%28System.String%29> Methode zum Suchen der <xref:System.Collections.Hashtable> -Klasse für die <xref:System.Runtime.Serialization.IDeserializationCallback> Schnittstelle und Listen die Methoden der Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="2da29-1145">The following code example uses the <xref:System.Type.GetInterface%28System.String%29> method to search the <xref:System.Collections.Hashtable> class for the <xref:System.Runtime.Serialization.IDeserializationCallback> interface, and lists the methods of the interface.</span></span>  
  
 <span data-ttu-id="2da29-1146">Im Codebeispiel wird veranschaulicht, die auch die <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> -methodenüberladung und die <xref:System.Type.GetInterfaceMap%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-1146">The code example also demonstrates the <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> method overload and the <xref:System.Type.GetInterfaceMap%2A> method.</span></span>  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-1147">
            <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1147">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="2da29-1148">Der aktuelle <see cref="T:System.Type" /> stellt einen Typ dar, der dieselbe generische Schnittstelle mit unterschiedlichen Typargumenten implementiert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1148">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-1149">Die Zeichenfolge, die den Namen der abzurufenden Schnittstelle enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1149">The string containing the name of the interface to get.</span>
          </span>
          <span data-ttu-id="2da29-1150">Bei generischen Schnittstellen ist dies der ergänzte Name.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1150">For generic interfaces, this is the mangled name.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="2da29-1151">
            <see langword="true" />, wenn die Groß-/Kleinschreibung dieses Teils von <c>name</c>, der den einfachen Schnittstellennamen angibt, ignoriert werden soll (Bei der Namespaceangabe im Namen muss die Groß-/Kleinschreibung immer beachtet werden)</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1151">
              <see langword="true" /> to ignore the case of that part of <c>name</c> that specifies the simple interface name (the part that specifies the namespace must be correctly cased).</span>
          </span>
          <span data-ttu-id="2da29-1152">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1152">-or-</span>
          </span>
          <span data-ttu-id="2da29-1153">
            <see langword="false" />, wenn nach allen Teilen von <c>name</c> unter Beachtung der Groß-/Kleinschreibung gesucht werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1153">
              <see langword="false" /> to perform a case-sensitive search for all parts of <c>name</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-1154">Sucht beim Überschreiben in einer abgeleiteten Klasse die angegebene Schnittstelle, wobei festgelegt wird, ob bei der Suche des Schnittstellennamens die Groß-/Kleinschreibung beachtet wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1154">When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1155">Ein Objekt, das die vom aktuellen <see cref="T:System.Type" /> implementierte oder geerbte Schnittstelle mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1155">An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1156">Die `ignoreCase` Parameter gilt nur für den einfachen Schnittstellennamen, nicht für den Namespace.</span><span class="sxs-lookup"><span data-stu-id="2da29-1156">The `ignoreCase` parameter applies only to the simple interface name, not to the namespace.</span></span> <span data-ttu-id="2da29-1157">Der Teil des `name` , die angibt, der Namespace muss die korrekte Groß-/Kleinschreibung, oder die Schnittstelle nicht gefunden werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1157">The portion of `name` that specifies the namespace must have the correct case, or the interface will not be found.</span></span> <span data-ttu-id="2da29-1158">Z. B. die Zeichenfolge "System.icomparable" sucht nach der <xref:System.IComparable> -Schnittstelle, die Zeichenfolge "system.icomparable" hingegen nicht.</span><span class="sxs-lookup"><span data-stu-id="2da29-1158">For example, the string "System.icomparable" finds the <xref:System.IComparable> interface, but the string "system.icomparable" does not.</span></span>  
  
 <span data-ttu-id="2da29-1159">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Type> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1159">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-1160">Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht das schnittstelleneinschränkungen und alle Schnittstellen, die von der Klasse oder Schnittstelle Einschränkungen geerbt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1160">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-1161">Bei generischen Schnittstellen die `name` Parameter ist der ergänzte Name, endend mit einem Gravis-Akzent (\`) und die Anzahl von Typparametern.</span><span class="sxs-lookup"><span data-stu-id="2da29-1161">For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\`) and the number of type parameters.</span></span> <span data-ttu-id="2da29-1162">Dies gilt für generische Schnittstellendefinitionen und konstruierte generische Schnittstellen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1162">This is true for both generic interface definitions and constructed generic interfaces.</span></span> <span data-ttu-id="2da29-1163">Z. B. mithilfe der Softwareoption `IExample<T>` (`IExample(Of T)` in Visual Basic) oder `IExample<string>` (`IExample(Of String)` in Visual Basic), suchen Sie nach `"IExample`1"".</span><span class="sxs-lookup"><span data-stu-id="2da29-1163">For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for `"IExample`1"\`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1164">Im folgenden Codebeispiel wird mit der <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> Methode Groß-/Kleinschreibung nicht beachtet werden soll von der <xref:System.Collections.Hashtable> -Klasse für die <xref:System.Collections.IEnumerable> Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="2da29-1164">The following code example uses the <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> method to perform a case-insensitive search of the <xref:System.Collections.Hashtable> class for the <xref:System.Collections.IEnumerable> interface.</span></span>  
  
 <span data-ttu-id="2da29-1165">Im Codebeispiel wird veranschaulicht, die auch die <xref:System.Type.GetInterface%28System.String%29> -methodenüberladung und die <xref:System.Type.GetInterfaceMap%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-1165">The code example also demonstrates the <xref:System.Type.GetInterface%28System.String%29> method overload and the <xref:System.Type.GetInterfaceMap%2A> method.</span></span>  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-1166">
            <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1166">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="2da29-1167">Der aktuelle <see cref="T:System.Type" /> stellt einen Typ dar, der dieselbe generische Schnittstelle mit unterschiedlichen Typargumenten implementiert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1167">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType">
          <span data-ttu-id="2da29-1168">Der Schnittstellentyp, für den eine Zuordnung abgerufen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1168">The interface type to retrieve a mapping for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-1169">Gibt eine Schnittstellenzuordnung für den angegebenen Schnittstellentyp zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1169">Returns an interface mapping for the specified interface type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1170">Ein Objekt, das die Schnittstellenzuordnung für <paramref name="interfaceType" /> darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1170">An object that represents the interface mapping for <paramref name="interfaceType" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1171">Die schnittstellenzuordnung gibt an, wie eine Schnittstelle zu den tatsächlichen Elementen auf einer Klasse zugeordnet ist, die diese Schnittstelle implementiert.</span><span class="sxs-lookup"><span data-stu-id="2da29-1171">The interface map denotes how an interface is mapped into the actual members on a class that implements that interface.</span></span>  
  
 <span data-ttu-id="2da29-1172">Wenn die aktuelle <xref:System.Type> stellt einen konstruierten generischen Typ, Typ, die Parameter werden durch die entsprechenden Typargumente in den Elementen ersetzt die <xref:System.Reflection.InterfaceMapping> von dieser Methode zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-1172">If the current <xref:System.Type> represents a constructed generic type, type parameters are replaced by the appropriate type arguments in the elements of the <xref:System.Reflection.InterfaceMapping> returned by this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1173">Im folgenden Beispiel wird der <xref:System.Type.GetInterfaceMap%2A> Methode, um zu bestimmen, wie die <xref:System.IFormatProvider> Schnittstelle ordnet <xref:System.Globalization.CultureInfo> Methoden, und wie die <xref:System.IAppDomainSetup> Schnittstelle ordnet <xref:System.AppDomainSetup> Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="2da29-1173">The following example calls the <xref:System.Type.GetInterfaceMap%2A> method to determine how the <xref:System.IFormatProvider> interface maps to <xref:System.Globalization.CultureInfo> methods, and how the <xref:System.IAppDomainSetup> interface maps to <xref:System.AppDomainSetup> properties.</span></span> <span data-ttu-id="2da29-1174">Beachten Sie Folgendes: Da die <xref:System.IAppDomainSetup> -Schnittstelle definiert einen Satz von Eigenschaften dar, das zurückgegebene <xref:System.Reflection.InterfaceMapping> Objekt enthält separate <xref:System.Reflection.MethodInfo> Objekte für eine Eigenschaft Get- und Set-Accessoren.</span><span class="sxs-lookup"><span data-stu-id="2da29-1174">Note that, because the <xref:System.IAppDomainSetup> interface defines a set of properties, the returned <xref:System.Reflection.InterfaceMapping> object includes separate <xref:System.Reflection.MethodInfo> objects for a property's get and set accessors.</span></span>  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-1175">
            <paramref name="interfaceType" /> wird nicht von dem aktuellen Typ implementiert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1175">
              <paramref name="interfaceType" /> is not implemented by the current type.</span>
          </span>
          <span data-ttu-id="2da29-1176">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1176">-or-</span>
          </span>
          <span data-ttu-id="2da29-1177">Der <paramref name="interfaceType" />-Parameter verweist auf keine Schnittstelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1177">The <paramref name="interfaceType" /> parameter does not refer to an interface.</span>
          </span>
          <span data-ttu-id="2da29-1178">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1178">-or-</span>
          </span>
          <span data-ttu-id="2da29-1179">
            <paramref name="interfaceType" /> ist eine generische Schnittstelle, und der aktuelle Typ ist ein Arraytyp.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1179">
              <paramref name="interfaceType" /> is a generic interface, and the current type is an array type.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-1180">
            <paramref name="interfaceType" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1180">
              <paramref name="interfaceType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="2da29-1181">Der aktuelle <see cref="T:System.Type" /> stellt einen generischen Typparameter dar; d. h. <see cref="P:System.Type.IsGenericParameter" /> ist <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1181">The current <see cref="T:System.Type" /> represents a generic type parameter; that is, <see cref="P:System.Type.IsGenericParameter" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2da29-1182">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1182">The invoked method is not supported in the base class.</span>
          </span>
          <span data-ttu-id="2da29-1183">Abgeleitete Klassen müssen eine Implementation angeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1183">Derived classes must provide an implementation.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-1184">Ruft beim Überschreiben in einer abgeleiteten Klasse sämtliche Schnittstellen ab, die vom aktuellen <see cref="T:System.Type" /> implementiert oder geerbt wurden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1184">When overridden in a derived class, gets all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1185">Ein Array von <see cref="T:System.Type" />-Objekten, die sämtliche vom aktuellen <see cref="T:System.Type" /> implementierten oder geerbten Schnittstellen darstellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1185">An array of <see cref="T:System.Type" /> objects representing all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="2da29-1186">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1186">-or-</span>
          </span>
          <span data-ttu-id="2da29-1187">Ein leeres Array vom <see cref="T:System.Type" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine Schnittstellen implementiert oder geerbt hat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1187">An empty array of type <see cref="T:System.Type" />, if no interfaces are implemented or inherited by the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1188">Die <xref:System.Type.GetInterfaces%2A> Methode gibt keinen zurück Schnittstellen in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</span><span class="sxs-lookup"><span data-stu-id="2da29-1188">The <xref:System.Type.GetInterfaces%2A> method does not return interfaces in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="2da29-1189">Der Code muss nicht richten sich nach der Reihenfolge, in der Schnittstellen zurückgegeben werden, da, bei der Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="2da29-1189">Your code must not depend on the order in which interfaces are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="2da29-1190">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Type> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1190">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-1191">Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht das schnittstelleneinschränkungen und alle Schnittstellen, die von der Klasse oder Schnittstelle Einschränkungen geerbt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1191">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1192">Im folgenden Beispiel ruft den Typ der angegebenen Klasse ab und zeigt alle Schnittstellen, die der Typ implementiert oder erbt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1192">The following example gets the type of the specified class and displays all the interfaces that the type implements or inherits.</span></span> <span data-ttu-id="2da29-1193">Um die Visual Basic-Beispiel zu kompilieren, verwenden Sie die folgenden Compilerbefehle:</span><span class="sxs-lookup"><span data-stu-id="2da29-1193">To compile the Visual Basic example, use the following compiler commands:</span></span>  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="2da29-1194">Ein statischer Initialisierer wird aufgerufen und löst eine Ausnahme aus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1194">A static initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-1195">Ruft die angegebenen Member des aktuellen <see cref="T:System.Type" /> ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1195">Gets the specified members of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-1196">Die Zeichenfolge, die den Namen des abzurufenden öffentlichen Members enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1196">The string containing the name of the public members to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-1197">Sucht die öffentlichen Member mit dem angegebenen Namen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1197">Searches for the public members with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1198">Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die die öffentlichen Member mit dem angegebenen Namen darstellen, sofern gefunden, andernfalls ein leeres Array.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1198">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1199">Die Suche nach `name` Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="2da29-1199">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="2da29-1200">Die Suche enthält öffentliche statisch und öffentlich Instanzmember.</span><span class="sxs-lookup"><span data-stu-id="2da29-1200">The search includes public static and public instance members.</span></span>  
  
 <span data-ttu-id="2da29-1201">Member enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.</span><span class="sxs-lookup"><span data-stu-id="2da29-1201">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="2da29-1202">Die <xref:System.Type.GetMember%2A> Methode gibt keinen zurück Mitglieder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</span><span class="sxs-lookup"><span data-stu-id="2da29-1202">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="2da29-1203">Der Code muss nicht richten sich nach der Reihenfolge, in der Elemente zurückgegeben werden, da, bei der Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="2da29-1203">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="2da29-1204">Diese methodenüberladung wird Klasseninitialisierer (".cctor") nicht gefunden werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1204">This method overload will not find class initializers (.cctor).</span></span> <span data-ttu-id="2da29-1205">Um Klasseninitialisierer zu ermitteln, verwenden Sie eine Überladung mit <xref:System.Reflection.BindingFlags>, und geben Sie <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-1205">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="2da29-1206">Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-1206">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="2da29-1207">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-1207">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="2da29-1208">Memberart</span><span class="sxs-lookup"><span data-stu-id="2da29-1208">Member Type</span></span>|<span data-ttu-id="2da29-1209">Statisch</span><span class="sxs-lookup"><span data-stu-id="2da29-1209">Static</span></span>|<span data-ttu-id="2da29-1210">Nicht statische</span><span class="sxs-lookup"><span data-stu-id="2da29-1210">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="2da29-1211">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="2da29-1211">Constructor</span></span>|<span data-ttu-id="2da29-1212">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1212">No</span></span>|<span data-ttu-id="2da29-1213">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1213">No</span></span>|  
|<span data-ttu-id="2da29-1214">Feld</span><span class="sxs-lookup"><span data-stu-id="2da29-1214">Field</span></span>|<span data-ttu-id="2da29-1215">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1215">No</span></span>|<span data-ttu-id="2da29-1216">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-1216">Yes.</span></span> <span data-ttu-id="2da29-1217">Ein Feld ist immer nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1217">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-1218">event</span><span class="sxs-lookup"><span data-stu-id="2da29-1218">Event</span></span>|<span data-ttu-id="2da29-1219">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-1219">Not applicable</span></span>|<span data-ttu-id="2da29-1220">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-1220">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-1221">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1221">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-1222">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1222">See note 2 below.</span></span>|  
|<span data-ttu-id="2da29-1223">Methode</span><span class="sxs-lookup"><span data-stu-id="2da29-1223">Method</span></span>|<span data-ttu-id="2da29-1224">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1224">No</span></span>|<span data-ttu-id="2da29-1225">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-1225">Yes.</span></span> <span data-ttu-id="2da29-1226">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1226">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-1227">Geschachtelten Typs</span><span class="sxs-lookup"><span data-stu-id="2da29-1227">Nested Type</span></span>|<span data-ttu-id="2da29-1228">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1228">No</span></span>|<span data-ttu-id="2da29-1229">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1229">No</span></span>|  
|<span data-ttu-id="2da29-1230">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="2da29-1230">Property</span></span>|<span data-ttu-id="2da29-1231">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-1231">Not applicable</span></span>|<span data-ttu-id="2da29-1232">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-1232">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-1233">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1233">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-1234">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1234">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="2da29-1235">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-1235">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="2da29-1236">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="2da29-1236">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="2da29-1237">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1237">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-1238">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1238">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="2da29-1239">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="2da29-1239">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="2da29-1240">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MemberInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1240">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-1241">Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Mitglieder der Class-Einschränkung oder die Elemente der <xref:System.Object> Wenn ohne klasseneinschränkung ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-1241">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-1242">Für generische Methoden enthalten nicht die Typargumente in `name`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1242">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="2da29-1243">Z. B. den C#-Code `GetMember("MyMethod<int>")` sucht ein Element mit dem Textnamen "`MyMethod<int>`", anstatt für eine Methode namens `MyMethod` , die ein generisches Argument des Typs hat `int`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1243">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1244">Das folgende Beispiel zeigt alle Member der `String` -Klasse, die mit dem Buchstaben c beginnen</span><span class="sxs-lookup"><span data-stu-id="2da29-1244">The following example displays all the members of the `String` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-1245">
            <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1245">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-1246">Die Zeichenfolge, die den Namen der abzurufenden Member enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1246">The string containing the name of the members to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="2da29-1247">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1247">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="2da29-1248">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1248">-or-</span>
          </span>
          <span data-ttu-id="2da29-1249">0 (null), um ein leeres Array zurückzugeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1249">Zero, to return an empty array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-1250">Sucht die angegebenen Member unter Verwendung der angegebenen Bindungseinschränkungen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1250">Searches for the specified members, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1251">Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die die öffentlichen Member mit dem angegebenen Namen darstellen, sofern gefunden, andernfalls ein leeres Array.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1251">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1252">Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1252">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="2da29-1253">Member enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.</span><span class="sxs-lookup"><span data-stu-id="2da29-1253">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="2da29-1254">Die <xref:System.Type.GetMember%2A> Methode gibt keinen zurück Mitglieder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</span><span class="sxs-lookup"><span data-stu-id="2da29-1254">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="2da29-1255">Der Code muss nicht richten sich nach der Reihenfolge, in der Elemente zurückgegeben werden, da, bei der Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="2da29-1255">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="2da29-1256">Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Member in die Suche einbezogen werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-1256">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="2da29-1257">Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1257">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="2da29-1258">Geben Sie `BindingFlags.Public` auf öffentliche Member in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1258">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="2da29-1259">Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Member (d. h. private, interne und geschützte Member) in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1259">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="2da29-1260">Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1260">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="2da29-1261">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</span><span class="sxs-lookup"><span data-stu-id="2da29-1261">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="2da29-1262">`BindingFlags.IgnoreCase` um die Groß-/Kleinschreibung ignorieren `name`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1262">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="2da29-1263">`BindingFlags.DeclaredOnly` Suche nur die deklarierten Member der <xref:System.Type>, nicht die Elemente, die nur geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1263">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="2da29-1264">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1264">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="2da29-1265">Um die klasseninitialisierung (".cctor"), die Verwendung dieser methodenüberladung zu erhalten, müssen Sie ".cctor" angeben, für `name`, und <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) für `bindingAttr`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1265">To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for `name`, and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`.</span></span> <span data-ttu-id="2da29-1266">Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-1266">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="2da29-1267">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MemberInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1267">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-1268">Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Mitglieder der Class-Einschränkung oder die Elemente der <xref:System.Object> Wenn ohne klasseneinschränkung ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-1268">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-1269">Für generische Methoden enthalten nicht die Typargumente in `name`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1269">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="2da29-1270">Z. B. den C#-Code `GetMember("MyMethod<int>")` sucht ein Element mit dem Textnamen "`MyMethod<int>`", anstatt für eine Methode namens `MyMethod` , die ein generisches Argument des Typs hat `int`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1270">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1271">Das folgende Beispiel zeigt alle öffentlichen statischen Member der `myString` -Klasse, die mit dem Buchstaben c beginnen</span><span class="sxs-lookup"><span data-stu-id="2da29-1271">The following example displays all the public static members of the `myString` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-1272">
            <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1272">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-1273">Die Zeichenfolge, die den Namen der abzurufenden Member enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1273">The string containing the name of the members to get.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="2da29-1274">Der zu suchende Wert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1274">The value to search for.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="2da29-1275">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1275">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="2da29-1276">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1276">-or-</span>
          </span>
          <span data-ttu-id="2da29-1277">0 (null), um ein leeres Array zurückzugeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1277">Zero, to return an empty array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-1278">Sucht die angegebenen Member des angegebenen Membertyps unter Verwendung der angegebenen Bindungseinschränkungen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1278">Searches for the specified members of the specified member type, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1279">Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die die öffentlichen Member mit dem angegebenen Namen darstellen, sofern gefunden, andernfalls ein leeres Array.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1279">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1280">Member enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.</span><span class="sxs-lookup"><span data-stu-id="2da29-1280">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="2da29-1281">Die <xref:System.Type.GetMember%2A> Methode gibt keinen zurück Mitglieder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</span><span class="sxs-lookup"><span data-stu-id="2da29-1281">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="2da29-1282">Der Code muss nicht richten sich nach der Reihenfolge, in der Elemente zurückgegeben werden, da, bei der Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="2da29-1282">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="2da29-1283">Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Member in die Suche einbezogen werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-1283">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="2da29-1284">Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1284">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="2da29-1285">Geben Sie `BindingFlags.Public` auf öffentliche Member in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1285">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="2da29-1286">Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Member (d. h. private, interne und geschützte Member) in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1286">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="2da29-1287">Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1287">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="2da29-1288">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</span><span class="sxs-lookup"><span data-stu-id="2da29-1288">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="2da29-1289">`BindingFlags.IgnoreCase` um die Groß-/Kleinschreibung ignorieren `name`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1289">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="2da29-1290">`BindingFlags.DeclaredOnly` Suche nur die deklarierten Member der <xref:System.Type>, nicht die Elemente, die nur geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1290">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="2da29-1291">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1291">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="2da29-1292">Um die klasseninitialisierung (".cctor"), die Verwendung dieser methodenüberladung zu erhalten, müssen Sie ".cctor" angeben, für `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> für `type`, und <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) für `bindingAttr`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1292">To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> for `type`, and  <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`.</span></span> <span data-ttu-id="2da29-1293">Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-1293">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="2da29-1294">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MemberInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1294">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-1295">Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Mitglieder der Class-Einschränkung oder die Elemente der <xref:System.Object> Wenn ohne klasseneinschränkung ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-1295">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-1296">Für generische Methoden enthalten nicht die Typargumente in `name`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1296">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="2da29-1297">Z. B. den C#-Code `GetMember("MyMethod<int>")` sucht ein Element mit dem Textnamen "`MyMethod<int>`", anstatt für eine Methode namens `MyMethod` , die ein generisches Argument des Typs hat `int`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1297">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1298">Das folgende Beispiel zeigt alle Methoden der `myString` -Klasse, die mit dem Buchstaben c beginnen</span><span class="sxs-lookup"><span data-stu-id="2da29-1298">The following example displays all the methods of the `myString` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-1299">
            <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1299">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2da29-1300">Eine abgeleitete Klasse muss eine Implementierung bereitstellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1300">A derived class must provide an implementation.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-1301">Ruft die Member (Eigenschaften, Methoden, Felder, Ereignisse usw.) des aktuellen <see cref="T:System.Type" /> ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1301">Gets the members (properties, methods, fields, events, and so on) of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-1302">Gibt sämtliche öffentlichen Member des aktuellen <see cref="T:System.Type" /> zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1302">Returns all the public members of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1303">Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die sämtliche öffentlichen Member des aktuellen <see cref="T:System.Type" /> darstellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1303">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all the public members of the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="2da29-1304">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1304">-or-</span>
          </span>
          <span data-ttu-id="2da29-1305">Ein leeres Array vom <see cref="T:System.Reflection.MemberInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine Standardmember besitzt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1305">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have public members.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1306">Member enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.</span><span class="sxs-lookup"><span data-stu-id="2da29-1306">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="2da29-1307">Die <xref:System.Type.GetMembers%2A> Methode gibt keinen zurück Mitglieder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</span><span class="sxs-lookup"><span data-stu-id="2da29-1307">The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="2da29-1308">Der Code muss nicht richten sich nach der Reihenfolge, in der Elemente zurückgegeben werden, da, bei der Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="2da29-1308">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="2da29-1309">Diese methodenüberladung Ruft die <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> -methodenüberladung mit <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-1309">This method overload calls the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="2da29-1310">Es findet keine Klasseninitialisierer (".cctor").</span><span class="sxs-lookup"><span data-stu-id="2da29-1310">It will not find class initializers (.cctor).</span></span> <span data-ttu-id="2da29-1311">Um Klasseninitialisierer zu ermitteln, verwenden Sie eine Überladung mit <xref:System.Reflection.BindingFlags>, und geben Sie <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-1311">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="2da29-1312">Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-1312">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="2da29-1313">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-1313">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="2da29-1314">Memberart</span><span class="sxs-lookup"><span data-stu-id="2da29-1314">Member Type</span></span>|<span data-ttu-id="2da29-1315">Statisch</span><span class="sxs-lookup"><span data-stu-id="2da29-1315">Static</span></span>|<span data-ttu-id="2da29-1316">Nicht statische</span><span class="sxs-lookup"><span data-stu-id="2da29-1316">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="2da29-1317">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="2da29-1317">Constructor</span></span>|<span data-ttu-id="2da29-1318">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1318">No</span></span>|<span data-ttu-id="2da29-1319">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1319">No</span></span>|  
|<span data-ttu-id="2da29-1320">Feld</span><span class="sxs-lookup"><span data-stu-id="2da29-1320">Field</span></span>|<span data-ttu-id="2da29-1321">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1321">No</span></span>|<span data-ttu-id="2da29-1322">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-1322">Yes.</span></span> <span data-ttu-id="2da29-1323">Ein Feld ist immer nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1323">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-1324">event</span><span class="sxs-lookup"><span data-stu-id="2da29-1324">Event</span></span>|<span data-ttu-id="2da29-1325">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-1325">Not applicable</span></span>|<span data-ttu-id="2da29-1326">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-1326">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-1327">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1327">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-1328">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1328">See note 2 below.</span></span>|  
|<span data-ttu-id="2da29-1329">Methode</span><span class="sxs-lookup"><span data-stu-id="2da29-1329">Method</span></span>|<span data-ttu-id="2da29-1330">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1330">No</span></span>|<span data-ttu-id="2da29-1331">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-1331">Yes.</span></span> <span data-ttu-id="2da29-1332">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1332">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-1333">Geschachtelten Typs</span><span class="sxs-lookup"><span data-stu-id="2da29-1333">Nested Type</span></span>|<span data-ttu-id="2da29-1334">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1334">No</span></span>|<span data-ttu-id="2da29-1335">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1335">No</span></span>|  
|<span data-ttu-id="2da29-1336">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="2da29-1336">Property</span></span>|<span data-ttu-id="2da29-1337">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-1337">Not applicable</span></span>|<span data-ttu-id="2da29-1338">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-1338">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-1339">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1339">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-1340">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1340">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="2da29-1341">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-1341">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="2da29-1342">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="2da29-1342">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="2da29-1343">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1343">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-1344">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1344">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="2da29-1345">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="2da29-1345">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="2da29-1346">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MemberInfo> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1346">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-1347">Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Mitglieder der Class-Einschränkung oder die Elemente der <xref:System.Object> Wenn ohne klasseneinschränkung ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-1347">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1348">Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Type.GetMembers> -methodenüberladung, um die Erfassung von Informationen über alle öffentlichen Member einer bestimmten Klasse.</span><span class="sxs-lookup"><span data-stu-id="2da29-1348">The following code example demonstrates how to use the <xref:System.Type.GetMembers> method overload to collect information about all public members of a specified class.</span></span>  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="2da29-1349">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1349">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="2da29-1350">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1350">-or-</span>
          </span>
          <span data-ttu-id="2da29-1351">0 (null), (<see cref="F:System.Reflection.BindingFlags.Default" />) um ein leeres Array zurückzugeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1351">Zero (<see cref="F:System.Reflection.BindingFlags.Default" />), to return an empty array.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-1352">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die für den aktuellen <see cref="T:System.Type" /> definierten Member.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1352">When overridden in a derived class, searches for the members defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1353">Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die sämtliche für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Member darstellen, die den angegebenen Bindungseinschränkungen entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1353">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all members defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="2da29-1354">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1354">-or-</span>
          </span>
          <span data-ttu-id="2da29-1355">Ein leeres Array vom <see cref="T:System.Reflection.MemberInfo" />-Typ, wenn für den aktuellen <see cref="T:System.Type" /> keine Member definiert sind oder keiner der definierten Member den Bindungseinschränkungen entspricht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1355">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if no members are defined for the current <see cref="T:System.Type" />, or if none of the defined members match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1356">Member enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.</span><span class="sxs-lookup"><span data-stu-id="2da29-1356">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="2da29-1357">Die <xref:System.Type.GetMembers%2A> Methode gibt keinen zurück Mitglieder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</span><span class="sxs-lookup"><span data-stu-id="2da29-1357">The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="2da29-1358">Der Code muss nicht richten sich nach der Reihenfolge, in der Elemente zurückgegeben werden, da, bei der Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="2da29-1358">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="2da29-1359">Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Member in die Suche einbezogen werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-1359">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="2da29-1360">Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1360">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="2da29-1361">Geben Sie `BindingFlags.Public` auf öffentliche Member in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1361">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="2da29-1362">Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Member (d. h. private, interne und geschützte Member) in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1362">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span> <span data-ttu-id="2da29-1363">Nur geschützte und interne Member in Basisklassen werden zurückgegeben. Private Member in Basisklassen werden nicht zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-1363">Only protected and internal members on base classes are returned; private members on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="2da29-1364">Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1364">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="2da29-1365">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</span><span class="sxs-lookup"><span data-stu-id="2da29-1365">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="2da29-1366">`BindingFlags.DeclaredOnly` Suche nur die deklarierten Member der <xref:System.Type>, nicht die Elemente, die nur geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1366">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="2da29-1367">Beim Aufrufen dieser Methode nur mit der `Public` Flag oder nur die `NonPublic` Flag die angegebenen Member zurück, und alle anderen Flags sind nicht erforderlich.</span><span class="sxs-lookup"><span data-stu-id="2da29-1367">Calling this method with only the `Public` flag or only the `NonPublic` flag will return the specified members and does not require any other flags.</span></span>  
  
 <span data-ttu-id="2da29-1368">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1368">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="2da29-1369">Um die klasseninitialisierung (".cctor"), die Verwendung dieser methodenüberladung zu erhalten, müssen Sie angeben <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-1369">To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="2da29-1370">Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <xref:System.Type.TypeInitializer%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-1370">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="2da29-1371">Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MemberInfo> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1371">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-1372">Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Mitglieder der Class-Einschränkung oder die Elemente der <xref:System.Object> Wenn ohne klasseneinschränkung ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-1372">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1373">Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> -methodenüberladung, um Informationen zu allen öffentlicher Instanzmember einer bestimmten Klasse zu sammeln.</span><span class="sxs-lookup"><span data-stu-id="2da29-1373">The following code example demonstrates how to use the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload to collect information about all public instance members of a specified class.</span></span>  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-1374">Ruft eine bestimmte Methode des aktuellen <see cref="T:System.Type" /> ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1374">Gets a specific method of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-1375">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Methode enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1375">The string containing the name of the public method to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-1376">Sucht die öffentliche Methode mit dem angegebenen Namen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1376">Searches for the public method with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1377">Ein Objekt, das die öffentliche Methode mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1377">An object that represents the public method with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1378">Die Suche nach `name` Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="2da29-1378">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="2da29-1379">Die Suche enthält öffentliche statisch und öffentlich Instanzmethoden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1379">The search includes public static and public instance methods.</span></span>  
  
 <span data-ttu-id="2da29-1380">Wenn eine Methode überladen wird und verfügt über mehr als eine öffentliche Methode, die <xref:System.Type.GetMethod%28System.String%29> -Methode löst eine <xref:System.Reflection.AmbiguousMatchException> Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="2da29-1380">If a method is overloaded and has more than one public method, the <xref:System.Type.GetMethod%28System.String%29> method throws an <xref:System.Reflection.AmbiguousMatchException> exception.</span></span> <span data-ttu-id="2da29-1381">Im folgenden Beispiel wird eine Ausnahme ausgelöst, da es mehr als eine öffentliche Überladung von ist der <xref:System.Int32.ToString%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-1381">In the following example, an exception is thrown because there is more than one public overload of the <xref:System.Int32.ToString%2A?displayProperty=nameWithType> method.</span></span>  <span data-ttu-id="2da29-1382">Andererseits, da die `Person.ToString` methodenüberschreibungen <xref:System.Object.ToString%2A?displayProperty=nameWithType> und ist daher nicht überladen, die <xref:System.Type.GetMethod%28System.String%29> Methode kann zum Abrufen der <xref:System.Reflection.MethodInfo> Objekt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1382">On the other hand, because the `Person.ToString` method overrides  <xref:System.Object.ToString%2A?displayProperty=nameWithType> and therefore is not overloaded, the <xref:System.Type.GetMethod%28System.String%29> method is able to retrieve the <xref:System.Reflection.MethodInfo> object.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 <span data-ttu-id="2da29-1383">Sie können eine der folgenden zum Abrufen einer bestimmten Methode vorgehen:</span><span class="sxs-lookup"><span data-stu-id="2da29-1383">You can do one of the following to retrieve a specific method:</span></span>  
  
-   <span data-ttu-id="2da29-1384">Rufen Sie die <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> Methode, und geben Sie einen `bindingAttr` Argument, das die Methode eindeutig identifiziert.</span><span class="sxs-lookup"><span data-stu-id="2da29-1384">Call the <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> method and specify a `bindingAttr` argument that uniquely identifies the method.</span></span> <span data-ttu-id="2da29-1385">Beispielsweise, wenn die Ausnahme ausgelöst wird, da ein Typ eine statische und eine Überladung für die Instanz hat, können Sie angeben einer `bindingAttr` Argument <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1385">For example, if the exception is thrown because a type has a static and an instance overload, you can specify a  `bindingAttr` argument  of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="2da29-1386">Rufen Sie eine Überladung von der <xref:System.Type.GetMethod%2A> Methode, enthält eine `types` Parameter, die die Typen der Parameter der Methode definiert.</span><span class="sxs-lookup"><span data-stu-id="2da29-1386">Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.</span></span>  
  
-   <span data-ttu-id="2da29-1387">Rufen Sie die <xref:System.Type.GetMethods> Methode, um ein Array, das alle öffentlichen Methoden, die zu einem Typ gehören enthält abzurufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1387">Call the <xref:System.Type.GetMethods> method to retrieve an array containing all of the public methods belonging to a type.</span></span> <span data-ttu-id="2da29-1388">Sie können dann durchlaufen, es zum Identifizieren von doppelten Methoden mit dem Namen `name`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1388">You can then iterate it to identify the duplicate methods named `name`.</span></span>  
  
 <span data-ttu-id="2da29-1389">Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1389">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-1390">Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <xref:System.Object> Wenn ohne klasseneinschränkung ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-1390">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-1391">Für generische Methoden enthalten nicht die Typargumente in `name`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1391">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="2da29-1392">Z. B. den C#-Code `GetMember("MyMethod<int>")` sucht ein Element mit dem Textnamen "`MyMethod<int>`", anstatt für eine Methode namens `MyMethod` , die ein generisches Argument des Typs hat `int`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1392">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1393">Im folgenden Beispiel wird eine Methode namens `MethodA`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1393">The following example gets a method named `MethodA`.</span></span>  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="2da29-1394">Es wurden mehrere Methoden mit dem angegebenen Namen gefunden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1394">More than one method is found with the specified name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-1395">
            <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1395">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-1396">Die Zeichenfolge, die den Namen der abzurufenden Methode enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1396">The string containing the name of the method to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="2da29-1397">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1397">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="2da29-1398">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1398">-or-</span>
          </span>
          <span data-ttu-id="2da29-1399">0 (null), damit <see langword="null" /> zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1399">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-1400">Sucht die angegebene Methode unter Verwendung der angegebenen Bindungseinschränkungen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1400">Searches for the specified method, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1401">Ein Objekt, das die Methode darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1401">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1402">Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Methoden in die Suche einbezogen werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-1402">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="2da29-1403">Geben Sie <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> oder <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> ändern, um einen Rückgabewert zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1403">You must specify either <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in order to get a return.</span></span>  
  
-   <span data-ttu-id="2da29-1404">Geben Sie <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> um öffentliche Methoden in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1404">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="2da29-1405">Geben Sie <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> auf nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1405">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="2da29-1406">Geben Sie <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1406">Specify <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="2da29-1407">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</span><span class="sxs-lookup"><span data-stu-id="2da29-1407">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="2da29-1408"><xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> um die Groß-/Kleinschreibung ignorieren `name`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1408"><xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="2da29-1409"><xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> Um nur die deklarierten Methoden suchen die <xref:System.Type>, nicht die Methoden, die nur geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1409"><xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="2da29-1410">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1410">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="2da29-1411">Wenn eine Methode überladen wird und mehrere Überladungen die Einschränkungen erfüllt, angegeben durch die `bindingAttr` Argument, löst die Methode eine <xref:System.Reflection.AmbiguousMatchException> Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="2da29-1411">If a method is overloaded and more than one overload meets the constraints specified by the `bindingAttr` argument, the method throws an <xref:System.Reflection.AmbiguousMatchException> exception.</span></span> <span data-ttu-id="2da29-1412">Im folgenden Beispiel wird eine Ausnahme ausgelöst, da:</span><span class="sxs-lookup"><span data-stu-id="2da29-1412">In the following example, an exception is thrown because:</span></span>  
  
-   <span data-ttu-id="2da29-1413">Die `TestClass` Typ hat zwei öffentliche Instanz Überladungen der `DisplayValue` Methode `DisplayValue(String)` und `DisplayValue(String, Object[])`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1413">The `TestClass` type has two public instance overloads of the `DisplayValue` method, `DisplayValue(String)` and `DisplayValue(String, Object[])`.</span></span>  
  
-   <span data-ttu-id="2da29-1414">Die `TestClass` Typ hat zwei öffentliche Instanz Überladungen der `Equals` -Methode, von denen geerbt wird, von <xref:System.Object>: `Equals(TestClass)` und `Equals(Object)`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1414">The `TestClass` type has two public instance overloads of the `Equals` method,  one of which is inherited from <xref:System.Object>: `Equals(TestClass)` and `Equals(Object)`.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 <span data-ttu-id="2da29-1415">Sie können eine der folgenden zum Abrufen einer bestimmten Methode vorgehen:</span><span class="sxs-lookup"><span data-stu-id="2da29-1415">You can do one of the following to retrieve a specific method:</span></span>  
  
-   <span data-ttu-id="2da29-1416">Ändern Sie die bindungseinschränkungen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1416">Change the binding constraints.</span></span> <span data-ttu-id="2da29-1417">Im vorherigen Beispiel versucht, eine öffentliche Instanz abzurufen `Equals` Methode, die vom Typ deklariert wird und nicht geerbt wurde erfolgreich abgerufen `Equals(TestClass)`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1417">In the previous example, attempting to retrieve a public instance `Equals` method that is declared by the type and not inherited successfully retrieves `Equals(TestClass)`.</span></span>  
  
-   <span data-ttu-id="2da29-1418">Rufen Sie eine Überladung von der <xref:System.Type.GetMethod%2A> Methode, enthält eine `types` Parameter, die die Typen der Parameter der Methode definiert.</span><span class="sxs-lookup"><span data-stu-id="2da29-1418">Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.</span></span>  
  
-   <span data-ttu-id="2da29-1419">Rufen Sie die <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> Methode, um ein Array mit allen Methoden, die zu einem Typ gehören, die über die angegebene Bindungsattribute verfügen abzurufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1419">Call the <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> method to retrieve an array containing all of the methods belonging to a type that have the specified binding attributes.</span></span> <span data-ttu-id="2da29-1420">Sie können dann durchlaufen, es zum Identifizieren von doppelten Methoden mit dem Namen `name`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1420">You can then iterate it to identify the duplicate methods named `name`.</span></span> <span data-ttu-id="2da29-1421">Dieser Ansatz wird veranschaulicht, in dem vorherigen Beispiel Handler für das <xref:System.Reflection.AmbiguousMatchException> Ausnahme.</span><span class="sxs-lookup"><span data-stu-id="2da29-1421">This approach is illustrated in the previous example's handler for the <xref:System.Reflection.AmbiguousMatchException> exception.</span></span>  
  
 <span data-ttu-id="2da29-1422">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1422">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-1423">Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <xref:System.Object> Wenn ohne klasseneinschränkung ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-1423">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-1424">Für generische Methoden enthalten nicht die Typargumente in `name`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1424">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="2da29-1425">Z. B. den C#-Code `GetMember("MyMethod<int>")` sucht ein Element mit dem Textnamen "`MyMethod<int>`", anstatt für eine Methode namens `MyMethod` , die ein generisches Argument des Typs hat `int`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1425">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1426">Im folgenden Beispiel wird die Methode, die den angegebenen Bindungsflags entspricht.</span><span class="sxs-lookup"><span data-stu-id="2da29-1426">The following example gets the method that matches the specified binding flags.</span></span>  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="2da29-1427">Es wurden mehrere Methoden gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1427">More than one method is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-1428">
            <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1428">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-1429">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Methode enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1429">The string containing the name of the public method to get.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="2da29-1430">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1430">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span>
          </span>
          <span data-ttu-id="2da29-1431">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1431">-or-</span>
          </span>
          <span data-ttu-id="2da29-1432">Ein leeres Array von <see cref="T:System.Type" />-Objekten (bereitgestellt vom <see cref="F:System.Type.EmptyTypes" />-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1432">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-1433">Sucht die angegebene öffentliche Methode, deren Parameter den angegebenen Argumenttypen entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1433">Searches for the specified public method whose parameters match the specified argument types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1434">Ein Objekt, das die öffentliche Methode darstellt, deren Parameter den angegebenen Argumenttypen entsprechen, sofern gefunden, andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1434">An object representing the public method whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1435">Die Suche nach `name` Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="2da29-1435">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="2da29-1436">Die Suche enthält öffentliche statisch und öffentlich Instanzmethoden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1436">The search includes public static and public instance methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-1437">Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1437">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="2da29-1438">Sie können nur Parameter auslassen, aufrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1438">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="2da29-1439">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1439">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-1440">Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <xref:System.Object> Wenn ohne klasseneinschränkung ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-1440">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-1441">Die `name` Parameter kann keine Typargumente enthalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1441">The `name` parameter cannot include type arguments.</span></span> <span data-ttu-id="2da29-1442">Z. B. den C#-Code `GetMethod("MyGenericMethod<int>")` sucht eine Methode mit dem Textnamen "`MyGenericMethod<int>`", anstatt für eine Methode namens `MyGenericMethod` , die ein generisches Argument des Typs hat `int`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1442">For example, the C# code `GetMethod("MyGenericMethod<int>")` searches for a method with the text name "`MyGenericMethod<int>`", rather than for a method named `MyGenericMethod` that has one generic argument of type `int`.</span></span> <span data-ttu-id="2da29-1443">Verwenden Sie stattdessen `GetMethod("MyGenericMethod")` mit dem entsprechenden Parameter in der `types` Array.</span><span class="sxs-lookup"><span data-stu-id="2da29-1443">Instead, use `GetMethod("MyGenericMethod")` with the appropriate parameter in the `types` array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1444">Das folgende Beispiel sucht nach bestimmten Überladungen der `MethodA`, eine Vielzahl von Argumenttypen angeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-1444">The following example finds specific overloads of `MethodA`, specifying a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-1445">Die [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Beispiel benötigen Sie die `/unsafe` -Compileroption.</span><span class="sxs-lookup"><span data-stu-id="2da29-1445">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 <span data-ttu-id="2da29-1446">Das folgende Beispiel ruft <xref:System.Reflection.MethodInfo> Objekte, die darstellen, die `Add` Methoden eines nicht generischen Typs (die <xref:System.Collections.ArrayList> Klasse), ein offener generischer Typ (die <xref:System.Collections.Generic.List%601> Klasse), und einen geschlossenen generischen Typs (die `List(Of String)` Typ.</span><span class="sxs-lookup"><span data-stu-id="2da29-1446">The following example retrieves <xref:System.Reflection.MethodInfo> objects that represent the `Add` methods  of a non-generic type (the <xref:System.Collections.ArrayList> class), an open generic type (the <xref:System.Collections.Generic.List%601> class), and a closed generic type (the `List(Of String)` type.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 <span data-ttu-id="2da29-1447">Im Beispiel definiert eine `GetAddMethod` Methode, die die entsprechende abruft <xref:System.Reflection.MethodInfo> Objekt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1447">The example defines a `GetAddMethod` method that retrieves the appropriate <xref:System.Reflection.MethodInfo> object.</span></span> <span data-ttu-id="2da29-1448">Bereitstellen der `types` Argument für einen offenen generischen Typ, ruft er die <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-1448">To provide the `types` argument for an open generic type, it calls the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="2da29-1449">Bereitstellen der `types` Argument für einen geschlossenen generischen Typs, ruft er den Wert des der <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-1449">To provide the `types` argument for a closed generic type, it retrieves the value of the <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="2da29-1450">Es wurden mehrere Methoden mit dem angegebenen Namen und den angegebenen Parametern gefunden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1450">More than one method is found with the specified name and specified parameters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-1451">
            <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1451">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2da29-1452">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1452">-or-</span>
          </span>
          <span data-ttu-id="2da29-1453">
            <paramref name="types" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1453">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2da29-1454">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1454">-or-</span>
          </span>
          <span data-ttu-id="2da29-1455">Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1455">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-1456">
            <paramref name="types" /> ist mehrdimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1456">
              <paramref name="types" /> is multidimensional.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-1457">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Methode enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1457">The string containing the name of the public method to get.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="2da29-1458">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1458">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span>
          </span>
          <span data-ttu-id="2da29-1459">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1459">-or-</span>
          </span>
          <span data-ttu-id="2da29-1460">Ein leeres Array von <see cref="T:System.Type" />-Objekten (bereitgestellt vom <see cref="F:System.Type.EmptyTypes" />-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1460">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="2da29-1461">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <c>types</c>-Array zugeordnet sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1461">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="2da29-1462">Darf nur bei Aufrufen über COM-Interop verwendet werden. Es werden außerdem nur Parameter berücksichtigt, die als Verweis übergeben werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1462">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span>
          </span>
          <span data-ttu-id="2da29-1463">Der Standardbinder verarbeitet diesen Parameter nicht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1463">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-1464">Sucht die angegebene öffentliche Methode, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1464">Searches for the specified public method whose parameters match the specified argument types and modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1465">Ein Objekt, das die öffentliche Methode darstellt, die den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1465">An object representing the public method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1466">Obwohl der Standardbinder nicht verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1466">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="2da29-1467">`ParameterModifier` wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1467">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="2da29-1468">Die Suche nach `name` Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="2da29-1468">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="2da29-1469">Die Suche enthält öffentliche statisch und öffentlich Instanzmethoden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1469">The search includes public static and public instance methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-1470">Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1470">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="2da29-1471">Sie können nur Parameter auslassen, aufrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1471">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="2da29-1472">Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1472">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-1473">Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <xref:System.Object> Wenn ohne klasseneinschränkung ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-1473">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-1474">Für generische Methoden enthalten nicht die Typargumente in `name`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1474">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="2da29-1475">Z. B. den C#-Code `GetMethod("MyMethod<int>")` sucht ein Element mit dem Textnamen "`MyMethod<int>`", anstatt für eine Methode namens `MyMethod` , die ein generisches Argument des Typs hat `int`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1475">For example, the C# code `GetMethod("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span> <span data-ttu-id="2da29-1476">Verwenden Sie stattdessen `GetMethod("MyMethod")` mit dem entsprechenden Parameter in der `types` Array.</span><span class="sxs-lookup"><span data-stu-id="2da29-1476">Instead, use `GetMethod("MyMethod")` with the appropriate parameter in the `types` array.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="2da29-1477">Es wurden mehrere Methoden mit dem angegebenen Namen und den angegebenen Parametern gefunden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1477">More than one method is found with the specified name and specified parameters.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-1478">
            <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1478">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2da29-1479">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1479">-or-</span>
          </span>
          <span data-ttu-id="2da29-1480">
            <paramref name="types" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1480">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2da29-1481">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1481">-or-</span>
          </span>
          <span data-ttu-id="2da29-1482">Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1482">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-1483">
            <paramref name="types" /> ist mehrdimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1483">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="2da29-1484">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1484">-or-</span>
          </span>
          <span data-ttu-id="2da29-1485">
            <paramref name="modifiers" /> ist mehrdimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1485">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-1486">Die Zeichenfolge, die den Namen der abzurufenden Methode enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1486">The string containing the name of the method to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="2da29-1487">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1487">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="2da29-1488">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1488">-or-</span>
          </span>
          <span data-ttu-id="2da29-1489">0 (null), damit <see langword="null" /> zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1489">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="2da29-1490">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1490">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="2da29-1491">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1491">-or-</span>
          </span>
          <span data-ttu-id="2da29-1492">Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1492">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="2da29-1493">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1493">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span>
          </span>
          <span data-ttu-id="2da29-1494">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1494">-or-</span>
          </span>
          <span data-ttu-id="2da29-1495">Ein leeres Array von <see cref="T:System.Type" />-Objekten (bereitgestellt vom <see cref="F:System.Type.EmptyTypes" />-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1495">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="2da29-1496">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <c>types</c>-Array zugeordnet sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1496">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="2da29-1497">Darf nur bei Aufrufen über COM-Interop verwendet werden. Es werden außerdem nur Parameter berücksichtigt, die als Verweis übergeben werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1497">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span>
          </span>
          <span data-ttu-id="2da29-1498">Der Standardbinder verarbeitet diesen Parameter nicht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1498">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-1499">Sucht unter Verwendung der angegebenen Bindungseinschränkungen nach der angegebenen Methode, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1499">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1500">Ein Objekt, das die Methode darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1500">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1501">Obwohl der Standardbinder nicht verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1501">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="2da29-1502">`ParameterModifier` wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1502">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="2da29-1503">Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Methoden in die Suche einbezogen werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-1503">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="2da29-1504">Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1504">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="2da29-1505">Geben Sie `BindingFlags.Public` um öffentliche Methoden in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1505">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="2da29-1506">Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1506">Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="2da29-1507">Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1507">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="2da29-1508">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</span><span class="sxs-lookup"><span data-stu-id="2da29-1508">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="2da29-1509">`BindingFlags.IgnoreCase` um die Groß-/Kleinschreibung ignorieren `name`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1509">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="2da29-1510">`BindingFlags.DeclaredOnly` Um nur die deklarierten Methoden suchen die <xref:System.Type>, nicht die Methoden, die nur geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1510">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="2da29-1511">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1511">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-1512">Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1512">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="2da29-1513">Sie können nur Parameter auslassen, aufrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1513">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="2da29-1514">Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1514">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-1515">Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <xref:System.Object> Wenn ohne klasseneinschränkung ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-1515">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-1516">Für generische Methoden enthalten nicht die Typargumente in `name`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1516">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="2da29-1517">Z. B. den C#-Code `GetMember("MyMethod<int>")` sucht ein Element mit dem Textnamen "`MyMethod<int>`", anstatt für eine Methode namens `MyMethod` , die ein generisches Argument des Typs hat `int`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1517">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1518">Das folgende Beispiel sucht nach bestimmten Überladungen der `MethodA`, bindungseinschränkungen sowie eine Vielzahl von Argumenttypen angeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-1518">The following example finds specific overloads of `MethodA`, specifying binding constraints and a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-1519">Die [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Beispiel benötigen Sie die `/unsafe` -Compileroption.</span><span class="sxs-lookup"><span data-stu-id="2da29-1519">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="2da29-1520">Es wurden mehrere Methoden gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1520">More than one method is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-1521">
            <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1521">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2da29-1522">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1522">-or-</span>
          </span>
          <span data-ttu-id="2da29-1523">
            <paramref name="types" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1523">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2da29-1524">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1524">-or-</span>
          </span>
          <span data-ttu-id="2da29-1525">Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1525">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-1526">
            <paramref name="types" /> ist mehrdimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1526">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="2da29-1527">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1527">-or-</span>
          </span>
          <span data-ttu-id="2da29-1528">
            <paramref name="modifiers" /> ist mehrdimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1528">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-1529">Die Zeichenfolge, die den Namen der abzurufenden Methode enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1529">The string containing the name of the method to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="2da29-1530">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1530">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="2da29-1531">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1531">-or-</span>
          </span>
          <span data-ttu-id="2da29-1532">0 (null), damit <see langword="null" /> zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1532">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="2da29-1533">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1533">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="2da29-1534">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1534">-or-</span>
          </span>
          <span data-ttu-id="2da29-1535">Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1535">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="2da29-1536">Das Objekt, das die Regeln für Reihenfolge und Layout der Argumente, die Art der Übergabe des Rückgabewerts, die für Argumente zu verwendenden Register und die Art der Stapelbereinigung angibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1536">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="2da29-1537">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1537">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span>
          </span>
          <span data-ttu-id="2da29-1538">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1538">-or-</span>
          </span>
          <span data-ttu-id="2da29-1539">Ein leeres Array von <see cref="T:System.Type" />-Objekten (bereitgestellt vom <see cref="F:System.Type.EmptyTypes" />-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1539">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="2da29-1540">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <c>types</c>-Array zugeordnet sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1540">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="2da29-1541">Darf nur bei Aufrufen über COM-Interop verwendet werden. Es werden außerdem nur Parameter berücksichtigt, die als Verweis übergeben werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1541">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span>
          </span>
          <span data-ttu-id="2da29-1542">Der Standardbinder verarbeitet diesen Parameter nicht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1542">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-1543">Sucht nach der angegebenen Methode, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen, und verwendet dabei die angegebenen Bindungseinschränkungen und die angegebene Aufrufkonvention.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1543">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1544">Ein Objekt, das die Methode darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1544">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1545">Obwohl der Standardbinder nicht verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1545">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="2da29-1546">`ParameterModifier` wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1546">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="2da29-1547">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `GetXXX` Methoden, wenn für einen Typ reflektieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-1547">The following table shows what members of a base class are returned by the `GetXXX` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="2da29-1548">Memberart</span><span class="sxs-lookup"><span data-stu-id="2da29-1548">Member Type</span></span>|<span data-ttu-id="2da29-1549">Statisch</span><span class="sxs-lookup"><span data-stu-id="2da29-1549">Static</span></span>|<span data-ttu-id="2da29-1550">Nicht statische</span><span class="sxs-lookup"><span data-stu-id="2da29-1550">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="2da29-1551">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="2da29-1551">Constructor</span></span>|<span data-ttu-id="2da29-1552">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1552">No</span></span>|<span data-ttu-id="2da29-1553">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1553">No</span></span>|  
|<span data-ttu-id="2da29-1554">Feld</span><span class="sxs-lookup"><span data-stu-id="2da29-1554">Field</span></span>|<span data-ttu-id="2da29-1555">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1555">No</span></span>|<span data-ttu-id="2da29-1556">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-1556">Yes.</span></span> <span data-ttu-id="2da29-1557">Ein Feld ist immer nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1557">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-1558">event</span><span class="sxs-lookup"><span data-stu-id="2da29-1558">Event</span></span>|<span data-ttu-id="2da29-1559">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-1559">Not applicable</span></span>|<span data-ttu-id="2da29-1560">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-1560">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-1561">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1561">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-1562">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1562">See note 2 below.</span></span>|  
|<span data-ttu-id="2da29-1563">Methode</span><span class="sxs-lookup"><span data-stu-id="2da29-1563">Method</span></span>|<span data-ttu-id="2da29-1564">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1564">No</span></span>|<span data-ttu-id="2da29-1565">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-1565">Yes.</span></span> <span data-ttu-id="2da29-1566">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1566">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-1567">Geschachtelten Typs</span><span class="sxs-lookup"><span data-stu-id="2da29-1567">Nested Type</span></span>|<span data-ttu-id="2da29-1568">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1568">No</span></span>|<span data-ttu-id="2da29-1569">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1569">No</span></span>|  
|<span data-ttu-id="2da29-1570">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="2da29-1570">Property</span></span>|<span data-ttu-id="2da29-1571">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-1571">Not applicable</span></span>|<span data-ttu-id="2da29-1572">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-1572">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-1573">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1573">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-1574">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1574">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="2da29-1575">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-1575">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="2da29-1576">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="2da29-1576">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="2da29-1577">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1577">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-1578">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1578">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="2da29-1579">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="2da29-1579">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="2da29-1580">Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Methoden in die Suche einbezogen werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-1580">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="2da29-1581">Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1581">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="2da29-1582">Geben Sie `BindingFlags.Public` um öffentliche Methoden in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1582">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="2da29-1583">Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1583">Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="2da29-1584">Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1584">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="2da29-1585">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</span><span class="sxs-lookup"><span data-stu-id="2da29-1585">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="2da29-1586">`BindingFlags.IgnoreCase` um die Groß-/Kleinschreibung ignorieren `name`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1586">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="2da29-1587">`BindingFlags.DeclaredOnly` Um nur die deklarierten Methoden suchen die <xref:System.Type>, nicht die Methoden, die nur geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1587">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="2da29-1588">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1588">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-1589">Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1589">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="2da29-1590">Sie können nur Parameter auslassen, aufrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1590">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="2da29-1591">Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1591">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-1592">Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <xref:System.Object> Wenn ohne klasseneinschränkung ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-1592">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-1593">Für generische Methoden enthalten nicht die Typargumente in `name`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1593">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="2da29-1594">Z. B. den C#-Code `GetMember("MyMethod<int>")` sucht ein Element mit dem Textnamen "`MyMethod<int>`", anstatt für eine Methode namens `MyMethod` , die ein generisches Argument des Typs hat `int`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1594">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1595">Das folgende Beispiel sucht nach bestimmten Überladungen der `MethodA`, bindungseinschränkungen angeben, das Aufrufen von Konventionen sowie eine Vielzahl von Argumenttypen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1595">The following example finds specific overloads of `MethodA`, specifying binding constraints, calling conventions, and a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-1596">Die [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Beispiel benötigen Sie die `/unsafe` -Compileroption.</span><span class="sxs-lookup"><span data-stu-id="2da29-1596">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="2da29-1597">Es wurden mehrere Methoden gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1597">More than one method is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-1598">
            <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1598">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2da29-1599">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1599">-or-</span>
          </span>
          <span data-ttu-id="2da29-1600">
            <paramref name="types" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1600">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2da29-1601">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1601">-or-</span>
          </span>
          <span data-ttu-id="2da29-1602">Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1602">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-1603">
            <paramref name="types" /> ist mehrdimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1603">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="2da29-1604">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1604">-or-</span>
          </span>
          <span data-ttu-id="2da29-1605">
            <paramref name="modifiers" /> ist mehrdimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1605">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-1606">Die Zeichenfolge, die den Namen der abzurufenden Methode enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1606">The string containing the name of the method to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="2da29-1607">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1607">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="2da29-1608">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1608">-or-</span>
          </span>
          <span data-ttu-id="2da29-1609">0 (null), damit <see langword="null" /> zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1609">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="2da29-1610">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1610">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="2da29-1611">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1611">-or-</span>
          </span>
          <span data-ttu-id="2da29-1612">Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1612">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="callConvention">
          <span data-ttu-id="2da29-1613">Das Objekt, das die Regeln für Reihenfolge und Layout der Argumente, die Art der Übergabe des Rückgabewerts, die für Argumente zu verwendenden Register und den Prozess angibt, der den Stapel bereinigt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1613">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="2da29-1614">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1614">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span>
          </span>
          <span data-ttu-id="2da29-1615">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1615">-or-</span>
          </span>
          <span data-ttu-id="2da29-1616">Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer Methode, die keine Parameter akzeptiert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1616">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</span>
          </span>
          <span data-ttu-id="2da29-1617">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1617">-or-</span>
          </span>
          <span data-ttu-id="2da29-1618">
            <see langword="null" />
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1618">
              <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2da29-1619">Wenn <c>types</c><see langword="null" /> entspricht, wird keine Übereinstimmung von Argumenten überprüft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1619">If <c>types</c> is <see langword="null" />, arguments are not matched.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="2da29-1620">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <c>types</c>-Array zugeordnet sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1620">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="2da29-1621">Der Standardbinder verarbeitet diesen Parameter nicht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1621">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-1622">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen und der angegebenen Aufrufkonvention nach der angegebenen Methode, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1622">When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1623">Ein Objekt, das die Methode darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1623">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1624">Obwohl der Standardbinder nicht verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1624">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="2da29-1625">`ParameterModifier` wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1625">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="2da29-1626">Wenn `types` `null` ist, wird keine Übereinstimmung von Argumenten überprüft.</span><span class="sxs-lookup"><span data-stu-id="2da29-1626">If `types` is `null`, arguments are not matched.</span></span>  
  
 <span data-ttu-id="2da29-1627">Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Methoden in die Suche einbezogen werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-1627">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="2da29-1628">Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1628">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="2da29-1629">Geben Sie `BindingFlags.Public` um öffentliche Methoden in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1629">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="2da29-1630">Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1630">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="2da29-1631">Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1631">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="2da29-1632">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</span><span class="sxs-lookup"><span data-stu-id="2da29-1632">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="2da29-1633">`BindingFlags.IgnoreCase` um die Groß-/Kleinschreibung ignorieren `name`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1633">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="2da29-1634">`BindingFlags.DeclaredOnly` Um nur die deklarierten Methoden suchen die <xref:System.Type>, nicht die Methoden, die nur geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1634">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="2da29-1635">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1635">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="2da29-1636">Es wurden mehrere Methoden gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1636">More than one method is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-1637">
            <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1637">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-1638">
            <paramref name="types" /> ist mehrdimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1638">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="2da29-1639">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1639">-or-</span>
          </span>
          <span data-ttu-id="2da29-1640">
            <paramref name="modifiers" /> ist mehrdimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1640">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="2da29-1641">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1641">-or-</span>
          </span>
          <span data-ttu-id="2da29-1642">
            <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1642">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2da29-1643">Der aktuelle Typ ist ein <see cref="T:System.Reflection.Emit.TypeBuilder" /> oder ein <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1643">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-1644">Ruft die Methoden des aktuellen <see cref="T:System.Type" /> ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1644">Gets the methods of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-1645">Gibt sämtliche öffentlichen Methoden des aktuellen <see cref="T:System.Type" /> zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1645">Returns all the public methods of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1646">Ein Array von <see cref="T:System.Reflection.MethodInfo" />-Objekten, die alle für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Member darstellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1646">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all the public methods defined for the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="2da29-1647">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1647">-or-</span>
          </span>
          <span data-ttu-id="2da29-1648">Ein leeres Array vom <see cref="T:System.Reflection.MethodInfo" />-Typ, wenn für den aktuellen <see cref="T:System.Type" /> keine öffentlichen Methoden definiert sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1648">An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no public methods are defined for the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1649">Die <xref:System.Type.GetMethods%2A> Methode gibt keinen zurück Methoden in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</span><span class="sxs-lookup"><span data-stu-id="2da29-1649">The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="2da29-1650">Der Code muss nicht richten sich nach der Reihenfolge, in der Methoden zurückgegeben werden, da, bei der Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="2da29-1650">Your code must not depend on the order in which methods are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="2da29-1651">Konstruktoren sind nicht im Array der Methoden, die durch diesen Aufruf zurückgegebene enthalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1651">Constructors are not included in the array of methods returned by this call.</span></span> <span data-ttu-id="2da29-1652">Stellen Sie einen separaten Aufruf von `GetConstructors()` Konstruktormethoden abgerufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1652">Make a separate call to `GetConstructors()` to get the constructor methods.</span></span>  
  
 <span data-ttu-id="2da29-1653">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-1653">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="2da29-1654">Memberart</span><span class="sxs-lookup"><span data-stu-id="2da29-1654">Member Type</span></span>|<span data-ttu-id="2da29-1655">Statisch</span><span class="sxs-lookup"><span data-stu-id="2da29-1655">Static</span></span>|<span data-ttu-id="2da29-1656">Nicht statische</span><span class="sxs-lookup"><span data-stu-id="2da29-1656">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="2da29-1657">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="2da29-1657">Constructor</span></span>|<span data-ttu-id="2da29-1658">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1658">No</span></span>|<span data-ttu-id="2da29-1659">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1659">No</span></span>|  
|<span data-ttu-id="2da29-1660">Feld</span><span class="sxs-lookup"><span data-stu-id="2da29-1660">Field</span></span>|<span data-ttu-id="2da29-1661">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1661">No</span></span>|<span data-ttu-id="2da29-1662">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-1662">Yes.</span></span> <span data-ttu-id="2da29-1663">Ein Feld ist immer nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1663">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-1664">event</span><span class="sxs-lookup"><span data-stu-id="2da29-1664">Event</span></span>|<span data-ttu-id="2da29-1665">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-1665">Not applicable</span></span>|<span data-ttu-id="2da29-1666">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-1666">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-1667">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1667">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-1668">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1668">See note 2 below.</span></span>|  
|<span data-ttu-id="2da29-1669">Methode</span><span class="sxs-lookup"><span data-stu-id="2da29-1669">Method</span></span>|<span data-ttu-id="2da29-1670">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1670">No</span></span>|<span data-ttu-id="2da29-1671">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-1671">Yes.</span></span> <span data-ttu-id="2da29-1672">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1672">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-1673">Geschachtelten Typs</span><span class="sxs-lookup"><span data-stu-id="2da29-1673">Nested Type</span></span>|<span data-ttu-id="2da29-1674">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1674">No</span></span>|<span data-ttu-id="2da29-1675">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1675">No</span></span>|  
|<span data-ttu-id="2da29-1676">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="2da29-1676">Property</span></span>|<span data-ttu-id="2da29-1677">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-1677">Not applicable</span></span>|<span data-ttu-id="2da29-1678">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-1678">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-1679">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1679">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-1680">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1680">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="2da29-1681">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-1681">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="2da29-1682">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="2da29-1682">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="2da29-1683">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1683">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-1684">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1684">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="2da29-1685">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="2da29-1685">Custom attributes are not part of the common type system.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-1686">Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1686">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="2da29-1687">Sie können nur Parameter auslassen, aufrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1687">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="2da29-1688">Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1688">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-1689">Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <xref:System.Object> Wenn ohne klasseneinschränkung ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-1689">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="2da29-1690">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1690">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="2da29-1691">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1691">-or-</span>
          </span>
          <span data-ttu-id="2da29-1692">0 (null), damit <see langword="null" /> zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1692">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-1693">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die für den aktuellen <see cref="T:System.Type" /> definierten Methoden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1693">When overridden in a derived class, searches for the methods defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1694">Ein Array von <see cref="T:System.Reflection.MethodInfo" />-Objekten, die sämtliche für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Methoden darstellen, die den angegebenen Bindungseinschränkungen entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1694">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all methods defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="2da29-1695">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1695">-or-</span>
          </span>
          <span data-ttu-id="2da29-1696">Ein leeres Array vom <see cref="T:System.Reflection.MethodInfo" />-Typ, wenn für den aktuellen <see cref="T:System.Type" /> keine Methoden definiert sind oder keine der definierten Methoden den Bindungseinschränkungen entspricht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1696">An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no methods are defined for the current <see cref="T:System.Type" />, or if none of the defined methods match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1697">Die <xref:System.Type.GetMethods%2A> Methode gibt keinen zurück Methoden in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</span><span class="sxs-lookup"><span data-stu-id="2da29-1697">The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="2da29-1698">Der Code muss nicht richten sich nach der Reihenfolge, in der Methoden zurückgegeben werden, da, bei der Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="2da29-1698">Your code must not depend on the order in which methods are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="2da29-1699">Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Methoden in die Suche einbezogen werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-1699">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="2da29-1700">Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1700">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="2da29-1701">Geben Sie `BindingFlags.Public` um öffentliche Methoden in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1701">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="2da29-1702">Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1702">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span> <span data-ttu-id="2da29-1703">Nur geschützte und interne Methoden in Basisklassen werden zurückgegeben. private Methoden in Basisklassen werden nicht zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-1703">Only protected and internal methods on base classes are returned; private methods on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="2da29-1704">Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1704">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="2da29-1705">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</span><span class="sxs-lookup"><span data-stu-id="2da29-1705">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="2da29-1706">`BindingFlags.DeclaredOnly` Um nur die deklarierten Methoden suchen die <xref:System.Type>, nicht die Methoden, die nur geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1706">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="2da29-1707">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1707">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-1708">Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1708">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="2da29-1709">Sie können nur Parameter auslassen, aufrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1709">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="2da29-1710">Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1710">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-1711">Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <xref:System.Object> Wenn ohne klasseneinschränkung ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-1711">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1712">Das folgende Beispiel erstellt eine Klasse mit zwei öffentliche Methoden und einer geschützten Methode, erstellt eine `Type` -Objekt entsprechende `MyTypeClass`Ruft alle öffentliche und nicht öffentlichen Methoden und ihre Namen angezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1712">The following example creates a class with two public methods and one protected method, creates a `Type` object corresponding to `MyTypeClass`, gets all public and non-public methods, and displays their names.</span></span>  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-1713">Ruft einen bestimmten Typ ab, der im aktuellen <see cref="T:System.Type" /> geschachtelt ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1713">Gets a specific type nested within the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-1714">Die Zeichenfolge, die den Namen des abzurufenden geschachtelten Typs enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1714">The string containing the name of the nested type to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-1715">Sucht den öffentlichen geschachtelten Typ mit dem angegebenen Namen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1715">Searches for the public nested type with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1716">Ein Objekt, das den öffentlichen geschachtelten Typ mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1716">An object representing the public nested type with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1717">Die Suche nach `name` Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="2da29-1717">The search for `name` is case-sensitive.</span></span>  
  
 <span data-ttu-id="2da29-1718">Verwenden Sie den einfachen Namen der geschachtelten Klasse für `name`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1718">Use the simple name of the nested class for `name`.</span></span> <span data-ttu-id="2da29-1719">Qualifizieren Sie ihn nicht mit dem Namen der äußeren Klasse.</span><span class="sxs-lookup"><span data-stu-id="2da29-1719">Do not qualify it with the name of the outer class.</span></span> <span data-ttu-id="2da29-1720">Verwenden Sie für eine generische geschachtelte Klasse der ergänzte Name – d. h. ein Graviszeichen und die Anzahl von generischen Argumenten angefügt werden soll.</span><span class="sxs-lookup"><span data-stu-id="2da29-1720">For a generic nested class, use the mangled name — that is, append a grave accent and the number of generic arguments.</span></span> <span data-ttu-id="2da29-1721">Verwenden Sie z. B. die Zeichenfolge "innere\`1" zum Abrufen des generisches der geschachtelten Klasse `Inner<T>` (`Inner(Of T)` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-1721">For example, use the string "Inner\`1" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic).</span></span> <span data-ttu-id="2da29-1722">Verwenden Sie keine sprachspezifische Syntax für Typparameter angegeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-1722">Do not include language-specific syntax for type parameters.</span></span>  
  
 <span data-ttu-id="2da29-1723">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-1723">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="2da29-1724">Memberart</span><span class="sxs-lookup"><span data-stu-id="2da29-1724">Member Type</span></span>|<span data-ttu-id="2da29-1725">Statisch</span><span class="sxs-lookup"><span data-stu-id="2da29-1725">Static</span></span>|<span data-ttu-id="2da29-1726">Nicht statische</span><span class="sxs-lookup"><span data-stu-id="2da29-1726">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="2da29-1727">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="2da29-1727">Constructor</span></span>|<span data-ttu-id="2da29-1728">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1728">No</span></span>|<span data-ttu-id="2da29-1729">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1729">No</span></span>|  
|<span data-ttu-id="2da29-1730">Feld</span><span class="sxs-lookup"><span data-stu-id="2da29-1730">Field</span></span>|<span data-ttu-id="2da29-1731">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1731">No</span></span>|<span data-ttu-id="2da29-1732">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-1732">Yes.</span></span> <span data-ttu-id="2da29-1733">Ein Feld ist immer nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1733">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-1734">event</span><span class="sxs-lookup"><span data-stu-id="2da29-1734">Event</span></span>|<span data-ttu-id="2da29-1735">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-1735">Not applicable</span></span>|<span data-ttu-id="2da29-1736">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-1736">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-1737">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1737">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-1738">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1738">See note 2 below.</span></span>|  
|<span data-ttu-id="2da29-1739">Methode</span><span class="sxs-lookup"><span data-stu-id="2da29-1739">Method</span></span>|<span data-ttu-id="2da29-1740">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1740">No</span></span>|<span data-ttu-id="2da29-1741">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-1741">Yes.</span></span> <span data-ttu-id="2da29-1742">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1742">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-1743">Geschachtelten Typs</span><span class="sxs-lookup"><span data-stu-id="2da29-1743">Nested Type</span></span>|<span data-ttu-id="2da29-1744">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1744">No</span></span>|<span data-ttu-id="2da29-1745">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1745">No</span></span>|  
|<span data-ttu-id="2da29-1746">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="2da29-1746">Property</span></span>|<span data-ttu-id="2da29-1747">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-1747">Not applicable</span></span>|<span data-ttu-id="2da29-1748">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-1748">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-1749">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1749">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-1750">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1750">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="2da29-1751">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-1751">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="2da29-1752">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="2da29-1752">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="2da29-1753">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1753">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-1754">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1754">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="2da29-1755">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="2da29-1755">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="2da29-1756">Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die geschachtelte Typen von der Class-Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="2da29-1756">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="2da29-1757">Wenn ein geschachtelter Typ generisch ist, gibt diese Methode die generische Typdefinition.</span><span class="sxs-lookup"><span data-stu-id="2da29-1757">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="2da29-1758">Dies gilt auch, wenn der einschließenden generischen Typs geschlossenen konstruierten Typs ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-1758">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-1759">Wenn die aktuelle <xref:System.Type> stellt einen generischen Typ definiert, die in c#, Visual Basic oder C++ die geschachtelten Typen sind alle generisch, auch wenn sie keine eigenen generischen Parameter verfügen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1759">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="2da29-1760">Dies gilt nicht unbedingt von geschachtelten Typen in dynamischen Assemblys definiert, oder Kompilieren mit der [Ilasm.exe (IL-Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="2da29-1760">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="2da29-1761">Informationen über geschachtelte generische Typen und zum Erstellen von geschachtelten generischer Typen von generischen Typdefinitionen finden Sie unter <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1761">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-1762">
            <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1762">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-1763">Die Zeichenfolge, die den Namen des abzurufenden geschachtelten Typs enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1763">The string containing the name of the nested type to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="2da29-1764">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1764">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="2da29-1765">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1765">-or-</span>
          </span>
          <span data-ttu-id="2da29-1766">0 (null), damit <see langword="null" /> zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1766">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-1767">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen den angegebenen geschachtelten Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1767">When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1768">Ein Objekt, das den geschachtelten Typ darstellt, der den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls<see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1768">An object representing the nested type that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1769">Verwenden Sie den einfachen Namen der geschachtelten Klasse für `name`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1769">Use the simple name of the nested class for `name`.</span></span> <span data-ttu-id="2da29-1770">Qualifizieren Sie ihn nicht mit dem Namen der äußeren Klasse.</span><span class="sxs-lookup"><span data-stu-id="2da29-1770">Do not qualify it with the name of the outer class.</span></span> <span data-ttu-id="2da29-1771">Verwenden Sie für eine generische geschachtelte Klasse der ergänzte Name – d. h. ein Graviszeichen und die Anzahl der generischen Parameter angefügt werden soll.</span><span class="sxs-lookup"><span data-stu-id="2da29-1771">For a generic nested class, use the mangled name — that is, append a grave accent and the number of generic parameters.</span></span> <span data-ttu-id="2da29-1772">Verwenden Sie z. B. die Zeichenfolge "innere\`1" zum Abrufen des generisches der geschachtelten Klasse `Inner<T>` (`Inner(Of T)` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-1772">For example, use the string "Inner\`1" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic).</span></span> <span data-ttu-id="2da29-1773">Verwenden Sie keine sprachspezifische Syntax für Typparameter angegeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-1773">Do not include language-specific syntax for type parameters.</span></span>  
  
 <span data-ttu-id="2da29-1774">Die folgenden <xref:System.Reflection.BindingFlags> Filter Flags können verwendet werden, um die definieren, welche geschachtelten Typen in die Suche einbeziehen:</span><span class="sxs-lookup"><span data-stu-id="2da29-1774">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="2da29-1775">Geben Sie <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> oder <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> ein Ergebnis zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-1775">You must specify either <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to get a return.</span></span>  
  
-   <span data-ttu-id="2da29-1776">Geben Sie <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> öffentliche geschachtelten Typen in die Suche eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1776">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public nested types in the search.</span></span>  
  
-   <span data-ttu-id="2da29-1777">Geben Sie <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> an nicht öffentlichen geschachtelte Typen (d. h. private, interne und geschützte geschachtelte Typen) in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1777">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</span></span>  
  
 <span data-ttu-id="2da29-1778">Diese Methode gibt nur die geschachtelten Typen des aktuellen Typs zurück.</span><span class="sxs-lookup"><span data-stu-id="2da29-1778">This method returns only the nested types of the current type.</span></span> <span data-ttu-id="2da29-1779">Die Basisklassen des aktuellen Typs werden nicht durchsucht.</span><span class="sxs-lookup"><span data-stu-id="2da29-1779">It does not search the base classes of the current type.</span></span> <span data-ttu-id="2da29-1780">Um Typen zu suchen, die geschachtelt sind in Basisklassen, führen Sie die Vererbungshierarchie Aufrufen <xref:System.Type.GetNestedType%2A> auf jeder Ebene.</span><span class="sxs-lookup"><span data-stu-id="2da29-1780">To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedType%2A> at each level.</span></span>  
  
 <span data-ttu-id="2da29-1781"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> und <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> werden ignoriert.</span><span class="sxs-lookup"><span data-stu-id="2da29-1781"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> are ignored.</span></span>  
  
 <span data-ttu-id="2da29-1782">Beim Aufrufen dieser Methode nur mit der <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> Flag oder nur die <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Flag zurück, den angegebenen geschachtelten Typen und alle anderen Flags sind nicht erforderlich.</span><span class="sxs-lookup"><span data-stu-id="2da29-1782">Calling this method with only the <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag or only the <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag will return the specified nested types and does not require any other flags.</span></span>  
  
 <span data-ttu-id="2da29-1783">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1783">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="2da29-1784">Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die geschachtelte Typen von der Class-Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="2da29-1784">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="2da29-1785">Wenn ein geschachtelter Typ generisch ist, gibt diese Methode die generische Typdefinition.</span><span class="sxs-lookup"><span data-stu-id="2da29-1785">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="2da29-1786">Dies gilt auch, wenn der einschließenden generischen Typs geschlossenen konstruierten Typs ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-1786">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-1787">Wenn die aktuelle <xref:System.Type> stellt einen generischen Typ definiert, die in c#, Visual Basic oder C++ die geschachtelten Typen sind alle generisch, auch wenn sie keine eigenen generischen Parameter verfügen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1787">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="2da29-1788">Dies gilt nicht unbedingt von geschachtelten Typen in dynamischen Assemblys definiert, oder Kompilieren mit der [Ilasm.exe (IL-Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="2da29-1788">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="2da29-1789">Informationen über geschachtelte generische Typen und zum Erstellen von geschachtelten generischer Typen von generischen Typdefinitionen finden Sie unter <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1789">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-1790">
            <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1790">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-1791">Ruft die im aktuellen <see cref="T:System.Type" /> geschachtelten Typen ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1791">Gets the types nested within the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-1792">Gibt die im aktuellen <see cref="T:System.Type" /> geschachtelten öffentlichen Typen zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1792">Returns the public types nested in the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1793">Ein Array von <see cref="T:System.Type" />-Objekten, das die im aktuellen <see cref="T:System.Type" /> geschachtelten öffentlichen Typen darstellt (die Suche ist nicht rekursiv) oder ein leeres Array vom Typ <see cref="T:System.Type" />, wenn im aktuellen <see cref="T:System.Type" /> keine öffentlichen Typen geschachtelt sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1793">An array of <see cref="T:System.Type" /> objects representing the public types nested in the current <see cref="T:System.Type" /> (the search is not recursive), or an empty array of type <see cref="T:System.Type" /> if no public types are nested in the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1794">Die <xref:System.Type.GetNestedTypes%2A> Methode gibt keinen zurück Typen in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</span><span class="sxs-lookup"><span data-stu-id="2da29-1794">The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="2da29-1795">Code muss nicht abhängig von der Reihenfolge, in der Typen zurückgegeben werden, da, bei der Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="2da29-1795">Your code must not depend on the order in which types are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="2da29-1796">Es werden nur die sofort im aktuellen Typ geschachtelten öffentlichen Typen zurückgegeben. die Suche ist nicht rekursiv.</span><span class="sxs-lookup"><span data-stu-id="2da29-1796">Only the public types immediately nested in the current type are returned; the search is not recursive.</span></span>  
  
 <span data-ttu-id="2da29-1797">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-1797">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="2da29-1798">Memberart</span><span class="sxs-lookup"><span data-stu-id="2da29-1798">Member Type</span></span>|<span data-ttu-id="2da29-1799">Statisch</span><span class="sxs-lookup"><span data-stu-id="2da29-1799">Static</span></span>|<span data-ttu-id="2da29-1800">Nicht statische</span><span class="sxs-lookup"><span data-stu-id="2da29-1800">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="2da29-1801">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="2da29-1801">Constructor</span></span>|<span data-ttu-id="2da29-1802">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1802">No</span></span>|<span data-ttu-id="2da29-1803">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1803">No</span></span>|  
|<span data-ttu-id="2da29-1804">Feld</span><span class="sxs-lookup"><span data-stu-id="2da29-1804">Field</span></span>|<span data-ttu-id="2da29-1805">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1805">No</span></span>|<span data-ttu-id="2da29-1806">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-1806">Yes.</span></span> <span data-ttu-id="2da29-1807">Ein Feld ist immer nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1807">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-1808">event</span><span class="sxs-lookup"><span data-stu-id="2da29-1808">Event</span></span>|<span data-ttu-id="2da29-1809">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-1809">Not applicable</span></span>|<span data-ttu-id="2da29-1810">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-1810">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-1811">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1811">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-1812">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1812">See note 2 below.</span></span>|  
|<span data-ttu-id="2da29-1813">Methode</span><span class="sxs-lookup"><span data-stu-id="2da29-1813">Method</span></span>|<span data-ttu-id="2da29-1814">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1814">No</span></span>|<span data-ttu-id="2da29-1815">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-1815">Yes.</span></span> <span data-ttu-id="2da29-1816">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1816">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-1817">Geschachtelten Typs</span><span class="sxs-lookup"><span data-stu-id="2da29-1817">Nested Type</span></span>|<span data-ttu-id="2da29-1818">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1818">No</span></span>|<span data-ttu-id="2da29-1819">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1819">No</span></span>|  
|<span data-ttu-id="2da29-1820">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="2da29-1820">Property</span></span>|<span data-ttu-id="2da29-1821">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-1821">Not applicable</span></span>|<span data-ttu-id="2da29-1822">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-1822">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-1823">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1823">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-1824">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1824">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="2da29-1825">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-1825">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="2da29-1826">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="2da29-1826">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="2da29-1827">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1827">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-1828">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1828">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="2da29-1829">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="2da29-1829">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="2da29-1830">Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die geschachtelte Typen von der Class-Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="2da29-1830">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="2da29-1831">Wenn ein geschachtelter Typ generisch ist, gibt diese Methode die generische Typdefinition.</span><span class="sxs-lookup"><span data-stu-id="2da29-1831">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="2da29-1832">Dies gilt auch, wenn der einschließenden generischen Typs geschlossenen konstruierten Typs ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-1832">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-1833">Wenn die aktuelle <xref:System.Type> stellt einen generischen Typ definiert, die in c#, Visual Basic oder C++ die geschachtelten Typen sind alle generisch, auch wenn sie keine eigenen generischen Parameter verfügen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1833">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="2da29-1834">Dies gilt nicht unbedingt von geschachtelten Typen in dynamischen Assemblys definiert, oder Kompilieren mit der [Ilasm.exe (IL-Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="2da29-1834">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="2da29-1835">Informationen über geschachtelte generische Typen und zum Erstellen von geschachtelten generischer Typen von generischen Typdefinitionen finden Sie unter <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1835">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1836">Das folgende Beispiel definiert eine geschachtelte Klasse und ein `struct` in `MyClass`, und klicken Sie dann ruft Objekte der geschachtelten Typen mit dem Typ der `MyClass`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1836">The following example defines a nested class and a `struct` in `MyClass`, and then obtains objects of the nested types using the type of `MyClass`.</span></span>  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="2da29-1837">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1837">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="2da29-1838">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1838">-or-</span>
          </span>
          <span data-ttu-id="2da29-1839">0 (null), damit <see langword="null" /> zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1839">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-1840">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die im aktuellen <see cref="T:System.Type" /> geschachtelten Typen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1840">When overridden in a derived class, searches for the types nested in the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1841">Ein Array von <see cref="T:System.Type" />-Objekten, das alle im aktuellen <see cref="T:System.Type" /> geschachtelten Typen darstellt, die mit den angegebenen Bindungseinschränkungen übereinstimmen (die Suche ist nicht rekursiv) oder ein leeres Array vom Typ <see cref="T:System.Type" />, wenn keine geschachtelten Typen gefunden werden, die mit den Bindungseinschränkungen übereinstimmen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1841">An array of <see cref="T:System.Type" /> objects representing all the types nested in the current <see cref="T:System.Type" /> that match the specified binding constraints (the search is not recursive), or an empty array of type <see cref="T:System.Type" />, if no nested types are found that match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1842">Die Suche nach geschachtelten Typen ist nicht rekursiv.</span><span class="sxs-lookup"><span data-stu-id="2da29-1842">The search for nested types is not recursive.</span></span>  
  
 <span data-ttu-id="2da29-1843">Die <xref:System.Type.GetNestedTypes%2A> Methode gibt keinen zurück Typen in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</span><span class="sxs-lookup"><span data-stu-id="2da29-1843">The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="2da29-1844">Code muss nicht abhängig von der Reihenfolge, in der Typen zurückgegeben werden, da, bei der Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="2da29-1844">Your code must not depend on the order in which types are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="2da29-1845">Die folgenden <xref:System.Reflection.BindingFlags> Filter Flags können verwendet werden, um die definieren, welche geschachtelten Typen in die Suche einbeziehen:</span><span class="sxs-lookup"><span data-stu-id="2da29-1845">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="2da29-1846">Geben Sie <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> oder <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> ein Ergebnis zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-1846">You must specify either <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to get a return.</span></span>  
  
-   <span data-ttu-id="2da29-1847">Geben Sie <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> öffentliche geschachtelten Typen in die Suche eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1847">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public nested types in the search.</span></span>  
  
-   <span data-ttu-id="2da29-1848">Geben Sie <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> an nicht öffentlichen geschachtelte Typen (d. h. private, interne und geschützte geschachtelte Typen) in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1848">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</span></span>  
  
 <span data-ttu-id="2da29-1849">Diese Methode gibt nur die geschachtelten Typen des aktuellen Typs zurück.</span><span class="sxs-lookup"><span data-stu-id="2da29-1849">This method returns only the nested types of the current type.</span></span> <span data-ttu-id="2da29-1850">Die Basisklassen des aktuellen Typs werden nicht durchsucht.</span><span class="sxs-lookup"><span data-stu-id="2da29-1850">It does not search the base classes of the current type.</span></span> <span data-ttu-id="2da29-1851">Um Typen zu suchen, die geschachtelt sind in Basisklassen, führen Sie die Vererbungshierarchie Aufrufen <xref:System.Type.GetNestedTypes%2A> auf jeder Ebene.</span><span class="sxs-lookup"><span data-stu-id="2da29-1851">To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedTypes%2A> at each level.</span></span>  
  
 <span data-ttu-id="2da29-1852"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> und <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> werden ignoriert.</span><span class="sxs-lookup"><span data-stu-id="2da29-1852"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> are ignored.</span></span>  
  
 <span data-ttu-id="2da29-1853">Beim Aufrufen dieser Methode nur mit der <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> Flag oder nur die <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Flag zurück, den angegebenen geschachtelten Typen und alle anderen Flags sind nicht erforderlich.</span><span class="sxs-lookup"><span data-stu-id="2da29-1853">Calling this method with only the <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag or only the <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag will return the specified nested types and does not require any other flags.</span></span>  
  
 <span data-ttu-id="2da29-1854">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1854">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="2da29-1855">Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die geschachtelte Typen von der Class-Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="2da29-1855">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="2da29-1856">Wenn ein geschachtelter Typ generisch ist, gibt diese Methode die generische Typdefinition.</span><span class="sxs-lookup"><span data-stu-id="2da29-1856">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="2da29-1857">Dies gilt auch, wenn der einschließenden generischen Typs geschlossenen konstruierten Typs ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-1857">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-1858">Wenn die aktuelle <xref:System.Type> stellt einen generischen Typ definiert, die in c#, Visual Basic oder C++ die geschachtelten Typen sind alle generisch, auch wenn sie keine eigenen generischen Parameter verfügen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1858">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="2da29-1859">Dies gilt nicht unbedingt von geschachtelten Typen in dynamischen Assemblys definiert, oder Kompilieren mit der [Ilasm.exe (IL-Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="2da29-1859">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="2da29-1860">Informationen über geschachtelte generische Typen und zum Erstellen von geschachtelten generischer Typen von generischen Typdefinitionen finden Sie unter <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1860">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1861">Das folgende Beispiel erstellt zwei geschachtelte öffentliche Klassen und zwei geschachtelte geschützten Klassen, und zeigt Informationen für Klassen, die die angegebenen bindungseinschränkungen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1861">The following example creates two nested public classes and two nested protected classes, and displays information for classes that match the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-1862">Ruft die Eigenschaften des aktuellen <see cref="T:System.Type" /> ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1862">Gets the properties of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-1863">Gibt sämtliche öffentlichen Eigenschaften des aktuellen <see cref="T:System.Type" /> zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1863">Returns all the public properties of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1864">Ein Array von <see cref="T:System.Reflection.PropertyInfo" />-Objekten, die alle öffentlichen Eigenschaften des aktuellen <see cref="T:System.Type" /> darstellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1864">An array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing all public properties of the current <see cref="T:System.Type" />.</span>
          </span>
          <span data-ttu-id="2da29-1865">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1865">-or-</span>
          </span>
          <span data-ttu-id="2da29-1866">Ein leeres Array vom <see cref="T:System.Reflection.PropertyInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine öffentlichen Eigenschaften besitzt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1866">An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have public properties.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1867">Das Aufrufen dieser Überladung entspricht dem Aufrufen der <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> -Überladung mit einer `bindingAttr` Argument gleich `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` in C# geschrieben und `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="2da29-1867">Calling this overload is equivalent to calling the <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> overload with a `bindingAttr` argument equal to `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` in C# and  `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` in Visual Basic.</span></span> <span data-ttu-id="2da29-1868">Gibt alle öffentlichen Instanz und statische Eigenschaften, die sowohl die vom aktuellen Typ definiert <xref:System.Type> Objekt als auch solche, die von dessen Basistypen geerbt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1868">It returns all public instance and static properties, both those defined by the type represented by the current <xref:System.Type> object as well as those inherited from its base types.</span></span>  
  
 <span data-ttu-id="2da29-1869">Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-1869">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="2da29-1870">Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1870">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="2da29-1871">Die <xref:System.Type.GetProperties%2A> Methode gibt keinen zurück Eigenschaften in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</span><span class="sxs-lookup"><span data-stu-id="2da29-1871">The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="2da29-1872">Der Code muss nicht richten sich nach der Reihenfolge, in der Eigenschaften zurückgegeben werden, da, bei der Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="2da29-1872">Your code must not depend on the order in which properties are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="2da29-1873">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-1873">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="2da29-1874">Memberart</span><span class="sxs-lookup"><span data-stu-id="2da29-1874">Member Type</span></span>|<span data-ttu-id="2da29-1875">Statisch</span><span class="sxs-lookup"><span data-stu-id="2da29-1875">Static</span></span>|<span data-ttu-id="2da29-1876">Nicht statische</span><span class="sxs-lookup"><span data-stu-id="2da29-1876">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="2da29-1877">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="2da29-1877">Constructor</span></span>|<span data-ttu-id="2da29-1878">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1878">No</span></span>|<span data-ttu-id="2da29-1879">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1879">No</span></span>|  
|<span data-ttu-id="2da29-1880">Feld</span><span class="sxs-lookup"><span data-stu-id="2da29-1880">Field</span></span>|<span data-ttu-id="2da29-1881">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1881">No</span></span>|<span data-ttu-id="2da29-1882">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-1882">Yes.</span></span> <span data-ttu-id="2da29-1883">Ein Feld ist immer nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1883">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-1884">event</span><span class="sxs-lookup"><span data-stu-id="2da29-1884">Event</span></span>|<span data-ttu-id="2da29-1885">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-1885">Not applicable</span></span>|<span data-ttu-id="2da29-1886">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-1886">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-1887">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1887">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-1888">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1888">See note 2 below.</span></span>|  
|<span data-ttu-id="2da29-1889">Methode</span><span class="sxs-lookup"><span data-stu-id="2da29-1889">Method</span></span>|<span data-ttu-id="2da29-1890">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1890">No</span></span>|<span data-ttu-id="2da29-1891">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-1891">Yes.</span></span> <span data-ttu-id="2da29-1892">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1892">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-1893">Geschachtelten Typs</span><span class="sxs-lookup"><span data-stu-id="2da29-1893">Nested Type</span></span>|<span data-ttu-id="2da29-1894">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1894">No</span></span>|<span data-ttu-id="2da29-1895">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-1895">No</span></span>|  
|<span data-ttu-id="2da29-1896">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="2da29-1896">Property</span></span>|<span data-ttu-id="2da29-1897">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-1897">Not applicable</span></span>|<span data-ttu-id="2da29-1898">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-1898">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-1899">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1899">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-1900">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1900">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="2da29-1901">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-1901">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="2da29-1902">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="2da29-1902">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="2da29-1903">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1903">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-1904">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1904">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="2da29-1905">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="2da29-1905">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="2da29-1906">Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1906">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-1907">Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="2da29-1907">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1908">Im folgenden Beispiel wird die Verwendung der `GetProperties`-Methode gezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1908">The following example demonstrates the use of the `GetProperties` method.</span></span>  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="2da29-1909">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1909">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="2da29-1910">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1910">-or-</span>
          </span>
          <span data-ttu-id="2da29-1911">0 (null), damit <see langword="null" /> zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1911">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-1912">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die Eigenschaften des aktuellen <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1912">When overridden in a derived class, searches for the properties of the current <see cref="T:System.Type" />, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1913">Ein Array von <see cref="T:System.Reflection.PropertyInfo" />-Objekten, die sämtliche Eigenschaften des aktuellen <see cref="T:System.Type" /> darstellen, die den angegebenen Bindungseinschränkungen entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1913">An array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing all properties of the current <see cref="T:System.Type" /> that match the specified binding constraints.</span>
          </span>
          <span data-ttu-id="2da29-1914">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1914">-or-</span>
          </span>
          <span data-ttu-id="2da29-1915">Ein leeres Array vom <see cref="T:System.Reflection.PropertyInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine Eigenschaften besitzt oder keine der Eigenschaften den Bindungseinschränkungen entspricht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1915">An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have properties, or if none of the properties match the binding constraints.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1916">Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-1916">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="2da29-1917">Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1917">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="2da29-1918">Die <xref:System.Type.GetProperties%2A> Methode gibt keinen zurück Eigenschaften in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</span><span class="sxs-lookup"><span data-stu-id="2da29-1918">The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="2da29-1919">Der Code muss nicht richten sich nach der Reihenfolge, in der Eigenschaften zurückgegeben werden, da, bei der Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="2da29-1919">Your code must not depend on the order in which properties are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="2da29-1920">Die folgenden <xref:System.Reflection.BindingFlags> Filter Flags können verwendet werden, um die definieren, welche geschachtelten Typen in die Suche einbeziehen:</span><span class="sxs-lookup"><span data-stu-id="2da29-1920">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="2da29-1921">Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1921">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="2da29-1922">Geben Sie `BindingFlags.Public` auf öffentliche Eigenschaften in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1922">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="2da29-1923">Geben Sie `BindingFlags.NonPublic` an nicht öffentlichen Eigenschaften (d. h. private, interne und geschützte) in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1923">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span> <span data-ttu-id="2da29-1924">Nur geschützte und interne Eigenschaften für Basisklassen werden zurückgegeben. Private Eigenschaften für Basisklassen werden nicht zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-1924">Only protected and internal properties on base classes are returned; private properties on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="2da29-1925">Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1925">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="2da29-1926">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</span><span class="sxs-lookup"><span data-stu-id="2da29-1926">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="2da29-1927">`BindingFlags.DeclaredOnly` Suche nur die deklarierten Eigenschaften der <xref:System.Type>, nicht die Eigenschaften, die nur geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1927">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="2da29-1928">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1928">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="2da29-1929">Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-1929">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="2da29-1930">Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1930">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="2da29-1931">Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1931">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-1932">Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="2da29-1932">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1933">Das folgende Beispiel definiert eine Klasse namens `PropertyClass` sechs Eigenschaften enthält: sind zwei öffentliche werden eine private ist, ist eine geschützt, interne (`Friend` in Visual Basic), und eine interne geschützt ist (`Protected Friend` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-1933">The following example defines a class named `PropertyClass` that includes six properties: two are public, one is private, one is protected, one is internal (`Friend` in Visual Basic), and one is protected internal (`Protected Friend` in Visual Basic).</span></span> <span data-ttu-id="2da29-1934">Es zeigt dann einige grundlegende Informationen (den Eigenschaftsnamen und den Typ, ob es sich um Lese-/Schreibzugriff und die Sichtbarkeit der seine `get` und `set` Accessoren) für die Eigenschaften, die die angegebenen bindungseinschränkungen entsprechen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1934">It then displays some basic property information (the property name and type, whether it is read/write, and the visibility of its `get` and `set` accessors) for the properties that match the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-1935">Ruft eine bestimmte Eigenschaft des aktuellen <see cref="T:System.Type" /> ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1935">Gets a specific property of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-1936">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1936">The string containing the name of the public property to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-1937">Sucht die öffentliche Eigenschaft mit dem angegebenen Namen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1937">Searches for the public property with the specified name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1938">Ein Objekt, das die öffentliche Eigenschaft mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1938">An object representing the public property with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1939">Die Suche nach `name` Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="2da29-1939">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="2da29-1940">Die Suche enthält öffentliche statische und öffentlichen Instanzeigenschaften.</span><span class="sxs-lookup"><span data-stu-id="2da29-1940">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="2da29-1941">Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-1941">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="2da29-1942">Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1942">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="2da29-1943">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1943">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-1944">Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="2da29-1944">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
 <span data-ttu-id="2da29-1945">Situationen, in denen <xref:System.Reflection.AmbiguousMatchException> tritt auf, umfassen Folgendes:</span><span class="sxs-lookup"><span data-stu-id="2da29-1945">Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:</span></span>  
  
-   <span data-ttu-id="2da29-1946">Ein Typ enthält zwei indizierte Eigenschaften, die den gleichen Namen, jedoch eine unterschiedliche Anzahl von Parametern.</span><span class="sxs-lookup"><span data-stu-id="2da29-1946">A type contains two indexed properties that have the same name but different numbers of parameters.</span></span> <span data-ttu-id="2da29-1947">Um die Mehrdeutigkeit zu beheben, verwenden Sie eine Überladung der <xref:System.Type.GetProperty%2A> Methode, die Parametertypen angibt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1947">To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.</span></span>  
  
-   <span data-ttu-id="2da29-1948">Ein abgeleiteter Typ deklariert eine Eigenschaft, die eine geerbte Eigenschaft mit dem gleichen Namen, blendet die `new` Modifizierer (`Shadows` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-1948">A derived type declares a property that hides an inherited property with the same name, by using the `new` modifier (`Shadows` in Visual Basic).</span></span> <span data-ttu-id="2da29-1949">Um die Mehrdeutigkeit zu beheben, verwenden die <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> -methodenüberladung, und fügen die <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> Flag, um die Suche auf Member zu beschränken, die nicht geerbt werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1949">To resolve the ambiguity, use the <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> method overload and add the <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> flag to restrict the search to members that are not inherited.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="2da29-1950">Indexer und Standardeigenschaften</span><span class="sxs-lookup"><span data-stu-id="2da29-1950">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="2da29-1951">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft den Standardwert für seinen Datentyp sein.</span><span class="sxs-lookup"><span data-stu-id="2da29-1951">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="2da29-1952">Beispielsweise, wenn die Variable `myList` bezieht sich auf eine <xref:System.Collections.ArrayList>, die Syntax `myList[3]` (`myList(3)` in Visual Basic) Ruft das Element mit dem Index von 3.</span><span class="sxs-lookup"><span data-stu-id="2da29-1952">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="2da29-1953">Sie können die Eigenschaft überladen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1953">You can overload the property.</span></span>  
  
 <span data-ttu-id="2da29-1954">In c# ist diese Funktion einen Indexer aufgerufen wird und nicht erteilt wurde, die anhand des Namens.</span><span class="sxs-lookup"><span data-stu-id="2da29-1954">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="2da29-1955">Standardmäßig wird als eine indizierte Eigenschaft mit dem Namen "Item" ein C#-Indexers in den Metadaten angezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1955">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="2da29-1956">Entwickeln einer Klassenbibliothek können jedoch die <xref:System.Runtime.CompilerServices.IndexerNameAttribute> Attribut zum Ändern des Namens des Indexers in den Metadaten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1956">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="2da29-1957">Z. B. die <xref:System.String> -Klasse verfügt über einen Indexer mit dem Namen <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1957">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="2da29-1958">Indizierte Eigenschaften, die mit anderen Sprachen als c# erstellt können auch die Namen als Element haben.</span><span class="sxs-lookup"><span data-stu-id="2da29-1958">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="2da29-1959">Um zu bestimmen, ob ein Typ eine Standardeigenschaft vorhanden ist, verwenden die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode zur Prüfung auf die <xref:System.Reflection.DefaultMemberAttribute> Attribut.</span><span class="sxs-lookup"><span data-stu-id="2da29-1959">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="2da29-1960">Wenn der Typ besitzt <xref:System.Reflection.DefaultMemberAttribute>die <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> Eigenschaft gibt den Namen der Standardeigenschaft zurück.</span><span class="sxs-lookup"><span data-stu-id="2da29-1960">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-1961">Das folgende Beispiel ruft die `Type` Objekt einer benutzerdefinierten Klasse ruft eine Eigenschaft dieser Klasse ab und zeigt den Namen der Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-1961">The following example retrieves the `Type` object of a user-defined class, retrieves a property of that class, and displays the property name.</span></span>  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 <span data-ttu-id="2da29-1962">Intern wird diese Eigenschaft in den Metadaten mit dem Namen "Item". bezeichnet</span><span class="sxs-lookup"><span data-stu-id="2da29-1962">Internally, this property is referred to in the metadata by the name "Item."</span></span> <span data-ttu-id="2da29-1963">Jeder Versuch zum Abrufen `PropertyInfo` über Reflektion ermöglicht diesen internen Namen angeben muss, um ordnungsgemäß Zurückgeben der `PropertyInfo` Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-1963">Any attempt to get `PropertyInfo` using reflection must specify this internal name in order to correctly return the `PropertyInfo` property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="2da29-1964">Es wurden mehrere Eigenschaften mit dem angegebenen Namen gefunden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1964">More than one property is found with the specified name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-1965">
            <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1965">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-1966">Die Zeichenfolge, die den Namen der abzurufenden Eigenschaft enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1966">The string containing the name of the property to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="2da29-1967">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1967">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="2da29-1968">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1968">-or-</span>
          </span>
          <span data-ttu-id="2da29-1969">0 (null), damit <see langword="null" /> zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1969">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-1970">Sucht die angegebene Eigenschaft unter Verwendung der angegebenen Bindungseinschränkungen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1970">Searches for the specified property, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-1971">Ein Objekt, das die Eigenschaft darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-1971">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-1972">Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-1972">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="2da29-1973">Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1973">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="2da29-1974">Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Eigenschaften in die Suche einbezogen werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-1974">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="2da29-1975">Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1975">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="2da29-1976">Geben Sie `BindingFlags.Public` auf öffentliche Eigenschaften in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1976">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="2da29-1977">Geben Sie `BindingFlags.NonPublic` an nicht öffentlichen Eigenschaften (d. h. private, interne und geschützte) in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1977">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="2da29-1978">Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1978">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="2da29-1979">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</span><span class="sxs-lookup"><span data-stu-id="2da29-1979">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="2da29-1980">`BindingFlags.IgnoreCase` um die Groß-/Kleinschreibung ignorieren `name`.</span><span class="sxs-lookup"><span data-stu-id="2da29-1980">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="2da29-1981">`BindingFlags.DeclaredOnly` Suche nur die deklarierten Eigenschaften der <xref:System.Type>, nicht die Eigenschaften, die nur geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1981">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="2da29-1982">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1982">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="2da29-1983">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1983">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-1984">Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="2da29-1984">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
 <span data-ttu-id="2da29-1985">Situationen, in denen <xref:System.Reflection.AmbiguousMatchException> tritt auf, umfassen Folgendes:</span><span class="sxs-lookup"><span data-stu-id="2da29-1985">Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:</span></span>  
  
-   <span data-ttu-id="2da29-1986">Ein Typ enthält zwei indizierte Eigenschaften, die den gleichen Namen, jedoch eine unterschiedliche Anzahl von Parametern.</span><span class="sxs-lookup"><span data-stu-id="2da29-1986">A type contains two indexed properties that have the same name but different numbers of parameters.</span></span> <span data-ttu-id="2da29-1987">Um die Mehrdeutigkeit zu beheben, verwenden Sie eine Überladung der <xref:System.Type.GetProperty%2A> Methode, die Parametertypen angibt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1987">To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.</span></span>  
  
-   <span data-ttu-id="2da29-1988">Ein abgeleiteter Typ deklariert eine Eigenschaft, die eine geerbte Eigenschaft mit dem gleichen Namen ausgeblendet mithilfe der `new` Modifizierer (`Shadows` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-1988">A derived type declares a property that hides an inherited property with the same name, using the `new` modifier (`Shadows` in Visual Basic).</span></span> <span data-ttu-id="2da29-1989">Um die Mehrdeutigkeit zu lösen, enthalten <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> um die Suche auf Member zu beschränken, die nicht geerbt werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-1989">To resolve the ambiguity, include <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> to restrict the search to members that are not inherited.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="2da29-1990">Indexer und Standardeigenschaften</span><span class="sxs-lookup"><span data-stu-id="2da29-1990">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="2da29-1991">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft den Standardwert für seinen Datentyp sein.</span><span class="sxs-lookup"><span data-stu-id="2da29-1991">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="2da29-1992">Beispielsweise, wenn die Variable `myList` bezieht sich auf eine <xref:System.Collections.ArrayList>, die Syntax `myList[3]` (`myList(3)` in Visual Basic) Ruft das Element mit dem Index von 3.</span><span class="sxs-lookup"><span data-stu-id="2da29-1992">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="2da29-1993">Sie können die Eigenschaft überladen.</span><span class="sxs-lookup"><span data-stu-id="2da29-1993">You can overload the property.</span></span>  
  
 <span data-ttu-id="2da29-1994">In c# ist diese Funktion einen Indexer aufgerufen wird und nicht erteilt wurde, die anhand des Namens.</span><span class="sxs-lookup"><span data-stu-id="2da29-1994">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="2da29-1995">Standardmäßig wird als eine indizierte Eigenschaft mit dem Namen "Item" ein C#-Indexers in den Metadaten angezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-1995">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="2da29-1996">Entwickeln einer Klassenbibliothek können jedoch die <xref:System.Runtime.CompilerServices.IndexerNameAttribute> Attribut zum Ändern des Namens des Indexers in den Metadaten.</span><span class="sxs-lookup"><span data-stu-id="2da29-1996">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="2da29-1997">Z. B. die <xref:System.String> -Klasse verfügt über einen Indexer mit dem Namen <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-1997">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="2da29-1998">Indizierte Eigenschaften, die mit anderen Sprachen als c# erstellt können auch die Namen als Element haben.</span><span class="sxs-lookup"><span data-stu-id="2da29-1998">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="2da29-1999">Um zu bestimmen, ob ein Typ eine Standardeigenschaft vorhanden ist, verwenden die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode zur Prüfung auf die <xref:System.Reflection.DefaultMemberAttribute> Attribut.</span><span class="sxs-lookup"><span data-stu-id="2da29-1999">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="2da29-2000">Wenn der Typ besitzt <xref:System.Reflection.DefaultMemberAttribute>die <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> Eigenschaft gibt den Namen der Standardeigenschaft zurück.</span><span class="sxs-lookup"><span data-stu-id="2da29-2000">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-2001">Das folgende Beispiel ruft den Typ einer benutzerdefinierten Klasse ab, ruft eine Eigenschaft dieser Klasse ab und zeigt den Namen der Eigenschaft in Übereinstimmung mit der angegebenen bindungseinschränkungen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2001">The following example retrieves the type of a user-defined class, retrieves a property of that class and displays the property name in accordance with the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="2da29-2002">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2002">More than one property is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-2003">
            <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2003">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-2004">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2004">The string containing the name of the public property to get.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="2da29-2005">Der Rückgabetyp der Eigenschaft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2005">The return type of the property.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-2006">Sucht die öffentliche Eigenschaft mit dem angegebenen Namen und Rückgabetyp.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2006">Searches for the public property with the specified name and return type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-2007">Ein Objekt, das die öffentliche Eigenschaft mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2007">An object representing the public property with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-2008">Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-2008">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="2da29-2009">Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2009">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="2da29-2010">Die Suche nach `name` Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="2da29-2010">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="2da29-2011">Die Suche enthält öffentliche statische und öffentlichen Instanzeigenschaften.</span><span class="sxs-lookup"><span data-stu-id="2da29-2011">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="2da29-2012">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2012">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-2013">Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="2da29-2013">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="2da29-2014">Indexer und Standardeigenschaften</span><span class="sxs-lookup"><span data-stu-id="2da29-2014">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="2da29-2015">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft den Standardwert für seinen Datentyp sein.</span><span class="sxs-lookup"><span data-stu-id="2da29-2015">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="2da29-2016">Beispielsweise, wenn die Variable `myList` bezieht sich auf eine <xref:System.Collections.ArrayList>, die Syntax `myList[3]` (`myList(3)` in Visual Basic) Ruft das Element mit dem Index von 3.</span><span class="sxs-lookup"><span data-stu-id="2da29-2016">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="2da29-2017">Sie können die Eigenschaft überladen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2017">You can overload the property.</span></span>  
  
 <span data-ttu-id="2da29-2018">In c# ist diese Funktion einen Indexer aufgerufen wird und nicht erteilt wurde, die anhand des Namens.</span><span class="sxs-lookup"><span data-stu-id="2da29-2018">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="2da29-2019">Standardmäßig wird als eine indizierte Eigenschaft mit dem Namen "Item" ein C#-Indexers in den Metadaten angezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2019">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="2da29-2020">Entwickeln einer Klassenbibliothek können jedoch die <xref:System.Runtime.CompilerServices.IndexerNameAttribute> Attribut zum Ändern des Namens des Indexers in den Metadaten.</span><span class="sxs-lookup"><span data-stu-id="2da29-2020">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="2da29-2021">Z. B. die <xref:System.String> -Klasse verfügt über einen Indexer mit dem Namen <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-2021">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="2da29-2022">Indizierte Eigenschaften, die mit anderen Sprachen als c# erstellt können auch die Namen als Element haben.</span><span class="sxs-lookup"><span data-stu-id="2da29-2022">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="2da29-2023">Um zu bestimmen, ob ein Typ eine Standardeigenschaft vorhanden ist, verwenden die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode zur Prüfung auf die <xref:System.Reflection.DefaultMemberAttribute> Attribut.</span><span class="sxs-lookup"><span data-stu-id="2da29-2023">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="2da29-2024">Wenn der Typ besitzt <xref:System.Reflection.DefaultMemberAttribute>die <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> Eigenschaft gibt den Namen der Standardeigenschaft zurück.</span><span class="sxs-lookup"><span data-stu-id="2da29-2024">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-2025">Im folgenden Beispiel definiert eine Klasse mit einer Eigenschaft, und ruft den Namen und Typ der Eigenschaft ab.</span><span class="sxs-lookup"><span data-stu-id="2da29-2025">The following example defines a class with one property and retrieves the name and type of the property.</span></span>  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="2da29-2026">Es wurden mehrere Eigenschaften mit dem angegebenen Namen gefunden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2026">More than one property is found with the specified name.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-2027">
            <paramref name="name" /> ist <see langword="null" />, oder <paramref name="returnType" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2027">
              <paramref name="name" /> is <see langword="null" />, or <paramref name="returnType" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-2028">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2028">The string containing the name of the public property to get.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="2da29-2029">Ein Array von <see cref="T:System.Type" />-Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2029">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span>
          </span>
          <span data-ttu-id="2da29-2030">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2030">-or-</span>
          </span>
          <span data-ttu-id="2da29-2031">Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2031">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-2032">Sucht die angegebene öffentliche Eigenschaft, deren Parameter den angegebenen Argumenttypen entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2032">Searches for the specified public property whose parameters match the specified argument types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-2033">Ein Objekt, das die öffentliche Eigenschaft darstellt, deren Parameter den angegebenen Argumenttypen entsprechen, sofern gefunden, andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2033">An object representing the public property whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-2034">Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-2034">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="2da29-2035">Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2035">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="2da29-2036">Die Suche nach `name` Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="2da29-2036">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="2da29-2037">Die Suche enthält öffentliche statische und öffentlichen Instanzeigenschaften.</span><span class="sxs-lookup"><span data-stu-id="2da29-2037">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="2da29-2038">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2038">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-2039">Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="2da29-2039">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="2da29-2040">Indexer und Standardeigenschaften</span><span class="sxs-lookup"><span data-stu-id="2da29-2040">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="2da29-2041">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft den Standardwert für seinen Datentyp sein.</span><span class="sxs-lookup"><span data-stu-id="2da29-2041">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="2da29-2042">Beispielsweise, wenn die Variable `myList` bezieht sich auf eine <xref:System.Collections.ArrayList>, die Syntax `myList[3]` (`myList(3)` in Visual Basic) Ruft das Element mit dem Index von 3.</span><span class="sxs-lookup"><span data-stu-id="2da29-2042">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="2da29-2043">Sie können die Eigenschaft überladen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2043">You can overload the property.</span></span>  
  
 <span data-ttu-id="2da29-2044">In c# ist diese Funktion einen Indexer aufgerufen wird und nicht erteilt wurde, die anhand des Namens.</span><span class="sxs-lookup"><span data-stu-id="2da29-2044">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="2da29-2045">Standardmäßig wird als eine indizierte Eigenschaft mit dem Namen "Item" ein C#-Indexers in den Metadaten angezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2045">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="2da29-2046">Entwickeln einer Klassenbibliothek können jedoch die <xref:System.Runtime.CompilerServices.IndexerNameAttribute> Attribut zum Ändern des Namens des Indexers in den Metadaten.</span><span class="sxs-lookup"><span data-stu-id="2da29-2046">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="2da29-2047">Z. B. die <xref:System.String> -Klasse verfügt über einen Indexer mit dem Namen <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-2047">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="2da29-2048">Indizierte Eigenschaften, die mit anderen Sprachen als c# erstellt können auch die Namen als Element haben.</span><span class="sxs-lookup"><span data-stu-id="2da29-2048">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="2da29-2049">Um zu bestimmen, ob ein Typ eine Standardeigenschaft vorhanden ist, verwenden die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode zur Prüfung auf die <xref:System.Reflection.DefaultMemberAttribute> Attribut.</span><span class="sxs-lookup"><span data-stu-id="2da29-2049">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="2da29-2050">Wenn der Typ besitzt <xref:System.Reflection.DefaultMemberAttribute>die <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> Eigenschaft gibt den Namen der Standardeigenschaft zurück.</span><span class="sxs-lookup"><span data-stu-id="2da29-2050">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-2051">Das folgende Beispiel ruft die `Type` Objekt einer benutzerdefinierten Klasse ruft die Eigenschaft dieser Klasse ab und zeigt die Eigenschaftsnamen und den Typ der Eigenschaft entsprechend den Angaben von übergebenen Argumente `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2051">The following example retrieves the `Type` object of a user-defined class, retrieves the property of that class, and displays the property name and type of the property as specified by the arguments passed to `GetProperty`.</span></span>  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="2da29-2052">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Argumenttypen entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2052">More than one property is found with the specified name and matching the specified argument types.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-2053">
            <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2053">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2da29-2054">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2054">-or-</span>
          </span>
          <span data-ttu-id="2da29-2055">
            <paramref name="types" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2055">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-2056">
            <paramref name="types" /> ist mehrdimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2056">
              <paramref name="types" /> is multidimensional.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="2da29-2057">Ein Element von <paramref name="types" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2057">An element of <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-2058">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2058">The string containing the name of the public property to get.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="2da29-2059">Der Rückgabetyp der Eigenschaft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2059">The return type of the property.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="2da29-2060">Ein Array von <see cref="T:System.Type" />-Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2060">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span>
          </span>
          <span data-ttu-id="2da29-2061">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2061">-or-</span>
          </span>
          <span data-ttu-id="2da29-2062">Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2062">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-2063">Sucht die angegebene öffentliche Eigenschaft, deren Parameter den angegebenen Argumenttypen entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2063">Searches for the specified public property whose parameters match the specified argument types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-2064">Ein Objekt, das die öffentliche Eigenschaft darstellt, deren Parameter den angegebenen Argumenttypen entsprechen, sofern gefunden, andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2064">An object representing the public property whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-2065">Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-2065">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="2da29-2066">Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2066">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="2da29-2067">Die Suche nach `name` Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="2da29-2067">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="2da29-2068">Die Suche enthält öffentliche statische und öffentlichen Instanzeigenschaften.</span><span class="sxs-lookup"><span data-stu-id="2da29-2068">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="2da29-2069">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2069">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-2070">Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="2da29-2070">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="2da29-2071">Indexer und Standardeigenschaften</span><span class="sxs-lookup"><span data-stu-id="2da29-2071">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="2da29-2072">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft den Standardwert für seinen Datentyp sein.</span><span class="sxs-lookup"><span data-stu-id="2da29-2072">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="2da29-2073">Beispielsweise, wenn die Variable `myList` bezieht sich auf eine <xref:System.Collections.ArrayList>, die Syntax `myList[3]` (`myList(3)` in Visual Basic) Ruft das Element mit dem Index von 3.</span><span class="sxs-lookup"><span data-stu-id="2da29-2073">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="2da29-2074">Sie können die Eigenschaft überladen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2074">You can overload the property.</span></span>  
  
 <span data-ttu-id="2da29-2075">In c# ist diese Funktion einen Indexer aufgerufen wird und nicht erteilt wurde, die anhand des Namens.</span><span class="sxs-lookup"><span data-stu-id="2da29-2075">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="2da29-2076">Standardmäßig wird als eine indizierte Eigenschaft mit dem Namen "Item" ein C#-Indexers in den Metadaten angezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2076">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="2da29-2077">Entwickeln einer Klassenbibliothek können jedoch die <xref:System.Runtime.CompilerServices.IndexerNameAttribute> Attribut zum Ändern des Namens des Indexers in den Metadaten.</span><span class="sxs-lookup"><span data-stu-id="2da29-2077">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="2da29-2078">Z. B. die <xref:System.String> -Klasse verfügt über einen Indexer mit dem Namen <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-2078">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="2da29-2079">Indizierte Eigenschaften, die mit anderen Sprachen als c# erstellt können auch die Namen als Element haben.</span><span class="sxs-lookup"><span data-stu-id="2da29-2079">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="2da29-2080">Um zu bestimmen, ob ein Typ eine Standardeigenschaft vorhanden ist, verwenden die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode zur Prüfung auf die <xref:System.Reflection.DefaultMemberAttribute> Attribut.</span><span class="sxs-lookup"><span data-stu-id="2da29-2080">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="2da29-2081">Wenn der Typ besitzt <xref:System.Reflection.DefaultMemberAttribute>die <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> Eigenschaft gibt den Namen der Standardeigenschaft zurück.</span><span class="sxs-lookup"><span data-stu-id="2da29-2081">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="2da29-2082">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Argumenttypen entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2082">More than one property is found with the specified name and matching the specified argument types.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-2083">
            <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2083">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2da29-2084">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2084">-or-</span>
          </span>
          <span data-ttu-id="2da29-2085">
            <paramref name="types" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2085">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-2086">
            <paramref name="types" /> ist mehrdimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2086">
              <paramref name="types" /> is multidimensional.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="2da29-2087">Ein Element von <paramref name="types" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2087">An element of <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-2088">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2088">The string containing the name of the public property to get.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="2da29-2089">Der Rückgabetyp der Eigenschaft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2089">The return type of the property.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="2da29-2090">Ein Array von <see cref="T:System.Type" />-Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2090">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span>
          </span>
          <span data-ttu-id="2da29-2091">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2091">-or-</span>
          </span>
          <span data-ttu-id="2da29-2092">Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2092">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="2da29-2093">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <c>types</c>-Array zugeordnet sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2093">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="2da29-2094">Der Standardbinder verarbeitet diesen Parameter nicht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2094">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-2095">Sucht die angegebene öffentliche Eigenschaft, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2095">Searches for the specified public property whose parameters match the specified argument types and modifiers.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-2096">Ein Objekt, das die öffentliche Eigenschaft darstellt, die den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2096">An object representing the public property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-2097">Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-2097">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="2da29-2098">Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2098">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="2da29-2099">Obwohl der Standardbinder nicht verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2099">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="2da29-2100">`ParameterModifier` wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2100">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="2da29-2101">Die Suche nach `name` Groß-/Kleinschreibung beachtet.</span><span class="sxs-lookup"><span data-stu-id="2da29-2101">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="2da29-2102">Die Suche enthält öffentliche statische und öffentlichen Instanzeigenschaften.</span><span class="sxs-lookup"><span data-stu-id="2da29-2102">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="2da29-2103">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2103">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-2104">Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="2da29-2104">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="2da29-2105">Indexer und Standardeigenschaften</span><span class="sxs-lookup"><span data-stu-id="2da29-2105">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="2da29-2106">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft den Standardwert für seinen Datentyp sein.</span><span class="sxs-lookup"><span data-stu-id="2da29-2106">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="2da29-2107">Beispielsweise, wenn die Variable `myList` bezieht sich auf eine <xref:System.Collections.ArrayList>, die Syntax `myList[3]` (`myList(3)` in Visual Basic) Ruft das Element mit dem Index von 3.</span><span class="sxs-lookup"><span data-stu-id="2da29-2107">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="2da29-2108">Sie können die Eigenschaft überladen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2108">You can overload the property.</span></span>  
  
 <span data-ttu-id="2da29-2109">In c# ist diese Funktion einen Indexer aufgerufen wird und nicht erteilt wurde, die anhand des Namens.</span><span class="sxs-lookup"><span data-stu-id="2da29-2109">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="2da29-2110">Standardmäßig wird als eine indizierte Eigenschaft mit dem Namen "Item" ein C#-Indexers in den Metadaten angezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2110">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="2da29-2111">Entwickeln einer Klassenbibliothek können jedoch die <xref:System.Runtime.CompilerServices.IndexerNameAttribute> Attribut zum Ändern des Namens des Indexers in den Metadaten.</span><span class="sxs-lookup"><span data-stu-id="2da29-2111">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="2da29-2112">Z. B. die <xref:System.String> -Klasse verfügt über einen Indexer mit dem Namen <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-2112">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="2da29-2113">Indizierte Eigenschaften, die mit anderen Sprachen als c# erstellt können auch die Namen als Element haben.</span><span class="sxs-lookup"><span data-stu-id="2da29-2113">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="2da29-2114">Um zu bestimmen, ob ein Typ eine Standardeigenschaft vorhanden ist, verwenden die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode zur Prüfung auf die <xref:System.Reflection.DefaultMemberAttribute> Attribut.</span><span class="sxs-lookup"><span data-stu-id="2da29-2114">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="2da29-2115">Wenn der Typ besitzt <xref:System.Reflection.DefaultMemberAttribute>die <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> Eigenschaft gibt den Namen der Standardeigenschaft zurück.</span><span class="sxs-lookup"><span data-stu-id="2da29-2115">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-2116">Im folgenden Beispiel wird eine `Type` -Objekt entsprechende `MyPropertyClass`, und indizierte Eigenschaft dieser Klasse abgerufen wird, verwenden die Argumente an die `GetProperty` Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-2116">The following example obtains a `Type` object corresponding to `MyPropertyClass`, and the indexed property of this class is retrieved using the arguments passed to the `GetProperty` method.</span></span>  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="2da29-2117">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Argumenttypen sowie Modifizierern entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2117">More than one property is found with the specified name and matching the specified argument types and modifiers.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-2118">
            <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2118">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2da29-2119">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2119">-or-</span>
          </span>
          <span data-ttu-id="2da29-2120">
            <paramref name="types" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2120">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-2121">
            <paramref name="types" /> ist mehrdimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2121">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="2da29-2122">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2122">-or-</span>
          </span>
          <span data-ttu-id="2da29-2123">
            <paramref name="modifiers" /> ist mehrdimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2123">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="2da29-2124">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2124">-or-</span>
          </span>
          <span data-ttu-id="2da29-2125">
            <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2125">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="2da29-2126">Ein Element von <paramref name="types" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2126">An element of <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-2127">Die Zeichenfolge, die den Namen der abzurufenden Eigenschaft enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2127">The string containing the name of the property to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="2da29-2128">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2128">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="2da29-2129">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2129">-or-</span>
          </span>
          <span data-ttu-id="2da29-2130">0 (null), damit <see langword="null" /> zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2130">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="2da29-2131">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2131">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="2da29-2132">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2132">-or-</span>
          </span>
          <span data-ttu-id="2da29-2133">Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2133">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="2da29-2134">Der Rückgabetyp der Eigenschaft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2134">The return type of the property.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="2da29-2135">Ein Array von <see cref="T:System.Type" />-Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2135">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span>
          </span>
          <span data-ttu-id="2da29-2136">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2136">-or-</span>
          </span>
          <span data-ttu-id="2da29-2137">Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2137">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="2da29-2138">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <c>types</c>-Array zugeordnet sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2138">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="2da29-2139">Der Standardbinder verarbeitet diesen Parameter nicht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2139">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-2140">Sucht anhand der angegebenen Bindungseinschränkungen nach der angegebenen Eigenschaft, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2140">Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-2141">Ein Objekt, das die Eigenschaft darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2141">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-2142">Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-2142">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="2da29-2143">Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, kombinieren Sie die Werte mit `Or`) zum Abrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2143">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="2da29-2144">Obwohl der Standardbinder nicht verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2144">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="2da29-2145">`ParameterModifier` wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2145">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="2da29-2146">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-2146">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="2da29-2147">Memberart</span><span class="sxs-lookup"><span data-stu-id="2da29-2147">Member Type</span></span>|<span data-ttu-id="2da29-2148">Statisch</span><span class="sxs-lookup"><span data-stu-id="2da29-2148">Static</span></span>|<span data-ttu-id="2da29-2149">Nicht statische</span><span class="sxs-lookup"><span data-stu-id="2da29-2149">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="2da29-2150">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="2da29-2150">Constructor</span></span>|<span data-ttu-id="2da29-2151">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-2151">No</span></span>|<span data-ttu-id="2da29-2152">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-2152">No</span></span>|  
|<span data-ttu-id="2da29-2153">Feld</span><span class="sxs-lookup"><span data-stu-id="2da29-2153">Field</span></span>|<span data-ttu-id="2da29-2154">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-2154">No</span></span>|<span data-ttu-id="2da29-2155">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-2155">Yes.</span></span> <span data-ttu-id="2da29-2156">Ein Feld ist immer nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2156">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-2157">event</span><span class="sxs-lookup"><span data-stu-id="2da29-2157">Event</span></span>|<span data-ttu-id="2da29-2158">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-2158">Not applicable</span></span>|<span data-ttu-id="2da29-2159">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-2159">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-2160">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2160">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-2161">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-2161">See note 2 below.</span></span>|  
|<span data-ttu-id="2da29-2162">Methode</span><span class="sxs-lookup"><span data-stu-id="2da29-2162">Method</span></span>|<span data-ttu-id="2da29-2163">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-2163">No</span></span>|<span data-ttu-id="2da29-2164">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-2164">Yes.</span></span> <span data-ttu-id="2da29-2165">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2165">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-2166">Geschachtelten Typs</span><span class="sxs-lookup"><span data-stu-id="2da29-2166">Nested Type</span></span>|<span data-ttu-id="2da29-2167">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-2167">No</span></span>|<span data-ttu-id="2da29-2168">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-2168">No</span></span>|  
|<span data-ttu-id="2da29-2169">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="2da29-2169">Property</span></span>|<span data-ttu-id="2da29-2170">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-2170">Not applicable</span></span>|<span data-ttu-id="2da29-2171">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-2171">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-2172">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2172">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-2173">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-2173">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="2da29-2174">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-2174">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="2da29-2175">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="2da29-2175">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="2da29-2176">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2176">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-2177">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2177">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="2da29-2178">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="2da29-2178">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="2da29-2179">Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Eigenschaften in die Suche einbezogen werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-2179">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="2da29-2180">Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-2180">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="2da29-2181">Geben Sie `BindingFlags.Public` auf öffentliche Eigenschaften in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2181">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="2da29-2182">Geben Sie `BindingFlags.NonPublic` an nicht öffentlichen Eigenschaften (d. h. private, interne und geschützte) in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2182">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="2da29-2183">Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2183">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="2da29-2184">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</span><span class="sxs-lookup"><span data-stu-id="2da29-2184">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="2da29-2185">`BindingFlags.IgnoreCase` um die Groß-/Kleinschreibung ignorieren `name`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2185">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="2da29-2186">`BindingFlags.DeclaredOnly` Suche nur die deklarierten Eigenschaften der <xref:System.Type>, nicht die Eigenschaften, die nur geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2186">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="2da29-2187">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-2187">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="2da29-2188">Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2188">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="2da29-2189">Wenn die aktuelle <xref:System.Type> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.</span><span class="sxs-lookup"><span data-stu-id="2da29-2189">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="2da29-2190">Indexer und Standardeigenschaften</span><span class="sxs-lookup"><span data-stu-id="2da29-2190">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="2da29-2191">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft den Standardwert für seinen Datentyp sein.</span><span class="sxs-lookup"><span data-stu-id="2da29-2191">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="2da29-2192">Beispielsweise, wenn die Variable `myList` bezieht sich auf eine <xref:System.Collections.ArrayList>, die Syntax `myList[3]` (`myList(3)` in Visual Basic) Ruft das Element mit dem Index von 3.</span><span class="sxs-lookup"><span data-stu-id="2da29-2192">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="2da29-2193">Sie können die Eigenschaft überladen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2193">You can overload the property.</span></span>  
  
 <span data-ttu-id="2da29-2194">In c# ist diese Funktion einen Indexer aufgerufen wird und nicht erteilt wurde, die anhand des Namens.</span><span class="sxs-lookup"><span data-stu-id="2da29-2194">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="2da29-2195">Standardmäßig wird als eine indizierte Eigenschaft mit dem Namen "Item" ein C#-Indexers in den Metadaten angezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2195">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="2da29-2196">Entwickeln einer Klassenbibliothek können jedoch die <xref:System.Runtime.CompilerServices.IndexerNameAttribute> Attribut zum Ändern des Namens des Indexers in den Metadaten.</span><span class="sxs-lookup"><span data-stu-id="2da29-2196">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="2da29-2197">Z. B. die <xref:System.String> -Klasse verfügt über einen Indexer mit dem Namen <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-2197">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="2da29-2198">Indizierte Eigenschaften, die mit anderen Sprachen als c# erstellt können auch die Namen als Element haben.</span><span class="sxs-lookup"><span data-stu-id="2da29-2198">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="2da29-2199">Um zu bestimmen, ob ein Typ eine Standardeigenschaft vorhanden ist, verwenden die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> -Methode zur Prüfung auf die <xref:System.Reflection.DefaultMemberAttribute> Attribut.</span><span class="sxs-lookup"><span data-stu-id="2da29-2199">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="2da29-2200">Wenn der Typ besitzt <xref:System.Reflection.DefaultMemberAttribute>die <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> Eigenschaft gibt den Namen der Standardeigenschaft zurück.</span><span class="sxs-lookup"><span data-stu-id="2da29-2200">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="2da29-2201">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2201">More than one property is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-2202">
            <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2202">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2da29-2203">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2203">-or-</span>
          </span>
          <span data-ttu-id="2da29-2204">
            <paramref name="types" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2204">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-2205">
            <paramref name="types" /> ist mehrdimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2205">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="2da29-2206">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2206">-or-</span>
          </span>
          <span data-ttu-id="2da29-2207">
            <paramref name="modifiers" /> ist mehrdimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2207">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="2da29-2208">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2208">-or-</span>
          </span>
          <span data-ttu-id="2da29-2209">
            <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2209">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="2da29-2210">Ein Element von <paramref name="types" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2210">An element of <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-2211">Die Zeichenfolge, die den Namen der abzurufenden Eigenschaft enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2211">The string containing the name of the property to get.</span>
          </span>
        </param>
        <param name="bindingAttr">
          <span data-ttu-id="2da29-2212">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2212">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="2da29-2213">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2213">-or-</span>
          </span>
          <span data-ttu-id="2da29-2214">0 (null), damit <see langword="null" /> zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2214">Zero, to return <see langword="null" />.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="2da29-2215">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl eines überladenen Members, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2215">An object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="2da29-2216">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2216">-or-</span>
          </span>
          <span data-ttu-id="2da29-2217">Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2217">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="2da29-2218">Der Rückgabetyp der Eigenschaft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2218">The return type of the property.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="2da29-2219">Ein Array von <see cref="T:System.Type" />-Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2219">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span>
          </span>
          <span data-ttu-id="2da29-2220">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2220">-or-</span>
          </span>
          <span data-ttu-id="2da29-2221">Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2221">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="2da29-2222">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <c>types</c>-Array zugeordnet sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2222">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>types</c> array.</span>
          </span>
          <span data-ttu-id="2da29-2223">Der Standardbinder verarbeitet diesen Parameter nicht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2223">The default binder does not process this parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-2224">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen nach der angegebenen Eigenschaft, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2224">When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-2225">Ein Objekt, das die Eigenschaft darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2225">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-2226">Obwohl der Standardbinder nicht verarbeitet <xref:System.Reflection.ParameterModifier> (die `modifiers` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2226">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="2da29-2227">`ParameterModifier` wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2227">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="2da29-2228">Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Eigenschaften in die Suche einbezogen werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-2228">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="2da29-2229">Geben Sie `BindingFlags.Instance` oder `BindingFlags.Static` ändern, um einen Rückgabewert zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-2229">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="2da29-2230">Geben Sie `BindingFlags.Public` auf öffentliche Eigenschaften in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2230">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="2da29-2231">Geben Sie `BindingFlags.NonPublic` an nicht öffentlichen Eigenschaften (d. h. private, interne und geschützte) in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2231">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="2da29-2232">Geben Sie `BindingFlags.FlattenHierarchy` einschließen `public` und `protected` statische Member der Hierarchie; nach oben `private` statische Member in geerbten Klassen sind nicht eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2232">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="2da29-2233">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</span><span class="sxs-lookup"><span data-stu-id="2da29-2233">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="2da29-2234">`BindingFlags.IgnoreCase` um die Groß-/Kleinschreibung ignorieren `name`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2234">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="2da29-2235">`BindingFlags.DeclaredOnly` Suche nur die deklarierten Eigenschaften der <xref:System.Type>, nicht die Eigenschaften, die nur geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2235">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="2da29-2236">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-2236">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="2da29-2237">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2237">More than one property is found with the specified name and matching the specified binding constraints.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-2238">
            <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2238">
              <paramref name="name" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2da29-2239">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2239">-or-</span>
          </span>
          <span data-ttu-id="2da29-2240">
            <paramref name="types" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2240">
              <paramref name="types" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2da29-2241">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2241">-or-</span>
          </span>
          <span data-ttu-id="2da29-2242">Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2242">One of the elements in <paramref name="types" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-2243">
            <paramref name="types" /> ist mehrdimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2243">
              <paramref name="types" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="2da29-2244">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2244">-or-</span>
          </span>
          <span data-ttu-id="2da29-2245">
            <paramref name="modifiers" /> ist mehrdimensional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2245">
              <paramref name="modifiers" /> is multidimensional.</span>
          </span>
          <span data-ttu-id="2da29-2246">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2246">-or-</span>
          </span>
          <span data-ttu-id="2da29-2247">
            <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2247">
              <paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2da29-2248">Der aktuelle Typ ist ein <see cref="T:System.Reflection.Emit.TypeBuilder" />, ein <see cref="T:System.Reflection.Emit.EnumBuilder" /> oder ein <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2248">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" />, or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-2249">Ruft ein <see cref="T:System.Type" />-Objekt ab, das den angegebenen Typ darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2249">Gets a <see cref="T:System.Type" /> object that represents the specified type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-2250">Ruft den aktuellen <see cref="T:System.Type" /> ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2250">Gets the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-2251">Der aktuelle <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2251">The current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="2da29-2252">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2252">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="2da29-2253">Der durch die Assembly bezeichnete Name des abzurufenden Typs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2253">The assembly-qualified name of the type to get.</span>
          </span>
          <span data-ttu-id="2da29-2254">Siehe <see cref="P:System.Type.AssemblyQualifiedName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2254">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span>
          </span>
          <span data-ttu-id="2da29-2255">Wenn sich der Typ in der aktuell ausgeführten Assembly oder in Mscorlib.dll befindet, ist eine Angabe des Typnamens einschließlich des qualifizierenden Namespace ausreichend.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2255">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-2256">Ruft den <see cref="T:System.Type" /> mit dem angegebenen Namen ab. Bei der Suche wird die Groß-/Kleinschreibung beachtet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2256">Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-2257">Der Typ mit dem angegebenen Namen, sofern gefunden, andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2257">The type with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-2258">Können Sie die <xref:System.Type.GetType%2A> Methode zum Abrufen einer <xref:System.Type> -Objekt für einen Typ in einer anderen Assembly, wenn Sie wissen, dass die Namespace-qualifizierten Namen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2258">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if you know its namespace-qualified name.</span></span> <span data-ttu-id="2da29-2259"><xref:System.Type.GetType%2A> führt zum Laden der Assembly im angegebenen `typeName`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2259"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="2da29-2260">Sie können auch laden eine Assembly mit der <xref:System.Reflection.Assembly.Load%2A> -Methode, und verwenden Sie dann die <xref:System.Type.GetType%2A> oder <xref:System.Reflection.Assembly.GetTypes%2A> Methoden die <xref:System.Reflection.Assembly> Klasse abgerufen <xref:System.Type> Objekte.</span><span class="sxs-lookup"><span data-stu-id="2da29-2260">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects.</span></span> <span data-ttu-id="2da29-2261">Wenn ein Typ in einer Assembly, die für Ihr Programm zur Kompilierzeit bekannt ist, ist es effizienter, in c# verwenden <xref:System.Type.GetType%2A> in Visual Basic oder c++.</span><span class="sxs-lookup"><span data-stu-id="2da29-2261">If a type is in an assembly known to your program at compile time, it is more efficient to use  in C#, <xref:System.Type.GetType%2A> in Visual Basic, or  in C++.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-2262">Wenn `typeName` kann nicht gefunden werden, den Aufruf der <xref:System.Type.GetType%28System.String%29> -Methode zurückkehrt `null`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2262">If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%29> method returns `null`.</span></span> <span data-ttu-id="2da29-2263">Es wird keine Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="2da29-2263">It does not throw an exception.</span></span> <span data-ttu-id="2da29-2264">Um zu steuern, ob eine Ausnahme ausgelöst, rufen Sie eine Überladung der <xref:System.Type.GetType%2A> Methode, die eine `throwOnError` Parameter.</span><span class="sxs-lookup"><span data-stu-id="2da29-2264">To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.</span></span>  
  
 <span data-ttu-id="2da29-2265"><xref:System.Type.GetType%2A> funktioniert nur für Assemblys, die von der Festplatte geladen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2265"><xref:System.Type.GetType%2A> only works on assemblies loaded from disk.</span></span> <span data-ttu-id="2da29-2266">Beim Aufrufen <xref:System.Type.GetType%2A> zum Nachschlagen eines Typs in eine dynamische Assembly mit definiert, definiert der <xref:System.Reflection.Emit> Services, erhalten Sie möglicherweise inkonsistentes Verhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-2266">If you call <xref:System.Type.GetType%2A> to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="2da29-2267">Das Verhalten abhängig, ob die dynamische Assembly persistent, d. h., erstellt, mit der `RunAndSave` oder `Save` Zugriff auf die Modi für die <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="2da29-2267">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="2da29-2268">Wenn die dynamische Assembly persistent ist und bevor Sie den Datenträger geschrieben wurden `GetType` wird aufgerufen, das Ladeprogramm für die gespeicherte Assembly sucht, auf dem Datenträger, lädt die Assembly und ruft den Typ aus dieser Assembly ab.</span><span class="sxs-lookup"><span data-stu-id="2da29-2268">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="2da29-2269">Wenn die Assembly nicht gespeichert wurde, wenn auf den Datenträger `GetType` aufgerufen wird, wird der Methodenrückgabe `null`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2269">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="2da29-2270">`GetType` flüchtige dynamische Assemblys versteht nicht; aus diesem Grund Aufrufen `GetType` zum Abrufen eines Typs in eine flüchtige dynamische Assembly gibt `null`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2270">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="2da29-2271">Mit `GetType` für ein dynamisches Modul Abonnieren der <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> Ereignis, und rufen `GetType` vor dem Speichern.</span><span class="sxs-lookup"><span data-stu-id="2da29-2271">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="2da29-2272">Andernfalls erhalten Sie zwei Kopien der Assembly im Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="2da29-2272">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="2da29-2273">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-2273">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="2da29-2274">Memberart</span><span class="sxs-lookup"><span data-stu-id="2da29-2274">Member Type</span></span>|<span data-ttu-id="2da29-2275">Statisch</span><span class="sxs-lookup"><span data-stu-id="2da29-2275">Static</span></span>|<span data-ttu-id="2da29-2276">Nicht statische</span><span class="sxs-lookup"><span data-stu-id="2da29-2276">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="2da29-2277">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="2da29-2277">Constructor</span></span>|<span data-ttu-id="2da29-2278">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-2278">No</span></span>|<span data-ttu-id="2da29-2279">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-2279">No</span></span>|  
|<span data-ttu-id="2da29-2280">Feld</span><span class="sxs-lookup"><span data-stu-id="2da29-2280">Field</span></span>|<span data-ttu-id="2da29-2281">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-2281">No</span></span>|<span data-ttu-id="2da29-2282">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-2282">Yes.</span></span> <span data-ttu-id="2da29-2283">Ein Feld ist immer nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2283">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-2284">event</span><span class="sxs-lookup"><span data-stu-id="2da29-2284">Event</span></span>|<span data-ttu-id="2da29-2285">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-2285">Not applicable</span></span>|<span data-ttu-id="2da29-2286">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-2286">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-2287">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2287">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-2288">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-2288">See note 2 below.</span></span>|  
|<span data-ttu-id="2da29-2289">Methode</span><span class="sxs-lookup"><span data-stu-id="2da29-2289">Method</span></span>|<span data-ttu-id="2da29-2290">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-2290">No</span></span>|<span data-ttu-id="2da29-2291">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-2291">Yes.</span></span> <span data-ttu-id="2da29-2292">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2292">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-2293">Geschachtelten Typs</span><span class="sxs-lookup"><span data-stu-id="2da29-2293">Nested Type</span></span>|<span data-ttu-id="2da29-2294">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-2294">No</span></span>|<span data-ttu-id="2da29-2295">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-2295">No</span></span>|  
|<span data-ttu-id="2da29-2296">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="2da29-2296">Property</span></span>|<span data-ttu-id="2da29-2297">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-2297">Not applicable</span></span>|<span data-ttu-id="2da29-2298">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-2298">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-2299">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2299">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-2300">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-2300">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="2da29-2301">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-2301">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="2da29-2302">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="2da29-2302">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="2da29-2303">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2303">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-2304">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2304">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="2da29-2305">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="2da29-2305">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="2da29-2306">Arrays oder COM-Typen werden nicht für durchsucht, es sei denn, sie bereits in der Tabelle der verfügbaren Klassen geladen wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2306">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="2da29-2307">`typeName` Der Typname kann durch den Namespace oder ein Assembly qualifizierter Name, der eine Assembly namensspezifikation enthält qualifiziert werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2307">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="2da29-2308">Siehe <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-2308">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="2da29-2309">Wenn `typeName` des Namespace, jedoch nicht den Assemblynamen eingeben, enthält diese Methode sucht nur die Assembly des aufrufenden Objekts und die Datei "mscorlib.dll", in dieser Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="2da29-2309">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="2da29-2310">Wenn TypeName vollqualifizierten mit dem Assemblynamen teilweise oder vollständig ist, sucht diese Methode in der angegebenen Assembly.</span><span class="sxs-lookup"><span data-stu-id="2da29-2310">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="2da29-2311">Wenn die Assembly einen starken Namen besitzt, ist ein vollständige Assemblyname erforderlich.</span><span class="sxs-lookup"><span data-stu-id="2da29-2311">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="2da29-2312">Die <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaft gibt einen vollqualifizierten Typnamen einschließlich geschachtelter Typen, Assemblyname und generische Typargumente.</span><span class="sxs-lookup"><span data-stu-id="2da29-2312">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic type arguments.</span></span> <span data-ttu-id="2da29-2313">Alle Compiler, die die common Language Runtime unterstützen, den einfachen Namen einer geschachtelten Klasse geben, und Reflektion erstellt einen ergänzten Namen bei einer Abfrage in Übereinstimmung mit den folgenden Konventionen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2313">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-2314">In .NET Framework, Version 2.0 Prozessorarchitektur Assemblyidentität hinzugefügt und kann als Teil der Assembly-Zeichenfolgen angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2314">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="2da29-2315">Z. B. "ProcessorArchitecture = Msil".</span><span class="sxs-lookup"><span data-stu-id="2da29-2315">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="2da29-2316">Ist jedoch nicht in die zurückgegebene Zeichenfolge enthalten die <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaft, aus Gründen der Kompatibilität.</span><span class="sxs-lookup"><span data-stu-id="2da29-2316">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="2da29-2317">Sie können Typen auch laden, indem Sie erstellen eine <xref:System.Reflection.AssemblyName> -Objekt und übergibt dieses an eine entsprechende Überladung der der <xref:System.Reflection.Assembly.Load%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-2317">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="2da29-2318">Anschließend können Sie die <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> -Methode zum Laden von Typen aus der Assembly.</span><span class="sxs-lookup"><span data-stu-id="2da29-2318">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="2da29-2319">Siehe auch <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-2319">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="2da29-2320">Trennzeichen</span><span class="sxs-lookup"><span data-stu-id="2da29-2320">Delimiter</span></span>|<span data-ttu-id="2da29-2321">Bedeutung</span><span class="sxs-lookup"><span data-stu-id="2da29-2321">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="2da29-2322">Umgekehrter Schrägstrich (\\)</span><span class="sxs-lookup"><span data-stu-id="2da29-2322">Backslash (\\)</span></span>|<span data-ttu-id="2da29-2323">Escape-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2323">Escape character.</span></span>|  
|<span data-ttu-id="2da29-2324">Umgekehrtes Apostroph (')</span><span class="sxs-lookup"><span data-stu-id="2da29-2324">Backtick (\`)</span></span>|<span data-ttu-id="2da29-2325">Steht vor eine oder mehrere Ziffern, die die Anzahl von Typparametern, am Ende des Namens eines generischen Typs darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2325">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="2da29-2326">Klammern ([])</span><span class="sxs-lookup"><span data-stu-id="2da29-2326">Brackets ([])</span></span>|<span data-ttu-id="2da29-2327">Schließen Sie eine generische Liste der Typargumente, für einen konstruierten generischen Typ; Schließen Sie in einer Liste der Typargumente eine Assembly qualifizierten Typnamen an.</span><span class="sxs-lookup"><span data-stu-id="2da29-2327">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="2da29-2328">Komma (,)</span><span class="sxs-lookup"><span data-stu-id="2da29-2328">Comma (,)</span></span>|<span data-ttu-id="2da29-2329">Ist der Name der Assembly vorangestellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2329">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="2da29-2330">Punkt (.)</span><span class="sxs-lookup"><span data-stu-id="2da29-2330">Period (.)</span></span>|<span data-ttu-id="2da29-2331">Gibt die Namespacebezeichner.</span><span class="sxs-lookup"><span data-stu-id="2da29-2331">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="2da29-2332">Pluszeichen (+)</span><span class="sxs-lookup"><span data-stu-id="2da29-2332">Plus sign (+)</span></span>|<span data-ttu-id="2da29-2333">Ist eine geschachtelte Klasse vorangestellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2333">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="2da29-2334">Beispielsweise kann der vollqualifizierte Name für eine Klasse wie folgt aussehen:</span><span class="sxs-lookup"><span data-stu-id="2da29-2334">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="2da29-2335">Wenn der Namespace wurden TopNamespace.Sub, würde die Zeichenfolge auf das Pluszeichen (+) ein Escapezeichen vorangestellt haben (\\) zu verhindern, dass er als schachteln Trennzeichen interpretiert wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-2335">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="2da29-2336">Reflektion wird diese Zeichenfolge wie folgt aus:</span><span class="sxs-lookup"><span data-stu-id="2da29-2336">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="2da29-2337">Ein "++" wird "\\+\\+", und ein "\\"wird"\\\\".</span><span class="sxs-lookup"><span data-stu-id="2da29-2337">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="2da29-2338">Dieser qualifizierte Name kann beibehalten und später zum Laden der <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="2da29-2338">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="2da29-2339">Suchen und Laden einer <xref:System.Type>, verwenden Sie <xref:System.Type.GetType%2A> entweder mit dem Typ oder einen Namen geben nur mit der Assembly qualifizierten Typnamen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2339">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="2da29-2340"><xref:System.Type.GetType%2A> mit dem Namen nur sieht für den <xref:System.Type> in der Assembly des Aufrufers, und klicken Sie dann in der System-Assembly.</span><span class="sxs-lookup"><span data-stu-id="2da29-2340"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="2da29-2341"><xref:System.Type.GetType%2A> mit der Assembly qualifizierten Typnamen für sieht die <xref:System.Type> in jeder beliebigen Assembly.</span><span class="sxs-lookup"><span data-stu-id="2da29-2341"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="2da29-2342">Geben Sie die Namen eventuell nachfolgende Zeichen, die zusätzliche über den Typ Informationen, z. B., ob der Typ ein Verweistyp, ein Zeigertyp oder ein Arraytyp ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-2342">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="2da29-2343">Verwenden Sie zum Abrufen der Typname ohne diese nachfolgenden Zeichen `t.GetElementType().ToString()`, wobei `t` ist der Typ.</span><span class="sxs-lookup"><span data-stu-id="2da29-2343">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="2da29-2344">Leerzeichen sind in allen Komponenten von Typnamen mit Ausnahme der Assemblyname relevant.</span><span class="sxs-lookup"><span data-stu-id="2da29-2344">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="2da29-2345">In der Assemblyname Leerzeichen vor dem Trennzeichen "," relevant sind, aber nach dem Trennzeichen "," Leerzeichen werden ignoriert.</span><span class="sxs-lookup"><span data-stu-id="2da29-2345">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="2da29-2346">Der Name eines generischen Typs endet mit der ein umgekehrtes Apostroph (\`) gefolgt von Ziffern, die die Anzahl der Argumente des generischen Typs darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2346">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="2da29-2347">Dieser Name-mangling dient zum Zulassen von Compilern zur Unterstützung von generischer Typen mit dem gleichen Namen, aber mit einer unterschiedlichen Anzahl von Typparametern, im selben Gültigkeitsbereich auftritt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2347">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="2da29-2348">Reflektion gibt z. B. die ergänzten Namen `Tuple`1` and `Tupel`2` aus den generischen Methoden `Tuple(Of T)` und `Tuple(Of T0, T1)` in Visual Basic oder `Tuple<T>` und Tupel`\<T0, T1>` in Visual c#.</span><span class="sxs-lookup"><span data-stu-id="2da29-2348">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="2da29-2349">Bei generischen Typen wird die Typargumentliste in Klammern gesetzt, und die Typargumente werden durch Kommas getrennt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2349">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="2da29-2350">Angenommen, eine generische <xref:System.Collections.Generic.Dictionary%602> verfügt über zwei Typparameter.</span><span class="sxs-lookup"><span data-stu-id="2da29-2350">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="2da29-2351">Ein <xref:System.Collections.Generic.Dictionary%602> von `MyType` mit Schlüsseln des Typs <xref:System.String> kann wie folgt dargestellt werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-2351">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="2da29-2352">Um eine Assembly qualifizierten Typnamen in einer Liste der Typargumente angeben, schließen Sie die Assembly qualifizierten Typnamen in Klammern ein.</span><span class="sxs-lookup"><span data-stu-id="2da29-2352">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="2da29-2353">Andernfalls werden die Kommas, die trennen die Bestandteile der Assembly qualifizierte Name, als Trennzeichen für weitere Typargumente interpretiert.</span><span class="sxs-lookup"><span data-stu-id="2da29-2353">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="2da29-2354">Z. B. eine <xref:System.Collections.Generic.Dictionary%602> von `MyType` fromMyAssembly.dll, mit Schlüsseln des Typs <xref:System.String>, kann wie folgt angegeben werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-2354">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` fromMyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="2da29-2355">Eine Assembly qualifizierten Typnamen kann in Klammern eingeschlossen werden, nur, wenn es in einer Typparameterliste angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-2355">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="2da29-2356">Die Regeln für das Suchen von Assemblys für qualifizierten und nicht qualifizierten Typen in Typparameterlisten sind identisch mit den Regeln für qualifizierte und nicht qualifizierte nicht generische Typen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2356">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="2da29-2357">Auf NULL festlegbare Typen sind ein besonderer Fall von generischen Typen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2357">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="2da29-2358">Angenommen, ein NULL-Werte zulassen <xref:System.Int32> wird durch die Zeichenfolge "System.Nullable'1[System.Int32]" dargestellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2358">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-2359">In c#, C++ und Visual Basic können Sie auch auf NULL festlegbaren Typen, die mithilfe von Operatoren abrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2359">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="2da29-2360">Angenommen, die NULL-Werte zulässt <xref:System.Boolean> zurückgegebene Typ `typeof(Nullable<bool>)` in c# durch `Nullable<Boolean>::typeid` in C++ und in `GetType(Nullable(Of Boolean))` in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="2da29-2360">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="2da29-2361">Die folgende Tabelle zeigt die Syntax, die Sie mit `GetType` für verschiedene Typen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2361">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="2da29-2362">Zum Abrufen</span><span class="sxs-lookup"><span data-stu-id="2da29-2362">To Get</span></span>|<span data-ttu-id="2da29-2363">Mit</span><span class="sxs-lookup"><span data-stu-id="2da29-2363">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="2da29-2364">Ein NULL-Werte zulässt <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="2da29-2364">A nullable <xref:System.Int32></span></span>|<span data-ttu-id="2da29-2365">`Type.GetType("System.Nullable`1[System.Int32]")\`</span><span class="sxs-lookup"><span data-stu-id="2da29-2365">`Type.GetType("System.Nullable`1[System.Int32]")\`</span></span>|  
|<span data-ttu-id="2da29-2366">Ein nicht verwalteter Zeiger auf `MyType`</span><span class="sxs-lookup"><span data-stu-id="2da29-2366">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="2da29-2367">Ein nicht verwalteter Zeiger auf einen Zeiger auf `MyType`</span><span class="sxs-lookup"><span data-stu-id="2da29-2367">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="2da29-2368">Ein verwalteter Zeiger oder Verweis auf `MyType`</span><span class="sxs-lookup"><span data-stu-id="2da29-2368">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="2da29-2369">`Type.GetType("MyType&")`</span><span class="sxs-lookup"><span data-stu-id="2da29-2369">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="2da29-2370">Beachten Sie, dass Verweise im Gegensatz zu Zeigern auf eine Ebene beschränkt sind.</span><span class="sxs-lookup"><span data-stu-id="2da29-2370">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="2da29-2371">Eine übergeordnete Klasse und eine geschachtelte Klasse</span><span class="sxs-lookup"><span data-stu-id="2da29-2371">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="2da29-2372">Ein eindimensionales Array mit einer unteren Grenze von 0</span><span class="sxs-lookup"><span data-stu-id="2da29-2372">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyType[]")`|  
|<span data-ttu-id="2da29-2373">Ein eindimensionales Array mit einer unbekannten Untergrenze</span><span class="sxs-lookup"><span data-stu-id="2da29-2373">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyType[*]")`|  
|<span data-ttu-id="2da29-2374">Ein n-dimensionalen array</span><span class="sxs-lookup"><span data-stu-id="2da29-2374">An n-dimensional array</span></span>|<span data-ttu-id="2da29-2375">Ein Komma (,) innerhalb der Klammern eine insgesamt n-1 Mal.</span><span class="sxs-lookup"><span data-stu-id="2da29-2375">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="2da29-2376">Beispielsweise `System.Object[,,]` stellt eine dreidimensionale `Object` Array.</span><span class="sxs-lookup"><span data-stu-id="2da29-2376">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="2da29-2377">Ein Array von eindimensionale arrays</span><span class="sxs-lookup"><span data-stu-id="2da29-2377">An array of one-dimensional arrays</span></span>|`Type.GetType("MyType[][]")`|  
|<span data-ttu-id="2da29-2378">Kein rechteckiges zweidimensionales Array mit unbekannten Untergrenzen</span><span class="sxs-lookup"><span data-stu-id="2da29-2378">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyType[,]")`|  
|<span data-ttu-id="2da29-2379">Ein generischer Typ mit einem Typargument</span><span class="sxs-lookup"><span data-stu-id="2da29-2379">A generic type with one type argument</span></span>|<span data-ttu-id="2da29-2380">`Type.GetType("MyGenericType`1[MyType]")\`</span><span class="sxs-lookup"><span data-stu-id="2da29-2380">`Type.GetType("MyGenericType`1[MyType]")\`</span></span>|  
|<span data-ttu-id="2da29-2381">Ein generischer Typ mit zwei Typargumenten</span><span class="sxs-lookup"><span data-stu-id="2da29-2381">A generic type with two type arguments</span></span>|<span data-ttu-id="2da29-2382">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span><span class="sxs-lookup"><span data-stu-id="2da29-2382">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span></span>|  
|<span data-ttu-id="2da29-2383">Ein generischer Typ mit zwei durch die Assembly qualifizierten Typargumenten</span><span class="sxs-lookup"><span data-stu-id="2da29-2383">A generic type with two assembly-qualified type arguments</span></span>|<span data-ttu-id="2da29-2384">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")"</span><span class="sxs-lookup"><span data-stu-id="2da29-2384">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")\`</span></span>|  
|<span data-ttu-id="2da29-2385">Ein assemblyqualifizierten generischer Typ mit einem Assembly qualifizierten Typnamen-argument</span><span class="sxs-lookup"><span data-stu-id="2da29-2385">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|<span data-ttu-id="2da29-2386">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")"</span><span class="sxs-lookup"><span data-stu-id="2da29-2386">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")\`</span></span>|  
|<span data-ttu-id="2da29-2387">Ein generischer Typ, dessen Type-Argument ein generischer Typ mit zwei Typargumenten ist</span><span class="sxs-lookup"><span data-stu-id="2da29-2387">A generic type whose type argument is a generic type with two type arguments</span></span>|<span data-ttu-id="2da29-2388">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span><span class="sxs-lookup"><span data-stu-id="2da29-2388">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="2da29-2389">Das folgende Beispiel ruft den Typ des `System.Int32` und verwendet diese Typobjekt zum Anzeigen der <xref:System.Type.FullName%2A> Eigenschaft `System.Int32`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2389">The following example retrieves the type of `System.Int32` and uses that type object to display the <xref:System.Type.FullName%2A> property of `System.Int32`.</span></span>  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-2390">
            <paramref name="typeName" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2390">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="2da29-2391">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2391">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-2392">
            <paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2392">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="2da29-2393">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2393">-or-</span>
          </span>
          <span data-ttu-id="2da29-2394">
            <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2394">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="2da29-2395">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2395">-or-</span>
          </span>
          <span data-ttu-id="2da29-2396">
            <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2396">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="2da29-2397">
            <paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2397">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="2da29-2398">Fangen Sie in [.NET für Windows Store-Apps](http://go.microsoft.com/fwlink/?LinkID=247912) oder der [portablen Klassenbibliothek](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) stattdessen die Basisklassenausnahme <see cref="T:System.IO.IOException" /> ab.</span>
              <span class="sxs-lookup">
                <span data-stu-id="2da29-2398">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="2da29-2399">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2399">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="2da29-2400">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2400">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="2da29-2401">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2401">-or-</span>
          </span>
          <span data-ttu-id="2da29-2402">Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und die Assembly wurde mit einer höheren Version kompiliert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2402">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="2da29-2403">Der durch die Assembly bezeichnete Name des abzurufenden Typs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2403">The assembly-qualified name of the type to get.</span>
          </span>
          <span data-ttu-id="2da29-2404">Siehe <see cref="P:System.Type.AssemblyQualifiedName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2404">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span>
          </span>
          <span data-ttu-id="2da29-2405">Wenn sich der Typ in der aktuell ausgeführten Assembly oder in Mscorlib.dll befindet, ist eine Angabe des Typnamens einschließlich des qualifizierenden Namespace ausreichend.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2405">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="2da29-2406">
            <see langword="true" />, damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden werden kann, <see langword="false" />, damit <see langword="null" /> zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2406">
              <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2da29-2407">Die Angabe von <see langword="false" /> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2407">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span>
          </span>
          <span data-ttu-id="2da29-2408">Informationen finden Sie im Abschnitt für Ausnahmen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2408">See the Exceptions section.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-2409">Ruft den <see cref="T:System.Type" /> mit dem angegebenen Namen ab. Bei der Suche wird die Groß-/Kleinschreibung beachtet. Dabei wird angegeben, ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2409">Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-2410">Der Typ mit dem angegebenen Namen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2410">The type with the specified name.</span>
          </span>
          <span data-ttu-id="2da29-2411">Wenn der Typ nicht gefunden wird, gibt der <paramref name="throwOnError" />-Parameter an, ob <see langword="null" /> zurückgegeben oder eine Ausnahme ausgelöst wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2411">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span>
          </span>
          <span data-ttu-id="2da29-2412">In einigen Fällen wird unabhängig vom Wert von <paramref name="throwOnError" /> eine Ausnahme ausgelöst.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2412">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span>
          </span>
          <span data-ttu-id="2da29-2413">Informationen finden Sie im Abschnitt für Ausnahmen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2413">See the Exceptions section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-2414">Können Sie die <xref:System.Type.GetType%2A> Methode zum Abrufen einer <xref:System.Type> -Objekt für einen Typ in einer anderen Assembly, wenn Sie wissen, dass die Namespace-qualifizierten Namen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2414">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if the you know its namespace-qualified name.</span></span> <span data-ttu-id="2da29-2415"><xref:System.Type.GetType%2A> führt zum Laden der Assembly im angegebenen `typeName`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2415"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="2da29-2416">Sie können auch laden eine Assembly mit der <xref:System.Reflection.Assembly.Load%2A> -Methode, und verwenden Sie dann die <xref:System.Type.GetType%2A> oder <xref:System.Reflection.Assembly.GetTypes%2A> Methoden die <xref:System.Reflection.Assembly> Klasse abgerufen <xref:System.Type> Objekte.</span><span class="sxs-lookup"><span data-stu-id="2da29-2416">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects.</span></span> <span data-ttu-id="2da29-2417">Wenn ein Typ in einer Assembly, die für Ihr Programm zur Kompilierzeit bekannt ist, ist es effizienter, verwenden `typeof` in c# <xref:System.Type.GetType%2A> in Visual Basic oder `typeid` in C++.</span><span class="sxs-lookup"><span data-stu-id="2da29-2417">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C#, <xref:System.Type.GetType%2A> in Visual Basic, or `typeid` in C++.</span></span>  
  
 <span data-ttu-id="2da29-2418">`GetType` funktioniert nur für Assemblys, die von der Festplatte geladen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2418">`GetType` only works on assemblies loaded from disk.</span></span> <span data-ttu-id="2da29-2419">Beim Aufrufen `GetType` zum Nachschlagen eines Typs in eine dynamische Assembly mit definiert, definiert der <xref:System.Reflection.Emit> Services, erhalten Sie möglicherweise inkonsistentes Verhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-2419">If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="2da29-2420">Das Verhalten abhängig, ob die dynamische Assembly persistent, d. h., erstellt, mit der `RunAndSave` oder `Save` Zugriff auf die Modi für die <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="2da29-2420">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="2da29-2421">Wenn die dynamische Assembly persistent ist und bevor Sie den Datenträger geschrieben wurden `GetType` wird aufgerufen, das Ladeprogramm für die gespeicherte Assembly sucht, auf dem Datenträger, lädt die Assembly und ruft den Typ aus dieser Assembly ab.</span><span class="sxs-lookup"><span data-stu-id="2da29-2421">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="2da29-2422">Wenn die Assembly nicht gespeichert wurde, wenn auf den Datenträger `GetType` aufgerufen wird, wird der Methodenrückgabe `null`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2422">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="2da29-2423">`GetType` flüchtige dynamische Assemblys versteht nicht; aus diesem Grund Aufrufen `GetType` zum Abrufen eines Typs in eine flüchtige dynamische Assembly gibt `null`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2423">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="2da29-2424">Mit `GetType` für ein dynamisches Modul Abonnieren der <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> Ereignis, und rufen `GetType` vor dem Speichern.</span><span class="sxs-lookup"><span data-stu-id="2da29-2424">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="2da29-2425">Andernfalls erhalten Sie zwei Kopien der Assembly im Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="2da29-2425">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="2da29-2426">Die `throwOnError` Parameter gibt an, was geschieht, wenn der Typ nicht gefunden wird, und auch bestimmte andere Ausnahmebedingungen unterdrückt, wie im Abschnitt für Ausnahmen beschrieben.</span><span class="sxs-lookup"><span data-stu-id="2da29-2426">The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="2da29-2427">Einige Ausnahmen werden ausgelöst, unabhängig vom Wert der `throwOnError`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2427">Some exceptions are thrown regardless of the value of `throwOnError`.</span></span> <span data-ttu-id="2da29-2428">Wenn der Typ wurde gefunden, aber kann nicht geladen werden kann, z. B. eine <xref:System.TypeLoadException> wird ausgelöst, selbst wenn `throwOnError` ist `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2428">For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.</span></span>  
  
 <span data-ttu-id="2da29-2429">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-2429">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="2da29-2430">Memberart</span><span class="sxs-lookup"><span data-stu-id="2da29-2430">Member Type</span></span>|<span data-ttu-id="2da29-2431">Statisch</span><span class="sxs-lookup"><span data-stu-id="2da29-2431">Static</span></span>|<span data-ttu-id="2da29-2432">Nicht statische</span><span class="sxs-lookup"><span data-stu-id="2da29-2432">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="2da29-2433">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="2da29-2433">Constructor</span></span>|<span data-ttu-id="2da29-2434">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-2434">No</span></span>|<span data-ttu-id="2da29-2435">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-2435">No</span></span>|  
|<span data-ttu-id="2da29-2436">Feld</span><span class="sxs-lookup"><span data-stu-id="2da29-2436">Field</span></span>|<span data-ttu-id="2da29-2437">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-2437">No</span></span>|<span data-ttu-id="2da29-2438">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-2438">Yes.</span></span> <span data-ttu-id="2da29-2439">Ein Feld ist immer nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2439">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-2440">event</span><span class="sxs-lookup"><span data-stu-id="2da29-2440">Event</span></span>|<span data-ttu-id="2da29-2441">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-2441">Not applicable</span></span>|<span data-ttu-id="2da29-2442">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-2442">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-2443">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2443">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-2444">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-2444">See note 2 below.</span></span>|  
|<span data-ttu-id="2da29-2445">Methode</span><span class="sxs-lookup"><span data-stu-id="2da29-2445">Method</span></span>|<span data-ttu-id="2da29-2446">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-2446">No</span></span>|<span data-ttu-id="2da29-2447">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-2447">Yes.</span></span> <span data-ttu-id="2da29-2448">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2448">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-2449">Geschachtelten Typs</span><span class="sxs-lookup"><span data-stu-id="2da29-2449">Nested Type</span></span>|<span data-ttu-id="2da29-2450">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-2450">No</span></span>|<span data-ttu-id="2da29-2451">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-2451">No</span></span>|  
|<span data-ttu-id="2da29-2452">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="2da29-2452">Property</span></span>|<span data-ttu-id="2da29-2453">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-2453">Not applicable</span></span>|<span data-ttu-id="2da29-2454">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-2454">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-2455">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2455">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-2456">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-2456">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="2da29-2457">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-2457">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="2da29-2458">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="2da29-2458">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="2da29-2459">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2459">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-2460">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2460">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="2da29-2461">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="2da29-2461">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="2da29-2462">Arrays oder COM-Typen werden nicht für durchsucht, es sei denn, sie bereits in der Tabelle der verfügbaren Klassen geladen wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2462">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="2da29-2463">`typeName` Der Typname kann durch den Namespace oder ein Assembly qualifizierter Name, der eine Assembly namensspezifikation enthält qualifiziert werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2463">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="2da29-2464">Siehe <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-2464">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="2da29-2465">Wenn `typeName` des Namespace, jedoch nicht den Assemblynamen eingeben, enthält diese Methode sucht nur die Assembly des aufrufenden Objekts und die Datei "mscorlib.dll", in dieser Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="2da29-2465">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="2da29-2466">Wenn TypeName vollqualifizierten mit dem Assemblynamen teilweise oder vollständig ist, sucht diese Methode in der angegebenen Assembly.</span><span class="sxs-lookup"><span data-stu-id="2da29-2466">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="2da29-2467">Wenn die Assembly einen starken Namen besitzt, ist ein vollständige Assemblyname erforderlich.</span><span class="sxs-lookup"><span data-stu-id="2da29-2467">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="2da29-2468">Die <xref:System.Type.AssemblyQualifiedName%2A> -Eigenschaft gibt einen vollqualifizierten Typnamen einschließlich geschachtelter Typen, der Name der Assembly und die generische Argumente zurück.</span><span class="sxs-lookup"><span data-stu-id="2da29-2468">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic arguments.</span></span> <span data-ttu-id="2da29-2469">Alle Compiler, die die common Language Runtime unterstützen, den einfachen Namen einer geschachtelten Klasse geben, und Reflektion erstellt einen ergänzten Namen bei einer Abfrage in Übereinstimmung mit den folgenden Konventionen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2469">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-2470">In .NET Framework, Version 2.0 Prozessorarchitektur Assemblyidentität hinzugefügt und kann als Teil der Assembly-Zeichenfolgen angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2470">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="2da29-2471">Z. B. "ProcessorArchitecture = Msil".</span><span class="sxs-lookup"><span data-stu-id="2da29-2471">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="2da29-2472">Ist jedoch nicht in die zurückgegebene Zeichenfolge enthalten die <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaft, aus Gründen der Kompatibilität.</span><span class="sxs-lookup"><span data-stu-id="2da29-2472">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="2da29-2473">Sie können Typen auch laden, indem Sie erstellen eine <xref:System.Reflection.AssemblyName> -Objekt und übergibt dieses an eine entsprechende Überladung der der <xref:System.Reflection.Assembly.Load%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-2473">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="2da29-2474">Anschließend können Sie die <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> -Methode zum Laden von Typen aus der Assembly.</span><span class="sxs-lookup"><span data-stu-id="2da29-2474">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="2da29-2475">Siehe auch <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-2475">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="2da29-2476">Trennzeichen</span><span class="sxs-lookup"><span data-stu-id="2da29-2476">Delimiter</span></span>|<span data-ttu-id="2da29-2477">Bedeutung</span><span class="sxs-lookup"><span data-stu-id="2da29-2477">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="2da29-2478">Umgekehrter Schrägstrich (\\)</span><span class="sxs-lookup"><span data-stu-id="2da29-2478">Backslash (\\)</span></span>|<span data-ttu-id="2da29-2479">Escape-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2479">Escape character.</span></span>|  
|<span data-ttu-id="2da29-2480">Umgekehrtes Apostroph (')</span><span class="sxs-lookup"><span data-stu-id="2da29-2480">Backtick (\`)</span></span>|<span data-ttu-id="2da29-2481">Steht vor eine oder mehrere Ziffern, die die Anzahl von Typparametern, am Ende des Namens eines generischen Typs darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2481">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="2da29-2482">Klammern ([])</span><span class="sxs-lookup"><span data-stu-id="2da29-2482">Brackets ([])</span></span>|<span data-ttu-id="2da29-2483">Schließen Sie eine generische Liste der Typargumente, für einen konstruierten generischen Typ; Schließen Sie in einer Liste der Typargumente eine Assembly qualifizierten Typnamen an.</span><span class="sxs-lookup"><span data-stu-id="2da29-2483">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="2da29-2484">Komma (,)</span><span class="sxs-lookup"><span data-stu-id="2da29-2484">Comma (,)</span></span>|<span data-ttu-id="2da29-2485">Ist der Name der Assembly vorangestellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2485">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="2da29-2486">Punkt (.)</span><span class="sxs-lookup"><span data-stu-id="2da29-2486">Period (.)</span></span>|<span data-ttu-id="2da29-2487">Gibt die Namespacebezeichner.</span><span class="sxs-lookup"><span data-stu-id="2da29-2487">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="2da29-2488">Pluszeichen (+)</span><span class="sxs-lookup"><span data-stu-id="2da29-2488">Plus sign (+)</span></span>|<span data-ttu-id="2da29-2489">Ist eine geschachtelte Klasse vorangestellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2489">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="2da29-2490">Beispielsweise kann der vollqualifizierte Name für eine Klasse wie folgt aussehen:</span><span class="sxs-lookup"><span data-stu-id="2da29-2490">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="2da29-2491">Wenn der Namespace wurden TopNamespace.Sub, würde die Zeichenfolge auf das Pluszeichen (+) ein Escapezeichen vorangestellt haben (\\) zu verhindern, dass er als schachteln Trennzeichen interpretiert wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-2491">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="2da29-2492">Reflektion wird diese Zeichenfolge wie folgt aus:</span><span class="sxs-lookup"><span data-stu-id="2da29-2492">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="2da29-2493">Ein "++" wird "\\+\\+", und ein "\\"wird"\\\\".</span><span class="sxs-lookup"><span data-stu-id="2da29-2493">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="2da29-2494">Dieser qualifizierte Name kann beibehalten und später zum Laden der <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="2da29-2494">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="2da29-2495">Suchen und Laden einer <xref:System.Type>, verwenden Sie <xref:System.Type.GetType%2A> entweder mit dem Typ oder einen Namen geben nur mit der Assembly qualifizierten Typnamen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2495">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="2da29-2496"><xref:System.Type.GetType%2A> mit dem Namen nur sieht für den <xref:System.Type> in der Assembly des Aufrufers, und klicken Sie dann in der System-Assembly.</span><span class="sxs-lookup"><span data-stu-id="2da29-2496"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="2da29-2497"><xref:System.Type.GetType%2A> mit der Assembly qualifizierten Typnamen für sieht die <xref:System.Type> in jeder beliebigen Assembly.</span><span class="sxs-lookup"><span data-stu-id="2da29-2497"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="2da29-2498">Geben Sie die Namen eventuell nachfolgende Zeichen, die zusätzliche über den Typ Informationen, z. B., ob der Typ ein Verweistyp, ein Zeigertyp oder ein Arraytyp ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-2498">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="2da29-2499">Verwenden Sie zum Abrufen der Typname ohne diese nachfolgenden Zeichen `t.GetElementType().ToString()`, wobei `t` ist der Typ.</span><span class="sxs-lookup"><span data-stu-id="2da29-2499">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="2da29-2500">Leerzeichen sind in allen Komponenten von Typnamen mit Ausnahme der Assemblyname relevant.</span><span class="sxs-lookup"><span data-stu-id="2da29-2500">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="2da29-2501">In der Assemblyname Leerzeichen vor dem Trennzeichen "," relevant sind, aber nach dem Trennzeichen "," Leerzeichen werden ignoriert.</span><span class="sxs-lookup"><span data-stu-id="2da29-2501">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="2da29-2502">Der Name eines generischen Typs endet mit der ein umgekehrtes Apostroph (\`) gefolgt von Ziffern, die die Anzahl der Argumente des generischen Typs darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2502">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="2da29-2503">Dieser Name-mangling dient zum Zulassen von Compilern zur Unterstützung von generischer Typen mit dem gleichen Namen, aber mit einer unterschiedlichen Anzahl von Typparametern, im selben Gültigkeitsbereich auftritt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2503">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="2da29-2504">Reflektion gibt z. B. die ergänzten Namen `Tuple`1` and `Tupel`2` aus den generischen Methoden `Tuple(Of T)` und `Tuple(Of T0, T1)` in Visual Basic oder `Tuple<T>` und Tupel`\<T0, T1>` in Visual c#.</span><span class="sxs-lookup"><span data-stu-id="2da29-2504">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="2da29-2505">Bei generischen Typen wird die Typargumentliste in Klammern gesetzt, und die Typargumente werden durch Kommas getrennt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2505">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="2da29-2506">Angenommen, eine generische <xref:System.Collections.Generic.Dictionary%602> verfügt über zwei Typparameter.</span><span class="sxs-lookup"><span data-stu-id="2da29-2506">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="2da29-2507">Ein <xref:System.Collections.Generic.Dictionary%602> von `MyType` mit Schlüsseln des Typs <xref:System.String> kann wie folgt dargestellt werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-2507">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="2da29-2508">Um eine Assembly qualifizierten Typnamen in einer Liste der Typargumente angeben, schließen Sie die Assembly qualifizierten Typnamen in Klammern ein.</span><span class="sxs-lookup"><span data-stu-id="2da29-2508">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="2da29-2509">Andernfalls werden die Kommas, die trennen die Bestandteile der Assembly qualifizierte Name, als Trennzeichen für weitere Typargumente interpretiert.</span><span class="sxs-lookup"><span data-stu-id="2da29-2509">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="2da29-2510">Z. B. eine <xref:System.Collections.Generic.Dictionary%602> von `MyType` aus MyAssembly.dll mit Schlüsseln des Typs <xref:System.String>, kann wie folgt angegeben werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-2510">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="2da29-2511">Eine Assembly qualifizierten Typnamen kann in Klammern eingeschlossen werden, nur, wenn es in einer Typparameterliste angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-2511">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="2da29-2512">Die Regeln für das Suchen von Assemblys für qualifizierten und nicht qualifizierten Typen in Typparameterlisten sind identisch mit den Regeln für qualifizierte und nicht qualifizierte nicht generische Typen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2512">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="2da29-2513">Auf NULL festlegbare Typen sind ein besonderer Fall von generischen Typen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2513">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="2da29-2514">Angenommen, ein NULL-Werte zulassen <xref:System.Int32> wird durch die Zeichenfolge "System.Nullable'1[System.Int32]" dargestellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2514">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-2515">In c#, C++ und Visual Basic können Sie auch auf NULL festlegbaren Typen, die mithilfe von Operatoren abrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2515">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="2da29-2516">Angenommen, die NULL-Werte zulässt <xref:System.Boolean> zurückgegebene Typ `typeof(Nullable<bool>)` in c# durch `Nullable<Boolean>::typeid` in C++ und in `GetType(Nullable(Of Boolean))` in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="2da29-2516">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="2da29-2517">Die folgende Tabelle zeigt die Syntax, die Sie mit `GetType` für verschiedene Typen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2517">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="2da29-2518">Zum Abrufen</span><span class="sxs-lookup"><span data-stu-id="2da29-2518">To Get</span></span>|<span data-ttu-id="2da29-2519">Mit</span><span class="sxs-lookup"><span data-stu-id="2da29-2519">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="2da29-2520">Ein NULL-Werte zulässt <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="2da29-2520">A nullable <xref:System.Int32></span></span>|<span data-ttu-id="2da29-2521">`Type.GetType("System.Nullable`1[System.Int32]")\`</span><span class="sxs-lookup"><span data-stu-id="2da29-2521">`Type.GetType("System.Nullable`1[System.Int32]")\`</span></span>|  
|<span data-ttu-id="2da29-2522">Ein nicht verwalteter Zeiger auf `MyType`</span><span class="sxs-lookup"><span data-stu-id="2da29-2522">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="2da29-2523">Ein nicht verwalteter Zeiger auf einen Zeiger auf `MyType`</span><span class="sxs-lookup"><span data-stu-id="2da29-2523">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="2da29-2524">Ein verwalteter Zeiger oder Verweis auf `MyType`</span><span class="sxs-lookup"><span data-stu-id="2da29-2524">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="2da29-2525">`Type.GetType("MyType&")`</span><span class="sxs-lookup"><span data-stu-id="2da29-2525">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="2da29-2526">Beachten Sie, dass Verweise im Gegensatz zu Zeigern auf eine Ebene beschränkt sind.</span><span class="sxs-lookup"><span data-stu-id="2da29-2526">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="2da29-2527">Eine übergeordnete Klasse und eine geschachtelte Klasse</span><span class="sxs-lookup"><span data-stu-id="2da29-2527">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="2da29-2528">Ein eindimensionales Array mit einer unteren Grenze von 0</span><span class="sxs-lookup"><span data-stu-id="2da29-2528">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyArray[]")`|  
|<span data-ttu-id="2da29-2529">Ein eindimensionales Array mit einer unbekannten Untergrenze</span><span class="sxs-lookup"><span data-stu-id="2da29-2529">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyArray[*]")`|  
|<span data-ttu-id="2da29-2530">Ein n-dimensionalen array</span><span class="sxs-lookup"><span data-stu-id="2da29-2530">An n-dimensional array</span></span>|<span data-ttu-id="2da29-2531">Ein Komma (,) innerhalb der Klammern eine insgesamt n-1 Mal.</span><span class="sxs-lookup"><span data-stu-id="2da29-2531">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="2da29-2532">Beispielsweise `System.Object[,,]` stellt eine dreidimensionale `Object` Array.</span><span class="sxs-lookup"><span data-stu-id="2da29-2532">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="2da29-2533">Ein zweidimensionales Array von Arrays</span><span class="sxs-lookup"><span data-stu-id="2da29-2533">A two-dimensional array's array</span></span>|`Type.GetType("MyArray[][]")`|  
|<span data-ttu-id="2da29-2534">Kein rechteckiges zweidimensionales Array mit unbekannten Untergrenzen</span><span class="sxs-lookup"><span data-stu-id="2da29-2534">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyArray[,]")`|  
|<span data-ttu-id="2da29-2535">Ein generischer Typ mit einem Typargument</span><span class="sxs-lookup"><span data-stu-id="2da29-2535">A generic type with one type argument</span></span>|<span data-ttu-id="2da29-2536">`Type.GetType("MyGenericType`1[MyType]")\`</span><span class="sxs-lookup"><span data-stu-id="2da29-2536">`Type.GetType("MyGenericType`1[MyType]")\`</span></span>|  
|<span data-ttu-id="2da29-2537">Ein generischer Typ mit zwei Typargumenten</span><span class="sxs-lookup"><span data-stu-id="2da29-2537">A generic type with two type arguments</span></span>|<span data-ttu-id="2da29-2538">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span><span class="sxs-lookup"><span data-stu-id="2da29-2538">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span></span>|  
|<span data-ttu-id="2da29-2539">Ein generischer Typ mit zwei durch die Assembly qualifizierten Typargumenten</span><span class="sxs-lookup"><span data-stu-id="2da29-2539">A generic type with two assembly-qualified type arguments</span></span>|<span data-ttu-id="2da29-2540">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")"</span><span class="sxs-lookup"><span data-stu-id="2da29-2540">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")\`</span></span>|  
|<span data-ttu-id="2da29-2541">Ein assemblyqualifizierten generischer Typ mit einem Assembly qualifizierten Typnamen-argument</span><span class="sxs-lookup"><span data-stu-id="2da29-2541">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|<span data-ttu-id="2da29-2542">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")"</span><span class="sxs-lookup"><span data-stu-id="2da29-2542">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")\`</span></span>|  
|<span data-ttu-id="2da29-2543">Ein generischer Typ, dessen Type-Argument ein generischer Typ mit zwei Typargumenten ist</span><span class="sxs-lookup"><span data-stu-id="2da29-2543">A generic type whose type argument is a generic type with two type arguments</span></span>|<span data-ttu-id="2da29-2544">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span><span class="sxs-lookup"><span data-stu-id="2da29-2544">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="2da29-2545">Das folgende Beispiel ruft den Typ des `System.Int32` und verwendet diese Typobjekt zum Anzeigen der <xref:System.Type.FullName%2A> Eigenschaft `System.Int32`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2545">The following example retrieves the type of `System.Int32` and uses that type object to display the <xref:System.Type.FullName%2A> property of `System.Int32`.</span></span> <span data-ttu-id="2da29-2546">Wenn ein Objekt vom Typ auf eine Assembly, die nicht vorhanden ist verweist, wird in diesem Beispiel wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="2da29-2546">If a type object refers to an assembly that does not exist, this example throws an exception.</span></span>  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-2547">
            <paramref name="typeName" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2547">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="2da29-2548">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2548">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="2da29-2549">
            <paramref name="throwOnError" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2549">
              <paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span>
          </span>
          <span data-ttu-id="2da29-2550">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2550">-or-</span>
          </span>
          <span data-ttu-id="2da29-2551">
            <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2551">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span>
          </span>
          <span data-ttu-id="2da29-2552">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2552">-or-</span>
          </span>
          <span data-ttu-id="2da29-2553">
            <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> ist eine leere Zeichenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2553">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span>
          </span>
          <span data-ttu-id="2da29-2554">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2554">-or-</span>
          </span>
          <span data-ttu-id="2da29-2555">
            <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> stellt einen Arraytyp mit einer ungültigen Größe dar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2555">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span>
          </span>
          <span data-ttu-id="2da29-2556">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2556">-or-</span>
          </span>
          <span data-ttu-id="2da29-2557">
            <paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2557">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-2558">
            <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Syntax,</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2558">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax.</span>
          </span>
          <span data-ttu-id="2da29-2559">beispielsweise "MyType[,\*,]".</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2559">For example, "MyType[,\*,]".</span>
          </span>
          <span data-ttu-id="2da29-2560">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2560">-or-</span>
          </span>
          <span data-ttu-id="2da29-2561">
            <paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2561">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="2da29-2562">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2562">-or-</span>
          </span>
          <span data-ttu-id="2da29-2563">
            <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2563">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="2da29-2564">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2564">-or-</span>
          </span>
          <span data-ttu-id="2da29-2565">
            <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2565">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="2da29-2566">
            <paramref name="throwOnError" /> ist <see langword="true" />, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2566">
              <paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <block subset="none" type="note">
            <para>
              <span data-ttu-id="2da29-2567">Fangen Sie in [.NET für Windows Store-Apps](http://go.microsoft.com/fwlink/?LinkID=247912) oder der [portablen Klassenbibliothek](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md) stattdessen die Basisklassenausnahme <see cref="T:System.IO.IOException" /> ab.</span>
              <span class="sxs-lookup">
                <span data-stu-id="2da29-2567">In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span>
              </span>
            </para>
          </block>
          <span data-ttu-id="2da29-2568">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2568">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="2da29-2569">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2569">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="2da29-2570">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2570">-or-</span>
          </span>
          <span data-ttu-id="2da29-2571">Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und die Assembly wurde mit einer höheren Version kompiliert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2571">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="2da29-2572">Der durch die Assembly bezeichnete Name des abzurufenden Typs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2572">The assembly-qualified name of the type to get.</span>
          </span>
          <span data-ttu-id="2da29-2573">Siehe <see cref="P:System.Type.AssemblyQualifiedName" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2573">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span>
          </span>
          <span data-ttu-id="2da29-2574">Wenn sich der Typ in der aktuell ausgeführten Assembly oder in Mscorlib.dll befindet, ist eine Angabe des Typnamens einschließlich des qualifizierenden Namespace ausreichend.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2574">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="2da29-2575">
            <see langword="true" />, um eine Ausnahme auszulösen, wenn der Typ nicht gefunden werden kann; <see langword="false" />, um <see langword="null" /> zurückzugeben. Die Angabe von <see langword="false" /> unterdrückt außerdem einige andere Ausnahmebedingungen, jedoch nicht alle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2575">
              <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span>
          </span>
          <span data-ttu-id="2da29-2576">Informationen finden Sie im Abschnitt für Ausnahmen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2576">See the Exceptions section.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="2da29-2577">
            <see langword="true" />, um ohne Beachtung der Groß-/Kleinschreibung nach <c>typeName</c> zu suchen; <see langword="false" />, um mit Beachtung der Groß-/Kleinschreibung nach <c>typeName</c> zu suchen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2577">
              <see langword="true" /> to perform a case-insensitive search for <c>typeName</c>, <see langword="false" /> to perform a case-sensitive search for <c>typeName</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-2578">Ruft den <see cref="T:System.Type" /> mit dem angegebenen Namen ab. Dabei wird angegeben, ob bei der Suche Groß- und Kleinschreibung berücksichtigt werden soll und ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2578">Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to throw an exception if the type is not found and whether to perform a case-sensitive search.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-2579">Der Typ mit dem angegebenen Namen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2579">The type with the specified name.</span>
          </span>
          <span data-ttu-id="2da29-2580">Wenn der Typ nicht gefunden wird, gibt der <paramref name="throwOnError" />-Parameter an, ob <see langword="null" /> zurückgegeben oder eine Ausnahme ausgelöst wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2580">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span>
          </span>
          <span data-ttu-id="2da29-2581">In einigen Fällen wird unabhängig vom Wert von <paramref name="throwOnError" /> eine Ausnahme ausgelöst.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2581">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span>
          </span>
          <span data-ttu-id="2da29-2582">Informationen finden Sie im Abschnitt für Ausnahmen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2582">See the Exceptions section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-2583">Können Sie die <xref:System.Type.GetType%2A> Methode zum Abrufen einer <xref:System.Type> -Objekt für einen Typ in einer anderen Assembly, wenn Sie wissen, dass die Namespace-qualifizierten Namen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2583">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if the you know its namespace-qualified name.</span></span> <span data-ttu-id="2da29-2584"><xref:System.Type.GetType%2A> führt zum Laden der Assembly im angegebenen `typeName`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2584"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="2da29-2585">Sie können auch laden eine Assembly mit der <xref:System.Reflection.Assembly.Load%2A> -Methode, und verwenden Sie dann die <xref:System.Type.GetType%2A> oder <xref:System.Reflection.Assembly.GetTypes%2A> Methoden die <xref:System.Reflection.Assembly> Klasse abgerufen <xref:System.Type> Objekte.</span><span class="sxs-lookup"><span data-stu-id="2da29-2585">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects.</span></span> <span data-ttu-id="2da29-2586">Wenn ein Typ in einer Assembly, die für Ihr Programm zur Kompilierzeit bekannt ist, ist es effizienter, verwenden `typeof` in c# <xref:System.Type.GetType%2A> in Visual Basic oder `typeid` in C++.</span><span class="sxs-lookup"><span data-stu-id="2da29-2586">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C#, <xref:System.Type.GetType%2A> in Visual Basic, or `typeid` in C++.</span></span>  
  
 <span data-ttu-id="2da29-2587">`GetType` funktioniert nur für Assemblys, die von der Festplatte geladen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2587">`GetType` only works on assemblies loaded from disk.</span></span> <span data-ttu-id="2da29-2588">Beim Aufrufen `GetType` zum Nachschlagen eines Typs in eine dynamische Assembly mit definiert, definiert der <xref:System.Reflection.Emit> Services, erhalten Sie möglicherweise inkonsistentes Verhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-2588">If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="2da29-2589">Das Verhalten abhängig, ob die dynamische Assembly persistent, d. h., erstellt, mit der `RunAndSave` oder `Save` Zugriff auf die Modi für die <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="2da29-2589">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="2da29-2590">Wenn die dynamische Assembly persistent ist und bevor Sie den Datenträger geschrieben wurden `GetType` wird aufgerufen, das Ladeprogramm für die gespeicherte Assembly sucht, auf dem Datenträger, lädt die Assembly und ruft den Typ aus dieser Assembly ab.</span><span class="sxs-lookup"><span data-stu-id="2da29-2590">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="2da29-2591">Wenn die Assembly nicht gespeichert wurde, wenn auf den Datenträger `GetType` aufgerufen wird, wird der Methodenrückgabe `null`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2591">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="2da29-2592">`GetType` flüchtige dynamische Assemblys versteht nicht; aus diesem Grund Aufrufen `GetType` zum Abrufen eines Typs in eine flüchtige dynamische Assembly gibt `null`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2592">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="2da29-2593">Mit `GetType` für ein dynamisches Modul Abonnieren der <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> Ereignis, und rufen `GetType` vor dem Speichern.</span><span class="sxs-lookup"><span data-stu-id="2da29-2593">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="2da29-2594">Andernfalls erhalten Sie zwei Kopien der Assembly im Arbeitsspeicher.</span><span class="sxs-lookup"><span data-stu-id="2da29-2594">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="2da29-2595">Die `throwOnError` Parameter gibt an, was geschieht, wenn der Typ nicht gefunden wird, und auch bestimmte andere Ausnahmebedingungen unterdrückt, wie im Abschnitt für Ausnahmen beschrieben.</span><span class="sxs-lookup"><span data-stu-id="2da29-2595">The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="2da29-2596">Einige Ausnahmen werden ausgelöst, unabhängig vom Wert der `throwOnError`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2596">Some exceptions are thrown regardless of the value of `throwOnError`.</span></span> <span data-ttu-id="2da29-2597">Wenn der Typ wurde gefunden, aber kann nicht geladen werden kann, z. B. eine <xref:System.TypeLoadException> wird ausgelöst, selbst wenn `throwOnError` ist `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2597">For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.</span></span>  
  
 <span data-ttu-id="2da29-2598">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die `Get` Methoden, wenn für einen Typ reflektieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-2598">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="2da29-2599">Memberart</span><span class="sxs-lookup"><span data-stu-id="2da29-2599">Member Type</span></span>|<span data-ttu-id="2da29-2600">Statisch</span><span class="sxs-lookup"><span data-stu-id="2da29-2600">Static</span></span>|<span data-ttu-id="2da29-2601">Nicht statische</span><span class="sxs-lookup"><span data-stu-id="2da29-2601">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="2da29-2602">Konstruktor</span><span class="sxs-lookup"><span data-stu-id="2da29-2602">Constructor</span></span>|<span data-ttu-id="2da29-2603">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-2603">No</span></span>|<span data-ttu-id="2da29-2604">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-2604">No</span></span>|  
|<span data-ttu-id="2da29-2605">Feld</span><span class="sxs-lookup"><span data-stu-id="2da29-2605">Field</span></span>|<span data-ttu-id="2da29-2606">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-2606">No</span></span>|<span data-ttu-id="2da29-2607">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-2607">Yes.</span></span> <span data-ttu-id="2da29-2608">Ein Feld ist immer nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2608">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-2609">event</span><span class="sxs-lookup"><span data-stu-id="2da29-2609">Event</span></span>|<span data-ttu-id="2da29-2610">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-2610">Not applicable</span></span>|<span data-ttu-id="2da29-2611">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-2611">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-2612">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2612">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-2613">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-2613">See note 2 below.</span></span>|  
|<span data-ttu-id="2da29-2614">Methode</span><span class="sxs-lookup"><span data-stu-id="2da29-2614">Method</span></span>|<span data-ttu-id="2da29-2615">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-2615">No</span></span>|<span data-ttu-id="2da29-2616">Ja.</span><span class="sxs-lookup"><span data-stu-id="2da29-2616">Yes.</span></span> <span data-ttu-id="2da29-2617">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2617">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="2da29-2618">Geschachtelten Typs</span><span class="sxs-lookup"><span data-stu-id="2da29-2618">Nested Type</span></span>|<span data-ttu-id="2da29-2619">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-2619">No</span></span>|<span data-ttu-id="2da29-2620">Nein</span><span class="sxs-lookup"><span data-stu-id="2da29-2620">No</span></span>|  
|<span data-ttu-id="2da29-2621">Eigenschaft</span><span class="sxs-lookup"><span data-stu-id="2da29-2621">Property</span></span>|<span data-ttu-id="2da29-2622">Nicht zutreffend</span><span class="sxs-lookup"><span data-stu-id="2da29-2622">Not applicable</span></span>|<span data-ttu-id="2da29-2623">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-2623">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="2da29-2624">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2624">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-2625">Siehe Hinweis 2 weiter unten.</span><span class="sxs-lookup"><span data-stu-id="2da29-2625">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="2da29-2626">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-2626">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="2da29-2627">Dies ist ein binärer Vergleich.</span><span class="sxs-lookup"><span data-stu-id="2da29-2627">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="2da29-2628">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2628">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="2da29-2629">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2629">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="2da29-2630">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</span><span class="sxs-lookup"><span data-stu-id="2da29-2630">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="2da29-2631">Arrays oder COM-Typen werden nicht für durchsucht, es sei denn, sie bereits in der Tabelle der verfügbaren Klassen geladen wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2631">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="2da29-2632">`typeName` Der Typname kann durch den Namespace oder ein Assembly qualifizierter Name, der eine Assembly namensspezifikation enthält qualifiziert werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2632">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="2da29-2633">Siehe <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-2633">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="2da29-2634">Wenn `typeName` des Namespace, jedoch nicht den Assemblynamen eingeben, enthält diese Methode sucht nur die Assembly des aufrufenden Objekts und die Datei "mscorlib.dll", in dieser Reihenfolge.</span><span class="sxs-lookup"><span data-stu-id="2da29-2634">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="2da29-2635">Wenn TypeName vollqualifizierten mit dem Assemblynamen teilweise oder vollständig ist, sucht diese Methode in der angegebenen Assembly.</span><span class="sxs-lookup"><span data-stu-id="2da29-2635">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="2da29-2636">Wenn die Assembly einen starken Namen besitzt, ist ein vollständige Assemblyname erforderlich.</span><span class="sxs-lookup"><span data-stu-id="2da29-2636">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="2da29-2637">Die <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaft gibt einen vollqualifizierten Typnamen einschließlich geschachtelter Typen, Assemblyname und Typargumente.</span><span class="sxs-lookup"><span data-stu-id="2da29-2637">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and type arguments.</span></span> <span data-ttu-id="2da29-2638">Alle Compiler, die die common Language Runtime unterstützen, den einfachen Namen einer geschachtelten Klasse geben, und Reflektion erstellt einen ergänzten Namen bei einer Abfrage in Übereinstimmung mit den folgenden Konventionen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2638">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-2639">In .NET Framework, Version 2.0 Prozessorarchitektur Assemblyidentität hinzugefügt und kann als Teil der Assembly-Zeichenfolgen angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2639">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="2da29-2640">Z. B. "ProcessorArchitecture = Msil".</span><span class="sxs-lookup"><span data-stu-id="2da29-2640">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="2da29-2641">Ist jedoch nicht in die zurückgegebene Zeichenfolge enthalten die <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaft, aus Gründen der Kompatibilität.</span><span class="sxs-lookup"><span data-stu-id="2da29-2641">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="2da29-2642">Sie können Typen auch laden, indem Sie erstellen eine <xref:System.Reflection.AssemblyName> -Objekt und übergibt dieses an eine entsprechende Überladung der der <xref:System.Reflection.Assembly.Load%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-2642">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="2da29-2643">Anschließend können Sie die <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> -Methode zum Laden von Typen aus der Assembly.</span><span class="sxs-lookup"><span data-stu-id="2da29-2643">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="2da29-2644">Siehe auch <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-2644">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="2da29-2645">Trennzeichen</span><span class="sxs-lookup"><span data-stu-id="2da29-2645">Delimiter</span></span>|<span data-ttu-id="2da29-2646">Bedeutung</span><span class="sxs-lookup"><span data-stu-id="2da29-2646">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="2da29-2647">Umgekehrter Schrägstrich (\\)</span><span class="sxs-lookup"><span data-stu-id="2da29-2647">Backslash (\\)</span></span>|<span data-ttu-id="2da29-2648">Escape-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2648">Escape character.</span></span>|  
|<span data-ttu-id="2da29-2649">Umgekehrtes Apostroph (')</span><span class="sxs-lookup"><span data-stu-id="2da29-2649">Backtick (\`)</span></span>|<span data-ttu-id="2da29-2650">Steht vor eine oder mehrere Ziffern, die die Anzahl von Typparametern, am Ende des Namens eines generischen Typs darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2650">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="2da29-2651">Klammern ([])</span><span class="sxs-lookup"><span data-stu-id="2da29-2651">Brackets ([])</span></span>|<span data-ttu-id="2da29-2652">Schließen Sie eine generische Liste der Typargumente, für einen konstruierten generischen Typ; Schließen Sie in einer Liste der Typargumente eine Assembly qualifizierten Typnamen an.</span><span class="sxs-lookup"><span data-stu-id="2da29-2652">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="2da29-2653">Komma (,)</span><span class="sxs-lookup"><span data-stu-id="2da29-2653">Comma (,)</span></span>|<span data-ttu-id="2da29-2654">Ist der Name der Assembly vorangestellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2654">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="2da29-2655">Punkt (.)</span><span class="sxs-lookup"><span data-stu-id="2da29-2655">Period (.)</span></span>|<span data-ttu-id="2da29-2656">Gibt die Namespacebezeichner.</span><span class="sxs-lookup"><span data-stu-id="2da29-2656">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="2da29-2657">Pluszeichen (+)</span><span class="sxs-lookup"><span data-stu-id="2da29-2657">Plus sign (+)</span></span>|<span data-ttu-id="2da29-2658">Ist eine geschachtelte Klasse vorangestellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2658">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="2da29-2659">Beispielsweise kann der vollqualifizierte Name für eine Klasse wie folgt aussehen:</span><span class="sxs-lookup"><span data-stu-id="2da29-2659">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="2da29-2660">Wenn der Namespace wurden TopNamespace.Sub, würde die Zeichenfolge auf das Pluszeichen (+) ein Escapezeichen vorangestellt haben (\\) zu verhindern, dass er als schachteln Trennzeichen interpretiert wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-2660">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="2da29-2661">Reflektion wird diese Zeichenfolge wie folgt aus:</span><span class="sxs-lookup"><span data-stu-id="2da29-2661">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="2da29-2662">Ein "++" wird "\\+\\+", und ein "\\"wird"\\\\".</span><span class="sxs-lookup"><span data-stu-id="2da29-2662">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="2da29-2663">Dieser qualifizierte Name kann beibehalten und später zum Laden der <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="2da29-2663">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="2da29-2664">Suchen und Laden einer <xref:System.Type>, verwenden Sie <xref:System.Type.GetType%2A> entweder mit dem Typ oder einen Namen geben nur mit der Assembly qualifizierten Typnamen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2664">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="2da29-2665"><xref:System.Type.GetType%2A> mit dem Namen nur sieht für den <xref:System.Type> in der Assembly des Aufrufers, und klicken Sie dann in der System-Assembly.</span><span class="sxs-lookup"><span data-stu-id="2da29-2665"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="2da29-2666"><xref:System.Type.GetType%2A> mit der Assembly qualifizierten Typnamen für sieht die <xref:System.Type> in jeder beliebigen Assembly.</span><span class="sxs-lookup"><span data-stu-id="2da29-2666"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="2da29-2667">Geben Sie die Namen eventuell nachfolgende Zeichen, die zusätzliche über den Typ Informationen, z. B., ob der Typ ein Verweistyp, ein Zeigertyp oder ein Arraytyp ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-2667">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="2da29-2668">Verwenden Sie zum Abrufen der Typname ohne diese nachfolgenden Zeichen `t.GetElementType().ToString()`, wobei `t` ist der Typ.</span><span class="sxs-lookup"><span data-stu-id="2da29-2668">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="2da29-2669">Leerzeichen sind in allen Komponenten von Typnamen mit Ausnahme der Assemblyname relevant.</span><span class="sxs-lookup"><span data-stu-id="2da29-2669">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="2da29-2670">In der Assemblyname Leerzeichen vor dem Trennzeichen "," relevant sind, aber nach dem Trennzeichen "," Leerzeichen werden ignoriert.</span><span class="sxs-lookup"><span data-stu-id="2da29-2670">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="2da29-2671">Der Name eines generischen Typs endet mit der ein umgekehrtes Apostroph (\`) gefolgt von Ziffern, die die Anzahl der Argumente des generischen Typs darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2671">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="2da29-2672">Dieser Name-mangling dient zum Zulassen von Compilern zur Unterstützung von generischer Typen mit dem gleichen Namen, aber mit einer unterschiedlichen Anzahl von Typparametern, im selben Gültigkeitsbereich auftritt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2672">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="2da29-2673">Reflektion gibt z. B. die ergänzten Namen `Tuple`1` and `Tupel`2` aus den generischen Methoden `Tuple(Of T)` und `Tuple(Of T0, T1)` in Visual Basic oder `Tuple<T>` und Tupel`\<T0, T1>` in Visual c#.</span><span class="sxs-lookup"><span data-stu-id="2da29-2673">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="2da29-2674">Bei generischen Typen wird die Typargumentliste in Klammern gesetzt, und die Typargumente werden durch Kommas getrennt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2674">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="2da29-2675">Angenommen, eine generische <xref:System.Collections.Generic.Dictionary%602> verfügt über zwei Typparameter.</span><span class="sxs-lookup"><span data-stu-id="2da29-2675">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="2da29-2676">Ein <xref:System.Collections.Generic.Dictionary%602> von `MyType` mit Schlüsseln des Typs <xref:System.String> kann wie folgt dargestellt werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-2676">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="2da29-2677">Um eine Assembly qualifizierten Typnamen in einer Liste der Typargumente angeben, schließen Sie die Assembly qualifizierten Typnamen in Klammern ein.</span><span class="sxs-lookup"><span data-stu-id="2da29-2677">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="2da29-2678">Andernfalls werden die Kommas, die trennen die Bestandteile der Assembly qualifizierte Name, als Trennzeichen für weitere Typargumente interpretiert.</span><span class="sxs-lookup"><span data-stu-id="2da29-2678">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="2da29-2679">Z. B. eine <xref:System.Collections.Generic.Dictionary%602> von `MyType` aus MyAssembly.dll mit Schlüsseln des Typs <xref:System.String>, kann wie folgt angegeben werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-2679">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="2da29-2680">Eine Assembly qualifizierten Typnamen kann in Klammern eingeschlossen werden, nur, wenn es in einer Typparameterliste angezeigt wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-2680">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="2da29-2681">Die Regeln für das Suchen von Assemblys für qualifizierten und nicht qualifizierten Typen in Typparameterlisten sind identisch mit den Regeln für qualifizierte und nicht qualifizierte nicht generische Typen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2681">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="2da29-2682">Auf NULL festlegbare Typen sind ein besonderer Fall von generischen Typen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2682">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="2da29-2683">Angenommen, ein NULL-Werte zulassen <xref:System.Int32> wird durch die Zeichenfolge "System.Nullable'1[System.Int32]" dargestellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2683">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-2684">In c#, C++ und Visual Basic können Sie auch auf NULL festlegbaren Typen, die mithilfe von Operatoren abrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2684">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="2da29-2685">Angenommen, die NULL-Werte zulässt <xref:System.Boolean> zurückgegebene Typ `typeof(Nullable<bool>)` in c# durch `Nullable<Boolean>::typeid` in C++ und in `GetType(Nullable(Of Boolean))` in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="2da29-2685">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="2da29-2686">Die folgende Tabelle zeigt die Syntax, die Sie mit `GetType` für verschiedene Typen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2686">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="2da29-2687">Zum Abrufen</span><span class="sxs-lookup"><span data-stu-id="2da29-2687">To Get</span></span>|<span data-ttu-id="2da29-2688">Mit</span><span class="sxs-lookup"><span data-stu-id="2da29-2688">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="2da29-2689">Ein NULL-Werte zulässt <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="2da29-2689">A nullable <xref:System.Int32></span></span>|<span data-ttu-id="2da29-2690">`Type.GetType("System.Nullable`1[System.Int32]")\`</span><span class="sxs-lookup"><span data-stu-id="2da29-2690">`Type.GetType("System.Nullable`1[System.Int32]")\`</span></span>|  
|<span data-ttu-id="2da29-2691">Ein nicht verwalteter Zeiger auf `MyType`</span><span class="sxs-lookup"><span data-stu-id="2da29-2691">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="2da29-2692">Ein nicht verwalteter Zeiger auf einen Zeiger auf `MyType`</span><span class="sxs-lookup"><span data-stu-id="2da29-2692">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="2da29-2693">Ein verwalteter Zeiger oder Verweis auf `MyType`</span><span class="sxs-lookup"><span data-stu-id="2da29-2693">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="2da29-2694">`Type.GetType("MyType&")`</span><span class="sxs-lookup"><span data-stu-id="2da29-2694">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="2da29-2695">Beachten Sie, dass Verweise im Gegensatz zu Zeigern auf eine Ebene beschränkt sind.</span><span class="sxs-lookup"><span data-stu-id="2da29-2695">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="2da29-2696">Eine übergeordnete Klasse und eine geschachtelte Klasse</span><span class="sxs-lookup"><span data-stu-id="2da29-2696">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="2da29-2697">Ein eindimensionales Array mit einer unteren Grenze von 0</span><span class="sxs-lookup"><span data-stu-id="2da29-2697">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyArray[]")`|  
|<span data-ttu-id="2da29-2698">Ein eindimensionales Array mit einer unbekannten Untergrenze</span><span class="sxs-lookup"><span data-stu-id="2da29-2698">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyArray[*]")`|  
|<span data-ttu-id="2da29-2699">Ein n-dimensionalen array</span><span class="sxs-lookup"><span data-stu-id="2da29-2699">An n-dimensional array</span></span>|<span data-ttu-id="2da29-2700">Ein Komma (,) innerhalb der Klammern eine insgesamt n-1 Mal.</span><span class="sxs-lookup"><span data-stu-id="2da29-2700">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="2da29-2701">Beispielsweise `System.Object[,,]` stellt eine dreidimensionale `Object` Array.</span><span class="sxs-lookup"><span data-stu-id="2da29-2701">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="2da29-2702">Ein zweidimensionales Array von Arrays</span><span class="sxs-lookup"><span data-stu-id="2da29-2702">A two-dimensional array's array</span></span>|`Type.GetType("MyArray[][]")`|  
|<span data-ttu-id="2da29-2703">Kein rechteckiges zweidimensionales Array mit unbekannten Untergrenzen</span><span class="sxs-lookup"><span data-stu-id="2da29-2703">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyArray[,]")`|  
|<span data-ttu-id="2da29-2704">Ein generischer Typ mit einem Typargument</span><span class="sxs-lookup"><span data-stu-id="2da29-2704">A generic type with one type argument</span></span>|<span data-ttu-id="2da29-2705">`Type.GetType("MyGenericType`1[MyType]")\`</span><span class="sxs-lookup"><span data-stu-id="2da29-2705">`Type.GetType("MyGenericType`1[MyType]")\`</span></span>|  
|<span data-ttu-id="2da29-2706">Ein generischer Typ mit zwei Typargumenten</span><span class="sxs-lookup"><span data-stu-id="2da29-2706">A generic type with two type arguments</span></span>|<span data-ttu-id="2da29-2707">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span><span class="sxs-lookup"><span data-stu-id="2da29-2707">`Type.GetType("MyGenericType`2[MyType,AnotherType]")\`</span></span>|  
|<span data-ttu-id="2da29-2708">Ein generischer Typ mit zwei durch die Assembly qualifizierten Typargumenten</span><span class="sxs-lookup"><span data-stu-id="2da29-2708">A generic type with two assembly-qualified type arguments</span></span>|<span data-ttu-id="2da29-2709">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")"</span><span class="sxs-lookup"><span data-stu-id="2da29-2709">`Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")\`</span></span>|  
|<span data-ttu-id="2da29-2710">Ein assemblyqualifizierten generischer Typ mit einem Assembly qualifizierten Typnamen-argument</span><span class="sxs-lookup"><span data-stu-id="2da29-2710">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|<span data-ttu-id="2da29-2711">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")"</span><span class="sxs-lookup"><span data-stu-id="2da29-2711">`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")\`</span></span>|  
|<span data-ttu-id="2da29-2712">Ein generischer Typ, dessen Type-Argument ein generischer Typ mit zwei Typargumenten ist</span><span class="sxs-lookup"><span data-stu-id="2da29-2712">A generic type whose type argument is a generic type with two type arguments</span></span>|<span data-ttu-id="2da29-2713">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span><span class="sxs-lookup"><span data-stu-id="2da29-2713">`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")`</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-2714">
            <paramref name="typeName" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2714">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="2da29-2715">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2715">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="2da29-2716">
            <paramref name="throwOnError" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2716">
              <paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span>
          </span>
          <span data-ttu-id="2da29-2717">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2717">-or-</span>
          </span>
          <span data-ttu-id="2da29-2718">
            <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2718">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span>
          </span>
          <span data-ttu-id="2da29-2719">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2719">-or-</span>
          </span>
          <span data-ttu-id="2da29-2720">
            <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> ist eine leere Zeichenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2720">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span>
          </span>
          <span data-ttu-id="2da29-2721">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2721">-or-</span>
          </span>
          <span data-ttu-id="2da29-2722">
            <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> stellt einen Arraytyp mit einer ungültigen Größe dar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2722">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span>
          </span>
          <span data-ttu-id="2da29-2723">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2723">-or-</span>
          </span>
          <span data-ttu-id="2da29-2724">
            <paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2724">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-2725">
            <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Syntax,</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2725">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax.</span>
          </span>
          <span data-ttu-id="2da29-2726">beispielsweise "MyType[,\*,]".</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2726">For example, "MyType[,\*,]".</span>
          </span>
          <span data-ttu-id="2da29-2727">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2727">-or-</span>
          </span>
          <span data-ttu-id="2da29-2728">
            <paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2728">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="2da29-2729">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2729">-or-</span>
          </span>
          <span data-ttu-id="2da29-2730">
            <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2730">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="2da29-2731">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2731">-or-</span>
          </span>
          <span data-ttu-id="2da29-2732">
            <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2732">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="2da29-2733">
            <paramref name="throwOnError" /> ist <see langword="true" />, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2733">
              <paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="2da29-2734">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2734">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="2da29-2735">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2735">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="2da29-2736">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2736">-or-</span>
          </span>
          <span data-ttu-id="2da29-2737">Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und die Assembly wurde mit einer höheren Version kompiliert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2737">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="2da29-2738">Der Name des abzurufenden Typs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2738">The name of the type to get.</span>
          </span>
          <span data-ttu-id="2da29-2739">Wenn der Parameter <c>typeResolver</c> bereitgestellt wird, kann der Typname jede Zeichenfolge sein, die vom <c>typeResolver</c> aufgelöst werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2739">If the <c>typeResolver</c> parameter is provided, the type name can be any string that <c>typeResolver</c> is capable of resolving.</span>
          </span>
          <span data-ttu-id="2da29-2740">Wenn der Parameter <c>assemblyResolver</c> bereitgestellt oder die Standardtypauflösung verwendet wird, muss es sich bei <c>typeName</c> um einen durch die Assembly qualifizierten Namen (siehe <see cref="P:System.Type.AssemblyQualifiedName" />) handeln, es sei denn, der Typ befindet sich in der gerade ausgeführten Assembly oder in der Datei Mscorlib.dll. In diesem Fall genügt es, den von seinem Namespace qualifizierten Typnamen anzugeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2740">If the <c>assemblyResolver</c> parameter is provided or if standard type resolution is used, <c>typeName</c> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <param name="assemblyResolver">
          <span data-ttu-id="2da29-2741">Eine Methode, die die Assembly sucht und zurückgibt, die in <c>typeName</c> angegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2741">A method that locates and returns the assembly that is specified in <c>typeName</c>.</span>
          </span>
          <span data-ttu-id="2da29-2742">Der Assemblyname wird als ein <see cref="T:System.Reflection.AssemblyName" />-Objekt an den <c>assemblyResolver</c> übergeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2742">The assembly name is passed to <c>assemblyResolver</c> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span>
          </span>
          <span data-ttu-id="2da29-2743">Wenn <c>typeName</c> keinen Namen einer Assembly enthält, wird der <c>assemblyResolver</c> nicht aufgerufen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2743">If <c>typeName</c> does not contain the name of an assembly, <c>assemblyResolver</c> is not called.</span>
          </span>
          <span data-ttu-id="2da29-2744">Wenn der <c>assemblyResolver</c> nicht angegeben wird, wird die Standardassemblyauflösung ausgeführt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2744">If <c>assemblyResolver</c> is not supplied, standard assembly resolution is performed.</span>
          </span>
          <span data-ttu-id="2da29-2745">Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2745">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
          <span data-ttu-id="2da29-2746">Andernfalls könnten Berechtigungen für bösartigen Code erweitert werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2746">Doing so could result in elevation of privilege for malicious code.</span>
          </span>
          <span data-ttu-id="2da29-2747">Verwenden Sie nur Methoden, die Sie bereitstellen oder mit denen Sie vertraut sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2747">Use only methods that you provide or that you are familiar with.</span>
          </span>
        </param>
        <param name="typeResolver">
          <span data-ttu-id="2da29-2748">Eine Methode, die den Typ sucht und zurückgibt, der von <c>typeName</c> von der Assembly angegeben wird, die vom <c>assemblyResolver</c> oder von der Standardassemblyauflösung zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2748">A method that locates and returns the type that is specified by <c>typeName</c> from the assembly that is returned by <c>assemblyResolver</c> or by standard assembly resolution.</span>
          </span>
          <span data-ttu-id="2da29-2749">Wenn keine Assembly bereitgestellt wird, kann die <c>assemblyResolver</c>-Methode eine Assembly zur Verfügung stellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2749">If no assembly is provided, the <c>typeResolver</c> method can provide one.</span>
          </span>
          <span data-ttu-id="2da29-2750">Die Methode nimmt auch einen Parameter an, der angibt, ob bei der Suche die Groß- und Kleinschreibung berücksichtigt werden soll; an diesen Parameter wird <see langword="false" /> übergeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2750">The method also takes a parameter that specifies whether to perform a case-insensitive search; <see langword="false" /> is passed to that parameter.</span>
          </span>
          <span data-ttu-id="2da29-2751">Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2751">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-2752">Ruft den Typ mit dem angegebenen Namen ab und stellt optional benutzerdefinierte Methoden bereit, um die Assembly und den Typ aufzulösen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2752">Gets the type with the specified name, optionally providing custom methods to resolve the assembly and the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-2753">Der Typ mit dem angegebenen Namen oder <see langword="null" />, wenn der Typ nicht gefunden wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2753">The type with the specified name, or <see langword="null" /> if the type is not found.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-2754">Verwendungsszenarien für diese Methode und die Details zu den `assemblyResolver` und `typeResolver` Parameter finden Sie in der <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> methodenüberladung.</span><span class="sxs-lookup"><span data-stu-id="2da29-2754">Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-2755">Wenn `typeName` kann nicht gefunden werden, den Aufruf der <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> -Methode zurückkehrt `null`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2755">If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> method returns `null`.</span></span> <span data-ttu-id="2da29-2756">Es wird keine Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="2da29-2756">It does not throw an exception.</span></span> <span data-ttu-id="2da29-2757">Um zu steuern, ob eine Ausnahme ausgelöst, rufen Sie eine Überladung der <xref:System.Type.GetType%2A> Methode, die eine `throwOnError` Parameter.</span><span class="sxs-lookup"><span data-stu-id="2da29-2757">To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.</span></span>  
  
 <span data-ttu-id="2da29-2758">Aufrufen der Überladung dieser Methode wird der gleiche wie das Aufrufen der <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> methodenüberladung und Angeben von `false` für die `throwOnError` und `ignoreCase` Parameter.</span><span class="sxs-lookup"><span data-stu-id="2da29-2758">Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `throwOnError` and `ignoreCase` parameters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-2759">
            <paramref name="typeName" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2759">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="2da29-2760">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2760">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-2761">Ein Fehler tritt auf, wenn <paramref name="typeName" /> in einen Typnamen und einen Assemblynamen analysiert wird (z. B. wenn der einfache Typname ein Sonderzeichen ohne Escapezeichen enthält).</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2761">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span>
          </span>
          <span data-ttu-id="2da29-2762">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2762">-or-</span>
          </span>
          <span data-ttu-id="2da29-2763">
            <paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2763">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="2da29-2764">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2764">-or-</span>
          </span>
          <span data-ttu-id="2da29-2765">
            <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2765">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="2da29-2766">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2766">-or-</span>
          </span>
          <span data-ttu-id="2da29-2767">
            <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2767">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="2da29-2768">
            <paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2768">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="2da29-2769">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2769">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
          <span data-ttu-id="2da29-2770">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2770">-or-</span>
          </span>
          <span data-ttu-id="2da29-2771">
            <paramref name="typeName" /> enthält einen ungültigen Assemblynamen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2771">
              <paramref name="typeName" /> contains an invalid assembly name.</span>
          </span>
          <span data-ttu-id="2da29-2772">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2772">-or-</span>
          </span>
          <span data-ttu-id="2da29-2773">
            <paramref name="typeName" /> ist ein gültiger Assemblyname ohne Typnamen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2773">
              <paramref name="typeName" /> is a valid assembly name without a type name.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="2da29-2774">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2774">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="2da29-2775">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2775">-or-</span>
          </span>
          <span data-ttu-id="2da29-2776">Die Assembly wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2776">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="2da29-2777">Der Name des abzurufenden Typs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2777">The name of the type to get.</span>
          </span>
          <span data-ttu-id="2da29-2778">Wenn der Parameter <c>typeResolver</c> bereitgestellt wird, kann der Typname jede Zeichenfolge sein, die vom <c>typeResolver</c> aufgelöst werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2778">If the <c>typeResolver</c> parameter is provided, the type name can be any string that <c>typeResolver</c> is capable of resolving.</span>
          </span>
          <span data-ttu-id="2da29-2779">Wenn der Parameter <c>assemblyResolver</c> bereitgestellt oder die Standardtypauflösung verwendet wird, muss es sich bei <c>typeName</c> um einen durch die Assembly qualifizierten Namen (siehe <see cref="P:System.Type.AssemblyQualifiedName" />) handeln, es sei denn, der Typ befindet sich in der gerade ausgeführten Assembly oder in der Datei Mscorlib.dll. In diesem Fall genügt es, den von seinem Namespace qualifizierten Typnamen anzugeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2779">If the <c>assemblyResolver</c> parameter is provided or if standard type resolution is used, <c>typeName</c> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <param name="assemblyResolver">
          <span data-ttu-id="2da29-2780">Eine Methode, die die Assembly sucht und zurückgibt, die in <c>typeName</c> angegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2780">A method that locates and returns the assembly that is specified in <c>typeName</c>.</span>
          </span>
          <span data-ttu-id="2da29-2781">Der Assemblyname wird als ein <see cref="T:System.Reflection.AssemblyName" />-Objekt an den <c>assemblyResolver</c> übergeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2781">The assembly name is passed to <c>assemblyResolver</c> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span>
          </span>
          <span data-ttu-id="2da29-2782">Wenn <c>typeName</c> keinen Namen einer Assembly enthält, wird der <c>assemblyResolver</c> nicht aufgerufen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2782">If <c>typeName</c> does not contain the name of an assembly, <c>assemblyResolver</c> is not called.</span>
          </span>
          <span data-ttu-id="2da29-2783">Wenn der <c>assemblyResolver</c> nicht angegeben wird, wird die Standardassemblyauflösung ausgeführt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2783">If <c>assemblyResolver</c> is not supplied, standard assembly resolution is performed.</span>
          </span>
          <span data-ttu-id="2da29-2784">Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2784">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
          <span data-ttu-id="2da29-2785">Andernfalls könnten Berechtigungen für bösartigen Code erweitert werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2785">Doing so could result in elevation of privilege for malicious code.</span>
          </span>
          <span data-ttu-id="2da29-2786">Verwenden Sie nur Methoden, die Sie bereitstellen oder mit denen Sie vertraut sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2786">Use only methods that you provide or that you are familiar with.</span>
          </span>
        </param>
        <param name="typeResolver">
          <span data-ttu-id="2da29-2787">Eine Methode, die den Typ sucht und zurückgibt, der von <c>typeName</c> von der Assembly angegeben wird, die vom <c>assemblyResolver</c> oder von der Standardassemblyauflösung zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2787">A method that locates and returns the type that is specified by <c>typeName</c> from the assembly that is returned by <c>assemblyResolver</c> or by standard assembly resolution.</span>
          </span>
          <span data-ttu-id="2da29-2788">Wenn keine Assembly bereitgestellt wird, kann die Methode eine Assembly zur Verfügung stellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2788">If no assembly is provided, the method can provide one.</span>
          </span>
          <span data-ttu-id="2da29-2789">Die Methode nimmt auch einen Parameter an, der angibt, ob bei der Suche die Groß- und Kleinschreibung berücksichtigt werden soll; an diesen Parameter wird <see langword="false" /> übergeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2789">The method also takes a parameter that specifies whether to perform a case-insensitive search; <see langword="false" /> is passed to that parameter.</span>
          </span>
          <span data-ttu-id="2da29-2790">Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2790">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="2da29-2791">
            <see langword="true" />, damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden werden kann, <see langword="false" />, damit <see langword="null" /> zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2791">
              <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2da29-2792">Die Angabe von <see langword="false" /> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2792">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span>
          </span>
          <span data-ttu-id="2da29-2793">Informationen finden Sie im Abschnitt für Ausnahmen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2793">See the Exceptions section.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-2794">Ruft den Typ mit dem angegebenen Namen ab. Dabei wird angegeben, ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird, und optional werden benutzerdefinierte Methoden bereitgestellt, um die Assembly und den Typ aufzulösen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2794">Gets the type with the specified name, specifying whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-2795">Der Typ mit dem angegebenen Namen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2795">The type with the specified name.</span>
          </span>
          <span data-ttu-id="2da29-2796">Wenn der Typ nicht gefunden wird, gibt der <paramref name="throwOnError" />-Parameter an, ob <see langword="null" /> zurückgegeben oder eine Ausnahme ausgelöst wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2796">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span>
          </span>
          <span data-ttu-id="2da29-2797">In einigen Fällen wird unabhängig vom Wert von <paramref name="throwOnError" /> eine Ausnahme ausgelöst.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2797">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span>
          </span>
          <span data-ttu-id="2da29-2798">Informationen finden Sie im Abschnitt für Ausnahmen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2798">See the Exceptions section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-2799">Verwendungsszenarien für diese Methode und die Details zu den `assemblyResolver` und `typeResolver` Parameter finden Sie in der <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> methodenüberladung.</span><span class="sxs-lookup"><span data-stu-id="2da29-2799">Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
 <span data-ttu-id="2da29-2800">Aufrufen der Überladung dieser Methode wird der gleiche wie das Aufrufen der <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> methodenüberladung und Angeben von `false` für die `ignoreCase` Parameter.</span><span class="sxs-lookup"><span data-stu-id="2da29-2800">Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `ignoreCase` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-2801">
            <paramref name="typeName" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2801">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="2da29-2802">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2802">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="2da29-2803">
            <paramref name="throwOnError" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2803">
              <paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span>
          </span>
          <span data-ttu-id="2da29-2804">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2804">-or-</span>
          </span>
          <span data-ttu-id="2da29-2805">
            <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2805">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span>
          </span>
          <span data-ttu-id="2da29-2806">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2806">-or-</span>
          </span>
          <span data-ttu-id="2da29-2807">
            <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> ist eine leere Zeichenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2807">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span>
          </span>
          <span data-ttu-id="2da29-2808">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2808">-or-</span>
          </span>
          <span data-ttu-id="2da29-2809">
            <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> stellt einen Arraytyp mit einer ungültigen Größe dar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2809">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span>
          </span>
          <span data-ttu-id="2da29-2810">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2810">-or-</span>
          </span>
          <span data-ttu-id="2da29-2811">
            <paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2811">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-2812">Ein Fehler tritt auf, wenn <paramref name="typeName" /> in einen Typnamen und einen Assemblynamen analysiert wird (z. B. wenn der einfache Typname ein Sonderzeichen ohne Escapezeichen enthält).</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2812">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span>
          </span>
          <span data-ttu-id="2da29-2813">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2813">-or-</span>
          </span>
          <span data-ttu-id="2da29-2814">
            <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Syntax (z. B. "MyType[,\*,]").</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2814">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax (for example, "MyType[,\*,]").</span>
          </span>
          <span data-ttu-id="2da29-2815">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2815">-or-</span>
          </span>
          <span data-ttu-id="2da29-2816">
            <paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2816">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="2da29-2817">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2817">-or-</span>
          </span>
          <span data-ttu-id="2da29-2818">
            <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2818">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="2da29-2819">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2819">-or-</span>
          </span>
          <span data-ttu-id="2da29-2820">
            <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2820">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="2da29-2821">
            <paramref name="throwOnError" /> ist <see langword="true" />, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2821">
              <paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span>
          </span>
          <span data-ttu-id="2da29-2822">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2822">-or-</span>
          </span>
          <span data-ttu-id="2da29-2823">
            <paramref name="typeName" /> enthält einen ungültigen Assemblynamen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2823">
              <paramref name="typeName" /> contains an invalid assembly name.</span>
          </span>
          <span data-ttu-id="2da29-2824">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2824">-or-</span>
          </span>
          <span data-ttu-id="2da29-2825">
            <paramref name="typeName" /> ist ein gültiger Assemblyname ohne Typnamen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2825">
              <paramref name="typeName" /> is a valid assembly name without a type name.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="2da29-2826">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, aber konnte nicht geladen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2826">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="2da29-2827">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2827">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="2da29-2828">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2828">-or-</span>
          </span>
          <span data-ttu-id="2da29-2829">Die Assembly wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2829">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="2da29-2830">Der Name des abzurufenden Typs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2830">The name of the type to get.</span>
          </span>
          <span data-ttu-id="2da29-2831">Wenn der Parameter <c>typeResolver</c> bereitgestellt wird, kann der Typname jede Zeichenfolge sein, die vom <c>typeResolver</c> aufgelöst werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2831">If the <c>typeResolver</c> parameter is provided, the type name can be any string that <c>typeResolver</c> is capable of resolving.</span>
          </span>
          <span data-ttu-id="2da29-2832">Wenn der Parameter <c>assemblyResolver</c> bereitgestellt oder die Standardtypauflösung verwendet wird, muss es sich bei <c>typeName</c> um einen durch die Assembly qualifizierten Namen (siehe <see cref="P:System.Type.AssemblyQualifiedName" />) handeln, es sei denn, der Typ befindet sich in der gerade ausgeführten Assembly oder in der Datei Mscorlib.dll. In diesem Fall genügt es, den von seinem Namespace qualifizierten Typnamen anzugeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2832">If the <c>assemblyResolver</c> parameter is provided or if standard type resolution is used, <c>typeName</c> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span>
          </span>
        </param>
        <param name="assemblyResolver">
          <span data-ttu-id="2da29-2833">Eine Methode, die die Assembly sucht und zurückgibt, die in <c>typeName</c> angegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2833">A method that locates and returns the assembly that is specified in <c>typeName</c>.</span>
          </span>
          <span data-ttu-id="2da29-2834">Der Assemblyname wird als ein <see cref="T:System.Reflection.AssemblyName" />-Objekt an den <c>assemblyResolver</c> übergeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2834">The assembly name is passed to <c>assemblyResolver</c> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span>
          </span>
          <span data-ttu-id="2da29-2835">Wenn <c>typeName</c> keinen Namen einer Assembly enthält, wird der <c>assemblyResolver</c> nicht aufgerufen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2835">If <c>typeName</c> does not contain the name of an assembly, <c>assemblyResolver</c> is not called.</span>
          </span>
          <span data-ttu-id="2da29-2836">Wenn der <c>assemblyResolver</c> nicht angegeben wird, wird die Standardassemblyauflösung ausgeführt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2836">If <c>assemblyResolver</c> is not supplied, standard assembly resolution is performed.</span>
          </span>
          <span data-ttu-id="2da29-2837">Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2837">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
          <span data-ttu-id="2da29-2838">Andernfalls könnten Berechtigungen für bösartigen Code erweitert werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2838">Doing so could result in elevation of privilege for malicious code.</span>
          </span>
          <span data-ttu-id="2da29-2839">Verwenden Sie nur Methoden, die Sie bereitstellen oder mit denen Sie vertraut sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2839">Use only methods that you provide or that you are familiar with.</span>
          </span>
        </param>
        <param name="typeResolver">
          <span data-ttu-id="2da29-2840">Eine Methode, die den Typ sucht und zurückgibt, der von <c>typeName</c> von der Assembly angegeben wird, die vom <c>assemblyResolver</c> oder von der Standardassemblyauflösung zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2840">A method that locates and returns the type that is specified by <c>typeName</c> from the assembly that is returned by <c>assemblyResolver</c> or by standard assembly resolution.</span>
          </span>
          <span data-ttu-id="2da29-2841">Wenn keine Assembly bereitgestellt wird, kann die Methode eine Assembly zur Verfügung stellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2841">If no assembly is provided, the method can provide one.</span>
          </span>
          <span data-ttu-id="2da29-2842">Die Methode nimmt auch einen Parameter an, der angibt, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll; der Wert von <c>ignoreCase</c> wird an diesen Parameter übergeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2842">The method also takes a parameter that specifies whether to perform a case-insensitive search; the value of <c>ignoreCase</c> is passed to that parameter.</span>
          </span>
          <span data-ttu-id="2da29-2843">Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2843">Caution   Do not pass methods from unknown or untrusted callers.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="2da29-2844">
            <see langword="true" />, damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden werden kann, <see langword="false" />, damit <see langword="null" /> zurückgegeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2844">
              <see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2da29-2845">Die Angabe von <see langword="false" /> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2845">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span>
          </span>
          <span data-ttu-id="2da29-2846">Informationen finden Sie im Abschnitt für Ausnahmen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2846">See the Exceptions section.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="2da29-2847">
            <see langword="true" />, um ohne Beachtung der Groß-/Kleinschreibung nach <c>typeName</c> zu suchen; <see langword="false" />, um mit Beachtung der Groß-/Kleinschreibung nach <c>typeName</c> zu suchen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2847">
              <see langword="true" /> to perform a case-insensitive search for <c>typeName</c>, <see langword="false" /> to perform a case-sensitive search for <c>typeName</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-2848">Ruft den Typ mit dem angegebenen Namen ab. Dabei wird angegeben, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll und ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird, und optional werden benutzerdefinierte Methoden bereitgestellt, um die Assembly und den Typ aufzulösen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2848">Gets the type with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-2849">Der Typ mit dem angegebenen Namen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2849">The type with the specified name.</span>
          </span>
          <span data-ttu-id="2da29-2850">Wenn der Typ nicht gefunden wird, gibt der <paramref name="throwOnError" />-Parameter an, ob <see langword="null" /> zurückgegeben oder eine Ausnahme ausgelöst wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2850">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span>
          </span>
          <span data-ttu-id="2da29-2851">In einigen Fällen wird unabhängig vom Wert von <paramref name="throwOnError" /> eine Ausnahme ausgelöst.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2851">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span>
          </span>
          <span data-ttu-id="2da29-2852">Informationen finden Sie im Abschnitt für Ausnahmen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2852">See the Exceptions section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-2853">Verwenden Sie diese methodenüberladung und ihre zugeordneten Überladungen (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> und <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) ersetzt die standardmäßige Implementierung des der <xref:System.Type.GetType%2A> Methode mit flexibler Implementierungen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2853">Use this method overload and its associated overloads (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> and <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) to replace the default implementation of the <xref:System.Type.GetType%2A> method with more flexible implementations.</span></span> <span data-ttu-id="2da29-2854">Durch Ihre eigenen Methoden, die aufgelöst werden Typnamen und die Namen der Assemblys, die sie enthalten, können Sie Folgendes tun:</span><span class="sxs-lookup"><span data-stu-id="2da29-2854">By providing your own methods that resolve type names and the names of the assemblies that contain them, you can do the following:</span></span>  
  
-   <span data-ttu-id="2da29-2855">Steuern Sie, welche Version einer Assembly, die ein Typ aus geladen wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-2855">Control which version of an assembly a type is loaded from.</span></span>  
  
-   <span data-ttu-id="2da29-2856">Geben Sie einen anderen Speicherort für für einen Typnamen zu suchen, die keine Namen einer Assembly enthalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-2856">Provide another place to look for a type name that does not include an assembly name.</span></span>  
  
-   <span data-ttu-id="2da29-2857">Laden von Assemblys mit partiellen Assemblynamen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2857">Load assemblies using partial assembly names.</span></span>  
  
-   <span data-ttu-id="2da29-2858">Zurückgeben von Unterklassen von <xref:System.Type?displayProperty=nameWithType> , die nicht von der common Language Runtime (CLR) erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2858">Return subclasses of <xref:System.Type?displayProperty=nameWithType> that are not created by the common language runtime (CLR).</span></span>  
  
 <span data-ttu-id="2da29-2859">Beispielsweise kann in versionstolerante dieser Methode suchen Sie nach einer "best fit"-Assembly mithilfe eines unvollständigen Namens.</span><span class="sxs-lookup"><span data-stu-id="2da29-2859">For example, in version-tolerant serialization this method enables you to search for a "best fit" assembly by using a partial name.</span></span> <span data-ttu-id="2da29-2860">Andere Überladungen der <xref:System.Type.GetType%2A> Methode benötigt einen Assembly qualifizierten Typnamen, die die Versionsnummer enthält.</span><span class="sxs-lookup"><span data-stu-id="2da29-2860">Other overloads of the <xref:System.Type.GetType%2A> method require an assembly-qualified type name, which includes the version number.</span></span>  
  
 <span data-ttu-id="2da29-2861">Alternative Implementierungen des Typsystems Unterklassen des zurückzugebenden müssen möglicherweise <xref:System.Type?displayProperty=nameWithType> , die von der CLR nicht erstellt werden, alle Typen, die von anderen Überladungen der zurückgegeben werden die <xref:System.Type.GetType%2A> Methode sind-Runtime-Typen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2861">Alternate implementations of the type system may need to return subclasses of <xref:System.Type?displayProperty=nameWithType> that are not created by the CLR; all types that are returned by other overloads of the <xref:System.Type.GetType%2A> method are runtime types.</span></span>  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a><span data-ttu-id="2da29-2862">Hinweise zur Verwendung</span><span class="sxs-lookup"><span data-stu-id="2da29-2862">Usage Notes</span></span>  
 <span data-ttu-id="2da29-2863">Überladung dieser Methode und ihre zugeordneten Überladungen analysieren `typeName` in den Namen eines Typs und den Namen einer Assembly, und klicken Sie dann den Namen aufzulösen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2863">This method overload and its associated overloads parse `typeName` into the name of a type and the name of an assembly, and then resolve the names.</span></span> <span data-ttu-id="2da29-2864">Auflösung des Assemblynamens tritt ein, bevor die Auflösung des Typnamens, da ein Typnamen im Kontext einer Assembly aufgelöst werden muss.</span><span class="sxs-lookup"><span data-stu-id="2da29-2864">Resolution of the assembly name occurs before resolution of the type name, because a type name must be resolved in the context of an assembly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-2865">Wenn Sie mit dem Konzept der Assembly qualifizierten Typnamen nicht vertraut sind, finden Sie unter der <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-2865">If you are unfamiliar with the concept of assembly-qualified type names, see the <xref:System.Type.AssemblyQualifiedName%2A> property.</span></span>  
  
 <span data-ttu-id="2da29-2866">Wenn `typeName` ist kein Assembly qualifizierter Name, Assemblyauflösung wird übersprungen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2866">If `typeName` is not an assembly-qualified name, assembly resolution is skipped.</span></span> <span data-ttu-id="2da29-2867">Nicht qualifizierte Typennamen können im Kontext von "mscorlib.dll" oder der aktuell ausgeführten Assembly aufgelöst werden, oder Sie können optional Bereitstellen einer Assembly in die `typeResolver` Parameter.</span><span class="sxs-lookup"><span data-stu-id="2da29-2867">Unqualified type names can be resolved in the context of Mscorlib.dll or the currently executing assembly, or you can optionally provide an assembly in the `typeResolver` parameter.</span></span> <span data-ttu-id="2da29-2868">Die Auswirkungen der ein- oder den Assemblynamen auslassen, für verschiedene Arten von namensauflösung, wie eine Tabelle in angezeigt werden der [gemischten namensauflösung](#mixed_name_resolution) Abschnitt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2868">The effects of including or omitting the assembly name for different kinds of name resolution are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section.</span></span>  
  
 <span data-ttu-id="2da29-2869">Allgemeine Verwendungshinweise:</span><span class="sxs-lookup"><span data-stu-id="2da29-2869">General usage notes:</span></span>  
  
-   <span data-ttu-id="2da29-2870">Übergeben Sie keine Methoden, um `assemblyResolver` oder `typeResolver` , wenn sie von unbekannten oder nicht vertrauenswürdigen Aufrufern stammen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2870">Do not pass methods to `assemblyResolver` or `typeResolver` if they come from unknown or untrusted callers.</span></span> <span data-ttu-id="2da29-2871">Verwenden Sie nur Methoden, die Sie bereitstellen oder mit denen Sie vertraut sind.</span><span class="sxs-lookup"><span data-stu-id="2da29-2871">Use only methods that you provide or that you are familiar with.</span></span>  
  
    > [!CAUTION]
    >  <span data-ttu-id="2da29-2872">Mithilfe der Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern kann zu einer Erhöhung von Berechtigungen für bösartigen Code führen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2872">Using methods from unknown or untrusted callers could result in elevation of privilege for malicious code.</span></span>  
  
-   <span data-ttu-id="2da29-2873">Wenn Sie weglassen der `assemblyResolver` und/oder `typeResolver` Parameter, der Wert der `throwOnError` Parameter übergeben wird, um die Methoden, die Standardlösung ausführen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2873">If you omit the `assemblyResolver` and/or `typeResolver` parameters, the value of the `throwOnError` parameter is passed to the methods that perform the default resolution.</span></span>  
  
-   <span data-ttu-id="2da29-2874">Wenn `throwOnError` ist `true`, löst diese Methode eine <xref:System.TypeLoadException> beim `typeResolver` gibt `null`, und ein <xref:System.IO.FileNotFoundException> Wenn `assemblyResolver` gibt `null`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2874">If `throwOnError` is `true`, this method throws a <xref:System.TypeLoadException> when `typeResolver` returns `null`, and a <xref:System.IO.FileNotFoundException> when `assemblyResolver` returns `null`.</span></span>  
  
-   <span data-ttu-id="2da29-2875">Diese Methode keine Ausnahmen ausgelöst werden, indem `assemblyResolver` und `typeResolver`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2875">This method does not catch exceptions thrown by `assemblyResolver` and `typeResolver`.</span></span> <span data-ttu-id="2da29-2876">Sie sind verantwortlich für alle Ausnahmen, die von den Konfliktlöser Methoden ausgelöst werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2876">You are responsible for any exceptions that are thrown by the resolver methods.</span></span>  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a><span data-ttu-id="2da29-2877">Auflösen von Assemblys</span><span class="sxs-lookup"><span data-stu-id="2da29-2877">Resolving Assemblies</span></span>  
 <span data-ttu-id="2da29-2878">Die `assemblyResolver` Methode empfängt einen <xref:System.Reflection.AssemblyName> -Objekt, das erzeugt wird, durch Analysieren der Zeichenfolge Assemblyname, der in enthalten ist `typeName`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2878">The `assemblyResolver` method receives an <xref:System.Reflection.AssemblyName> object, which is produced by parsing the string assembly name that is included in `typeName`.</span></span> <span data-ttu-id="2da29-2879">Wenn `typeName` enthält keinen Namen einer Assembly `assemblyResolver` wird nicht aufgerufen und `null` übergeben `typeResolver`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2879">If `typeName` does not contain an assembly name, `assemblyResolver` is not called and `null` is passed to `typeResolver`.</span></span>  
  
 <span data-ttu-id="2da29-2880">Wenn `assemblyResolver` ist nicht angegeben wird, Überprüfung wird verwendet, um die Assembly gesucht werden soll.</span><span class="sxs-lookup"><span data-stu-id="2da29-2880">If `assemblyResolver` is not supplied, standard assembly probing is used to locate the assembly.</span></span> <span data-ttu-id="2da29-2881">Wenn `assemblyResolver` angegeben ist, die <xref:System.Type.GetType%2A> Methode führt keine Standardsuche; in diesem Fall müssen Sie sicherstellen, dass Ihre `assemblyResolver` können behandeln alle Assemblys, die Sie an diesen weitergegeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-2881">If `assemblyResolver` is provided, the <xref:System.Type.GetType%2A> method does not do standard probing; in that case you must ensure that your `assemblyResolver` can handle all the assemblies you pass to it.</span></span>  
  
 <span data-ttu-id="2da29-2882">Die `assemblyResolver` -Methode zurückgeben sollte `null` Wenn die Assembly aufgelöst werden kann.</span><span class="sxs-lookup"><span data-stu-id="2da29-2882">The `assemblyResolver` method should return `null` if the assembly cannot be resolved.</span></span> <span data-ttu-id="2da29-2883">Wenn `assemblyResolver` gibt `null`, `typeResolver` wird nicht aufgerufen, und keine weitere Verarbeitung erfolgt; darüber hinaus Wenn `throwOnError` ist `true`, eine <xref:System.IO.FileNotFoundException> ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-2883">If `assemblyResolver` returns `null`, `typeResolver` is not called and no further processing occurs; additionally, if `throwOnError` is `true`, a <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="2da29-2884">Wenn die <xref:System.Reflection.AssemblyName> übergebene `assemblyResolver` ist eine partielle Name, eine oder mehrere Teile sind `null`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2884">If the <xref:System.Reflection.AssemblyName> that is passed to `assemblyResolver` is a partial name, one or more of its parts are `null`.</span></span> <span data-ttu-id="2da29-2885">Wenn sie keine Version verfügt beispielsweise die <xref:System.Reflection.AssemblyName.Version%2A> Eigenschaft ist `null`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2885">For example, if it has no version, the <xref:System.Reflection.AssemblyName.Version%2A> property is `null`.</span></span> <span data-ttu-id="2da29-2886">Wenn die <xref:System.Reflection.AssemblyName.Version%2A> -Eigenschaft, die <xref:System.Reflection.AssemblyName.CultureInfo%2A> -Eigenschaft, und die <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> alle-Methodenrückgabe `null`, und klicken Sie dann nur der einfache Namen der Assembly angegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="2da29-2886">If the <xref:System.Reflection.AssemblyName.Version%2A> property, the <xref:System.Reflection.AssemblyName.CultureInfo%2A> property, and the <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> method all return `null`, then only the simple name of the assembly was supplied.</span></span> <span data-ttu-id="2da29-2887">Die `assemblyResolver` Methode verwenden oder ignorieren Sie alle Teile des Assemblynamens.</span><span class="sxs-lookup"><span data-stu-id="2da29-2887">The `assemblyResolver` method can use or ignore all parts of the assembly name.</span></span>  
  
 <span data-ttu-id="2da29-2888">Die Auswirkungen der verschiedenen Auflösung Assemblyoptionen werden angezeigt, wie eine Tabelle in der [gemischten namensauflösung](#mixed_name_resolution) Abschnitt für einfache und Assembly qualifizierten Typnamen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2888">The effects of different assembly resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.</span></span>  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a><span data-ttu-id="2da29-2889">Auflösen von Typen</span><span class="sxs-lookup"><span data-stu-id="2da29-2889">Resolving Types</span></span>  
 <span data-ttu-id="2da29-2890">Wenn `typeName` gibt keinen Namen einer Assembly `typeResolver` wird immer aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2890">If `typeName` does not specify an assembly name, `typeResolver` is always called.</span></span> <span data-ttu-id="2da29-2891">Wenn `typeName` gibt den Namen einer Assembly `typeResolver` wird nur aufgerufen, wenn der Name der Assembly erfolgreich aufgelöst wurde.</span><span class="sxs-lookup"><span data-stu-id="2da29-2891">If `typeName` specifies an assembly name, `typeResolver` is called only when the assembly name is successfully resolved.</span></span> <span data-ttu-id="2da29-2892">Wenn `assemblyResolver` oder Standardassembly gibt `null`, `typeResolver` wird nicht aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2892">If `assemblyResolver` or standard assembly probing returns `null`, `typeResolver` is not called.</span></span>  
  
 <span data-ttu-id="2da29-2893">Die `typeResolver` -Methode empfängt drei Argumente:</span><span class="sxs-lookup"><span data-stu-id="2da29-2893">The `typeResolver` method receives three arguments:</span></span>  
  
-   <span data-ttu-id="2da29-2894">Die Assembly zu suchen oder `null` Wenn `typeName` enthält keinen Namen einer Assembly.</span><span class="sxs-lookup"><span data-stu-id="2da29-2894">The assembly to search or `null` if `typeName` does not contain an assembly name.</span></span>  
  
-   <span data-ttu-id="2da29-2895">Der einfache Name des Typs.</span><span class="sxs-lookup"><span data-stu-id="2da29-2895">The simple name of the type.</span></span> <span data-ttu-id="2da29-2896">Im Falle eines geschachtelten Typs ist dies der äußersten enthaltenden Typ.</span><span class="sxs-lookup"><span data-stu-id="2da29-2896">In the case of a nested type, this is the outermost containing type.</span></span> <span data-ttu-id="2da29-2897">Im Falle eines generischen Typs ist dies der einfache Name des generischen Typs.</span><span class="sxs-lookup"><span data-stu-id="2da29-2897">In the case of a generic type, this is the simple name of the generic type.</span></span>  
  
-   <span data-ttu-id="2da29-2898">Ein boolescher Wert, der `true` Wenn Typnamen die Groß-/Kleinschreibung ignoriert werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2898">A Boolean value that is `true` if the case of type names is to be ignored.</span></span>  
  
 <span data-ttu-id="2da29-2899">Die Implementierung bestimmt, wie diese Argumente verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2899">The implementation determines the way these arguments are used.</span></span> <span data-ttu-id="2da29-2900">Die `typeResolver` -Methode zurückgeben sollte `null` , wenn den Typ nicht auflösen kann.</span><span class="sxs-lookup"><span data-stu-id="2da29-2900">The `typeResolver` method should return `null` if it cannot resolve the type.</span></span> <span data-ttu-id="2da29-2901">Wenn `typeResolver` gibt `null` und `throwOnError` ist `true`, diese Überladung der <xref:System.Type.GetType%2A> löst eine <xref:System.TypeLoadException>.</span><span class="sxs-lookup"><span data-stu-id="2da29-2901">If `typeResolver` returns `null` and `throwOnError` is `true`, this overload of <xref:System.Type.GetType%2A> throws a <xref:System.TypeLoadException>.</span></span>  
  
 <span data-ttu-id="2da29-2902">Die Auswirkungen eines anderen Typs Optionen werden angezeigt, wie eine Tabelle in der [gemischten namensauflösung](#mixed_name_resolution) Abschnitt für einfache und Assembly qualifizierten Typnamen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2902">The effects of different type resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.</span></span>  
  
#### <a name="resolving-nested-types"></a><span data-ttu-id="2da29-2903">Auflösen von geschachtelten Typen</span><span class="sxs-lookup"><span data-stu-id="2da29-2903">Resolving Nested Types</span></span>  
 <span data-ttu-id="2da29-2904">Wenn `typeName` geschachtelter Typ, nur den Namen des äußersten übergeben wird, enthält Typ `typeResolver`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2904">If `typeName` is a nested type, only the name of the outermost containing type is passed to `typeResolver`.</span></span> <span data-ttu-id="2da29-2905">Wenn `typeResolver` diesen Typ zurückgibt, der <xref:System.Type.GetNestedType%2A> Methode rekursiv aufgerufen, bis der innersten geschachtelten Typ aufgelöst wurde.</span><span class="sxs-lookup"><span data-stu-id="2da29-2905">When `typeResolver` returns this type, the <xref:System.Type.GetNestedType%2A> method is called recursively until the innermost nested type has been resolved.</span></span>  
  
#### <a name="resolving-generic-types"></a><span data-ttu-id="2da29-2906">Auflösen von generischen Typen</span><span class="sxs-lookup"><span data-stu-id="2da29-2906">Resolving Generic Types</span></span>  
 <span data-ttu-id="2da29-2907">Die <xref:System.Type.GetType%2A> rekursiv aufgerufen, um generische Typen aufzulösen: zuerst an, um den generischen Typ selbst zu beheben und dann seine Typargumente aufgelöst.</span><span class="sxs-lookup"><span data-stu-id="2da29-2907">The <xref:System.Type.GetType%2A> is called recursively to resolve generic types: First to resolve the generic type itself, and then to resolve its type arguments.</span></span> <span data-ttu-id="2da29-2908">Wenn ein Argument vom Typ generisch ist, wird <xref:System.Type.GetType%2A> rekursiv aufgerufen, um zu seiner Typargumente beheben und so weiter.</span><span class="sxs-lookup"><span data-stu-id="2da29-2908">If a type argument is generic, <xref:System.Type.GetType%2A> is called recursively to resolve its type arguments, and so on.</span></span>  
  
 <span data-ttu-id="2da29-2909">Die Kombination von `assemblyResolver` und `typeResolver` der Auflösung dieses alle Stufen in der Lage sein, dass Sie zur Verfügung stellen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2909">The combination of `assemblyResolver` and `typeResolver` that you provide must be capable of resolving all levels of this recursion.</span></span> <span data-ttu-id="2da29-2910">Nehmen wir beispielsweise an, Sie geben eine `assemblyResolver` , steuert das Laden von `MyAssembly`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2910">For example, suppose you supply an `assemblyResolver` that controls the loading of `MyAssembly`.</span></span> <span data-ttu-id="2da29-2911">Angenommen, Sie möchten den generischen Typ aufgelöst `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-2911">Suppose you want to resolve the generic type `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` in Visual Basic).</span></span> <span data-ttu-id="2da29-2912">Sie können die folgenden Name des generischen Typs übergeben:</span><span class="sxs-lookup"><span data-stu-id="2da29-2912">You might pass the following generic type name:</span></span>  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 <span data-ttu-id="2da29-2913">Beachten Sie, dass `MyType` ist das Argument nur Assembly qualifizierten Typnamen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2913">Notice that `MyType` is the only assembly-qualified type argument.</span></span> <span data-ttu-id="2da29-2914">Die Namen der <xref:System.Collections.Generic.Dictionary%602> und <xref:System.String> Klassen sind nicht für die Assembly qualifizierten.</span><span class="sxs-lookup"><span data-stu-id="2da29-2914">The names of the <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String> classes are not assembly-qualified.</span></span> <span data-ttu-id="2da29-2915">Ihre `typeResolver` muss Handle kann entweder eine Assembly oder `null`, da er erhält `null` für <xref:System.Collections.Generic.Dictionary%602> und <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="2da29-2915">Your `typeResolver` must be able handle either an assembly or `null`, because it will receive `null` for <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String>.</span></span> <span data-ttu-id="2da29-2916">Sie können diesen Fall behandeln, durch Aufruf einer Überladung von der <xref:System.Type.GetType%2A> -Methode, die eine Zeichenfolge akzeptiert, da beide den nicht qualifizierten Typnamen in "mscorlib.dll" sind:</span><span class="sxs-lookup"><span data-stu-id="2da29-2916">It can handle that case by calling an overload of the <xref:System.Type.GetType%2A> method that takes a string, because both of the unqualified type names are in Mscorlib.dll:</span></span>  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 <span data-ttu-id="2da29-2917">Die `assemblyResolver` Methode wird für den Wörterbuchtyp und den String-Datentyp nicht aufgerufen, da diese Namen nicht Assembly qualifiziert sind.</span><span class="sxs-lookup"><span data-stu-id="2da29-2917">The `assemblyResolver` method is not called for the dictionary type and the string type, because those type names are not assembly-qualified.</span></span>  
  
 <span data-ttu-id="2da29-2918">Nehmen wir jetzt an, die anstelle von `System.String`, ist der erste generische Argumenttyp `YourType`, aus `YourAssembly`:</span><span class="sxs-lookup"><span data-stu-id="2da29-2918">Now suppose that instead of `System.String`, the first generic argument type is `YourType`, from `YourAssembly`:</span></span>  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 <span data-ttu-id="2da29-2919">Da diese Assembly weder "mscorlib.dll" als auch der aktuell ausgeführten Assembly ist, können Sie nicht auflösen `YourType` ohne ein Assembly qualifizierter Name.</span><span class="sxs-lookup"><span data-stu-id="2da29-2919">Because this assembly is neither Mscorlib.dll nor the currently executing assembly, you cannot resolve `YourType` without an assembly-qualified name.</span></span> <span data-ttu-id="2da29-2920">Da Ihre `assemblyResolve` werden rekursiv aufgerufen wird, muss er in diesem Fall können.</span><span class="sxs-lookup"><span data-stu-id="2da29-2920">Because your `assemblyResolve` will be called recursively, it must be able to handle this case.</span></span> <span data-ttu-id="2da29-2921">Anstatt `null` für andere Assemblys als `MyAssembly`, führt es jetzt Laden einer Assembly, die mit dem angegebenen <xref:System.Reflection.AssemblyName> Objekt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2921">Instead of returning `null` for assemblies other than `MyAssembly`, it now performs an assembly load using the supplied <xref:System.Reflection.AssemblyName> object.</span></span>  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 <span data-ttu-id="2da29-2922">Zurück zur [Verwendungshinweise](#usage_notes).</span><span class="sxs-lookup"><span data-stu-id="2da29-2922">Back to [Usage Notes](#usage_notes).</span></span>  
  
#### <a name="resolving-type-names-with-special-characters"></a><span data-ttu-id="2da29-2923">Auflösen von Typnamen mit Sonderzeichen</span><span class="sxs-lookup"><span data-stu-id="2da29-2923">Resolving Type Names with Special Characters</span></span>  
 <span data-ttu-id="2da29-2924">Bestimmte Zeichen eine besondere Bedeutung in assemblyqualifizierten Namen an.</span><span class="sxs-lookup"><span data-stu-id="2da29-2924">Certain characters have special meanings in assembly-qualified names.</span></span> <span data-ttu-id="2da29-2925">Wenn ein einfache Typname diese Zeichen enthält, verursachen die Zeichen Analysefehler aus, wenn der einfache Namen einer Assembly qualifizierte Name gehört.</span><span class="sxs-lookup"><span data-stu-id="2da29-2925">If a simple type name contains these characters, the characters cause parsing errors when the simple name is part of an assembly-qualified name.</span></span> <span data-ttu-id="2da29-2926">Um die Analysefehler zu vermeiden, müssen Sie die Sonderzeichen nicht mit einem umgekehrten Schrägstrich sein, bevor Sie die Assembly qualifizierte Name zu übergeben, können die <xref:System.Type.GetType%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-2926">To avoid the parsing errors, you must escape the special characters with a backslash before you can pass the assembly-qualified name to the <xref:System.Type.GetType%2A> method.</span></span> <span data-ttu-id="2da29-2927">Wenn ein Typ mit dem Namen wird z. B. `Strange]Type`, das Escape-Zeichen muss wie folgt vor die eckige Klammer hinzugefügt werden: `Strange\]Type`.</span><span class="sxs-lookup"><span data-stu-id="2da29-2927">For example, if a type is named `Strange]Type`, the escape character must be added ahead of the square bracket as follows: `Strange\]Type`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-2928">Namen mit solchen Sonderzeichen können nicht in Visual Basic oder c# erstellt werden, aber Sie können mithilfe von Microsoft intermediate Language (MSIL) oder durch Ausgeben von dynamischen Assemblys erstellt werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-2928">Names with such special characters cannot be created in Visual Basic or C#, but can be created by using Microsoft intermediate language (MSIL) or by emitting dynamic assemblies.</span></span>  
  
 <span data-ttu-id="2da29-2929">Die folgende Tabelle zeigt die Sonderzeichen für Typnamen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2929">The following table shows the special characters for type names.</span></span>  
  
|<span data-ttu-id="2da29-2930">Zeichen</span><span class="sxs-lookup"><span data-stu-id="2da29-2930">Character</span></span>|<span data-ttu-id="2da29-2931">Bedeutung</span><span class="sxs-lookup"><span data-stu-id="2da29-2931">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="2da29-2932">`,` (Komma)</span><span class="sxs-lookup"><span data-stu-id="2da29-2932">`,` (comma)</span></span>|<span data-ttu-id="2da29-2933">Trennzeichen für die Assembly qualifizierten Namen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2933">Delimiter for assembly-qualified names.</span></span>|  
|<span data-ttu-id="2da29-2934">`[]` (eckige Klammern)</span><span class="sxs-lookup"><span data-stu-id="2da29-2934">`[]` (square brackets)</span></span>|<span data-ttu-id="2da29-2935">Als Suffix paarweise angegeben gibt Sie einen Arraytyp an. als Trennzeichen paarweise angegeben umfasst generische Argumentlisten und qualifizierte Assemblynamen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2935">As a suffix pair, indicates an array type; as a delimiter pair, encloses generic argument lists and assembly-qualified names.</span></span>|  
|<span data-ttu-id="2da29-2936">`&` (kaufmännisches und-Zeichen)</span><span class="sxs-lookup"><span data-stu-id="2da29-2936">`&` (ampersand)</span></span>|<span data-ttu-id="2da29-2937">Gibt an, dass ein Typ ein Verweistyp ist, als Suffix.</span><span class="sxs-lookup"><span data-stu-id="2da29-2937">As a suffix, indicates that a type is a reference type.</span></span>|  
|<span data-ttu-id="2da29-2938">`*` (Sternchen)</span><span class="sxs-lookup"><span data-stu-id="2da29-2938">`*` (asterisk)</span></span>|<span data-ttu-id="2da29-2939">Gibt an, dass ein Typ ein Zeigertyp ist, als Suffix.</span><span class="sxs-lookup"><span data-stu-id="2da29-2939">As a suffix, indicates that a type is a pointer type.</span></span>|  
|<span data-ttu-id="2da29-2940">`+` (plus)</span><span class="sxs-lookup"><span data-stu-id="2da29-2940">`+` (plus)</span></span>|<span data-ttu-id="2da29-2941">Trennzeichen für geschachtelte Typen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2941">Delimiter for nested types.</span></span>|  
|<span data-ttu-id="2da29-2942">`\` (umgekehrter Schrägstrich)</span><span class="sxs-lookup"><span data-stu-id="2da29-2942">`\` (backslash)</span></span>|<span data-ttu-id="2da29-2943">Escape-Zeichen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2943">Escape character.</span></span>|  
  
 <span data-ttu-id="2da29-2944">Eigenschaften, z. B. <xref:System.Type.AssemblyQualifiedName%2A> Return Zeichenfolgen korrekt in Escapezeichen eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2944">Properties such as <xref:System.Type.AssemblyQualifiedName%2A> return correctly escaped strings.</span></span> <span data-ttu-id="2da29-2945">Müssen Sie ordnungsgemäß mit Escapezeichen versehene Zeichenfolgen zum Übergeben der <xref:System.Type.GetType%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-2945">You must pass correctly escaped strings to the <xref:System.Type.GetType%2A> method.</span></span> <span data-ttu-id="2da29-2946">Wiederum die <xref:System.Type.GetType%2A> Methode übergibt ordnungsgemäß mit Escapezeichen versehene Objektnamen `typeResolver` und Auflösung die Standardmethoden-Typ.</span><span class="sxs-lookup"><span data-stu-id="2da29-2946">In turn, the <xref:System.Type.GetType%2A> method passes correctly escaped names to `typeResolver` and to the default type resolution methods.</span></span> <span data-ttu-id="2da29-2947">Wenn Sie einen Namen, den Namen einer ohne Escapezeichen in Vergleichen `typeResolver`, müssen Sie die Escape-Zeichen entfernen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2947">If you need to compare a name to an unescaped name in `typeResolver`, you must remove the escape characters.</span></span>  
  
 <span data-ttu-id="2da29-2948">Zurück zur [Verwendungshinweise](#usage_notes).</span><span class="sxs-lookup"><span data-stu-id="2da29-2948">Back to [Usage Notes](#usage_notes).</span></span>  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a><span data-ttu-id="2da29-2949">Gemischte namensauflösung</span><span class="sxs-lookup"><span data-stu-id="2da29-2949">Mixed Name Resolution</span></span>  
 <span data-ttu-id="2da29-2950">Die folgende Tabelle enthält die Interaktionen zwischen `assemblyResolver`, `typeResolver`, und die standardmäßige namensauflösung für alle Kombinationen von Typ und Assemblynamen im `typeName`:</span><span class="sxs-lookup"><span data-stu-id="2da29-2950">The following table summarizes the interactions between `assemblyResolver`, `typeResolver`, and default name resolution, for all combinations of type name and assembly name in `typeName`:</span></span>  
  
|<span data-ttu-id="2da29-2951">Inhalt des Typnamens</span><span class="sxs-lookup"><span data-stu-id="2da29-2951">Contents of type name</span></span>|<span data-ttu-id="2da29-2952">Assembly-Resolver-Methode</span><span class="sxs-lookup"><span data-stu-id="2da29-2952">Assembly resolver method</span></span>|<span data-ttu-id="2da29-2953">Typ-Resolver-Methode</span><span class="sxs-lookup"><span data-stu-id="2da29-2953">Type resolver method</span></span>|<span data-ttu-id="2da29-2954">Ergebnis</span><span class="sxs-lookup"><span data-stu-id="2da29-2954">Result</span></span>|  
|---------------------------|------------------------------|--------------------------|------------|  
|<span data-ttu-id="2da29-2955">Typ-assembly</span><span class="sxs-lookup"><span data-stu-id="2da29-2955">type, assembly</span></span>|<span data-ttu-id="2da29-2956">NULL</span><span class="sxs-lookup"><span data-stu-id="2da29-2956">null</span></span>|<span data-ttu-id="2da29-2957">NULL</span><span class="sxs-lookup"><span data-stu-id="2da29-2957">null</span></span>|<span data-ttu-id="2da29-2958">Entspricht dem Aufrufen der <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> -methodenüberladung.</span><span class="sxs-lookup"><span data-stu-id="2da29-2958">Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload.</span></span>|  
|<span data-ttu-id="2da29-2959">Typ-assembly</span><span class="sxs-lookup"><span data-stu-id="2da29-2959">type, assembly</span></span>|<span data-ttu-id="2da29-2960">bereitgestellt</span><span class="sxs-lookup"><span data-stu-id="2da29-2960">provided</span></span>|<span data-ttu-id="2da29-2961">NULL</span><span class="sxs-lookup"><span data-stu-id="2da29-2961">null</span></span>|<span data-ttu-id="2da29-2962">`assemblyResolver` Gibt die Assembly zurück oder `null` Falls die Assembly aufgelöst werden kann.</span><span class="sxs-lookup"><span data-stu-id="2da29-2962">`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly.</span></span> <span data-ttu-id="2da29-2963">Wenn die Assembly aufgelöst wird, wird die <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> methodenüberladung wird verwendet, um den Typ aus der Assembly zu laden; andernfalls ist es versucht nicht, die den Typ aufzulösen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2963">If the assembly is resolved, the <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload is used to load the type from the assembly; otherwise, there is no attempt to resolve the type.</span></span>|  
|<span data-ttu-id="2da29-2964">Typ-assembly</span><span class="sxs-lookup"><span data-stu-id="2da29-2964">type, assembly</span></span>|<span data-ttu-id="2da29-2965">NULL</span><span class="sxs-lookup"><span data-stu-id="2da29-2965">null</span></span>|<span data-ttu-id="2da29-2966">bereitgestellt</span><span class="sxs-lookup"><span data-stu-id="2da29-2966">provided</span></span>|<span data-ttu-id="2da29-2967">Konvertiert den Namen der Ausgabeassembly ein <xref:System.Reflection.AssemblyName> Objekt und der Aufruf der <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> -methodenüberladung, um die Assembly zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-2967">Equivalent to converting the assembly name to an <xref:System.Reflection.AssemblyName> object and calling the <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> method overload to get the assembly.</span></span> <span data-ttu-id="2da29-2968">Wenn die Assembly aufgelöst wird, erfolgt eine Übergabe an `typeResolver`ist, andernfalls `typeResolver` wird nicht aufgerufen, und es gibt keinen weiteren Versuch, den Typ aufzulösen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2968">If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.</span></span>|  
|<span data-ttu-id="2da29-2969">Typ-assembly</span><span class="sxs-lookup"><span data-stu-id="2da29-2969">type, assembly</span></span>|<span data-ttu-id="2da29-2970">bereitgestellt</span><span class="sxs-lookup"><span data-stu-id="2da29-2970">provided</span></span>|<span data-ttu-id="2da29-2971">bereitgestellt</span><span class="sxs-lookup"><span data-stu-id="2da29-2971">provided</span></span>|<span data-ttu-id="2da29-2972">`assemblyResolver` Gibt die Assembly zurück oder `null` Falls die Assembly aufgelöst werden kann.</span><span class="sxs-lookup"><span data-stu-id="2da29-2972">`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly.</span></span> <span data-ttu-id="2da29-2973">Wenn die Assembly aufgelöst wird, erfolgt eine Übergabe an `typeResolver`ist, andernfalls `typeResolver` wird nicht aufgerufen, und es gibt keinen weiteren Versuch, den Typ aufzulösen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2973">If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.</span></span>|  
|<span data-ttu-id="2da29-2974">Typ</span><span class="sxs-lookup"><span data-stu-id="2da29-2974">type</span></span>|<span data-ttu-id="2da29-2975">NULL, bereitgestellt wird,</span><span class="sxs-lookup"><span data-stu-id="2da29-2975">null, provided</span></span>|<span data-ttu-id="2da29-2976">NULL</span><span class="sxs-lookup"><span data-stu-id="2da29-2976">null</span></span>|<span data-ttu-id="2da29-2977">Entspricht dem Aufrufen der <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> -methodenüberladung.</span><span class="sxs-lookup"><span data-stu-id="2da29-2977">Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="2da29-2978">Da der Assemblyname nicht angegeben wird, werden nur "mscorlib.dll" und der aktuell ausgeführten Assembly durchsucht.</span><span class="sxs-lookup"><span data-stu-id="2da29-2978">Because the assembly name is not provided, only Mscorlib.dll and the currently executing assembly are searched.</span></span> <span data-ttu-id="2da29-2979">Wenn `assemblyResolver` angegeben wird, diese ignoriert wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-2979">If `assemblyResolver` is provided, it is ignored.</span></span>|  
|<span data-ttu-id="2da29-2980">Typ</span><span class="sxs-lookup"><span data-stu-id="2da29-2980">type</span></span>|<span data-ttu-id="2da29-2981">NULL, bereitgestellt wird,</span><span class="sxs-lookup"><span data-stu-id="2da29-2981">null, provided</span></span>|<span data-ttu-id="2da29-2982">bereitgestellt</span><span class="sxs-lookup"><span data-stu-id="2da29-2982">provided</span></span>|<span data-ttu-id="2da29-2983">`typeResolver` wird aufgerufen, und `null` für die Assembly übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-2983">`typeResolver` is called, and `null` is passed for the assembly.</span></span> <span data-ttu-id="2da29-2984">`typeResolver` Geben Sie einen Typ können aus beliebigen Assemblys, einschließlich der Assemblys, die sie für diesen Zweck lädt.</span><span class="sxs-lookup"><span data-stu-id="2da29-2984">`typeResolver` can provide a type from any assembly, including assemblies it loads for the purpose.</span></span> <span data-ttu-id="2da29-2985">Wenn `assemblyResolver` angegeben wird, diese ignoriert wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-2985">If `assemblyResolver` is provided, it is ignored.</span></span>|  
|<span data-ttu-id="2da29-2986">Assembly</span><span class="sxs-lookup"><span data-stu-id="2da29-2986">assembly</span></span>|<span data-ttu-id="2da29-2987">NULL, bereitgestellt wird,</span><span class="sxs-lookup"><span data-stu-id="2da29-2987">null, provided</span></span>|<span data-ttu-id="2da29-2988">NULL, bereitgestellt wird,</span><span class="sxs-lookup"><span data-stu-id="2da29-2988">null, provided</span></span>|<span data-ttu-id="2da29-2989">Ein <xref:System.IO.FileLoadException> ausgelöst wird, da der Assemblyname analysiert wird, als handele es sich um eine Assembly qualifizierten Typnamen an.</span><span class="sxs-lookup"><span data-stu-id="2da29-2989">A <xref:System.IO.FileLoadException> is thrown, because the assembly name is parsed as if it were an assembly-qualified type name.</span></span> <span data-ttu-id="2da29-2990">Dies führt zu einem ungültigen Assemblynamen.</span><span class="sxs-lookup"><span data-stu-id="2da29-2990">This results in an invalid assembly name.</span></span>|  
  
 <span data-ttu-id="2da29-2991">Zurück zur: [Verwendungshinweise](#usage_notes), [Auflösen von Assemblys](#resolving_assemblies), [Auflösen von Typen](#resolving_types).</span><span class="sxs-lookup"><span data-stu-id="2da29-2991">Back to: [Usage Notes](#usage_notes), [Resolving Assemblies](#resolving_assemblies), [Resolving Types](#resolving_types).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-2992">
            <paramref name="typeName" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2992">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="2da29-2993">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2993">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="2da29-2994">
            <paramref name="throwOnError" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2994">
              <paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span>
          </span>
          <span data-ttu-id="2da29-2995">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2995">-or-</span>
          </span>
          <span data-ttu-id="2da29-2996">
            <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2996">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span>
          </span>
          <span data-ttu-id="2da29-2997">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2997">-or-</span>
          </span>
          <span data-ttu-id="2da29-2998">
            <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> ist eine leere Zeichenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2998">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span>
          </span>
          <span data-ttu-id="2da29-2999">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-2999">-or-</span>
          </span>
          <span data-ttu-id="2da29-3000">
            <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> stellt einen Arraytyp mit einer ungültigen Größe dar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3000">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span>
          </span>
          <span data-ttu-id="2da29-3001">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3001">-or-</span>
          </span>
          <span data-ttu-id="2da29-3002">
            <paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3002">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-3003">Ein Fehler tritt auf, wenn <paramref name="typeName" /> in einen Typnamen und einen Assemblynamen analysiert wird (z. B. wenn der einfache Typname ein Sonderzeichen ohne Escapezeichen enthält).</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3003">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span>
          </span>
          <span data-ttu-id="2da29-3004">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3004">-or-</span>
          </span>
          <span data-ttu-id="2da29-3005">
            <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Syntax (z. B. "MyType[,\*,]").</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3005">
              <paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax (for example, "MyType[,\*,]").</span>
          </span>
          <span data-ttu-id="2da29-3006">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3006">-or-</span>
          </span>
          <span data-ttu-id="2da29-3007">
            <paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3007">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="2da29-3008">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3008">-or-</span>
          </span>
          <span data-ttu-id="2da29-3009">
            <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3009">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="2da29-3010">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3010">-or-</span>
          </span>
          <span data-ttu-id="2da29-3011">
            <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3011">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="2da29-3012">
            <paramref name="throwOnError" /> ist <see langword="true" />, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3012">
              <paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="2da29-3013">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3013">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
          <span data-ttu-id="2da29-3014">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3014">-or-</span>
          </span>
          <span data-ttu-id="2da29-3015">
            <paramref name="typeName" /> enthält einen ungültigen Assemblynamen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3015">
              <paramref name="typeName" /> contains an invalid assembly name.</span>
          </span>
          <span data-ttu-id="2da29-3016">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3016">-or-</span>
          </span>
          <span data-ttu-id="2da29-3017">
            <paramref name="typeName" /> ist ein gültiger Assemblyname ohne Typnamen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3017">
              <paramref name="typeName" /> is a valid assembly name without a type name.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="2da29-3018">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3018">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="2da29-3019">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3019">-or-</span>
          </span>
          <span data-ttu-id="2da29-3020">Die Assembly wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3020">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">
          <span data-ttu-id="2da29-3021">Ein Array von Objekten, deren Typen bestimmt werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3021">An array of objects whose types to determine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-3022">Ruft die Typen der Objekte im angegebenen Array ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3022">Gets the types of the objects in the specified array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3023">Ein Array von <see cref="T:System.Type" />-Objekten, die die Typen der entsprechenden Elemente in <paramref name="args" /> darstellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3023">An array of <see cref="T:System.Type" /> objects representing the types of the corresponding elements in <paramref name="args" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="2da29-3024">Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Type.GetTypeArray%2A> Methode, um die Typen der Elemente eines Arrays aufführen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3024">The following code example demonstrates how to use the <xref:System.Type.GetTypeArray%2A> method to list the types of the elements of an array.</span></span>  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-3025">
            <paramref name="args" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3025">
              <paramref name="args" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2da29-3026">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3026">-or-</span>
          </span>
          <span data-ttu-id="2da29-3027">Mindestens eines der Elemente in <paramref name="args" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3027">One or more of the elements in <paramref name="args" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="2da29-3028">Die Klasseninitialisierer werden aufgerufen, und mindestens einer löst eine Ausnahme aus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3028">The class initializers are invoked and at least one throws an exception.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">
          <span data-ttu-id="2da29-3029">Der Typ, dessen zugrunde liegender Typcode abgerufen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3029">The type whose underlying type code to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-3030">Ruft den zugrunde liegenden Typcode des angegebenen <see cref="T:System.Type" /> ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3030">Gets the underlying type code of the specified <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3031">Der Code des zugrunde liegenden Typs oder <see cref="F:System.TypeCode.Empty" />, wenn <paramref name="type" /><see langword="null" /> ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3031">The code of the underlying type, or <see cref="F:System.TypeCode.Empty" /> if <paramref name="type" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3032">Beim Erben von <xref:System.Type>, Sie können das Verhalten dieser Methode ändern, durch Überschreiben der <xref:System.Type.GetTypeCodeImpl%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-3032">When you inherit from <xref:System.Type>, you can change the behavior of this method by overriding the <xref:System.Type.GetTypeCodeImpl%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3033">Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.TypeCode> Enumeration verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="2da29-3033">The following code example demonstrates how the <xref:System.TypeCode> enumeration can be used.</span></span> <span data-ttu-id="2da29-3034">In einem Entscheidungsblock innerhalb der `WriteObjectInfo` -Methode, die <xref:System.TypeCode> des ein <xref:System.Object> Parameter wird untersucht und eine entsprechende Meldung in die Konsole geschrieben wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-3034">In a decision block inside the `WriteObjectInfo` method, the <xref:System.TypeCode> of an <xref:System.Object> parameter is examined, and an appropriate message is written to the console.</span></span>  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3035">Gibt den zugrunde liegenden Typcode dieser <see cref="T:System.Type" />-Instanz zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3035">Returns the underlying type code of this <see cref="T:System.Type" /> instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3036">Der Typcode des zugrunde liegenden Typs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3036">The type code of the underlying type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3037">Diese Methode stellt die Implementierung für die `static` (in c#) oder `Shared` (in Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-3037">This method provides the implementation for the `static` (in C#) or `Shared` (in Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> method.</span></span> <span data-ttu-id="2da29-3038">Beim Erben von <xref:System.Type>, Sie können diese Methode, um eine eigene Implementierung bereitstellen überschreiben <xref:System.Type.GetTypeCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-3038">When you inherit from <xref:System.Type>, you can override this method to provide your own implementation of <xref:System.Type.GetTypeCode%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3039">Ruft den Typ ab, dem die angegebene Klassen-ID (CLSID) zugeordnet ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3039">Gets the type associated with the specified class identifier (CLSID).</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid">
          <span data-ttu-id="2da29-3040">Die CLSID des abzurufenden Typs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3040">The CLSID of the type to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-3041">Ruft den Typ ab, dem die angegebene Klassen-ID (CLSID) zugeordnet ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3041">Gets the type associated with the specified class identifier (CLSID).</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3042">
            <see langword="System.__ComObject" /> unabhängig von der Gültigkeit der CLSID.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3042">
              <see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3043">Die <xref:System.Type.GetTypeFromCLSID%2A> Methode unterstützt spät gebundener Zugriff auf nicht verwalteten COM-Objekte aus .NET Framework-apps, wenn Sie wissen, dass der Klassenbezeichner (CLSID) der COM-Objekt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3043">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="2da29-3044">Die Klassen-ID für COM-Klassen wird in den Schlüssel HKEY_CLASSES_ROOT\CLSID der Registrierung definiert.</span><span class="sxs-lookup"><span data-stu-id="2da29-3044">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="2da29-3045">Sie können den Wert der Abrufen der <xref:System.Type.IsCOMObject%2A> Eigenschaft, um zu bestimmen, ob der von dieser Methode zurückgegebene Typ ein COM-Objekt ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3045">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="2da29-3046">Sie erreichen die <xref:System.Type.GetTypeFromProgID%2A> Methode für spät gebundener Zugriff für COM-Objekte, deren programmatischen Bezeichner (ProgID), die Sie kennen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3046">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="2da29-3047">Instanziieren ein nicht verwaltetes COM-Objekt aus seiner CLSID ist ein zweistufiger Prozess:</span><span class="sxs-lookup"><span data-stu-id="2da29-3047">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="2da29-3048">Abrufen einer <xref:System.Type> Objekt, das darstellt der`__ComObject` , entspricht die CLSID durch Aufrufen der <xref:System.Type.GetTypeFromCLSID%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-3048">Get a <xref:System.Type> object that represents the`__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="2da29-3049">Rufen Sie die <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> Methode, um das COM-Objekt zu instanziieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-3049">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="2da29-3050">Siehe das Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="2da29-3050">See the example for an illustration.</span></span>  
  
 <span data-ttu-id="2da29-3051">Die <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> Überladung ignoriert alle Ausnahmen, die auftreten können, bei der Instanziierung einer <xref:System.Type> -Objekt auf Grundlage der `clsid` Argument.</span><span class="sxs-lookup"><span data-stu-id="2da29-3051">The <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> overload ignores any exception that may occur when instantiating a <xref:System.Type> object based on the `clsid` argument.</span></span> <span data-ttu-id="2da29-3052">Beachten Sie, die keine Ausnahme ausgelöst wird, wenn `clsid` befindet sich nicht in der Registrierung.</span><span class="sxs-lookup"><span data-stu-id="2da29-3052">Note that no exception is thrown if `clsid` is not found in the registry.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3053">Im folgenden Beispiel wird die CLSID der Microsoft Word [Anwendungsobjekt](http://msdn.microsoft.com/library/office/ff838565.aspx) ein COM-Typs abgerufen, die die Microsoft Word-Anwendung darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3053">The following example uses the CLSID of the Microsoft Word [Application object](http://msdn.microsoft.com/library/office/ff838565.aspx) to retrieve a COM type that represents the Microsoft Word application.</span></span> <span data-ttu-id="2da29-3054">Dann instanziiert den Typ durch Aufrufen der <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> -Methode und schließt ihn durch Aufrufen der [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-3054">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) method.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="2da29-3055">Diese Methode dient zur Verwendung bei der Arbeit mit COM-Objekte nicht mit .NET Framework-Objekten.</span>
            <span class="sxs-lookup">
              <span data-stu-id="2da29-3055">This method is intended for use when working with COM objects, not with .NET Framework objects.</span>
            </span>
            <span data-ttu-id="2da29-3056">Alle verwalteten Objekte, einschließlich derer, die für COM sichtbar sind (d. h. deren <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> -Attribut ist <see langword="true" />) haben eine GUID, die von zurückgegeben wird die <see cref="P:System.Type.GUID" /> Eigenschaft.</span>
            <span class="sxs-lookup">
              <span data-stu-id="2da29-3056">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span>
            </span>
            <span data-ttu-id="2da29-3057">Obwohl die Methode gibt ein <see cref="T:System.Type" /> -Objekten Objekt, das die GUID für .NET Framework entspricht, kann nicht verwendet <see cref="T:System.Type" /> Objekt so erstellen eine Instanz eines Datentyps durch Aufrufen der <see cref="M:System.Activator.CreateInstance(System.Type)" /> Methode, wie im folgenden Beispiel gezeigt.</span>
            <span class="sxs-lookup">
              <span data-stu-id="2da29-3057">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span>
            </span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 <span data-ttu-id="2da29-3058">Stattdessen die <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> sollte nur verwendet werden, um die GUID der nicht verwaltete COM-Objekte und die resultierende abrufen <see cref="T:System.Type" /> -Objekt, das an die <see cref="M:System.Activator.CreateInstance(System.Type)" /> Methode muss ein nicht verwaltetes COM-Objekt darstellen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3058">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">
          <span data-ttu-id="2da29-3059">Die CLSID des abzurufenden Typs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3059">The CLSID of the type to get.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="2da29-3060">
            <see langword="true" />, um mögliche Ausnahmen auszulösen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3060">
              <see langword="true" /> to throw any exception that occurs.</span>
          </span>
          <span data-ttu-id="2da29-3061">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3061">-or-</span>
          </span>
          <span data-ttu-id="2da29-3062">
            <see langword="false" />, um Ausnahmen zu ignorieren.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3062">
              <see langword="false" /> to ignore any exception that occurs.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-3063">Ruft den Typ ab, dem die angegebene Klassen-ID (CLSID) zugeordnet ist. Dabei wird angegeben, ob bei Auftreten eines Fehlers beim Laden des Typs eine Ausnahme ausgelöst werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3063">Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3064">
            <see langword="System.__ComObject" /> unabhängig von der Gültigkeit der CLSID.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3064">
              <see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3065">Die <xref:System.Type.GetTypeFromCLSID%2A> Methode unterstützt spät gebundener Zugriff auf nicht verwalteten COM-Objekte aus .NET Framework-apps, wenn Sie wissen, dass der Klassenbezeichner (CLSID) der COM-Objekt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3065">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="2da29-3066">Die Klassen-ID für COM-Klassen wird in den Schlüssel HKEY_CLASSES_ROOT\CLSID der Registrierung definiert.</span><span class="sxs-lookup"><span data-stu-id="2da29-3066">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="2da29-3067">Sie können den Wert der Abrufen der <xref:System.Type.IsCOMObject%2A> Eigenschaft, um zu bestimmen, ob der von dieser Methode zurückgegebene Typ ein COM-Objekt ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3067">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="2da29-3068">Sie erreichen die <xref:System.Type.GetTypeFromProgID%2A> Methode für spät gebundener Zugriff für COM-Objekte, deren programmatischen Bezeichner (ProgID), die Sie kennen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3068">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="2da29-3069">Instanziieren ein nicht verwaltetes COM-Objekt aus seiner CLSID ist ein zweistufiger Prozess:</span><span class="sxs-lookup"><span data-stu-id="2da29-3069">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="2da29-3070">Abrufen einer <xref:System.Type> Objekt, das darstellt der `__ComObject` , entspricht die CLSID durch Aufrufen der <xref:System.Type.GetTypeFromCLSID%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-3070">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="2da29-3071">Rufen Sie die <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> Methode, um das COM-Objekt zu instanziieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-3071">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="2da29-3072">Siehe das Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="2da29-3072">See the example for an illustration.</span></span>  
  
 <span data-ttu-id="2da29-3073">Ausnahmen wie <xref:System.OutOfMemoryException> wird ausgelöst, wenn die Angabe `true` für `throwOnError`, aber nicht registrierte CLSIDs führen nicht zu einem Fehler.</span><span class="sxs-lookup"><span data-stu-id="2da29-3073">Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3074">Im folgenden Beispiel wird die CLSID der Microsoft Word [Anwendungsobjekt](http://msdn.microsoft.com/library/office/ff838565.aspx) ein COM-Typs abgerufen, die die Microsoft Word-Anwendung darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3074">The following example uses the CLSID of the Microsoft Word [Application object](http://msdn.microsoft.com/library/office/ff838565.aspx) to retrieve a COM type that represents the Microsoft Word application.</span></span> <span data-ttu-id="2da29-3075">Dann instanziiert den Typ durch Aufrufen der <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> -Methode und schließt ihn durch Aufrufen der [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-3075">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) method.</span></span> <span data-ttu-id="2da29-3076">Eine Ausnahme wird ausgelöst, wenn beim Laden des Typs ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3076">An exception is thrown if an error occurs while loading the type.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="2da29-3077">Diese Methode dient zur Verwendung bei der Arbeit mit COM-Objekte nicht mit .NET Framework-Objekten.</span>
            <span class="sxs-lookup">
              <span data-stu-id="2da29-3077">This method is intended for use when working with COM objects, not with .NET Framework objects.</span>
            </span>
            <span data-ttu-id="2da29-3078">Alle verwalteten Objekte, einschließlich derer, die für COM sichtbar sind (d. h. deren <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> -Attribut ist <see langword="true" />) haben eine GUID, die von zurückgegeben wird die <see cref="P:System.Type.GUID" /> Eigenschaft.</span>
            <span class="sxs-lookup">
              <span data-stu-id="2da29-3078">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span>
            </span>
            <span data-ttu-id="2da29-3079">Obwohl die Methode gibt ein <see cref="T:System.Type" /> -Objekten Objekt, das die GUID für .NET Framework entspricht, kann nicht verwendet <see cref="T:System.Type" /> Objekt so erstellen eine Instanz eines Datentyps durch Aufrufen der <see cref="M:System.Activator.CreateInstance(System.Type)" /> Methode, wie im folgenden Beispiel gezeigt.</span>
            <span class="sxs-lookup">
              <span data-stu-id="2da29-3079">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span>
            </span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 <span data-ttu-id="2da29-3080">Stattdessen die <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> sollte nur verwendet werden, um die GUID der nicht verwaltete COM-Objekte und die resultierende abrufen <see cref="T:System.Type" /> -Objekt, das an die <see cref="M:System.Activator.CreateInstance(System.Type)" /> Methode muss ein nicht verwaltetes COM-Objekt darstellen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3080">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid">
          <span data-ttu-id="2da29-3081">Die CLSID des abzurufenden Typs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3081">The CLSID of the type to get.</span>
          </span>
        </param>
        <param name="server">
          <span data-ttu-id="2da29-3082">Der Server, von dem der Typ geladen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3082">The server from which to load the type.</span>
          </span>
          <span data-ttu-id="2da29-3083">Wenn der Servername <see langword="null" /> ist, wird diese Methode automatisch auf den lokalen Computer zurückgesetzt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3083">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-3084">Ruft den Typ, dem die angegebene Klassen-ID (CLSID) zugeordnet ist, vom angegebenen Server ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3084">Gets the type associated with the specified class identifier (CLSID) from the specified server.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3085">
            <see langword="System.__ComObject" /> unabhängig von der Gültigkeit der CLSID.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3085">
              <see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3086">Die <xref:System.Type.GetTypeFromCLSID%2A> Methode unterstützt spät gebundener Zugriff auf nicht verwalteten COM-Objekte aus .NET Framework-apps, wenn Sie wissen, dass der Klassenbezeichner (CLSID) der COM-Objekt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3086">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="2da29-3087">Die Klassen-ID für COM-Klassen wird in den Schlüssel HKEY_CLASSES_ROOT\CLSID der Registrierung definiert.</span><span class="sxs-lookup"><span data-stu-id="2da29-3087">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="2da29-3088">Sie können den Wert der Abrufen der <xref:System.Type.IsCOMObject%2A> Eigenschaft, um zu bestimmen, ob der von dieser Methode zurückgegebene Typ ein COM-Objekt ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3088">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="2da29-3089">Sie erreichen die <xref:System.Type.GetTypeFromProgID%2A> Methode für spät gebundener Zugriff für COM-Objekte, deren programmatischen Bezeichner (ProgID), die Sie kennen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3089">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="2da29-3090">Instanziieren ein nicht verwaltetes COM-Objekt aus seiner CLSID ist ein zweistufiger Prozess:</span><span class="sxs-lookup"><span data-stu-id="2da29-3090">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="2da29-3091">Abrufen einer <xref:System.Type> Objekt, das darstellt der `__ComObject` , entspricht die CLSID durch Aufrufen der <xref:System.Type.GetTypeFromCLSID%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-3091">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="2da29-3092">Rufen Sie die <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> Methode, um das COM-Objekt zu instanziieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-3092">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3093">Im folgenden Beispiel wird die CLSID der Microsoft Word [Anwendungsobjekt](http://msdn.microsoft.com/library/office/ff838565.aspx) ein COM-Typs abgerufen, die die Microsoft Word-Anwendung von einem pullserver namens computer17.central.contoso.com darstellt. Dann instanziiert den Typ durch Aufrufen der <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> -Methode und schließt ihn durch Aufrufen der [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-3093">The following example uses the CLSID of the Microsoft Word [Application object](http://msdn.microsoft.com/library/office/ff838565.aspx) to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com. It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) method.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="2da29-3094">Diese Methode dient zur Verwendung bei der Arbeit mit COM-Objekte nicht mit .NET Framework-Objekten.</span>
            <span class="sxs-lookup">
              <span data-stu-id="2da29-3094">This method is intended for use when working with COM objects, not with .NET Framework objects.</span>
            </span>
            <span data-ttu-id="2da29-3095">Alle verwalteten Objekte, einschließlich derer, die für COM sichtbar sind (d. h. deren <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> -Attribut ist <see langword="true" />) haben eine GUID, die von zurückgegeben wird die <see cref="P:System.Type.GUID" /> Eigenschaft.</span>
            <span class="sxs-lookup">
              <span data-stu-id="2da29-3095">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span>
            </span>
            <span data-ttu-id="2da29-3096">Obwohl die Methode gibt ein <see cref="T:System.Type" /> -Objekten Objekt, das die GUID für .NET Framework entspricht, kann nicht verwendet <see cref="T:System.Type" /> Objekt so erstellen eine Instanz eines Datentyps durch Aufrufen der <see cref="M:System.Activator.CreateInstance(System.Type)" /> Methode, wie im folgenden Beispiel gezeigt.</span>
            <span class="sxs-lookup">
              <span data-stu-id="2da29-3096">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span>
            </span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 <span data-ttu-id="2da29-3097">Stattdessen die <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> sollte nur verwendet werden, um die GUID der nicht verwaltete COM-Objekte und die resultierende abrufen <see cref="T:System.Type" /> -Objekt, das an die <see cref="M:System.Activator.CreateInstance(System.Type)" /> Methode muss ein nicht verwaltetes COM-Objekt darstellen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3097">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid">
          <span data-ttu-id="2da29-3098">Die CLSID des abzurufenden Typs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3098">The CLSID of the type to get.</span>
          </span>
        </param>
        <param name="server">
          <span data-ttu-id="2da29-3099">Der Server, von dem der Typ geladen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3099">The server from which to load the type.</span>
          </span>
          <span data-ttu-id="2da29-3100">Wenn der Servername <see langword="null" /> ist, wird diese Methode automatisch auf den lokalen Computer zurückgesetzt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3100">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="2da29-3101">
            <see langword="true" />, um mögliche Ausnahmen auszulösen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3101">
              <see langword="true" /> to throw any exception that occurs.</span>
          </span>
          <span data-ttu-id="2da29-3102">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3102">-or-</span>
          </span>
          <span data-ttu-id="2da29-3103">
            <see langword="false" />, um Ausnahmen zu ignorieren.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3103">
              <see langword="false" /> to ignore any exception that occurs.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-3104">Ruft den Typ, dem die angegebene Klassen-ID (CLSID) zugeordnet ist, vom angegebenen Server ab. Dabei wird angegeben, ob bei Auftreten eines Fehlers beim Laden des Typs eine Ausnahme ausgelöst werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3104">Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3105">
            <see langword="System.__ComObject" /> unabhängig von der Gültigkeit der CLSID.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3105">
              <see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3106">Die <xref:System.Type.GetTypeFromCLSID%2A> Methode unterstützt spät gebundener Zugriff auf nicht verwalteten COM-Objekte aus .NET Framework-apps, wenn Sie wissen, dass der Klassenbezeichner (CLSID) der COM-Objekt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3106">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="2da29-3107">Die Klassen-ID für COM-Klassen wird in den Schlüssel HKEY_CLASSES_ROOT\CLSID der Registrierung definiert.</span><span class="sxs-lookup"><span data-stu-id="2da29-3107">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="2da29-3108">Sie können den Wert der Abrufen der <xref:System.Type.IsCOMObject%2A> Eigenschaft, um zu bestimmen, ob der von dieser Methode zurückgegebene Typ ein COM-Objekt ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3108">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="2da29-3109">Sie erreichen die <xref:System.Type.GetTypeFromProgID%2A> Methode für spät gebundener Zugriff für COM-Objekte, deren programmatischen Bezeichner (ProgID), die Sie kennen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3109">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="2da29-3110">Instanziieren ein nicht verwaltetes COM-Objekt aus seiner CLSID ist ein zweistufiger Prozess:</span><span class="sxs-lookup"><span data-stu-id="2da29-3110">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="2da29-3111">Abrufen einer <xref:System.Type> Objekt, das darstellt der `__ComObject` , entspricht die CLSID durch Aufrufen der <xref:System.Type.GetTypeFromCLSID%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-3111">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="2da29-3112">Rufen Sie die <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> Methode, um das COM-Objekt zu instanziieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-3112">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="2da29-3113">Ausnahmen wie <xref:System.OutOfMemoryException> wird ausgelöst, wenn die Angabe `true` für `throwOnError`, aber nicht registrierte CLSIDs führen nicht zu einem Fehler.</span><span class="sxs-lookup"><span data-stu-id="2da29-3113">Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3114">Im folgenden Beispiel wird die CLSID der Microsoft Word [Anwendungsobjekt](http://msdn.microsoft.com/library/office/ff838565.aspx) ein COM-Typs abgerufen, die die Microsoft Word-Anwendung von einem pullserver namens computer17.central.contoso.com darstellt. Dann instanziiert den Typ durch Aufrufen der <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> -Methode und schließt ihn durch Aufrufen der [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-3114">The following example uses the CLSID of the Microsoft Word [Application object](http://msdn.microsoft.com/library/office/ff838565.aspx) to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com. It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) method.</span></span> <span data-ttu-id="2da29-3115">Eine Ausnahme wird ausgelöst, wenn beim Laden des Typs ein Fehler auftritt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3115">An exception is thrown if an error occurs while loading the type.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>
            <span data-ttu-id="2da29-3116">Diese Methode dient zur Verwendung bei der Arbeit mit COM-Objekte nicht mit .NET Framework-Objekten.</span>
            <span class="sxs-lookup">
              <span data-stu-id="2da29-3116">This method is intended for use when working with COM objects, not with .NET Framework objects.</span>
            </span>
            <span data-ttu-id="2da29-3117">Alle verwalteten Objekte, einschließlich derer, die für COM sichtbar sind (d. h. deren <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> -Attribut ist <see langword="true" />) haben eine GUID, die von zurückgegeben wird die <see cref="P:System.Type.GUID" /> Eigenschaft.</span>
            <span class="sxs-lookup">
              <span data-stu-id="2da29-3117">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span>
            </span>
            <span data-ttu-id="2da29-3118">Obwohl die <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> Methode gibt ein <see cref="T:System.Type" /> Objekt, das die GUID für ein bestimmtes verwaltetes Objekt entspricht, kann nicht verwendet <see cref="T:System.Type" /> Objekt so erstellen eine Instanz eines Datentyps durch Aufrufen der <see cref="M:System.Activator.CreateInstance(System.Type)" /> Methode, wie im folgenden Beispiel zeigt.</span>
            <span class="sxs-lookup">
              <span data-stu-id="2da29-3118">Although the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for a particular managed object, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span>
            </span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)]
 [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]  
  
 <span data-ttu-id="2da29-3119">Stattdessen die <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> sollte nur verwendet werden, um die GUID der nicht verwaltete COM-Objekte und die resultierende abrufen <see cref="T:System.Type" /> -Objekt, das an die <see cref="M:System.Activator.CreateInstance(System.Type)" /> Methode muss ein nicht verwaltetes COM-Objekt darstellen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3119">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">
          <span data-ttu-id="2da29-3120">Das Objekt, das auf den Typ verweist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3120">The object that refers to the type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-3121">Ruft den Typ ab, auf den das angegebene Typhandle verweist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3121">Gets the type referenced by the specified type handle.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3122">Der Typ, auf den das angegebene <see cref="T:System.RuntimeTypeHandle" /> verweist, oder <see langword="null" />, wenn die <see cref="P:System.RuntimeTypeHandle.Value" />-Eigenschaft von <paramref name="handle" /> den Wert <see langword="null" /> hat.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3122">The type referenced by the specified <see cref="T:System.RuntimeTypeHandle" />, or <see langword="null" /> if the <see cref="P:System.RuntimeTypeHandle.Value" /> property of <paramref name="handle" /> is <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3123">Die Handles gelten nur in der Anwendungsdomäne, in der sie erworben wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3123">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3124">Im folgenden Beispiel wird die <xref:System.Type.GetTypeFromHandle%2A> Methode zum Abrufen einer <xref:System.Type> -Objekt aus einer <xref:System.RuntimeTypeHandle> gebotenen die <xref:System.Type.GetTypeHandle%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-3124">The following example uses the <xref:System.Type.GetTypeFromHandle%2A> method to get a <xref:System.Type> object from a <xref:System.RuntimeTypeHandle> provided by the <xref:System.Type.GetTypeHandle%2A> method.</span></span>  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="2da29-3125">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3125">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3126">Ruft den Typ ab, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3126">Gets the type associated with the specified program identifier (ProgID).</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">
          <span data-ttu-id="2da29-3127">Die ProgID des abzurufenden Typs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3127">The ProgID of the type to get.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-3128">Ruft den Typ ab, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist. Wenn beim Laden des <see cref="T:System.Type" /> ein Fehler auftritt, wird NULL zurückgegeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3128">Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3129">Der Typ, dem die angegebene ProgID zugeordnet ist, wenn <paramref name="progID" /> ein gültiger Eintrag in der Registrierung ist und diesem ein Typ zugeordnet ist, andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3129">The type associated with the specified ProgID, if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3130">Diese Methode wird bereitgestellt, für COM-Unterstützung.</span><span class="sxs-lookup"><span data-stu-id="2da29-3130">This method is provided for COM support.</span></span> <span data-ttu-id="2da29-3131">Versionsabhängige Programm-IDs werden nicht in Microsoft .NET Framework verwendet, da sie durch das Konzept der Namespace ersetzt wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3131">ProgIDs are not used in the Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-3132">
            <paramref name="progID" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3132">
              <paramref name="progID" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="2da29-3133">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3133">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="2da29-3134">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3134">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">
          <span data-ttu-id="2da29-3135">Die ProgID des abzurufenden Typs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3135">The ProgID of the type to get.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="2da29-3136">
            <see langword="true" />, um mögliche Ausnahmen auszulösen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3136">
              <see langword="true" /> to throw any exception that occurs.</span>
          </span>
          <span data-ttu-id="2da29-3137">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3137">-or-</span>
          </span>
          <span data-ttu-id="2da29-3138">
            <see langword="false" />, um Ausnahmen zu ignorieren.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3138">
              <see langword="false" /> to ignore any exception that occurs.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-3139">Ruft den Typ ab, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist. Dabei wird angegeben, ob bei Auftreten eines Fehlers beim Laden des Typs eine Ausnahme ausgelöst werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3139">Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3140">Der Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, wenn <paramref name="progID" /> ein gültiger Eintrag in der Registrierung ist und diesem ein Typ zugeordnet ist, andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3140">The type associated with the specified program identifier (ProgID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3141">Diese Methode wird bereitgestellt, für COM-Unterstützung.</span><span class="sxs-lookup"><span data-stu-id="2da29-3141">This method is provided for COM support.</span></span> <span data-ttu-id="2da29-3142">Programm-IDs werden nicht in Microsoft .NET Framework verwendet, da sie durch das Konzept der Namespace ersetzt wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3142">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3143">Im folgende Beispiel ruft einen Typ ab, durch Übergeben einer ProgID, der angibt, ob eine Ausnahme auslöst, wenn die ProgID ungültig ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3143">The following example retrieves a type by passing a ProgID, specifying whether to throw an exception if the ProgID is invalid.</span></span> <span data-ttu-id="2da29-3144">Das Beispiel zeigt dann die ClassID im Zusammenhang mit der ProgID sowie alle anwendbaren Ausnahmemeldung.</span><span class="sxs-lookup"><span data-stu-id="2da29-3144">The example then displays the ClassID related to the ProgID, along with any applicable exception message.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-3145">
            <paramref name="progID" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3145">
              <paramref name="progID" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <span data-ttu-id="2da29-3146">Die angegebene ProgID ist nicht registriert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3146">The specified ProgID is not registered.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="2da29-3147">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3147">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="2da29-3148">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3148">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID">
          <span data-ttu-id="2da29-3149">Die ProgID des abzurufenden Typs.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3149">The progID of the type to get.</span>
          </span>
        </param>
        <param name="server">
          <span data-ttu-id="2da29-3150">Der Server, von dem der Typ geladen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3150">The server from which to load the type.</span>
          </span>
          <span data-ttu-id="2da29-3151">Wenn der Servername <see langword="null" /> ist, wird diese Methode automatisch auf den lokalen Computer zurückgesetzt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3151">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-3152">Ruft den Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, vom angegebenen Server ab. Wenn bei Laden des Typs ein Fehler auftritt, wird NULL zurückgegeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3152">Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3153">Der Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, wenn <paramref name="progID" /> ein gültiger Eintrag in der Registrierung ist und diesem ein Typ zugeordnet ist, andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3153">The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3154">Diese Methode wird bereitgestellt, für COM-Unterstützung.</span><span class="sxs-lookup"><span data-stu-id="2da29-3154">This method is provided for COM support.</span></span> <span data-ttu-id="2da29-3155">Programm-IDs werden nicht in Microsoft .NET Framework verwendet, da sie durch das Konzept der Namespace ersetzt wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3155">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3156">Im folgende Beispiel ruft einen Typ ab, durch die Übergabe einer ProgID "und" Server-Namens.</span><span class="sxs-lookup"><span data-stu-id="2da29-3156">The following example retrieves a type by passing a ProgID and server name.</span></span> <span data-ttu-id="2da29-3157">Im Beispiel für die ClassID angezeigt, die ProgID oder löst eine Ausnahme aus, wenn die ProgID oder den Namen des Servers ungültig ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3157">The example then displays the ClassID related to the ProgID, or throws an exception if the ProgID or the server name is invalid.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-3158">
            <paramref name="prodID" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3158">
              <paramref name="prodID" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="2da29-3159">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3159">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="2da29-3160">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3160">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID">
          <span data-ttu-id="2da29-3161">Die ProgID des abzurufenden <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3161">The progID of the <see cref="T:System.Type" /> to get.</span>
          </span>
        </param>
        <param name="server">
          <span data-ttu-id="2da29-3162">Der Server, von dem der Typ geladen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3162">The server from which to load the type.</span>
          </span>
          <span data-ttu-id="2da29-3163">Wenn der Servername <see langword="null" /> ist, wird diese Methode automatisch auf den lokalen Computer zurückgesetzt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3163">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span>
          </span>
        </param>
        <param name="throwOnError">
          <span data-ttu-id="2da29-3164">
            <see langword="true" />, um mögliche Ausnahmen auszulösen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3164">
              <see langword="true" /> to throw any exception that occurs.</span>
          </span>
          <span data-ttu-id="2da29-3165">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3165">-or-</span>
          </span>
          <span data-ttu-id="2da29-3166">
            <see langword="false" />, um Ausnahmen zu ignorieren.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3166">
              <see langword="false" /> to ignore any exception that occurs.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-3167">Ruft den Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, vom angegebenen Server ab. Dabei wird angegeben, ob bei Auftreten eines Fehlers beim Laden des Typs eine Ausnahme ausgelöst werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3167">Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3168">Der Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, wenn <paramref name="progID" /> ein gültiger Eintrag in der Registrierung ist und diesem ein Typ zugeordnet ist, andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3168">The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3169">Diese Methode wird bereitgestellt, für COM-Unterstützung.</span><span class="sxs-lookup"><span data-stu-id="2da29-3169">This method is provided for COM support.</span></span> <span data-ttu-id="2da29-3170">Programm-IDs werden nicht in Microsoft .NET Framework verwendet, da sie durch das Konzept der Namespace ersetzt wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3170">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3171">Im folgende Beispiel ruft einen Typ ab, durch die Übergabe einer ProgID "und" Server-Namens.</span><span class="sxs-lookup"><span data-stu-id="2da29-3171">The following example retrieves a type by passing a ProgID and server name.</span></span> <span data-ttu-id="2da29-3172">Das Beispiel zeigt dann die ClassID im Zusammenhang mit der ProgID angeben, ob eine Ausnahme auslöst, wenn die ProgID oder den Namen des Servers ungültig ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3172">The example then displays the ClassID related to the ProgID, specifying whether to throw an exception if the ProgID or the server name is invalid.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-3173">
            <paramref name="progID" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3173">
              <paramref name="progID" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">
          <span data-ttu-id="2da29-3174">Die angegebene progID ist nicht registriert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3174">The specified progID is not registered.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="2da29-3175">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3175">Requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="2da29-3176">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3176">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="2da29-3177">Das Objekt, für das das Typhandle abgerufen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3177">The object for which to get the type handle.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-3178">Ruft das Handle für den <see cref="T:System.Type" />-Wert eines angegebenen Objekts ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3178">Gets the handle for the <see cref="T:System.Type" /> of a specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3179">Das Handle für den <see cref="T:System.Type" /> des angegebenen <see cref="T:System.Object" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3179">The handle for the <see cref="T:System.Type" /> of the specified <see cref="T:System.Object" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3180">Die Handles gelten nur in der Anwendungsdomäne, in der sie erworben wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3180">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3181">Das folgende Beispiel definiert die Klasse `MyClass1`, ruft eine Instanz des Zertifikats ab und ruft die Common Language Runtime Handle des Objekts ab.</span><span class="sxs-lookup"><span data-stu-id="2da29-3181">The following example defines the class `MyClass1`, gets an instance of it, and retrieves the runtime handle of the object.</span></span>  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-3182">
            <paramref name="o" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3182">
              <paramref name="o" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3183">Ruft die dem <see cref="T:System.Type" /> zugeordnete GUID ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3183">Gets the GUID associated with the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3184">Die dem <see cref="T:System.Type" /> zugeordnete GUID.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3184">The GUID associated with the <see cref="T:System.Type" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3185">Eine GUID bezieht sich auf einen Typ mit dem <xref:System.Runtime.InteropServices.GuidAttribute> Attribut.</span><span class="sxs-lookup"><span data-stu-id="2da29-3185">A GUID is associated with a type using the <xref:System.Runtime.InteropServices.GuidAttribute> attribute.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3186">Im folgenden Beispiel wird die Klasse `MyClass1` mit einer öffentlichen Methode erstellt eine `Type` , Objekt entspricht `MyClass1`, und ruft die <xref:System.Guid> -Struktur unter Verwendung der `GUID` Eigenschaft von der `Type` Klasse.</span><span class="sxs-lookup"><span data-stu-id="2da29-3186">The following example creates the class `MyClass1` with a public method, creates a `Type` object corresponding to `MyClass1`, and gets the <xref:System.Guid> structure using the `GUID` property of the `Type` class.</span></span>  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3187">Ruft einen Wert ab, der angibt, ob der aktuelle <see cref="T:System.Type" /> einen anderen Typ umfasst oder auf einen anderen Typ verweist, d. h. ob der aktuelle <see cref="T:System.Type" /> ein Array oder ein Zeiger ist oder als Verweis übergeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3187">Gets a value indicating whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3188">
            <see langword="true" />, wenn <see cref="T:System.Type" /> ein Array oder ein Zeiger ist oder als Verweis übergeben wird, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3188">
              <see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3189">Beispielsweise Type.GetType("Int32[]"). HasElementType gibt `true`, wohingegen Type.GetType("Int32"). HasElementType gibt `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3189">For example, Type.GetType("Int32[]").HasElementType returns `true`, but Type.GetType("Int32").HasElementType returns `false`.</span></span> <span data-ttu-id="2da29-3190">HasElementType gibt auch `true` für "Int32 \*" und "Int32 &".</span><span class="sxs-lookup"><span data-stu-id="2da29-3190">HasElementType also returns `true` for "Int32\*" and "Int32&".</span></span>  
  
 <span data-ttu-id="2da29-3191">Wenn die aktuelle <xref:System.Type> stellt einen generischen Typ oder Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Eigenschaft gibt immer `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3191">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3192">Das folgende Beispiel gibt `true` oder `false` abhängig davon, ob das Objekt ein Array, ein Verweistyp oder ein Zeiger ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3192">The following example returns `true` or `false` depending on whether or not the object is an array, a reference type, or a pointer.</span></span>  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3193">Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.HasElementType" />-Eigenschaft und bestimmt, ob der aktuelle <see cref="T:System.Type" /> einen anderen Typ umfasst oder auf einen solchen verweist, d. h. ob der aktuelle <see cref="T:System.Type" /> ein Array oder Zeiger ist oder als Verweis übergeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3193">When overridden in a derived class, implements the <see cref="P:System.Type.HasElementType" /> property and determines whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3194">
            <see langword="true" />, wenn <see cref="T:System.Type" /> ein Array oder ein Zeiger ist oder als Verweis übergeben wird, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3194">
              <see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3195">Beispielsweise Type.GetType("Int32[]"). HasElementTypeImpl gibt `true`, wohingegen Type.GetType("Int32"). HasElementTypeImpl gibt `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3195">For example, Type.GetType("Int32[]").HasElementTypeImpl returns `true`, but Type.GetType("Int32").HasElementTypeImpl returns `false`.</span></span> <span data-ttu-id="2da29-3196">HasElementTypeImpl gibt auch `true` für "Int32 \*" und "Int32 &".</span><span class="sxs-lookup"><span data-stu-id="2da29-3196">HasElementTypeImpl also returns `true` for "Int32\*" and "Int32&".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3197">Das folgende Beispiel definiert die Klasse `MyTypeDelegator`, welche Außerkraftsetzungen der `HasElementTypeImpl` Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-3197">The following example defines the class `MyTypeDelegator`, which overrides the `HasElementTypeImpl` method.</span></span> <span data-ttu-id="2da29-3198">Die Hauptklasse überprüft die `HasElementType` Eigenschaft und zeigt den Elementtyp an.</span><span class="sxs-lookup"><span data-stu-id="2da29-3198">The main class checks for the `HasElementType` property and displays the element type.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3199">Ruft einen bestimmten Member vom aktuellen <see cref="T:System.Type" /> auf.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3199">Invokes a specific member of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-3200">Die Zeichenfolge, die den Namen des Konstruktors, der Methode, der Eigenschaft oder des Feldmembers enthält, der bzw. die aufgerufen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3200">The string containing the name of the constructor, method, property, or field member to invoke.</span>
          </span>
          <span data-ttu-id="2da29-3201">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3201">-or-</span>
          </span>
          <span data-ttu-id="2da29-3202">Eine leere Zeichenfolge ("") zum Aufrufen des Standardmembers.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3202">An empty string ("") to invoke the default member.</span>
          </span>
          <span data-ttu-id="2da29-3203">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3203">-or-</span>
          </span>
          <span data-ttu-id="2da29-3204">Für <see langword="IDispatch" />-Member eine Zeichenfolge, die die DispID darstellt, z. B. "[DispID=3]".</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3204">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="2da29-3205">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3205">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="2da29-3206">Der Zugriff kann aus einem der <see langword="BindingFlags" /> wie <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> usw. bestehen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3206">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span>
          </span>
          <span data-ttu-id="2da29-3207">Die Art der Suche muss nicht angegeben werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3207">The type of lookup need not be specified.</span>
          </span>
          <span data-ttu-id="2da29-3208">Wenn die Art der Suche nicht angegeben ist, werden <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> verwendet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3208">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="2da29-3209">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3209">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="2da29-3210">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3210">-or-</span>
          </span>
          <span data-ttu-id="2da29-3211">Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3211">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
          <span data-ttu-id="2da29-3212">Beachten Sie, dass möglicherweise ein <see cref="T:System.Reflection.Binder" />-Objekt explizit definiert werden muss, um erfolgreich Methodenüberladungen mit Variablenargumenten aufrufen zu können.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3212">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="2da29-3213">Das Objekt, für das der angegebene Member aufgerufen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3213">The object on which to invoke the specified member.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="2da29-3214">Ein Array mit den Argumenten, die dem aufzurufenden Member übergeben werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3214">An array containing the arguments to pass to the member to invoke.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-3215">Ruft den angegebenen Member auf, der den angegebenen Bindungseinschränkungen und der angegebenen Argumentliste entspricht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3215">Invokes the specified member, using the specified binding constraints and matching the specified argument list.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3216">Ein Objekt, das den Rückgabewert des aufgerufenen Members darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3216">An object representing the return value of the invoked member.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="2da29-3217">Sie können keine <xref:System.Type.InvokeMember%2A> um eine generische Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3217">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="2da29-3218">Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Member in die Suche einbezogen werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-3218">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="2da29-3219">Geben Sie `BindingFlags.Public` auf öffentliche Member in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3219">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="2da29-3220">Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Member (d. h. private und geschützte Member) in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3220">Specify `BindingFlags.NonPublic` to include non-public members (that is, private and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="2da29-3221">Geben Sie `BindingFlags.FlattenHierarchy` statische Mitglieder der Hierarchie aufwärts eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3221">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="2da29-3222">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</span><span class="sxs-lookup"><span data-stu-id="2da29-3222">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="2da29-3223">`BindingFlags.IgnoreCase` um die Groß-/Kleinschreibung ignorieren `name`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3223">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="2da29-3224">`BindingFlags.DeclaredOnly` Suche nur die deklarierten Member der <xref:System.Type>, nicht die Elemente, die nur geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3224">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="2da29-3225">Die folgenden <xref:System.Reflection.BindingFlags> Aufrufflags genutzt werden, welche Aktion für das Element ausführen soll:</span><span class="sxs-lookup"><span data-stu-id="2da29-3225">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="2da29-3226">`CreateInstance` Um einen Konstruktor aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3226">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="2da29-3227">`name` wird ignoriert.</span><span class="sxs-lookup"><span data-stu-id="2da29-3227">`name` is ignored.</span></span> <span data-ttu-id="2da29-3228">Mit anderen Aufrufflags ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="2da29-3228">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="2da29-3229">`InvokeMethod` Aufrufen einer Methode, jedoch nicht auf einen Konstruktor oder Typinitialisierer</span><span class="sxs-lookup"><span data-stu-id="2da29-3229">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="2da29-3230">Ungültig mit `SetField` oder `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3230">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="2da29-3231">Wenn `InvokeMethod` angegeben wird, `BindingFlags.Public`, `BindingFlags.Instance`, und `BindingFlags.Static` werden automatisch mit eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3231">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="2da29-3232">`GetField` den Wert eines Felds abgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="2da29-3232">`GetField` to get the value of a field.</span></span> <span data-ttu-id="2da29-3233">Ungültig mit `SetField`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3233">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="2da29-3234">`SetField` den Wert eines Felds festgelegt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3234">`SetField` to set the value of a field.</span></span> <span data-ttu-id="2da29-3235">Ungültig mit `GetField`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3235">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="2da29-3236">`GetProperty` zum Abrufen einer Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-3236">`GetProperty` to get a property.</span></span> <span data-ttu-id="2da29-3237">Ungültig mit `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3237">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="2da29-3238">`SetProperty` Festlegen von Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="2da29-3238">`SetProperty` to set a property.</span></span> <span data-ttu-id="2da29-3239">Ungültig mit `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3239">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="2da29-3240">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-3240">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="2da29-3241">Eine Methode wird aufgerufen, wenn beide der folgenden Bedingungen zutreffen:</span><span class="sxs-lookup"><span data-stu-id="2da29-3241">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="2da29-3242">Die Anzahl von Parametern in der Deklaration der Methode entspricht der Anzahl der Argumente in der `args` Array (, wenn Standardargumente für das Element definiert sind und `BindingFlags.OptionalParamBinding` angegeben ist).</span><span class="sxs-lookup"><span data-stu-id="2da29-3242">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="2da29-3243">Der Typ jedes Arguments kann vom Binder in den Typ des Parameters konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3243">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="2da29-3244">Der Binder findet alle übereinstimmenden Methoden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3244">The binder will find all of the matching methods.</span></span> <span data-ttu-id="2da29-3245">Diese Methoden werden basierend auf den Typ der Bindung, die angeforderte gefunden (<xref:System.Reflection.BindingFlags> Werte `InvokeMethod`, `GetProperty`usw.).</span><span class="sxs-lookup"><span data-stu-id="2da29-3245">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="2da29-3246">Der Satz von Methoden wird durch den Namen, Anzahl von Argumenten und einen Satz von Suchabfragen in der Binder definierten gefiltert.</span><span class="sxs-lookup"><span data-stu-id="2da29-3246">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="2da29-3247">Wenn die Methode ausgewählt wurde, wird er aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3247">After the method is selected, it is invoked.</span></span> <span data-ttu-id="2da29-3248">Eingabehilfen ist an diesem Punkt aktiviert.</span><span class="sxs-lookup"><span data-stu-id="2da29-3248">Accessibility is checked at that point.</span></span> <span data-ttu-id="2da29-3249">Die Suche kann gesteuert werden durchsucht, welchen Satz von Methoden basierend auf der Eingabehilfen-Attribut, das der Methode zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="2da29-3249">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="2da29-3250">Die <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Methode von der <xref:System.Reflection.Binder> -Klasse ist verantwortlich für die Auswahl der Methode, die aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3250">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="2da29-3251">Der Standardbinder wählt die spezifischste Übereinstimmung.</span><span class="sxs-lookup"><span data-stu-id="2da29-3251">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="2da29-3252">Zugriffseinschränkungen werden für vollständig vertrauenswürdige Code ignoriert. d. h. private Konstruktoren, Methoden, Felder und Eigenschaften können zugegriffen und aufgerufene <xref:System.Reflection> immer der Code vollständig vertrauenswürdig ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3252">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="2da29-3253">Sie können `Type.InvokeMember` auf ein Feld auf einen bestimmten Wert festgelegt wird, durch Angabe <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-3253">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2da29-3254">Beispielsweise, wenn Sie eine öffentliche Instanzenfeld F auf Klasse C und F festlegen möchten ist eine `String`, können Sie Code wie z. B.:</span><span class="sxs-lookup"><span data-stu-id="2da29-3254">For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 <span data-ttu-id="2da29-3255">Wenn F# ist eine `String[]`, können Sie Code wie z. B.:</span><span class="sxs-lookup"><span data-stu-id="2da29-3255">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 <span data-ttu-id="2da29-3256">die wird das Feld F für dieses neue Array zu initialisieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-3256">which will initialize the field F to this new array.</span></span> <span data-ttu-id="2da29-3257">Sie können auch `Type.InvokeMember` an eine Position in einem Array festlegen, indem der Index des Werts, und klicken Sie dann den nächsten Wert mit Code wie dem folgenden:</span><span class="sxs-lookup"><span data-stu-id="2da29-3257">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 <span data-ttu-id="2da29-3258">Dadurch wird die Zeichenfolge "Z" in das Array geändert, die in der Zeichenfolge "b" F enthält.</span><span class="sxs-lookup"><span data-stu-id="2da29-3258">This will change string "z" in the array that F holds to string "b".</span></span>  
  
 <span data-ttu-id="2da29-3259">Beim Aufruf einer `IDispatch` Member auf, Sie können die DispID anstelle des Namens des Elements, das Zeichenfolgenformat mithilfe angeben "[DispID = ##]".</span><span class="sxs-lookup"><span data-stu-id="2da29-3259">When you invoke an `IDispatch` member, you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="2da29-3260">Beispielsweise, wenn die DispID MyComMethod 3 ist, können Sie angeben die Zeichenfolge "[DispID = 3]" statt "MyComMethod".</span><span class="sxs-lookup"><span data-stu-id="2da29-3260">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="2da29-3261">Der Aufruf eines Members durch DispID ist schneller als das Element anhand des Namens nachschlagen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3261">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="2da29-3262">In komplexen Aggregation Szenarien ist die DispID in einigen Fällen die einzige Möglichkeit zum Aufrufen des gewünschten Mitglieds an.</span><span class="sxs-lookup"><span data-stu-id="2da29-3262">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-3263">Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, auf nicht öffentliche Member zuzugreifen, wenn der Aufrufer erteilt wurde <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> kennzeichnen und erteilen Sie der Berechtigungssatz für die nicht öffentlichen Member an des Aufrufers beschränkt ist Set- oder eine Teilmenge davon.</span><span class="sxs-lookup"><span data-stu-id="2da29-3263">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="2da29-3264">(Siehe [Sicherheitsüberlegungen für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="2da29-3264">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="2da29-3265">Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein. </span><span class="sxs-lookup"><span data-stu-id="2da29-3265">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3266">Im folgenden Beispiel wird `InvokeMember` den Zugriff auf Member eines Typs.</span><span class="sxs-lookup"><span data-stu-id="2da29-3266">The following example uses `InvokeMember` to access members of a type.</span></span>  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-3267">
            <paramref name="invokeAttr" /> enthält keine <see langword="CreateInstance" />, und <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3267">
              <paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-3268">
            <paramref name="invokeAttr" /> ist kein gültiges <see cref="T:System.Reflection.BindingFlags" />-Attribut.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3268">
              <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span>
          </span>
          <span data-ttu-id="2da29-3269">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3269">-or-</span>
          </span>
          <span data-ttu-id="2da29-3270">
            <paramref name="invokeAttr" /> enthält keines der folgenden Bindungsflags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3270">
              <paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="2da29-3271">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3271">-or-</span>
          </span>
          <span data-ttu-id="2da29-3272">
            <paramref name="invokeAttr" /> enthält <see langword="CreateInstance" /> in Kombination mit <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3272">
              <paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="2da29-3273">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3273">-or-</span>
          </span>
          <span data-ttu-id="2da29-3274">
            <paramref name="invokeAttr" /> enthält sowohl <see langword="GetField" /> als auch <see langword="SetField" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3274">
              <paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span>
          </span>
          <span data-ttu-id="2da29-3275">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3275">-or-</span>
          </span>
          <span data-ttu-id="2da29-3276">
            <paramref name="invokeAttr" /> enthält sowohl <see langword="GetProperty" /> als auch <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3276">
              <paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="2da29-3277">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3277">-or-</span>
          </span>
          <span data-ttu-id="2da29-3278">
            <paramref name="invokeAttr" /> enthält <see langword="InvokeMethod" /> in Kombination mit <see langword="SetField" /> oder <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3278">
              <paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="2da29-3279">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3279">-or-</span>
          </span>
          <span data-ttu-id="2da29-3280">
            <paramref name="invokeAttr" /> enthält <see langword="SetField" />, und <paramref name="args" /> enthält mehr als ein Element.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3280">
              <paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span>
          </span>
          <span data-ttu-id="2da29-3281">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3281">-or-</span>
          </span>
          <span data-ttu-id="2da29-3282">Diese Methode wird für ein COM-Objekt aufgerufen, und eines der folgenden Bindungsflags wurde nicht übergeben: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> oder <see langword="BindingFlags.PutRefDispProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3282">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span>
          </span>
          <span data-ttu-id="2da29-3283">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3283">-or-</span>
          </span>
          <span data-ttu-id="2da29-3284">Eines der benannten Parameterarrays enthält eine Zeichenfolge, die <see langword="null" /> ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3284">One of the named parameter arrays contains a string that is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="2da29-3285">Der angegebene Member ist ein Klasseninitialisierer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3285">The specified member is a class initializer.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingFieldException">
          <span data-ttu-id="2da29-3286">Das Feld oder die Eigenschaft wurde nicht gefunden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3286">The field or property cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="2da29-3287">Es wurde keine Methode gefunden, die den Argumenten in <paramref name="args" /> entspricht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3287">No method can be found that matches the arguments in <paramref name="args" />.</span>
          </span>
          <span data-ttu-id="2da29-3288">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3288">-or-</span>
          </span>
          <span data-ttu-id="2da29-3289">Das aktuelle <see cref="T:System.Type" />-Objekt stellt einen Typ dar, der offene Typparameter enthält. Das bedeutet, dass <see cref="P:System.Type.ContainsGenericParameters" /> den Wert <see langword="true" /> zurückgibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3289">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="2da29-3290">Der angegebene Member kann nicht für <paramref name="target" /> aufgerufen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3290">The specified member cannot be invoked on <paramref name="target" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="2da29-3291">Mehrere Methoden entsprechen den Bindungskriterien.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3291">More than one method matches the binding criteria.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2da29-3292">Diese Methode wird von .NET Compact Framework derzeit nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3292">The .NET Compact Framework does not currently support this method.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="2da29-3293">Die durch <paramref name="name" /> dargestellte Methode enthält mindestens einen nicht angegebenen generischen Typparameter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3293">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span>
          </span>
          <span data-ttu-id="2da29-3294">Das bedeutet, dass die <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" />-Eigenschaft der Methode <see langword="true" /> zurückgibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3294">That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns <see langword="true" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="2da29-3295">Legen Sie für den Zugriff auf nicht öffentliche Member unabhängig von deren Berechtigungssatz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3295">for accessing non-public members regardless of their grant set.</span>
          </span>
          <span data-ttu-id="2da29-3296">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3296">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="2da29-3297">zum Aufrufen von nicht verwalteten Code.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3297">to call unmanaged code.</span>
          </span>
          <span data-ttu-id="2da29-3298">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3298">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-3299">Die Zeichenfolge, die den Namen des Konstruktors, der Methode, der Eigenschaft oder des Feldmembers enthält, der bzw. die aufgerufen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3299">The string containing the name of the constructor, method, property, or field member to invoke.</span>
          </span>
          <span data-ttu-id="2da29-3300">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3300">-or-</span>
          </span>
          <span data-ttu-id="2da29-3301">Eine leere Zeichenfolge ("") zum Aufrufen des Standardmembers.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3301">An empty string ("") to invoke the default member.</span>
          </span>
          <span data-ttu-id="2da29-3302">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3302">-or-</span>
          </span>
          <span data-ttu-id="2da29-3303">Für <see langword="IDispatch" />-Member eine Zeichenfolge, die die DispID darstellt, z. B. "[DispID=3]".</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3303">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="2da29-3304">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3304">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="2da29-3305">Der Zugriff kann aus einem der <see langword="BindingFlags" /> wie <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> usw. bestehen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3305">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span>
          </span>
          <span data-ttu-id="2da29-3306">Die Art der Suche muss nicht angegeben werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3306">The type of lookup need not be specified.</span>
          </span>
          <span data-ttu-id="2da29-3307">Wenn die Art der Suche nicht angegeben ist, werden <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> verwendet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3307">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="2da29-3308">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3308">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="2da29-3309">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3309">-or-</span>
          </span>
          <span data-ttu-id="2da29-3310">Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3310">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
          <span data-ttu-id="2da29-3311">Beachten Sie, dass möglicherweise ein <see cref="T:System.Reflection.Binder" />-Objekt explizit definiert werden muss, um erfolgreich Methodenüberladungen mit Variablenargumenten aufrufen zu können.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3311">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="2da29-3312">Das Objekt, für das der angegebene Member aufgerufen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3312">The object on which to invoke the specified member.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="2da29-3313">Ein Array mit den Argumenten, die dem aufzurufenden Member übergeben werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3313">An array containing the arguments to pass to the member to invoke.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="2da29-3314">Das Objekt, das das zu verwendende Globalisierungsgebietsschema darstellt, das für gebietsspezifische Konvertierungen wie die Konvertierung einer numerischen <see cref="T:System.String" /> in einen <see cref="T:System.Double" /> erforderlich sein kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3314">The object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric <see cref="T:System.String" /> to a <see cref="T:System.Double" />.</span>
          </span>
          <span data-ttu-id="2da29-3315">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3315">-or-</span>
          </span>
          <span data-ttu-id="2da29-3316">Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3316">A null reference (<see langword="Nothing" /> in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-3317">Ruft den angegebenen Member auf, der den angegebenen Bindungseinschränkungen sowie der angegebenen Argumentliste und Kultur entspricht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3317">Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3318">Ein Objekt, das den Rückgabewert des aufgerufenen Members darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3318">An object representing the return value of the invoked member.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3319">Obwohl der Standardbinder nicht verarbeitet <xref:System.Globalization.CultureInfo> (die `culture` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden `culture`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3319">Although the default binder does not process <xref:System.Globalization.CultureInfo> (the `culture` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `culture`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-3320">Sie können keine <xref:System.Type.InvokeMember%2A> um eine generische Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3320">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="2da29-3321">Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Member in die Suche einbezogen werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-3321">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="2da29-3322">Geben Sie `BindingFlags.Public` auf öffentliche Member in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3322">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="2da29-3323">Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Member (d. h. private, interne und geschützte Member) in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3323">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="2da29-3324">Geben Sie `BindingFlags.FlattenHierarchy` statische Mitglieder der Hierarchie aufwärts eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3324">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="2da29-3325">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</span><span class="sxs-lookup"><span data-stu-id="2da29-3325">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="2da29-3326">`BindingFlags.IgnoreCase` um die Groß-/Kleinschreibung ignorieren `name`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3326">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="2da29-3327">`BindingFlags.DeclaredOnly` Suche nur die deklarierten Member der <xref:System.Type>, nicht die Elemente, die nur geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3327">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="2da29-3328">Die folgenden <xref:System.Reflection.BindingFlags> Aufrufflags genutzt werden, welche Aktion für das Element ausführen soll:</span><span class="sxs-lookup"><span data-stu-id="2da29-3328">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="2da29-3329">`CreateInstance` Um einen Konstruktor aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3329">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="2da29-3330">`name` wird ignoriert.</span><span class="sxs-lookup"><span data-stu-id="2da29-3330">`name` is ignored.</span></span> <span data-ttu-id="2da29-3331">Mit anderen Aufrufflags ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="2da29-3331">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="2da29-3332">`InvokeMethod` Aufrufen einer Methode, jedoch nicht auf einen Konstruktor oder Typinitialisierer</span><span class="sxs-lookup"><span data-stu-id="2da29-3332">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="2da29-3333">Ungültig mit `SetField` oder `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3333">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="2da29-3334">Wenn `InvokeMethod` angegeben wird, `BindingFlags.Public`, `BindingFlags.Instance`, und `BindingFlags.Static` werden automatisch mit eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3334">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="2da29-3335">`GetField` den Wert eines Felds abgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="2da29-3335">`GetField` to get the value of a field.</span></span> <span data-ttu-id="2da29-3336">Ungültig mit `SetField`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3336">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="2da29-3337">`SetField` den Wert eines Felds festgelegt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3337">`SetField` to set the value of a field.</span></span> <span data-ttu-id="2da29-3338">Ungültig mit `GetField`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3338">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="2da29-3339">`GetProperty` zum Abrufen einer Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-3339">`GetProperty` to get a property.</span></span> <span data-ttu-id="2da29-3340">Ungültig mit `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3340">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="2da29-3341">`SetProperty` Festlegen von Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="2da29-3341">`SetProperty` to set a property.</span></span> <span data-ttu-id="2da29-3342">Ungültig mit `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3342">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="2da29-3343">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-3343">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="2da29-3344">Eine Methode wird aufgerufen, wenn beide der folgenden Bedingungen zutreffen:</span><span class="sxs-lookup"><span data-stu-id="2da29-3344">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="2da29-3345">Die Anzahl von Parametern in der Deklaration der Methode entspricht der Anzahl der Argumente in der `args` Array (, wenn Standardargumente für das Element definiert sind und `BindingFlags.OptionalParamBinding` angegeben ist).</span><span class="sxs-lookup"><span data-stu-id="2da29-3345">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="2da29-3346">Der Typ jedes Arguments kann vom Binder in den Typ des Parameters konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3346">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="2da29-3347">Der Binder findet alle übereinstimmenden Methoden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3347">The binder will find all of the matching methods.</span></span> <span data-ttu-id="2da29-3348">Diese Methoden werden basierend auf den Typ der Bindung, die angeforderte gefunden (<xref:System.Reflection.BindingFlags> Werte `InvokeMethod`, `GetProperty`usw.).</span><span class="sxs-lookup"><span data-stu-id="2da29-3348">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="2da29-3349">Der Satz von Methoden wird durch den Namen, Anzahl von Argumenten und einen Satz von Suchabfragen in der Binder definierten gefiltert.</span><span class="sxs-lookup"><span data-stu-id="2da29-3349">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="2da29-3350">Wenn die Methode ausgewählt wurde, wird er aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3350">After the method is selected, it is invoked.</span></span> <span data-ttu-id="2da29-3351">Eingabehilfen ist an diesem Punkt aktiviert.</span><span class="sxs-lookup"><span data-stu-id="2da29-3351">Accessibility is checked at that point.</span></span> <span data-ttu-id="2da29-3352">Die Suche kann gesteuert werden durchsucht, welchen Satz von Methoden basierend auf der Eingabehilfen-Attribut, das der Methode zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="2da29-3352">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="2da29-3353">Die <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Methode von der <xref:System.Reflection.Binder> -Klasse ist verantwortlich für die Auswahl der Methode, die aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3353">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="2da29-3354">Der Standardbinder wählt die spezifischste Übereinstimmung.</span><span class="sxs-lookup"><span data-stu-id="2da29-3354">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="2da29-3355">Zugriffseinschränkungen werden für vollständig vertrauenswürdige Code ignoriert. d. h. können private Konstruktoren, Methoden, Felder und Eigenschaften werden zugegriffen und durch Reflektion aufgerufen werden, wenn der Code vollständig vertrauenswürdig ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3355">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="2da29-3356">Sie können `Type.InvokeMember` auf ein Feld auf einen bestimmten Wert festgelegt wird, durch Angabe <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-3356">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2da29-3357">Beispielsweise, wenn Sie eine öffentliche Instanzenfeld F auf Klasse C und F festlegen möchten ist eine `String` Sie Code verwenden, z. B.:</span><span class="sxs-lookup"><span data-stu-id="2da29-3357">For example, if you want to set a public instance field named F on class C, and F is a `String` you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 <span data-ttu-id="2da29-3358">Wenn F# ist eine `String[]`, können Sie Code wie z. B.:</span><span class="sxs-lookup"><span data-stu-id="2da29-3358">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 <span data-ttu-id="2da29-3359">die wird das Feld F für dieses neue Array zu initialisieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-3359">which will initialize the field F to this new array.</span></span> <span data-ttu-id="2da29-3360">Sie können auch `Type.InvokeMember` an eine Position in einem Array festlegen, indem der Index des Werts, und klicken Sie dann den nächsten Wert mit Code wie dem folgenden:</span><span class="sxs-lookup"><span data-stu-id="2da29-3360">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 <span data-ttu-id="2da29-3361">Dadurch wird die Zeichenfolge "Z" in das Array geändert, die in der Zeichenfolge "b" F enthält.</span><span class="sxs-lookup"><span data-stu-id="2da29-3361">This will change string "z" in the array that F holds to string "b".</span></span>  
  
 <span data-ttu-id="2da29-3362">Beim Aufruf einer `IDispatch` Member können Sie angeben, die DispID anstelle der Elementname, verwenden das Format der Zeichenfolge "[DispID = ##]".</span><span class="sxs-lookup"><span data-stu-id="2da29-3362">When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="2da29-3363">Beispielsweise, wenn die DispID MyComMethod 3 ist, können Sie angeben die Zeichenfolge "[DispID = 3]" statt "MyComMethod".</span><span class="sxs-lookup"><span data-stu-id="2da29-3363">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="2da29-3364">Der Aufruf eines Members durch DispID ist schneller als das Element anhand des Namens nachschlagen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3364">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="2da29-3365">In komplexen Aggregation Szenarien ist die DispID in einigen Fällen die einzige Möglichkeit zum Aufrufen des gewünschten Mitglieds an.</span><span class="sxs-lookup"><span data-stu-id="2da29-3365">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-3366">Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, auf nicht öffentliche Member zuzugreifen, wenn der Aufrufer erteilt wurde <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> kennzeichnen und erteilen Sie der Berechtigungssatz für die nicht öffentlichen Member an des Aufrufers beschränkt ist Set- oder eine Teilmenge davon.</span><span class="sxs-lookup"><span data-stu-id="2da29-3366">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="2da29-3367">(Siehe [Sicherheitsüberlegungen für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="2da29-3367">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="2da29-3368">Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein. </span><span class="sxs-lookup"><span data-stu-id="2da29-3368">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-3369">
            <paramref name="invokeAttr" /> enthält keine <see langword="CreateInstance" />, und <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3369">
              <paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-3370">
            <paramref name="invokeAttr" /> ist kein gültiges <see cref="T:System.Reflection.BindingFlags" />-Attribut.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3370">
              <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span>
          </span>
          <span data-ttu-id="2da29-3371">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3371">-or-</span>
          </span>
          <span data-ttu-id="2da29-3372">
            <paramref name="invokeAttr" /> enthält keines der folgenden Bindungsflags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3372">
              <paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="2da29-3373">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3373">-or-</span>
          </span>
          <span data-ttu-id="2da29-3374">
            <paramref name="invokeAttr" /> enthält <see langword="CreateInstance" /> in Kombination mit <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3374">
              <paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="2da29-3375">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3375">-or-</span>
          </span>
          <span data-ttu-id="2da29-3376">
            <paramref name="invokeAttr" /> enthält sowohl <see langword="GetField" /> als auch <see langword="SetField" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3376">
              <paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span>
          </span>
          <span data-ttu-id="2da29-3377">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3377">-or-</span>
          </span>
          <span data-ttu-id="2da29-3378">
            <paramref name="invokeAttr" /> enthält sowohl <see langword="GetProperty" /> als auch <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3378">
              <paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="2da29-3379">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3379">-or-</span>
          </span>
          <span data-ttu-id="2da29-3380">
            <paramref name="invokeAttr" /> enthält <see langword="InvokeMethod" /> in Kombination mit <see langword="SetField" /> oder <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3380">
              <paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="2da29-3381">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3381">-or-</span>
          </span>
          <span data-ttu-id="2da29-3382">
            <paramref name="invokeAttr" /> enthält <see langword="SetField" />, und <paramref name="args" /> enthält mehr als ein Element.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3382">
              <paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span>
          </span>
          <span data-ttu-id="2da29-3383">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3383">-or-</span>
          </span>
          <span data-ttu-id="2da29-3384">Diese Methode wird für ein COM-Objekt aufgerufen, und eines der folgenden Bindungsflags wurde nicht übergeben: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> oder <see langword="BindingFlags.PutRefDispProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3384">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span>
          </span>
          <span data-ttu-id="2da29-3385">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3385">-or-</span>
          </span>
          <span data-ttu-id="2da29-3386">Eines der benannten Parameterarrays enthält eine Zeichenfolge, die <see langword="null" /> ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3386">One of the named parameter arrays contains a string that is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="2da29-3387">Der angegebene Member ist ein Klasseninitialisierer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3387">The specified member is a class initializer.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingFieldException">
          <span data-ttu-id="2da29-3388">Das Feld oder die Eigenschaft wurde nicht gefunden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3388">The field or property cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="2da29-3389">Es wurde keine Methode gefunden, die den Argumenten in <paramref name="args" /> entspricht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3389">No method can be found that matches the arguments in <paramref name="args" />.</span>
          </span>
          <span data-ttu-id="2da29-3390">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3390">-or-</span>
          </span>
          <span data-ttu-id="2da29-3391">Das aktuelle <see cref="T:System.Type" />-Objekt stellt einen Typ dar, der offene Typparameter enthält. Das bedeutet, dass <see cref="P:System.Type.ContainsGenericParameters" /> den Wert <see langword="true" /> zurückgibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3391">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="2da29-3392">Der angegebene Member kann nicht für <paramref name="target" /> aufgerufen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3392">The specified member cannot be invoked on <paramref name="target" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="2da29-3393">Mehrere Methoden entsprechen den Bindungskriterien.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3393">More than one method matches the binding criteria.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="2da29-3394">Die durch <paramref name="name" /> dargestellte Methode enthält mindestens einen nicht angegebenen generischen Typparameter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3394">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span>
          </span>
          <span data-ttu-id="2da29-3395">Das bedeutet, dass die <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" />-Eigenschaft der Methode <see langword="true" /> zurückgibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3395">That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns <see langword="true" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="2da29-3396">Legen Sie für den Zugriff auf nicht öffentliche Member unabhängig von deren Berechtigungssatz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3396">for accessing non-public members regardless of their grant set.</span>
          </span>
          <span data-ttu-id="2da29-3397">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3397">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="2da29-3398">zum Aufrufen von nicht verwalteten Code.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3398">to call unmanaged code.</span>
          </span>
          <span data-ttu-id="2da29-3399">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3399">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name">
          <span data-ttu-id="2da29-3400">Die Zeichenfolge, die den Namen des Konstruktors, der Methode, der Eigenschaft oder des Feldmembers enthält, der bzw. die aufgerufen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3400">The string containing the name of the constructor, method, property, or field member to invoke.</span>
          </span>
          <span data-ttu-id="2da29-3401">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3401">-or-</span>
          </span>
          <span data-ttu-id="2da29-3402">Eine leere Zeichenfolge ("") zum Aufrufen des Standardmembers.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3402">An empty string ("") to invoke the default member.</span>
          </span>
          <span data-ttu-id="2da29-3403">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3403">-or-</span>
          </span>
          <span data-ttu-id="2da29-3404">Für <see langword="IDispatch" />-Member eine Zeichenfolge, die die DispID darstellt, z. B. "[DispID=3]".</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3404">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span>
          </span>
        </param>
        <param name="invokeAttr">
          <span data-ttu-id="2da29-3405">Eine Bitmaske aus einem oder mehreren <see cref="T:System.Reflection.BindingFlags" />, die angeben, wie die Suche durchgeführt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3405">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span>
          </span>
          <span data-ttu-id="2da29-3406">Der Zugriff kann aus einem der <see langword="BindingFlags" /> wie <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> usw. bestehen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3406">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span>
          </span>
          <span data-ttu-id="2da29-3407">Die Art der Suche muss nicht angegeben werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3407">The type of lookup need not be specified.</span>
          </span>
          <span data-ttu-id="2da29-3408">Wenn die Art der Suche nicht angegeben ist, werden <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> verwendet.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3408">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span>
          </span>
        </param>
        <param name="binder">
          <span data-ttu-id="2da29-3409">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3409">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span>
          </span>
          <span data-ttu-id="2da29-3410">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3410">-or-</span>
          </span>
          <span data-ttu-id="2da29-3411">Ein Nullverweis (Nothing in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3411">A null reference (Nothing in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span>
          </span>
          <span data-ttu-id="2da29-3412">Beachten Sie, dass möglicherweise ein <see cref="T:System.Reflection.Binder" />-Objekt explizit definiert werden muss, um erfolgreich Methodenüberladungen mit Variablenargumenten aufrufen zu können.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3412">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span>
          </span>
        </param>
        <param name="target">
          <span data-ttu-id="2da29-3413">Das Objekt, für das der angegebene Member aufgerufen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3413">The object on which to invoke the specified member.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="2da29-3414">Ein Array mit den Argumenten, die dem aufzurufenden Member übergeben werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3414">An array containing the arguments to pass to the member to invoke.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="2da29-3415">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <c>args</c>-Array zugeordnet sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3415">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <c>args</c> array.</span>
          </span>
          <span data-ttu-id="2da29-3416">Die einem Parameter zugeordneten Attribute werden in der Signatur des Members gespeichert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3416">A parameter's associated attributes are stored in the member's signature.</span>
          </span>
          <span data-ttu-id="2da29-3417">Der Standardbinder verarbeitet diesen Parameter nur, wenn eine COM-Komponente aufgerufen wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3417">The default binder processes this parameter only when calling a COM component.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="2da29-3418">Das <see cref="T:System.Globalization.CultureInfo" />-Objekt, das das zu verwendende Globalisierungsgebietsschema darstellt, das für gebietsspezifische Konvertierungen wie die Konvertierung einer numerischen Zeichenfolge in einen Double erforderlich sein kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3418">The <see cref="T:System.Globalization.CultureInfo" /> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.</span>
          </span>
          <span data-ttu-id="2da29-3419">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3419">-or-</span>
          </span>
          <span data-ttu-id="2da29-3420">Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3420">A null reference (<see langword="Nothing" /> in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />.</span>
          </span>
        </param>
        <param name="namedParameters">
          <span data-ttu-id="2da29-3421">Ein Array mit den Namen der Parameter, an die die Werte des <c>args</c>-Arrays übergeben werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3421">An array containing the names of the parameters to which the values in the <c>args</c> array are passed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-3422">Ruft nach Überschreiben in einer abgeleiteten Klasse den angegebenen Member auf, der den angegebenen Bindungseinschränkungen sowie der angegebenen Argumentliste, den Modifizierern und der Kultur entspricht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3422">When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3423">Ein Objekt, das den Rückgabewert des aufgerufenen Members darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3423">An object representing the return value of the invoked member.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3424">`InvokeMember` Mitglied Konstruktor oder eine Methodenmember aufruft, ruft ab oder legt ein Eigenschaftenelement, ruft ab oder legt einen Feldmember Daten oder abgerufen oder festgelegt ein Element von einen Arraymember angeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-3424">`InvokeMember` calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-3425">Sie können keine <xref:System.Type.InvokeMember%2A> um eine generische Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3425">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="2da29-3426">Beim Aufruf einer `IDispatch` Member können Sie angeben, die DispID anstelle der Elementname, verwenden das Format der Zeichenfolge "[DispID = ##]".</span><span class="sxs-lookup"><span data-stu-id="2da29-3426">When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="2da29-3427">Beispielsweise, wenn die DispID MyComMethod 3 ist, können Sie angeben die Zeichenfolge "[DispID = 3]" statt "MyComMethod".</span><span class="sxs-lookup"><span data-stu-id="2da29-3427">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="2da29-3428">Der Aufruf eines Members durch DispID ist schneller als das Element anhand des Namens nachschlagen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3428">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="2da29-3429">In komplexen Aggregation Szenarien ist die DispID in einigen Fällen die einzige Möglichkeit zum Aufrufen des gewünschten Mitglieds an.</span><span class="sxs-lookup"><span data-stu-id="2da29-3429">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
 <span data-ttu-id="2da29-3430">Obwohl der Standardbinder nicht verarbeitet <xref:System.Reflection.ParameterModifier> oder <xref:System.Globalization.CultureInfo> (die `modifiers` und `culture` Parameter), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden `modifiers` und `culture`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3430">Although the default binder does not process <xref:System.Reflection.ParameterModifier> or <xref:System.Globalization.CultureInfo> (the `modifiers` and `culture` parameters), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers` and `culture`.</span></span> <span data-ttu-id="2da29-3431">`ParameterModifier` wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3431">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="2da29-3432">Jeder Parameter im `namedParameters`-Array ruft den Wert aus dem entsprechenden Element im `args`-Array ab.</span><span class="sxs-lookup"><span data-stu-id="2da29-3432">Each parameter in the `namedParameters` array gets the value in the corresponding element in the `args` array.</span></span> <span data-ttu-id="2da29-3433">Wenn die Länge von `args` größer als die Länge von `namedParameters` ist, werden die restlichen Argumentwerte in der bestehenden Reihenfolge übergeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-3433">If the length of `args` is greater than the length of `namedParameters`, the remaining argument values are passed in order.</span></span>  
  
 <span data-ttu-id="2da29-3434">Die `namedParameters` Array kann verwendet werden, um die Reihenfolge der Argumente in der ein Eingabearray zu ändern.</span><span class="sxs-lookup"><span data-stu-id="2da29-3434">The `namedParameters` array can be used to change the order of arguments in an input array.</span></span> <span data-ttu-id="2da29-3435">Angenommen, die Methode `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` in Visual Basic) und das Eingabearray `{ 42, "x" }`, das Eingabearray unverändert an den übergeben werden kann `args` Wenn das Array `{ "b", "a" }` angegeben wird, für die `namedParameters`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3435">For example, given the method `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` in Visual Basic) and the input array `{ 42, "x" }`, the input array can be passed unchanged to `args` if the array `{ "b", "a" }` is supplied for `namedParameters`.</span></span>  
  
 <span data-ttu-id="2da29-3436">Die folgenden <xref:System.Reflection.BindingFlags> Filterkennzeichnungen genutzt werden, welche Member in die Suche einbezogen werden:</span><span class="sxs-lookup"><span data-stu-id="2da29-3436">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="2da29-3437">Geben Sie `BindingFlags.Public` auf öffentliche Member in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3437">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="2da29-3438">Geben Sie `BindingFlags.NonPublic` auf nicht öffentliche Member (d. h. private, interne und geschützte Member) in die Suche einbeziehen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3438">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="2da29-3439">Geben Sie `BindingFlags.FlattenHierarchy` statische Mitglieder der Hierarchie aufwärts eingeschlossen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3439">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="2da29-3440">Die folgenden <xref:System.Reflection.BindingFlags> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</span><span class="sxs-lookup"><span data-stu-id="2da29-3440">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="2da29-3441">`BindingFlags.IgnoreCase` um die Groß-/Kleinschreibung ignorieren `name`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3441">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="2da29-3442">`BindingFlags.DeclaredOnly` Suche nur die deklarierten Member der <xref:System.Type>, nicht die Elemente, die nur geerbt wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3442">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="2da29-3443">Die folgenden <xref:System.Reflection.BindingFlags> Aufrufflags genutzt werden, welche Aktion für das Element ausführen soll:</span><span class="sxs-lookup"><span data-stu-id="2da29-3443">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="2da29-3444">`CreateInstance` Um einen Konstruktor aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3444">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="2da29-3445">`name` wird ignoriert.</span><span class="sxs-lookup"><span data-stu-id="2da29-3445">`name` is ignored.</span></span> <span data-ttu-id="2da29-3446">Mit anderen Aufrufflags ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="2da29-3446">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="2da29-3447">`InvokeMethod` Aufrufen einer Methode, jedoch nicht auf einen Konstruktor oder Typinitialisierer</span><span class="sxs-lookup"><span data-stu-id="2da29-3447">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="2da29-3448">Ungültig mit `SetField` oder `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3448">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="2da29-3449">Wenn `InvokeMethod` angegeben wird, `BindingFlags.Public`, `BindingFlags.Instance`, und `BindingFlags.Static` werden automatisch mit eingeschlossen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3449">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="2da29-3450">`GetField` den Wert eines Felds abgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="2da29-3450">`GetField` to get the value of a field.</span></span> <span data-ttu-id="2da29-3451">Ungültig mit `SetField`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3451">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="2da29-3452">`SetField` den Wert eines Felds festgelegt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3452">`SetField` to set the value of a field.</span></span> <span data-ttu-id="2da29-3453">Ungültig mit `GetField`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3453">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="2da29-3454">`GetProperty` zum Abrufen einer Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-3454">`GetProperty` to get a property.</span></span> <span data-ttu-id="2da29-3455">Ungültig mit `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3455">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="2da29-3456">`SetProperty` Festlegen von Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="2da29-3456">`SetProperty` to set a property.</span></span> <span data-ttu-id="2da29-3457">Ungültig mit `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3457">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="2da29-3458">Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-3458">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="2da29-3459">Eine Methode wird aufgerufen, wenn beide der folgenden Bedingungen zutreffen:</span><span class="sxs-lookup"><span data-stu-id="2da29-3459">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="2da29-3460">Die Anzahl von Parametern in der Deklaration der Methode entspricht der Anzahl der Argumente in der `args` Array (, wenn Standardargumente für das Element definiert sind und `BindingFlags.OptionalParamBinding` angegeben ist).</span><span class="sxs-lookup"><span data-stu-id="2da29-3460">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="2da29-3461">Der Typ jedes Arguments kann vom Binder in den Typ des Parameters konvertiert werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3461">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="2da29-3462">Der Binder findet alle übereinstimmenden Methoden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3462">The binder will find all of the matching methods.</span></span> <span data-ttu-id="2da29-3463">Diese Methoden werden basierend auf den Typ der Bindung, die angeforderte gefunden (<xref:System.Reflection.BindingFlags> Werte `InvokeMethod`, `GetProperty`usw.).</span><span class="sxs-lookup"><span data-stu-id="2da29-3463">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="2da29-3464">Der Satz von Methoden wird durch den Namen, Anzahl von Argumenten und einen Satz von Suchabfragen in der Binder definierten gefiltert.</span><span class="sxs-lookup"><span data-stu-id="2da29-3464">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="2da29-3465">Wenn die Methode ausgewählt wurde, wird er aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3465">After the method is selected, it is invoked.</span></span> <span data-ttu-id="2da29-3466">Eingabehilfen ist an diesem Punkt aktiviert.</span><span class="sxs-lookup"><span data-stu-id="2da29-3466">Accessibility is checked at that point.</span></span> <span data-ttu-id="2da29-3467">Die Suche kann gesteuert werden durchsucht, welchen Satz von Methoden basierend auf der Eingabehilfen-Attribut, das der Methode zugeordnet.</span><span class="sxs-lookup"><span data-stu-id="2da29-3467">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="2da29-3468">Die <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> Methode von der <xref:System.Reflection.Binder> -Klasse ist verantwortlich für die Auswahl der Methode, die aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3468">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="2da29-3469">Der Standardbinder wählt die spezifischste Übereinstimmung.</span><span class="sxs-lookup"><span data-stu-id="2da29-3469">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="2da29-3470">`InvokeMember` kann verwendet werden, zum Aufrufen von Methoden mit Parametern, die über Standardwerte verfügen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3470">`InvokeMember` can be used to invoke methods with parameters that have default values.</span></span> <span data-ttu-id="2da29-3471">Um diese Methoden zu binden, muss für die Reflektion <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3471">To bind to these methods, Reflection requires <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> to be specified.</span></span> <span data-ttu-id="2da29-3472">Für einen Parameter, die über einen Standardwert verfügt, können Sie entweder einen anderen Wert angeben oder angeben <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> auf den Standardwert verwenden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3472">For a parameter that has a default value, you can either supply a different value, or supply <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> to use the default value.</span></span>  
  
 <span data-ttu-id="2da29-3473">Betrachten Sie beispielsweise eine Methode wie MyMethod (Int, x, "float" y = 2.0).</span><span class="sxs-lookup"><span data-stu-id="2da29-3473">For example, consider a method such as MyMethod(int x, float y = 2.0).</span></span> <span data-ttu-id="2da29-3474">Klicken Sie zum Aufrufen dieser Methode mit nur das erste Argument als MyMethod(4), übergeben Sie eine der oben genannten Bindungsflags und zwei Argumente, d. h. 4 für das erste Argument übergeben und `Missing.Value` für das zweite Argument.</span><span class="sxs-lookup"><span data-stu-id="2da29-3474">To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and `Missing.Value` for the second argument.</span></span> <span data-ttu-id="2da29-3475">Es sei denn, Sie verwenden `Missing.Value`, kann nicht ausgelassen werden optionale Parameter mit der `Invoke` Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-3475">Unless you use `Missing.Value`, you may not omit optional parameters with the `Invoke` method.</span></span> <span data-ttu-id="2da29-3476">Wenn Sie dies tun müssen, verwenden `InvokeMember` stattdessen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3476">If you must do so, use `InvokeMember` instead.</span></span>  
  
 <span data-ttu-id="2da29-3477">Zugriffseinschränkungen werden für vollständig vertrauenswürdige Code ignoriert. d. h. private Konstruktoren, Methoden, Felder und Eigenschaften können zugegriffen und aufgerufene <xref:System.Reflection> immer der Code vollständig vertrauenswürdig ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3477">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="2da29-3478">Sie können `Type.InvokeMember` auf ein Feld auf einen bestimmten Wert festgelegt wird, durch Angabe <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-3478">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2da29-3479">Beispielsweise, wenn Sie eine öffentliche Instanzenfeld F auf Klasse C und F festlegen möchten ist eine `String`, können Sie Code wie z. B.:</span><span class="sxs-lookup"><span data-stu-id="2da29-3479">For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 <span data-ttu-id="2da29-3480">Wenn F# ist eine `String[]`, können Sie Code wie z. B.:</span><span class="sxs-lookup"><span data-stu-id="2da29-3480">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 <span data-ttu-id="2da29-3481">die wird das Feld F für dieses neue Array zu initialisieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-3481">which will initialize the field F to this new array.</span></span> <span data-ttu-id="2da29-3482">Sie können auch `Type.InvokeMember` an eine Position in einem Array festlegen, indem der Index des Werts, und klicken Sie dann den nächsten Wert mit Code wie dem folgenden:</span><span class="sxs-lookup"><span data-stu-id="2da29-3482">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 <span data-ttu-id="2da29-3483">Dadurch wird die Zeichenfolge "Z" in das Array geändert, die in der Zeichenfolge "b" F enthält.</span><span class="sxs-lookup"><span data-stu-id="2da29-3483">This will change string "z" in the array that F holds to string "b".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-3484">Beginnend mit der [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], diese Methode kann verwendet werden, auf nicht öffentliche Member zuzugreifen, wenn der Aufrufer erteilt wurde <xref:System.Security.Permissions.ReflectionPermission> mit der <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> kennzeichnen und erteilen Sie der Berechtigungssatz für die nicht öffentlichen Member an des Aufrufers beschränkt ist Set- oder eine Teilmenge davon.</span><span class="sxs-lookup"><span data-stu-id="2da29-3484">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</span></span> <span data-ttu-id="2da29-3485">(Siehe [Sicherheitsüberlegungen für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="2da29-3485">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="2da29-3486">Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein. </span><span class="sxs-lookup"><span data-stu-id="2da29-3486">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-3487">
            <paramref name="invokeAttr" /> enthält keine <see langword="CreateInstance" />, und <paramref name="name" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3487">
              <paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-3488">
            <paramref name="args" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3488">
              <paramref name="args" /> and <paramref name="modifiers" /> do not have the same length.</span>
          </span>
          <span data-ttu-id="2da29-3489">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3489">-or-</span>
          </span>
          <span data-ttu-id="2da29-3490">
            <paramref name="invokeAttr" /> ist kein gültiges <see cref="T:System.Reflection.BindingFlags" />-Attribut.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3490">
              <paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span>
          </span>
          <span data-ttu-id="2da29-3491">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3491">-or-</span>
          </span>
          <span data-ttu-id="2da29-3492">
            <paramref name="invokeAttr" /> enthält keines der folgenden Bindungsflags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3492">
              <paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="2da29-3493">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3493">-or-</span>
          </span>
          <span data-ttu-id="2da29-3494">
            <paramref name="invokeAttr" /> enthält <see langword="CreateInstance" /> in Kombination mit <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3494">
              <paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="2da29-3495">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3495">-or-</span>
          </span>
          <span data-ttu-id="2da29-3496">
            <paramref name="invokeAttr" /> enthält sowohl <see langword="GetField" /> als auch <see langword="SetField" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3496">
              <paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span>
          </span>
          <span data-ttu-id="2da29-3497">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3497">-or-</span>
          </span>
          <span data-ttu-id="2da29-3498">
            <paramref name="invokeAttr" /> enthält sowohl <see langword="GetProperty" /> als auch <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3498">
              <paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="2da29-3499">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3499">-or-</span>
          </span>
          <span data-ttu-id="2da29-3500">
            <paramref name="invokeAttr" /> enthält <see langword="InvokeMethod" /> in Kombination mit <see langword="SetField" /> oder <see langword="SetProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3500">
              <paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span>
          </span>
          <span data-ttu-id="2da29-3501">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3501">-or-</span>
          </span>
          <span data-ttu-id="2da29-3502">
            <paramref name="invokeAttr" /> enthält <see langword="SetField" />, und <paramref name="args" /> enthält mehr als ein Element.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3502">
              <paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span>
          </span>
          <span data-ttu-id="2da29-3503">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3503">-or-</span>
          </span>
          <span data-ttu-id="2da29-3504">Das benannte Parameterarray ist größer als das Argumentarray.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3504">The named parameter array is larger than the argument array.</span>
          </span>
          <span data-ttu-id="2da29-3505">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3505">-or-</span>
          </span>
          <span data-ttu-id="2da29-3506">Diese Methode wird für ein COM-Objekt aufgerufen, und eines der folgenden Bindungsflags wurde nicht übergeben: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> oder <see langword="BindingFlags.PutRefDispProperty" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3506">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span>
          </span>
          <span data-ttu-id="2da29-3507">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3507">-or-</span>
          </span>
          <span data-ttu-id="2da29-3508">Eines der benannten Parameterarrays enthält eine Zeichenfolge, die <see langword="null" /> ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3508">One of the named parameter arrays contains a string that is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.MethodAccessException">
          <span data-ttu-id="2da29-3509">Der angegebene Member ist ein Klasseninitialisierer.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3509">The specified member is a class initializer.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingFieldException">
          <span data-ttu-id="2da29-3510">Das Feld oder die Eigenschaft wurde nicht gefunden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3510">The field or property cannot be found.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="2da29-3511">Es wurde keine Methode gefunden, die den Argumenten in <paramref name="args" /> entspricht.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3511">No method can be found that matches the arguments in <paramref name="args" />.</span>
          </span>
          <span data-ttu-id="2da29-3512">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3512">-or-</span>
          </span>
          <span data-ttu-id="2da29-3513">Es wurde kein Member gefunden, dessen Argumentnamen in <paramref name="namedParameters" /> angegeben sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3513">No member can be found that has the argument names supplied in <paramref name="namedParameters" />.</span>
          </span>
          <span data-ttu-id="2da29-3514">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3514">-or-</span>
          </span>
          <span data-ttu-id="2da29-3515">Das aktuelle <see cref="T:System.Type" />-Objekt stellt einen Typ dar, der offene Typparameter enthält. Das bedeutet, dass <see cref="P:System.Type.ContainsGenericParameters" /> den Wert <see langword="true" /> zurückgibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3515">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetException">
          <span data-ttu-id="2da29-3516">Der angegebene Member kann nicht für <paramref name="target" /> aufgerufen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3516">The specified member cannot be invoked on <paramref name="target" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="2da29-3517">Mehrere Methoden entsprechen den Bindungskriterien.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3517">More than one method matches the binding criteria.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="2da29-3518">Die durch <paramref name="name" /> dargestellte Methode enthält mindestens einen nicht angegebenen generischen Typparameter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3518">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span>
          </span>
          <span data-ttu-id="2da29-3519">Das bedeutet, dass die <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" />-Eigenschaft der Methode <see langword="true" /> zurückgibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3519">That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns <see langword="true" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">
          <span data-ttu-id="2da29-3520">Legen Sie für den Zugriff auf nicht öffentliche Member unabhängig von deren Berechtigungssatz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3520">for accessing non-public members regardless of their grant set.</span>
          </span>
          <span data-ttu-id="2da29-3521">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3521">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="2da29-3522">zum Aufrufen von nicht verwalteten Code.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3522">to call unmanaged code.</span>
          </span>
          <span data-ttu-id="2da29-3523">Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3523">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3524">Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Type" /> abstrakt ist und überschrieben werden muss.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3524">Gets a value indicating whether the <see cref="T:System.Type" /> is abstract and must be overridden.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3525">
            <see langword="true" />, wenn <see cref="T:System.Type" /> abstrakt ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3525">
              <see langword="true" /> if the <see cref="T:System.Type" /> is abstract; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3526">Die <xref:System.Type.IsAbstract%2A> -Eigenschaft gibt `true` in den folgenden Fällen:</span><span class="sxs-lookup"><span data-stu-id="2da29-3526">The <xref:System.Type.IsAbstract%2A> property returns `true` in the following cases:</span></span>  
  
-   <span data-ttu-id="2da29-3527">Der aktuelle Typ ist abstrakt. d. h. kann nicht instanziiert werden, aber kann nur als Basisklasse für abgeleitete Klassen dienen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3527">The current type is abstract; that is, it cannot be instantiated, but can only serve as the base class for derived classes.</span></span> <span data-ttu-id="2da29-3528">Abstrakte Klassen werden in c# mit markiert die [abstrakte](~/docs/csharp/language-reference/keywords/abstract.md) Schlüsselwort in Visual Basic markiert sind mit den [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) Schlüsselwort.</span><span class="sxs-lookup"><span data-stu-id="2da29-3528">In C#, abstract classes are marked with the [abstract](~/docs/csharp/language-reference/keywords/abstract.md) keyword; in Visual Basic, they are marked with the [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) keyword.</span></span>  
  
-   <span data-ttu-id="2da29-3529">Der aktuelle Typ ist eine Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="2da29-3529">The current type is an interface.</span></span>  
  
 <span data-ttu-id="2da29-3530">Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3530">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3531">Das folgende Beispiel erstellt ein Array von <xref:System.Type> Objekte, die die folgenden Typen darstellen: Typ gibt enthält `true` , wenn das angegebene Objekt `abstract`ist, andernfalls gibt `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3531">The following example creates an array of <xref:System.Type> objects that represent the following types:contains type returns `true` if the specified object is `abstract`; otherwise, it returns `false`.</span></span>  
  
-   <span data-ttu-id="2da29-3532">`AbstractClass`, eine abstrakte Klasse (eine Klasse als markiert `abstract` in C# geschrieben und `MustInherit` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-3532">`AbstractClass`, an abstract class (a class marked as `abstract` in C# and `MustInherit` in Visual Basic).</span></span>  
  
-   <span data-ttu-id="2da29-3533">`DerivedClass`, eine Klasse, die von erben `AbstractClass`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3533">`DerivedClass`, a class that inherits from `AbstractClass`.</span></span>  
  
-   <span data-ttu-id="2da29-3534">`SingleClass`, einer nicht vererbbaren Klasse.</span><span class="sxs-lookup"><span data-stu-id="2da29-3534">`SingleClass`, a non-inheritable class.</span></span> <span data-ttu-id="2da29-3535">Es ist definiert als `sealed` in C# geschrieben und `NotInheritable` in Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="2da29-3535">It is defined as `sealed` in C# and `NotInheritable` in Visual Basic.</span></span>  
  
-   <span data-ttu-id="2da29-3536">`ITypeInfo`, eine Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="2da29-3536">`ITypeInfo`, an interface.</span></span>  
  
-   <span data-ttu-id="2da29-3537">`ImplementingClass`, eine Klasse, implementiert die `ITypeInfo` Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="2da29-3537">`ImplementingClass`, a class that implements the `ITypeInfo` interface.</span></span>  
  
 <span data-ttu-id="2da29-3538">Gibt die Methode `true` nur für `AbstractClass`, die abstrakte Klasse und `ITypeInfo`, die Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="2da29-3538">The method returns `true` only for `AbstractClass`, the abstract class, and `ITypeInfo`, the interface.</span></span>  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3539">Ruft einen Wert ab, der angibt, ob für <see langword="AnsiClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3539">Gets a value indicating whether the string format attribute <see langword="AnsiClass" /> is selected for the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3540">
            <see langword="true" />, wenn für <see langword="AnsiClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3540">
              <see langword="true" /> if the string format attribute <see langword="AnsiClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3541">Die <xref:System.Reflection.TypeAttributes.StringFormatMask> wählt die Zeichenfolgenformatattribute.</span><span class="sxs-lookup"><span data-stu-id="2da29-3541">The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes.</span></span> <span data-ttu-id="2da29-3542">Die Zeichenfolge Formatattribute zur Verbesserung der Interoperabilität von definieren, wie Zeichenfolgen interpretiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3542">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="2da29-3543">Wenn die aktuelle <xref:System.Type> stellt ein generischer Typ, der diese Eigenschaft bezieht sich auf die generische Typdefinition, aus der der Typ konstruiert wurde.</span><span class="sxs-lookup"><span data-stu-id="2da29-3543">If the current <xref:System.Type> represents a generic type, this property pertains to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="2da29-3544">Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3544">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="2da29-3545">Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3545">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3546">Im folgenden Beispiel ruft die Feldinformationen ab und überprüft, ob die `AnsiClass` Attribut.</span><span class="sxs-lookup"><span data-stu-id="2da29-3546">The following example gets the field information and checks for the `AnsiClass` attribute.</span></span>  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3547">Ruft einen Wert ab, der angibt, ob der Typ ein Array ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3547">Gets a value that indicates whether the type is an array.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3548">
            <see langword="true" />, wenn der aktuelle Typ ein Array ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3548">
              <see langword="true" /> if the current type is an array; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3549">Die <xref:System.Type.IsArray%2A> -Eigenschaft gibt `false` für die <xref:System.Array> Klasse.</span><span class="sxs-lookup"><span data-stu-id="2da29-3549">The <xref:System.Type.IsArray%2A> property returns `false` for the <xref:System.Array> class.</span></span> <span data-ttu-id="2da29-3550">Sie gibt überdies `false` , wenn die aktuelle Instanz ist eine <xref:System.Type> Objekt, das einen Auflistungstyp oder eine Schnittstelle, die Auflistungen, wie z. B. ausgelegt darstellt <xref:System.Collections.IEnumerable> oder <xref:System.Collections.Generic.IEnumerable%601>.</span><span class="sxs-lookup"><span data-stu-id="2da29-3550">It also returns `false` if the current instance is a <xref:System.Type> object that represents a collection type or an interface designed to work with collections, such as <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>.</span></span>  
  
 <span data-ttu-id="2da29-3551">Verwenden Sie z. B. Code, um ein Array zu prüfen:</span><span class="sxs-lookup"><span data-stu-id="2da29-3551">To check for an array, use code such as:</span></span>  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 <span data-ttu-id="2da29-3552">Wenn der aktuelle Typ ein generischer Typ oder ein Typparameter in der Definition einer generischen Typ- oder Methodendefinition darstellt, gibt diese Eigenschaft immer `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3552">If the current type represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="2da29-3553">Diese Eigenschaft ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3553">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3554">Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Type.IsArray%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-3554">The following example demonstrates using the <xref:System.Type.IsArray%2A> property.</span></span>  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3555">Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.IsArray" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> ein Array ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3555">When overridden in a derived class, implements the <see cref="P:System.Type.IsArray" /> property and determines whether the <see cref="T:System.Type" /> is an array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3556">
            <see langword="true" />, wenn <see cref="T:System.Type" /> ein Array ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3556">
              <see langword="true" /> if the <see cref="T:System.Type" /> is an array; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3557">Eine Instanz von der <xref:System.Array> Klasse zurückgeben muss `false` , da es sich um ein Objekt, das kein Array ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3557">An instance of the <xref:System.Array> class must return `false` because it is an object, not an array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3558">Im folgende Beispiel überschreibt die `IsArrayImpl` Methode in der `MyTypeDelegator` -Klasse überprüft, ob eine Variable ein Array ist, und das Ergebnis wird angezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3558">The following example overrides the `IsArrayImpl` method in the `MyTypeDelegator` class, checks if a variable is an array, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">
          <span data-ttu-id="2da29-3559">Der Typ, der mit dem aktuellen Typ verglichen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3559">The type to compare with the current type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-3560">Bestimmt, ob eine Instanz des angegebenen Typs der Instanz des aktuellen Typs zugewiesen werden kann</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3560">Determines whether an instance of a specified type can be assigned to an instance of the current type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3561">
            <see langword="true" />, wenn eine der folgenden Bedingungen erfüllt ist:</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3561">
              <see langword="true" /> if any of the following conditions is true:</span>
          </span>  
  
-   <span data-ttu-id="2da29-3562"><paramref name="c" /> und die aktuelle Instanz haben denselben Typ.</span><span class="sxs-lookup"><span data-stu-id="2da29-3562"><paramref name="c" /> and the current instance represent the same type.</span></span>  
  
-   <span data-ttu-id="2da29-3563"><paramref name="c" /> ist entweder direkt oder indirekt von der aktuellen Instanz abgeleitet.</span><span class="sxs-lookup"><span data-stu-id="2da29-3563"><paramref name="c" /> is derived either directly or indirectly from the current instance.</span></span><span data-ttu-id="2da29-3564"><paramref name="c" /> wird direkt von der aktuellen Instanz abgeleitet, wenn es von der aktuellen Instanz erbt; <paramref name="c" /> wird indirekt von der aktuellen Instanz abgeleitet, wenn es von einer Folge von einer oder mehr Klassen erbt, die von der aktuellen Instanz erben.</span><span class="sxs-lookup"><span data-stu-id="2da29-3564"><paramref name="c" /> is derived directly from the current instance if it inherits from the current instance; <paramref name="c" /> is derived indirectly from the current instance if it inherits from a succession of one or more classes that inherit from the current instance.</span></span>  
  
-   <span data-ttu-id="2da29-3565">Die aktuelle Instanz ist eine Schnittstelle, die von <paramref name="c" /> implementiert wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-3565">The current instance is an interface that <paramref name="c" /> implements.</span></span>  
  
-   <span data-ttu-id="2da29-3566"><paramref name="c" /> ist ein generischer Typparameter, und die aktuelle Instanz stellt eine der Einschränkungen von <paramref name="c" /> dar.</span><span class="sxs-lookup"><span data-stu-id="2da29-3566"><paramref name="c" /> is a generic type parameter, and the current instance represents one of the constraints of <paramref name="c" />.</span></span><span data-ttu-id="2da29-3567">Im folgenden Beispiel handelt es sich bei der aktuellen Instanz um ein <see cref="T:System.Type" />-Objekt, das die Klasse <see cref="T:System.IO.Stream" /> darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3567">In the following example, the current instance is a <see cref="T:System.Type" /> object that represents the <see cref="T:System.IO.Stream" /> class.</span></span><span data-ttu-id="2da29-3568">Bei <c>GenericWithConstraint</c> handel es sich um einen generische Typ, dessen generischer Typparameter vom Typ <see cref="T:System.IO.Stream" /> sein muss.</span><span class="sxs-lookup"><span data-stu-id="2da29-3568"><c>GenericWithConstraint</c> is a generic type whose generic type parameter must be of type    <see cref="T:System.IO.Stream" />.</span></span><span data-ttu-id="2da29-3569">Wenn der generische Typparameter an <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> übergeben wird,zeigt dies, dass eine Instanz des generischen Typparameters einem <see cref="T:System.IO.Stream" />-Objekt zugewiesen werden kann.</span><span class="sxs-lookup"><span data-stu-id="2da29-3569">Passing its generic type parameter to the <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> indicates that  an instance of the generic type parameter can be assigned to an <see cref="T:System.IO.Stream" /> object.</span></span>  
  
     [!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)]
     [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]  
  
-   <span data-ttu-id="2da29-3570"><paramref name="c" /> stellt einen Werttyp dar, und die aktuelle Instanz stellt <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> in Visual Basic) dar.</span><span class="sxs-lookup"><span data-stu-id="2da29-3570"><paramref name="c" /> represents a value type, and the current instance represents <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> in Visual Basic).</span></span><span data-ttu-id="2da29-3571"><see langword="false" />, wenn keine dieser Bedingungen erfüllt sind oder wenn <paramref name="c" /><see langword="null" /> ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3571"><see langword="false" /> if none of these conditions are true, or if <paramref name="c" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3572">Die <xref:System.Type.IsAssignableFrom%2A> Methode kann verwendet werden, um zu bestimmen, ob eine Instanz von `c` zugewiesen werden kann mit einer Instanz des aktuellen Typs, die Methode eignet sich am besten, wenn Sie Objekte verarbeiten, deren Typen zur Entwurfszeit nicht bekannt sind, und ermöglicht die bedingte Zuweisung, wie im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="2da29-3572">The <xref:System.Type.IsAssignableFrom%2A> method can be used to determine whether an instance of `c` can be assigned to an instance of the current type, The method is most useful when you are handling objects whose types are not known at design time and allows for conditional assignment, as the following example shows.</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 <span data-ttu-id="2da29-3573">Diese Methode somit wird sichergestellt, dass eine Codezeile wie Folgendes zur Laufzeit, ohne Auslösen ausgeführt wird einer <xref:System.InvalidCastException> Ausnahme oder eine ähnliche Ausnahme:</span><span class="sxs-lookup"><span data-stu-id="2da29-3573">This method thus ensures that a line of code like the following will execute at runtime without throwing an <xref:System.InvalidCastException> exception or a similar exception:</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 <span data-ttu-id="2da29-3574">Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3574">This method can be overridden by a derived class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-3575">Eine generische Typdefinition ist nicht von einem geschlossenen konstruierten Typ zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3575">A generic type definition is not assignable from a closed constructed type.</span></span> <span data-ttu-id="2da29-3576">D. h. Sie geschlossenen konstruierten Typs zuweisen können nicht `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) einer Variablen vom Typ `MyGenericList<T>`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3576">That is, you cannot assign the closed constructed type `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) to a variable of type `MyGenericList<T>`.</span></span>  
  
 <span data-ttu-id="2da29-3577">Wenn die `c` Parameter ist vom Typ <xref:System.Reflection.Emit.TypeBuilder>, das Ergebnis wird auf Grundlage des Typs, die erstellt werden soll.</span><span class="sxs-lookup"><span data-stu-id="2da29-3577">If the `c` parameter is of type <xref:System.Reflection.Emit.TypeBuilder>, the result is based on the type that is to be built.</span></span> <span data-ttu-id="2da29-3578">Im folgenden Codebeispiel wird veranschaulicht, dies mithilfe eines integrierten Typs mit dem Namen `B`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3578">The following code example demonstrates this using a built type named `B`.</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3579">Das folgende Beispiel veranschaulicht die `IsAssignableFrom` -Methode definiert Klassen, Arrays Ganzzahlen und Generika.</span><span class="sxs-lookup"><span data-stu-id="2da29-3579">The following example demonstrates the `IsAssignableFrom` method using defined classes, integer arrays, and generics.</span></span>  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3580">Ruft einen Wert ab, der angibt, ob für <see langword="AutoClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3580">Gets a value indicating whether the string format attribute <see langword="AutoClass" /> is selected for the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3581">
            <see langword="true" />, wenn für <see langword="AutoClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3581">
              <see langword="true" /> if the string format attribute <see langword="AutoClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3582">Die <xref:System.Reflection.TypeAttributes.StringFormatMask> wählt die Zeichenfolgenformatattribute.</span><span class="sxs-lookup"><span data-stu-id="2da29-3582">The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes.</span></span> <span data-ttu-id="2da29-3583">Die Zeichenfolge Formatattribute zur Verbesserung der Interoperabilität von definieren, wie Zeichenfolgen interpretiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3583">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="2da29-3584">Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde.</span><span class="sxs-lookup"><span data-stu-id="2da29-3584">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="2da29-3585">Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3585">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="2da29-3586">Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3586">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3587">Ruft einen Wert ab, der angibt, ob die Felder des aktuellen Typs automatisch von der Common Language Runtime angelegt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3587">Gets a value indicating whether the fields of the current type are laid out automatically by the common language runtime.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3588">
            <see langword="true" />, wenn die <see cref="P:System.Type.Attributes" />-Eigenschaft des aktuellen Typs <see cref="F:System.Reflection.TypeAttributes.AutoLayout" /> umfasst; andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3588">
              <see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3589">Diese Eigenschaft wird als Annehmlichkeit bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3589">This property is provided as a convenience.</span></span> <span data-ttu-id="2da29-3590">Alternativ können Sie die <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> Enumerationswert, wählen Sie die Attribute des Typs Layout und diesen dann testen, ob <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3590">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="2da29-3591">Die <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, und <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> Enumerationswerte anzugeben, wie die Felder des Typs werden im Arbeitsspeicher angeordnet.</span><span class="sxs-lookup"><span data-stu-id="2da29-3591">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="2da29-3592">Für dynamische Typen festlegbaren <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> beim Erstellen des Typs.</span><span class="sxs-lookup"><span data-stu-id="2da29-3592">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="2da29-3593">Im Code, gelten die <xref:System.Runtime.InteropServices.StructLayoutAttribute> -Attribut mit der <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> Enumerationswert in den Typ, damit die Laufzeit die geeignete Möglichkeit zum Klassenlayout bestimmen können.</span><span class="sxs-lookup"><span data-stu-id="2da29-3593">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> enumeration value to the type, to let the runtime determine the appropriate way to lay out the class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-3594">Können Sie keine der <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> Methode, um zu bestimmen, ob die <xref:System.Runtime.InteropServices.StructLayoutAttribute> auf einen Typ angewendet wurde.</span><span class="sxs-lookup"><span data-stu-id="2da29-3594">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="2da29-3595">Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde.</span><span class="sxs-lookup"><span data-stu-id="2da29-3595">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="2da29-3596">Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft wird bestimmt durch `MyGenericType<T>.`</span><span class="sxs-lookup"><span data-stu-id="2da29-3596">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`</span></span>  
  
 <span data-ttu-id="2da29-3597">Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3597">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3598">Das folgende Beispiel erstellt eine Instanz des Typs und zeigt die <xref:System.Type.IsAutoLayout%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-3598">The following example creates an instance of the type and displays the <xref:System.Type.IsAutoLayout%2A> property.</span></span>  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3599">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> als Verweis übergeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3599">Gets a value indicating whether the <see cref="T:System.Type" /> is passed by reference.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3600">
            <see langword="true" />, wenn <see cref="T:System.Type" /> als Verweis übergeben wird, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3600">
              <see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3601">Um den tatsächlichen Typ zu erhalten, dereferenzieren den Typ, der als Verweis übergeben wurde, und rufen Sie anschließend <xref:System.Type.GetElementType%2A> für diesen Typ.</span><span class="sxs-lookup"><span data-stu-id="2da29-3601">To get to the actual type, dereference the type that was passed by reference, and then call <xref:System.Type.GetElementType%2A> on that type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3602">Das folgende Beispiel veranschaulicht die Verwendung von der `IsByRef` Eigenschaft zu überprüfen, ob ein angegebenen Typs als Verweis übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-3602">The following example demonstrates a use of the `IsByRef` property to check whether a specified type is passed by reference.</span></span> <span data-ttu-id="2da29-3603">Im Beispiel wird die Klasse definiert `MyTypeDelegator`, welche Außerkraftsetzungen der `HasElementTypeImpl` Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-3603">The example defines the class `MyTypeDelegator`, which overrides the `HasElementTypeImpl` method.</span></span> <span data-ttu-id="2da29-3604">Die Hauptklasse überprüft die `HasElementType` Eigenschaft und zeigt den Elementtyp an.</span><span class="sxs-lookup"><span data-stu-id="2da29-3604">The main class checks for the `HasElementType` property and displays the element type.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3605">Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.IsByRef" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> als Verweis übergeben wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3605">When overridden in a derived class, implements the <see cref="P:System.Type.IsByRef" /> property and determines whether the <see cref="T:System.Type" /> is passed by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3606">
            <see langword="true" />, wenn <see cref="T:System.Type" /> als Verweis übergeben wird, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3606">
              <see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3607">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> eine Klasse oder ein Delegat ist, d. h. weder ein Werttyp noch eine Schnittstelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3607">Gets a value indicating whether the <see cref="T:System.Type" /> is a class or a delegate; that is, not a value type or interface.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3608">
            <see langword="true" />, wenn <see cref="T:System.Type" /> eine Klasse ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3608">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a class; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3609">Diese Eigenschaft gibt `true` für Klassen als auch für Delegaten.</span><span class="sxs-lookup"><span data-stu-id="2da29-3609">This property returns `true` for classes as well as delegates.</span></span> <span data-ttu-id="2da29-3610">Es gibt `false` für Werttypen (für Strukturen und Enumerationen) auch wenn sie verschachtelt sind.</span><span class="sxs-lookup"><span data-stu-id="2da29-3610">It returns `false` for value types (for structures and enumerations) even if they are boxed.</span></span>  
  
 <span data-ttu-id="2da29-3611">Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `true`. Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Eigenschaft `true` ist die generische Typdefinition einer Klassendefinition; d. h. kein definiert eine Schnittstelle oder ein Werttyp.</span><span class="sxs-lookup"><span data-stu-id="2da29-3611">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `true`.If the current <xref:System.Type> represents a constructed generic type, this property returns `true` if the generic type definition is a class definition; that is, it does not define an interface or a value type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-3612">Diese Eigenschaft gibt `true` für `Type` Instanzen, die darstellen, die <xref:System.Enum> und <xref:System.ValueType> Klassen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3612">This property returns `true` for `Type` instances that represent the <xref:System.Enum> and <xref:System.ValueType> classes.</span></span> <span data-ttu-id="2da29-3613">Diese beiden Klassen sind die Basisklasse für Enumerationen und Werttypen, allerdings sind nicht Enumerationen oder Werttypen selbst.</span><span class="sxs-lookup"><span data-stu-id="2da29-3613">These two classes are the base types for enumerations and value types, respectively, but they are not enumerations or value types themselves.</span></span> <span data-ttu-id="2da29-3614">Weitere Informationen finden Sie unter der <xref:System.Type.IsValueType%2A> und <xref:System.Type.IsEnum%2A> Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="2da29-3614">For more information, see the <xref:System.Type.IsValueType%2A> and <xref:System.Type.IsEnum%2A> properties.</span></span>  
  
 <span data-ttu-id="2da29-3615">Die <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> Enumerationswert kennzeichnet eine Typdeklaration als Klasse oder Schnittstelle. Klassen und Werttypen sind jedoch mit markierten der <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> Attribut.</span><span class="sxs-lookup"><span data-stu-id="2da29-3615">The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> enumeration value  distinguishes a type declaration as class or interface.However, both classes and value types are marked with the <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> attribute.</span></span> <span data-ttu-id="2da29-3616">Wenn Sie den Wert der Eigenschaft Attributes aus und Verwenden des Typs Abrufen der <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> um zu bestimmen, ob ein Typ eine Klasse anstelle eines Werttyps ist, müssen Sie auch Aufrufen der <xref:System.Type.IsValueType%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-3616">If you retrieve the value of a type's Attributes property and use the <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> value to determine whether a type is a class instead of a value type, you must also call the <xref:System.Type.IsValueType%2A> property.</span></span> <span data-ttu-id="2da29-3617">Im Beispiel für die <xref:System.Reflection.TypeAttributes> Enumeration enthält zusätzliche Informationen sowie beispielsweise.</span><span class="sxs-lookup"><span data-stu-id="2da29-3617">The example for the <xref:System.Reflection.TypeAttributes> enumeration contains additional information as well as anexample.</span></span>  
  
 <span data-ttu-id="2da29-3618">Diese Eigenschaft ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3618">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3619">Das folgende Beispiel erstellt eine Instanz eines Typs und gibt an, ob der Typ eine Klasse ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3619">The following example creates an instance of a type and indicates whether the type is a class.</span></span>  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3620">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> ein COM-Objekt ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3620">Gets a value indicating whether the <see cref="T:System.Type" /> is a COM object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3621">
            <see langword="true" />, wenn <see cref="T:System.Type" /> ein COM-Objekt ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3621">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3622">Diese Methode gibt `false` für COM-Schnittstellen, da diese keine Objekte sind.</span><span class="sxs-lookup"><span data-stu-id="2da29-3622">This method returns `false` for COM interfaces because they are not objects.</span></span> <span data-ttu-id="2da29-3623">COM-Schnittstellen können von Microsoft .NET Framework-Objekte implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3623">COM interfaces can be implemented by Microsoft .NET Framework objects.</span></span>  
  
 <span data-ttu-id="2da29-3624">Sie können auch eine COM‑Klasse laden und Abrufen eine `Type` Objekt für diese COM-Klasse, indem die [Tlbimp.exe (Type Library Importer-Tool)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) Tool.</span><span class="sxs-lookup"><span data-stu-id="2da29-3624">You can also load a COM class and get a `Type` object for that COM class by using the [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool.</span></span>  
  
 <span data-ttu-id="2da29-3625">Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde.</span><span class="sxs-lookup"><span data-stu-id="2da29-3625">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="2da29-3626">Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int`> (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3626">For example, if the current <xref:System.Type> represents `MyGenericType<int`> (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="2da29-3627">Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3627">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3628">Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.IsCOMObject" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> ein COM-Objekt ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3628">When overridden in a derived class, implements the <see cref="P:System.Type.IsCOMObject" /> property and determines whether the <see cref="T:System.Type" /> is a COM object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3629">
            <see langword="true" />, wenn <see cref="T:System.Type" /> ein COM-Objekt ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3629">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3630">Diese Methode gibt `false` für COM-Schnittstellen, da diese keine Objekte sind.</span><span class="sxs-lookup"><span data-stu-id="2da29-3630">This method returns `false` for COM interfaces because they are not objects.</span></span> <span data-ttu-id="2da29-3631">COM-Schnittstellen können von Microsoft .NET Framework-Objekte implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3631">COM interfaces can be implemented by Microsoft .NET Framework objects.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3632">Ruft einen Wert ab, der angibt, ob dieses Objekt einen konstruierten generischen Typ darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3632">Gets a value that indicates whether this object represents a constructed generic type.</span>
          </span>
          <span data-ttu-id="2da29-3633">Sie können Instanzen eines konstruierten generischen Typs erstellen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3633">You can create instances of a constructed generic type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3634">
            <see langword="true" />, wenn dieses Objekt einen konstruierten generischen Typ darstellt, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3634">
              <see langword="true" /> if this object represents a constructed generic type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3635">Ein konstruierter generischer Typ wies explizite Typen, die für alle generischen Typparameter angegeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-3635">A constructed generic type has had explicit types supplied for all of its generic type parameters.</span></span> <span data-ttu-id="2da29-3636">Es wird auch als ein geschlossener generischer Typ bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="2da29-3636">It is also referred to as a closed generic type.</span></span>  
  
 <span data-ttu-id="2da29-3637">Wenn diese Eigenschaft den Wert `true`, können Sie Instanzen des aktuellen Typs erstellen, wenn es sich um `false`, nicht möglich.</span><span class="sxs-lookup"><span data-stu-id="2da29-3637">When this property is `true`, you can create instances of the current type; when it is `false`, you can't.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3638">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> in einen Kontext aufgenommen werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3638">Gets a value indicating whether the <see cref="T:System.Type" /> can be hosted in a context.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3639">
            <see langword="true" />, wenn <see cref="T:System.Type" /> in einen Kontext aufgenommen werden kann, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3639">
              <see langword="true" /> if the <see cref="T:System.Type" /> can be hosted in a context; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3640">Ein Kontext fängt Aufrufe von Klassenmembern ab und erzwingt Richtlinien, die auf die Klasse, z. B. Synchronisierung angewendet werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3640">A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization.</span></span> <span data-ttu-id="2da29-3641">Ausführlichere Informationen über Remotekontext finden Sie unter <xref:System.Runtime.Remoting.Contexts.Context>.</span><span class="sxs-lookup"><span data-stu-id="2da29-3641">For more detailed information on remoting contexts, see <xref:System.Runtime.Remoting.Contexts.Context>.</span></span>  
  
 <span data-ttu-id="2da29-3642">Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3642">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3643">Das folgende Beispiel veranschaulicht die `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, und <xref:System.Type.IsPrimitive%2A> Eigenschaften der <xref:System.Type> Klasse.</span><span class="sxs-lookup"><span data-stu-id="2da29-3643">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="2da29-3644">Er überprüft, ob der angegebene Typ in den Kontext aufgenommen werden kann, ob er als Verweis gemarshallt werden kann und ob der Typ ein primitiver Datentyp ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3644">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3645">Implementiert die <see cref="P:System.Type.IsContextful" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> in einen Kontext aufgenommen werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3645">Implements the <see cref="P:System.Type.IsContextful" /> property and determines whether the <see cref="T:System.Type" /> can be hosted in a context.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3646">
            <see langword="true" />, wenn <see cref="T:System.Type" /> in einen Kontext aufgenommen werden kann, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3646">
              <see langword="true" /> if the <see cref="T:System.Type" /> can be hosted in a context; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3647">Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3647">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="2da29-3648">Ein Kontext fängt Aufrufe von Klassenmembern ab und erzwingt Richtlinien, die auf die Klasse, z. B. Synchronisierung angewendet werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3648">A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3649">Das folgende Beispiel veranschaulicht die Verwendung von der `IsContextfulImpl` Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-3649">The following example demonstrates a use of the `IsContextfulImpl` method.</span></span>  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3650">Ruft einen Wert ab, der angibt, ob der aktuelle <see cref="T:System.Type" /> eine Enumeration darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3650">Gets a value indicating whether the current <see cref="T:System.Type" /> represents an enumeration.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3651">
            <see langword="true" />, wenn der aktuelle <see cref="T:System.Type" /> eine Enumeration darstellt, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3651">
              <see langword="true" /> if the current <see cref="T:System.Type" /> represents an enumeration; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3652">Diese Eigenschaft gibt `true` für eine Enumeration, aber nicht für die <xref:System.Enum> -Typ selbst.</span><span class="sxs-lookup"><span data-stu-id="2da29-3652">This property returns `true` for an enumeration, but not for the <xref:System.Enum> type itself.</span></span>  
  
 <span data-ttu-id="2da29-3653">Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde.</span><span class="sxs-lookup"><span data-stu-id="2da29-3653">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="2da29-3654">Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3654">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="2da29-3655">Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3655">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="2da29-3656">Diese Eigenschaft ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3656">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3657">Im folgenden Beispiel wird veranschaulicht, wie die `IsEnum` Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-3657">The following example demonstrates how to use the `IsEnum` property.</span></span>  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="2da29-3658">Der zu überprüfende Wert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3658">The value to be tested.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-3659">Gibt einen Wert zurück, der angibt, ob der angegebene Wert im aktuellen Enumerationstyp vorhanden ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3659">Returns a value that indicates whether the specified value exists in the current enumeration type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3660">
            <see langword="true" />, wenn der angegebene Wert ein Member des aktuellen Enumerationstyps ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3660">
              <see langword="true" /> if the specified value is a member of the current enumeration type; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-3661">Der aktuelle Typ ist keine Enumeration.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3661">The current type is not an enumeration.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-3662">
            <paramref name="value" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3662">
              <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="2da29-3663">
            <paramref name="value" /> ist von einem Typ, der nicht der zugrunde liegende Typ einer Enumeration sein kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3663">
              <paramref name="value" /> is of a type that cannot be the underlying type of an enumeration.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="2da29-3664">Der COM-Typ, der auf Äquivalenz mit dem aktuellen Typ überprüft wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3664">The COM type that is tested for equivalence with the current type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-3665">Bestimmt, ob zwei COM-Typen die gleiche Identität haben und äquivalente Typen aufweisen können.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3665">Determines whether two COM types have the same identity and are eligible for type equivalence.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3666">
            <see langword="true" />, wenn die COM-Typen äquivalent sind, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3666">
              <see langword="true" /> if the COM types are equivalent; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="2da29-3667">Diese Methode gibt auch <see langword="false" /> zurück, wenn ein Typ in einer Assembly enthalten ist, die zum Ausführen geladen wird, und der andere in einer Assembly enthalten ist, die in den reflektionsbezogenen Kontext geladen wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3667">This method also returns <see langword="false" /> if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3668">Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], die common Language Runtime unterstützt das Einbetten von Typinformationen für COM-Typen direkt in verwaltete Assemblys, anstatt die verwalteten Assemblys zum Abrufen der Typinformationen für COM-Typen von Interop Assemblys.</span><span class="sxs-lookup"><span data-stu-id="2da29-3668">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the common language runtime supports the embedding of type information for COM types directly into managed assemblies, instead of requiring the managed assemblies to obtain type information for COM types from interop assemblies.</span></span> <span data-ttu-id="2da29-3669">Da die eingebettete Typinformation nur die Typen und Member enthält, die tatsächlich von einer verwalteten Assembly verwendet werden, können zwei verwaltete Assemblys möglicherweise sehr unterschiedliche Ansichten desselben COM-Typs haben.</span><span class="sxs-lookup"><span data-stu-id="2da29-3669">Because the embedded type information includes only the types and members that are actually used by a managed assembly, two managed assemblies might have very different views of the same COM type.</span></span> <span data-ttu-id="2da29-3670">Jede verwaltete Assembly besitzt ein anderes <xref:System.Type>-Objekt, das eine Ansicht des COM-Typs darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3670">Each managed assembly has a different <xref:System.Type> object to represent its view of the COM type.</span></span> <span data-ttu-id="2da29-3671">Die Common Language Runtime unterstützt Typäquivalenz zwischen diesen unterschiedlichen Ansichten für Schnittstellen, Strukturen, Enumerationen und Delegaten.</span><span class="sxs-lookup"><span data-stu-id="2da29-3671">The common language runtime supports type equivalence between these different views for interfaces, structures, enumerations, and delegates.</span></span>  
  
 <span data-ttu-id="2da29-3672">Typäquivalenz bedeutet, dass ein COM-Objekt, das von einer verwalteten Assembly an eine andere übergeben wird, für den entsprechenden verwalteten Typ in der empfangenden Assembly bereitgestellt werden kann.</span><span class="sxs-lookup"><span data-stu-id="2da29-3672">Type equivalence means that a COM object that is passed from one managed assembly to another can be cast to the appropriate managed type in the receiving assembly.</span></span> <span data-ttu-id="2da29-3673">Die <xref:System.Type.IsEquivalentTo%2A> -Methode können Sie eine Assembly, um zu ermitteln, ein COM-Objekt, das von einer anderen Assembly abgerufen, die gleiche COM-Identität als eines der ersten eigenen eingebettete Interop-Assemblytyp hat und daher auf diesen Typ umgewandelt werden kann.</span><span class="sxs-lookup"><span data-stu-id="2da29-3673">The <xref:System.Type.IsEquivalentTo%2A> method enables an assembly to determine that a COM object obtained from another assembly has the same COM identity as one of the first assembly's own embedded interop types, and thus can be cast to that type.</span></span>  
  
 <span data-ttu-id="2da29-3674">Weitere Informationen finden Sie unter [Typäquivalenz und eingebettete Interop-Typen](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).</span><span class="sxs-lookup"><span data-stu-id="2da29-3674">For more information, see [Type Equivalence and Embedded Interop Types](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3675">Ruft einen Wert ab, der angibt, ob die Felder des aktuellen Typs an den explizit angegebenen Offsets angelegt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3675">Gets a value indicating whether the fields of the current type are laid out at explicitly specified offsets.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3676">
            <see langword="true" />, wenn die <see cref="P:System.Type.Attributes" />-Eigenschaft des aktuellen Typs <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" /> umfasst; andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3676">
              <see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3677">Diese Eigenschaft wird als Annehmlichkeit bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3677">This property is provided as a convenience.</span></span> <span data-ttu-id="2da29-3678">Alternativ können Sie die <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> Enumerationswert, wählen Sie die Attribute des Typs Layout und diesen dann testen, ob <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3678">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="2da29-3679">Die <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, und <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> Enumerationswerte anzugeben, wie die Felder des Typs werden im Arbeitsspeicher angeordnet.</span><span class="sxs-lookup"><span data-stu-id="2da29-3679">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="2da29-3680">Für dynamische Typen festlegbaren <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> beim Erstellen des Typs.</span><span class="sxs-lookup"><span data-stu-id="2da29-3680">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="2da29-3681">Im Code, gelten die <xref:System.Runtime.InteropServices.StructLayoutAttribute> -Attribut mit der <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> Enumerationswert in den Typ, um anzugeben, dass die Offsets, an dem die Felder starten, explizit angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3681">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> enumeration value to the type, to specify that the offsets at which the fields start are specified explicitly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-3682">Können Sie keine der <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> Methode, um zu bestimmen, ob die <xref:System.Runtime.InteropServices.StructLayoutAttribute> auf einen Typ angewendet wurde.</span><span class="sxs-lookup"><span data-stu-id="2da29-3682">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="2da29-3683">Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde.</span><span class="sxs-lookup"><span data-stu-id="2da29-3683">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="2da29-3684">Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3684">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="2da29-3685">Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3685">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3686">Das folgende Beispiel erstellt eine Instanz eines Typs und zeigt den Wert des seine <xref:System.Type.IsExplicitLayout%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-3686">The following example creates an instance of a type and displays the value of its <xref:System.Type.IsExplicitLayout%2A> property.</span></span> <span data-ttu-id="2da29-3687">Er verwendet die `MySystemTime` Klasse, die auch im Codebeispiel für <xref:System.Runtime.InteropServices.StructLayoutAttribute>.</span><span class="sxs-lookup"><span data-stu-id="2da29-3687">It uses the `MySystemTime` class, which is also in the code example for <xref:System.Runtime.InteropServices.StructLayoutAttribute>.</span></span>  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3688">Ruft einen Wert ab, der angibt, ob der aktuelle <see cref="T:System.Type" /> einen Typparameter einer generischen Typ- oder Methodendefinition darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3688">Gets a value indicating whether the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or method.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3689">
            <see langword="true" />, wenn das <see cref="T:System.Type" />-Objekt einen Typparameter einer generischen Typ- oder Methodendefinition darstellt, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3689">
              <see langword="true" /> if the <see cref="T:System.Type" /> object represents a type parameter of a generic type definition or generic method definition; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3690"><xref:System.Type> Objekte, die generischen Typparameter darstellen, abgerufen werden können, durch den Aufruf der <xref:System.Type.GetGenericArguments%2A> Methode eine <xref:System.Type> -Objekt, das eine generische Typdefinition darstellt, oder die <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> Methode eine <xref:System.Reflection.MethodInfo> -Objekt, das eine generische Methode darstellt Definition.</span><span class="sxs-lookup"><span data-stu-id="2da29-3690"><xref:System.Type> objects that represent generic type parameters can be obtained by calling the <xref:System.Type.GetGenericArguments%2A> method of a <xref:System.Type> object that represents a generic type definition, or the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> method of a <xref:System.Reflection.MethodInfo> object that represents a generic method definition.</span></span>  
  
-   <span data-ttu-id="2da29-3691">Für eine generische Typ- bzw. Methodendefinition die <xref:System.Type.IsGenericParameter%2A> -Eigenschaft gibt `true` für jedes Element des sich ergebenden Array.</span><span class="sxs-lookup"><span data-stu-id="2da29-3691">For a generic type or method definition, the <xref:System.Type.IsGenericParameter%2A> property returns `true` for every element of the resulting array.</span></span>  
  
-   <span data-ttu-id="2da29-3692">Für einen geschlossenen konstruierten Typ oder Methode die <xref:System.Type.IsGenericParameter%2A> -Eigenschaft gibt `false` für jedes Element des Arrays zurückgegebenes die <xref:System.Type.GetGenericArguments%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-3692">For a closed constructed type or method, the <xref:System.Type.IsGenericParameter%2A> property returns `false` for every element of the array returned by the <xref:System.Type.GetGenericArguments%2A> method.</span></span>  
  
-   <span data-ttu-id="2da29-3693">Für einen offenen konstruierten Typ oder eine Methode einige Elemente des Arrays möglicherweise bestimmte Typen und andere möglicherweise Typparameter.</span><span class="sxs-lookup"><span data-stu-id="2da29-3693">For an open constructed type or method, some elements of the array might be specific types and others might be type parameters.</span></span> <span data-ttu-id="2da29-3694"><xref:System.Type.IsGenericParameter%2A> Gibt `false` für die Typen und `true` für den Typparameter.</span><span class="sxs-lookup"><span data-stu-id="2da29-3694"><xref:System.Type.IsGenericParameter%2A> returns `false` for the types and `true` for the type parameters.</span></span> <span data-ttu-id="2da29-3695">Das Codebeispiel für die <xref:System.Type.ContainsGenericParameters%2A> Eigenschaft wird mit einer Mischung von Typen und die Typparameter eine generische Klasse veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="2da29-3695">The code example for the <xref:System.Type.ContainsGenericParameters%2A> property demonstrates a generic class with a mixture of types and type parameters.</span></span>  
  
 <span data-ttu-id="2da29-3696">Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-3696">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3697">Im folgenden Beispiel wird die <xref:System.Type.IsGenericParameter%2A> Eigenschaft so testen Sie die generischen Typparameter in einem generischen Typ.</span><span class="sxs-lookup"><span data-stu-id="2da29-3697">The following example uses the <xref:System.Type.IsGenericParameter%2A> property to test for generic type parameters in a generic type.</span></span>  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3698">Ruft einen Wert ab, der angibt, ob der aktuelle Typ ein generischer Typ ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3698">Gets a value indicating whether the current type is a generic type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3699">
            <see langword="true" /> Wenn der aktuelle Typ ein generischer Typ ist; andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3699">
              <see langword="true" /> if the current type is a generic type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3700">Verwenden der <xref:System.Type.IsGenericType%2A> -Eigenschaft können Sie bestimmen, ob ein <xref:System.Type> -Objekt einen generischen Typ darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3700">Use the <xref:System.Type.IsGenericType%2A> property to determine whether a <xref:System.Type> object represents a generic type.</span></span> <span data-ttu-id="2da29-3701">Verwenden der <xref:System.Type.ContainsGenericParameters%2A> -Eigenschaft können Sie bestimmen, ob ein <xref:System.Type> -Objekt ein offener konstruierten Typ oder einen geschlossenen konstruierten Typ darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3701">Use the <xref:System.Type.ContainsGenericParameters%2A> property to determine whether a <xref:System.Type> object represents an open constructed type or a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-3702">Die <xref:System.Type.IsGenericType%2A> -Eigenschaft gibt `false` Wenn nicht die unmittelbare Typ generisch ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3702">The <xref:System.Type.IsGenericType%2A> property returns `false` if the immediate type is not generic.</span></span> <span data-ttu-id="2da29-3703">Angenommen, ein Array, dessen Elemente vom Typ sind `A<int>` (`A(Of Integer)` in Visual Basic) ist nicht selbst ein generischer Typ.</span><span class="sxs-lookup"><span data-stu-id="2da29-3703">For example, an array whose elements are of type `A<int>` (`A(Of Integer)` in Visual Basic) is not itself a generic type.</span></span>  
  
 <span data-ttu-id="2da29-3704">In der folgenden Tabelle werden die Invarianten Bedingungen für allgemeine Begriffe in generischen Reflektion verwendet zusammengefasst.</span><span class="sxs-lookup"><span data-stu-id="2da29-3704">The following table summarizes the invariant conditions for common terms used in generic reflection.</span></span>  
  
|<span data-ttu-id="2da29-3705">Begriff</span><span class="sxs-lookup"><span data-stu-id="2da29-3705">Term</span></span>|<span data-ttu-id="2da29-3706">Invariante</span><span class="sxs-lookup"><span data-stu-id="2da29-3706">Invariant</span></span>|  
|----------|---------------|  
|<span data-ttu-id="2da29-3707">generische Typdefinition</span><span class="sxs-lookup"><span data-stu-id="2da29-3707">generic type definition</span></span>|<span data-ttu-id="2da29-3708">Die <xref:System.Type.IsGenericTypeDefinition%2A>-Eigenschaft ist `true`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3708">The <xref:System.Type.IsGenericTypeDefinition%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="2da29-3709">Definiert einen generischen Typ an.</span><span class="sxs-lookup"><span data-stu-id="2da29-3709">Defines a generic type.</span></span> <span data-ttu-id="2da29-3710">Ein konstruierter Typ wird erstellt, durch Aufrufen der <xref:System.Type.MakeGenericType%2A> Methode auf eine <xref:System.Type> -Objekt, das eine generische Typdefinition darstellt, und ein Array der Argumente des Typs angeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-3710">A constructed type is created by calling the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object that represents a generic type definition and specifying an array of type arguments.</span></span><br /><br /> <span data-ttu-id="2da29-3711"><xref:System.Type.MakeGenericType%2A> kann nur für generische Typdefinitionen aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3711"><xref:System.Type.MakeGenericType%2A> can be called only on generic type definitions.</span></span><br /><br /> <span data-ttu-id="2da29-3712">Generische Typdefinition ist ein generischer Typ (die <xref:System.Type.IsGenericType%2A> Eigenschaft `true`), das Gegenteil aber nicht "true".</span><span class="sxs-lookup"><span data-stu-id="2da29-3712">Any generic type definition is a generic type (the <xref:System.Type.IsGenericType%2A> property is `true`), but the converse is not true.</span></span>|  
|<span data-ttu-id="2da29-3713">generischer Typ</span><span class="sxs-lookup"><span data-stu-id="2da29-3713">generic type</span></span>|<span data-ttu-id="2da29-3714">Die <xref:System.Type.IsGenericType%2A>-Eigenschaft ist `true`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3714">The <xref:System.Type.IsGenericType%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="2da29-3715">Hierbei kann es sich um eine generische Typdefinition, ein offener konstruierten Typ oder einen geschlossenen konstruierten Typ sein.</span><span class="sxs-lookup"><span data-stu-id="2da29-3715">Can be a generic type definition, an open constructed type, or a closed constructed type.</span></span><br /><br /> <span data-ttu-id="2da29-3716">Beachten Sie, dass ein, dessen Elementtyp Arraytyp ist generisch ist nicht selbst ein generischer Typ.</span><span class="sxs-lookup"><span data-stu-id="2da29-3716">Note that an array type whose element type is generic is not itself a generic type.</span></span> <span data-ttu-id="2da29-3717">Dasselbe gilt für eine <xref:System.Type> Objekt, das einen Zeiger auf einen generischen Typ darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3717">The same is true of a <xref:System.Type> object representing a pointer to a generic type.</span></span>|  
|<span data-ttu-id="2da29-3718">Öffnen Sie konstruierten Typ</span><span class="sxs-lookup"><span data-stu-id="2da29-3718">open constructed type</span></span>|<span data-ttu-id="2da29-3719">Die <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft ist `true`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3719">The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="2da29-3720">Beispiele sind ein generischer Typ, der nicht zugewiesene Typparameter verfügt, ein Typ, der in der Definition eines generischen Typs oder in einen offenen konstruierten Typ geschachtelt ist oder einen generischen Typ an, die ein Type-Argument für die die <xref:System.Type.ContainsGenericParameters%2A> Eigenschaft ist `true`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3720">Examples are a generic type that has unassigned type parameters, a type that is nested in a generic type definition or in an open constructed type, or a generic type that has a type argument for which the <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="2da29-3721">Es ist nicht möglich, eine Instanz einer offenen konstruierten Typ erstellen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3721">It is not possible to create an instance of an open constructed type.</span></span><br /><br /> <span data-ttu-id="2da29-3722">Beachten Sie, dass nicht alle offene konstruierte Typen generisch sind.</span><span class="sxs-lookup"><span data-stu-id="2da29-3722">Note that not all open constructed types are generic.</span></span> <span data-ttu-id="2da29-3723">Angenommen, ein Array, dessen Elementtyp eine generische Typdefinition ist, ist nicht generisch, und ein Zeiger auf einen offenen konstruierten Typ ist nicht generisch.</span><span class="sxs-lookup"><span data-stu-id="2da29-3723">For example, an array whose element type is a generic type definition is not generic, and a pointer to an open constructed type is not generic.</span></span>|  
|<span data-ttu-id="2da29-3724">geschlossenen konstruierten Typs</span><span class="sxs-lookup"><span data-stu-id="2da29-3724">closed constructed type</span></span>|<span data-ttu-id="2da29-3725">Die <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft ist `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3725">The <xref:System.Type.ContainsGenericParameters%2A> property is `false`.</span></span><br /><br /> <span data-ttu-id="2da29-3726">Wenn hat untersuchten rekursiv, den Typ nicht zugewiesene generische Parameter.</span><span class="sxs-lookup"><span data-stu-id="2da29-3726">When examined recursively, the type has no unassigned generic parameters.</span></span>|  
|<span data-ttu-id="2da29-3727">generischer Typparameter</span><span class="sxs-lookup"><span data-stu-id="2da29-3727">generic type parameter</span></span>|<span data-ttu-id="2da29-3728">Die <xref:System.Type.IsGenericParameter%2A>-Eigenschaft ist `true`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3728">The <xref:System.Type.IsGenericParameter%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="2da29-3729">Die <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft ist `true`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3729">The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="2da29-3730">In einer generischen Typdefinition ein Platzhalter für einen Typ, der später zugewiesen wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-3730">In a generic type definition, a placeholder for a type that will be assigned later.</span></span>|  
|<span data-ttu-id="2da29-3731">generisches Typargument</span><span class="sxs-lookup"><span data-stu-id="2da29-3731">generic type argument</span></span>|<span data-ttu-id="2da29-3732">Kann beliebigen Typs, einschließlich einen generischen Typparameter ab.</span><span class="sxs-lookup"><span data-stu-id="2da29-3732">Can be any type, including a generic type parameter.</span></span><br /><br /> <span data-ttu-id="2da29-3733">Typargumente werden als Array von angegeben <xref:System.Type> -Objekte übergeben, um die <xref:System.Type.MakeGenericType%2A> Methode, wenn Sie einen konstruierten generischen Typ erstellen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3733">Type arguments are specified as an array of <xref:System.Type> objects passed to the <xref:System.Type.MakeGenericType%2A> method when creating a constructed generic type.</span></span> <span data-ttu-id="2da29-3734">Wenn Instanzen des resultierenden Typs erstellt werden, sind die <xref:System.Type.ContainsGenericParameters%2A> Eigenschaft muss `false` für alle Typargumente.</span><span class="sxs-lookup"><span data-stu-id="2da29-3734">If instances of the resulting type are to be created, the <xref:System.Type.ContainsGenericParameters%2A> property must be `false` for all the type arguments.</span></span>|  
  
 <span data-ttu-id="2da29-3735">Im folgenden Codebeispiel und Tabelle veranschaulichen einige dieser Begriffe und Invarianten.</span><span class="sxs-lookup"><span data-stu-id="2da29-3735">The following code example and table illustrate some of these terms and invariants.</span></span> <span data-ttu-id="2da29-3736">Die `Derived` -Klasse ist von besonderem Interesse, da Basistyp einen konstruierten Typ ist, eine Mischung von Typen und die Typparameter in der Liste der Typargumente hat.</span><span class="sxs-lookup"><span data-stu-id="2da29-3736">The `Derived` class is of particular interest because its base type is a constructed type that has a mixture of types and type parameters in its type argument list.</span></span>  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 <span data-ttu-id="2da29-3737">Die folgende Tabelle zeigt Beispiele, die in den Klassen zu erstellen und verwenden `Base`, `Derived`, und `G`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3737">The following table shows examples that use and build on the classes `Base`, `Derived`, and `G`.</span></span> <span data-ttu-id="2da29-3738">Wenn die C++- und C#-Code identisch ist, wird nur ein Eintrag angezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3738">When the C++ and C# code is the same, only one entry is shown.</span></span>  
  
|<span data-ttu-id="2da29-3739">Beispiel</span><span class="sxs-lookup"><span data-stu-id="2da29-3739">Example</span></span>|<span data-ttu-id="2da29-3740">Invarianten</span><span class="sxs-lookup"><span data-stu-id="2da29-3740">Invariants</span></span>|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|<span data-ttu-id="2da29-3741">Für diesen Typ:</span><span class="sxs-lookup"><span data-stu-id="2da29-3741">For this type:</span></span><br /><br /> <span data-ttu-id="2da29-3742"><xref:System.Type.IsGenericType%2A> ist `true`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3742"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="2da29-3743"><xref:System.Type.IsGenericTypeDefinition%2A> ist `true`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3743"><xref:System.Type.IsGenericTypeDefinition%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="2da29-3744"><xref:System.Type.ContainsGenericParameters%2A> ist `true`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3744"><xref:System.Type.ContainsGenericParameters%2A> is `true`.</span></span>|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|<span data-ttu-id="2da29-3745">Für diesen Typ:</span><span class="sxs-lookup"><span data-stu-id="2da29-3745">For this type:</span></span><br /><br /> <span data-ttu-id="2da29-3746"><xref:System.Type.IsGenericType%2A> ist `true`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3746"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="2da29-3747"><xref:System.Type.IsGenericTypeDefinition%2A> ist `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3747"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="2da29-3748"><xref:System.Type.ContainsGenericParameters%2A> ist `true`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3748"><xref:System.Type.ContainsGenericParameters%2A> is `true`.</span></span>|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|<span data-ttu-id="2da29-3749">Für den Typ der Variable `d`:</span><span class="sxs-lookup"><span data-stu-id="2da29-3749">For the type of variable `d`:</span></span><br /><br /> <span data-ttu-id="2da29-3750"><xref:System.Type.IsGenericType%2A> ist `false` da `d` ist ein Array.</span><span class="sxs-lookup"><span data-stu-id="2da29-3750"><xref:System.Type.IsGenericType%2A> is `false` because `d` is an array.</span></span><br /><br /> <span data-ttu-id="2da29-3751"><xref:System.Type.IsGenericTypeDefinition%2A> ist `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3751"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="2da29-3752"><xref:System.Type.ContainsGenericParameters%2A> ist `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3752"><xref:System.Type.ContainsGenericParameters%2A> is `false`.</span></span>|  
|<span data-ttu-id="2da29-3753">`T`, `U`, und `V` (bei allen Vorkommen)</span><span class="sxs-lookup"><span data-stu-id="2da29-3753">`T`, `U`, and `V` (everywhere they appear)</span></span>|<span data-ttu-id="2da29-3754"><xref:System.Type.IsGenericParameter%2A> ist `true`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3754"><xref:System.Type.IsGenericParameter%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="2da29-3755"><xref:System.Type.IsGenericType%2A> ist `false` , da es keine Möglichkeit gibt, die einen Typparameter auf generische Typen zu beschränken.</span><span class="sxs-lookup"><span data-stu-id="2da29-3755"><xref:System.Type.IsGenericType%2A> is `false` because there is no way to constrain a type parameter to generic types.</span></span><br /><br /> <span data-ttu-id="2da29-3756"><xref:System.Type.IsGenericTypeDefinition%2A> ist `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3756"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="2da29-3757"><xref:System.Type.ContainsGenericParameters%2A> ist `true` da `T`, `U`, und `V` selbst generische Typparameter sind.</span><span class="sxs-lookup"><span data-stu-id="2da29-3757"><xref:System.Type.ContainsGenericParameters%2A> is `true` because `T`, `U`, and `V` are themselves generic type parameters.</span></span> <span data-ttu-id="2da29-3758">Dies bedeutet nichts über Typargumente nicht, die ihnen später zugewiesen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3758">This does not imply anything about type arguments that are assigned to them later.</span></span>|  
|<span data-ttu-id="2da29-3759">Der Typ des Felds `F`</span><span class="sxs-lookup"><span data-stu-id="2da29-3759">The type of field `F`</span></span>|<span data-ttu-id="2da29-3760"><xref:System.Type.IsGenericType%2A> ist `true`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3760"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="2da29-3761"><xref:System.Type.IsGenericTypeDefinition%2A> ist `false` , da der Typparameter, der ein Typ zugewiesen wurde `G`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3761"><xref:System.Type.IsGenericTypeDefinition%2A> is `false` because a type has been assigned to the type parameter of `G`.</span></span> <span data-ttu-id="2da29-3762">Beachten Sie, dass dies dem Aufruf der <xref:System.Type.MakeGenericType%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-3762">Note that this is equivalent to having called the <xref:System.Type.MakeGenericType%2A> method.</span></span><br /><br /> <span data-ttu-id="2da29-3763"><xref:System.Type.ContainsGenericParameters%2A> ist `true` da der Typ des Felds `F` ist ein Typargument, das ein offener konstruierten Typ ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3763"><xref:System.Type.ContainsGenericParameters%2A> is `true` because the type of field `F` has a type argument that is an open constructed type.</span></span> <span data-ttu-id="2da29-3764">Der konstruierte Typ geöffnet ist. da Typargument (d. h. `Base`) ist eine generische Typdefinition.</span><span class="sxs-lookup"><span data-stu-id="2da29-3764">The constructed type is open because its type argument (that is, `Base`) is a generic type definition.</span></span> <span data-ttu-id="2da29-3765">Dies veranschaulicht die rekursive Charakter der <xref:System.Type.IsGenericType%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-3765">This illustrates the recursive nature of the <xref:System.Type.IsGenericType%2A> property.</span></span>|  
|<span data-ttu-id="2da29-3766">Die geschachtelte Klasse `Nested`</span><span class="sxs-lookup"><span data-stu-id="2da29-3766">The nested class `Nested`</span></span>|<span data-ttu-id="2da29-3767"><xref:System.Type.IsGenericType%2A> ist `true`, obwohl die `Nested` -Klasse verfügt über keine generischen Typparameter von allein, weil sie in einem generischen Typ geschachtelt ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3767"><xref:System.Type.IsGenericType%2A> is `true`, even though the `Nested` class has no generic type parameters of its own, because it is nested in a generic type.</span></span><br /><br /> <span data-ttu-id="2da29-3768"><xref:System.Type.IsGenericTypeDefinition%2A> ist `true`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3768"><xref:System.Type.IsGenericTypeDefinition%2A> is `true`.</span></span> <span data-ttu-id="2da29-3769">Sie können also Aufrufen der <xref:System.Type.MakeGenericType%2A> -Methode, und übergeben Sie den Typparameter von einschließenden Typs `Derived`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3769">That is, you can call the <xref:System.Type.MakeGenericType%2A> method and supply the type parameter of the enclosing type, `Derived`.</span></span><br /><br /> <span data-ttu-id="2da29-3770"><xref:System.Type.ContainsGenericParameters%2A> ist `true` , da der einschließende Typ, `Derived`, verfügt der generische Typparameter.</span><span class="sxs-lookup"><span data-stu-id="2da29-3770"><xref:System.Type.ContainsGenericParameters%2A> is `true` because the enclosing type, `Derived`, has generic type parameters.</span></span> <span data-ttu-id="2da29-3771">Dies veranschaulicht die rekursive Charakter der <xref:System.Type.ContainsGenericParameters%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-3771">This illustrates the recursive nature of the <xref:System.Type.ContainsGenericParameters%2A> property.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3772">Das folgende Codebeispiel zeigt den Wert, der die <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, und <xref:System.Type.ContainsGenericParameters%2A> Eigenschaften für die Typen, die im Abschnitt "Hinweise" beschrieben.</span><span class="sxs-lookup"><span data-stu-id="2da29-3772">The following code example displays the value of the <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, and <xref:System.Type.ContainsGenericParameters%2A> properties for the types described in the Remarks section.</span></span> <span data-ttu-id="2da29-3773">Erläuterungen der Eigenschaftswerte finden Sie unter "Hinweise" der zugehörigen Tabelle.</span><span class="sxs-lookup"><span data-stu-id="2da29-3773">For explanations of the property values, see the accompanying table in Remarks.</span></span>  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3774">Ruft einen Wert ab, der angibt, ob der aktuelle <see cref="T:System.Type" /> eine generische Typdefinition darstellt, aus der andere generische Typen konstruiert werden können.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3774">Gets a value indicating whether the current <see cref="T:System.Type" /> represents a generic type definition, from which other generic types can be constructed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3775">
            <see langword="true" />, wenn das <see cref="T:System.Type" />-Objekt eine generische Typdefinition darstellt, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3775">
              <see langword="true" /> if the <see cref="T:System.Type" /> object represents a generic type definition; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3776">Eine generische Typdefinition ist eine Vorlage aus der anderen Typen konstruiert werden können.</span><span class="sxs-lookup"><span data-stu-id="2da29-3776">A generic type definition is a template from which other types can be constructed.</span></span> <span data-ttu-id="2da29-3777">Z. B. von der generischen Typdefinition `G<T>` (ausgedrückt in C#-Syntax; `G(Of T)` in Visual Basic oder `generic <typename T> ref class G` in C++) können Sie erstellen und instanziieren Sie den Typ `G<int>` (`G(Of Integer)` in Visual Basic), durch Aufrufen der <xref:System.Type.MakeGenericType%2A> Methode mit einer Liste mit generisches Argument der <xref:System.Int32> Typ.</span><span class="sxs-lookup"><span data-stu-id="2da29-3777">For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic), by calling the <xref:System.Type.MakeGenericType%2A> method with a generic argument list containing the <xref:System.Int32> type.</span></span> <span data-ttu-id="2da29-3778">Erhält eine <xref:System.Type> Objekt, das dies darstellt konstruierter Typ, der <xref:System.Type.GetGenericTypeDefinition%2A> Methode ruft die generische Typdefinition zurück, erneut aus.</span><span class="sxs-lookup"><span data-stu-id="2da29-3778">Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method gets the generic type definition back again.</span></span>  
  
 <span data-ttu-id="2da29-3779">Verwenden der <xref:System.Type.IsGenericTypeDefinition%2A> Eigenschaft, um zu bestimmen, ob Sie aus dem aktuellen Typ neue Typen erstellen können.</span><span class="sxs-lookup"><span data-stu-id="2da29-3779">Use the <xref:System.Type.IsGenericTypeDefinition%2A> property to determine whether you can create new types from the current type.</span></span> <span data-ttu-id="2da29-3780">Wenn die <xref:System.Type.IsGenericTypeDefinition%2A> -Eigenschaft gibt `true`, Sie erreichen die <xref:System.Type.MakeGenericType%2A> Methode, um neue generische Typen zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3780">If the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `true`, you can call the <xref:System.Type.MakeGenericType%2A> method to create new generic types.</span></span>  
  
 <span data-ttu-id="2da29-3781">Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-3781">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3782">Das folgende Beispiel zeigt Informationen zu einem Typ, einschließlich, und zwar unabhängig davon, ob es sich um eine generische Typdefinition ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3782">The following example displays information about a type, including whether or not it is a generic type definition.</span></span> <span data-ttu-id="2da29-3783">Informationen werden für einen konstruierten Typ, dessen Definition eines generischen Typs und einem normalen Typ angezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3783">Information is displayed for a constructed type, for its generic type definition, and for an ordinary type.</span></span>  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3784">Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Type" /> ein <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />-Attribut hat, was bedeutet, dass er aus einer COM-Typbibliothek importiert wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3784">Gets a value indicating whether the <see cref="T:System.Type" /> has a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> attribute applied, indicating that it was imported from a COM type library.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3785">
            <see langword="true" />, wenn der <see cref="T:System.Type" /> ein <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> hat, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3785">
              <see langword="true" /> if the <see cref="T:System.Type" /> has a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3786">Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde.</span><span class="sxs-lookup"><span data-stu-id="2da29-3786">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="2da29-3787">Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft wird bestimmt durch `MyGenericType<T>.`</span><span class="sxs-lookup"><span data-stu-id="2da29-3787">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`</span></span>  
  
 <span data-ttu-id="2da29-3788">Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3788">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="2da29-3789">Das mit dem aktuellen Typ zu vergleichende Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3789">The object to compare with the current type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-3790">Bestimmt, ob das angegebene Objekt eine Instanz des aktuellen <see cref="T:System.Type" /> ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3790">Determines whether the specified object is an instance of the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3791">
            <see langword="true" />, wenn der aktuelle <see langword="Type" /> in der Vererbungshierarchie des von <paramref name="o" /> dargestellten Objekts vorhanden ist oder wenn der aktuelle <see langword="Type" /> eine Schnittstelle ist, die von <paramref name="o" /> implementiert wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3791">
              <see langword="true" /> if the current <see langword="Type" /> is in the inheritance hierarchy of the object represented by <paramref name="o" />, or if the current <see langword="Type" /> is an interface that <paramref name="o" /> implements.</span>
          </span>
          <span data-ttu-id="2da29-3792">
            <see langword="false" />, wenn keine dieser Bedingungen zutrifft, wenn <paramref name="o" /> den Wert <see langword="null" /> hat oder wenn der aktuelle <see langword="Type" /> ein offener generischer Typ ist (d. h. <see cref="P:System.Type.ContainsGenericParameters" /> gibt <see langword="true" /> zurück).</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3792">
              <see langword="false" /> if neither of these conditions is the case, if <paramref name="o" /> is <see langword="null" />, or if the current <see langword="Type" /> is an open generic type (that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />).</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3793">Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3793">This method can be overridden by a derived class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-3794">Ein konstruierter Typ ist keine Instanz der generischen Typdefinition.</span><span class="sxs-lookup"><span data-stu-id="2da29-3794">A constructed type is not an instance of its generic type definition.</span></span> <span data-ttu-id="2da29-3795">D. h. `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) ist keine Instanz des `MyGenericList<T>` (`MyGenericList(Of T)` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-3795">That is, `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) is not an instance of `MyGenericList<T>` (`MyGenericList(Of T)` in Visual Basic).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3796">Im folgenden Beispiel wird die Verwendung der `IsInstanceOfType`-Methode gezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3796">The following example demonstrates the use of the `IsInstanceOfType` method.</span></span>  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3797">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> eine Schnittstelle ist, d. h. weder eine Klasse noch ein Werttyp.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3797">Gets a value indicating whether the <see cref="T:System.Type" /> is an interface; that is, not a class or a value type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3798">
            <see langword="true" />, wenn <see cref="T:System.Type" /> eine Schnittstelle ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3798">
              <see langword="true" /> if the <see cref="T:System.Type" /> is an interface; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3799">Die <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> eine Typdeklaration als Klasse, Schnittstelle oder ein Wert unterscheidet.</span><span class="sxs-lookup"><span data-stu-id="2da29-3799">The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> distinguishes a type declaration as class, interface or value type.</span></span>  
  
 <span data-ttu-id="2da29-3800">Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3800">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="2da29-3801">Diese Eigenschaft ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3801">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3802">Das folgende Beispiel erstellt eine Schnittstelle, für den Schnittstellentyp überprüft und gibt an, ob eine Klasse verfügt über die `IsInterface` Eigenschaftensatz.</span><span class="sxs-lookup"><span data-stu-id="2da29-3802">The following example creates an interface, checks for the interface type, and indicates whether a class has the `IsInterface` property set.</span></span>  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3803">Ruft einen Wert ab, der angibt, ob die Felder des aktuellen Typs sequenziell angelegt werden, in der Reihenfolge, in der sie definiert oder an die Metadaten ausgegeben wurden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3803">Gets a value indicating whether the fields of the current type are laid out sequentially, in the order that they were defined or emitted to the metadata.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3804">
            <see langword="true" />, wenn die <see cref="P:System.Type.Attributes" />-Eigenschaft des aktuellen Typs <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /> umfasst; andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3804">
              <see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3805">Diese Eigenschaft wird als Annehmlichkeit bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3805">This property is provided as a convenience.</span></span> <span data-ttu-id="2da29-3806">Alternativ können Sie die <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> Enumerationswert, wählen Sie die Attribute des Typs Layout und diesen dann testen, ob <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3806">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="2da29-3807">Die <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, und <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> Enumerationswerte anzugeben, wie die Felder des Typs werden im Arbeitsspeicher angeordnet.</span><span class="sxs-lookup"><span data-stu-id="2da29-3807">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="2da29-3808">Für dynamische Typen festlegbaren <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> beim Erstellen des Typs.</span><span class="sxs-lookup"><span data-stu-id="2da29-3808">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="2da29-3809">Im Code, gelten die <xref:System.Runtime.InteropServices.StructLayoutAttribute> -Attribut mit der <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> Enumerationswert in den Typ, um anzugeben, das Layout ist sequenziell.</span><span class="sxs-lookup"><span data-stu-id="2da29-3809">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> enumeration value to the type, to specify that layout is sequential.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-3810">Können Sie keine der <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> Methode, um zu bestimmen, ob die <xref:System.Runtime.InteropServices.StructLayoutAttribute> auf einen Typ angewendet wurde.</span><span class="sxs-lookup"><span data-stu-id="2da29-3810">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="2da29-3811">Weitere Informationen finden Sie im Abschnitt 9.1.2 der Spezifikation für die Common Language Infrastructure (CLI)-Dokumentation "Partition II: Metadata Definition and Semantics".</span><span class="sxs-lookup"><span data-stu-id="2da29-3811">For more information, see section 9.1.2 of the specification for the Common Language Infrastructure (CLI) documentation, "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="2da29-3812">Die Dokumentation ist online verfügbar. Sie finden sie unter [ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)](http://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))](http://go.microsoft.com/fwlink/?LinkID=65552) auf der Ecma International-Website.</span><span class="sxs-lookup"><span data-stu-id="2da29-3812">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 <span data-ttu-id="2da29-3813">Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde.</span><span class="sxs-lookup"><span data-stu-id="2da29-3813">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="2da29-3814">Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3814">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="2da29-3815">Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3815">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3816">Das folgende Beispiel erstellt eine Instanz einer Klasse für die die <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> Enumerationswert in der <xref:System.Runtime.InteropServices.StructLayoutAttribute> -Klasse festgelegt wurde, überprüft, ob die <xref:System.Type.IsLayoutSequential%2A> -Eigenschaft, und das Ergebnis wird angezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3816">The following example creates an instance of a class for which the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> enumeration value in the <xref:System.Runtime.InteropServices.StructLayoutAttribute> class has been set, checks for the <xref:System.Type.IsLayoutSequential%2A> property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3817">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> als Verweis gemarshallt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3817">Gets a value indicating whether the <see cref="T:System.Type" /> is marshaled by reference.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3818">
            <see langword="true" />, wenn <see cref="T:System.Type" /> als Verweis gemarshallt wird, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3818">
              <see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="2da29-3819">Das folgende Beispiel veranschaulicht die `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, und <xref:System.Type.IsPrimitive%2A> Eigenschaften der <xref:System.Type> Klasse.</span><span class="sxs-lookup"><span data-stu-id="2da29-3819">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="2da29-3820">Er überprüft, ob der angegebene Typ in den Kontext aufgenommen werden kann, ob er als Verweis gemarshallt werden kann und ob der Typ ein primitiver Datentyp ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3820">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3821">Implementiert die <see cref="P:System.Type.IsMarshalByRef" />-Eigenschaft und bestimmt, ob der <see cref="T:System.Type" /> als Verweis gemarshallt wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3821">Implements the <see cref="P:System.Type.IsMarshalByRef" /> property and determines whether the <see cref="T:System.Type" /> is marshaled by reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3822">
            <see langword="true" />, wenn <see cref="T:System.Type" /> als Verweis gemarshallt wird, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3822">
              <see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3823">Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-3823">This method can be overridden by a derived class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3824">Im folgenden Beispiel wird bestimmt, ob der angegebene Typ Verweis gemarshallt wird, und das Ergebnis wird angezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3824">The following example determines whether the given type is marshaled by reference and displays the result.</span></span>  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3825">Ruft einen Wert ab, der angibt, ob das aktuelle <see cref="T:System.Type" />-Objekt einen Typ darstellt, dessen Definition in der Definition eines anderen Typs geschachtelt ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3825">Gets a value indicating whether the current <see cref="T:System.Type" /> object represents a type whose definition is nested inside the definition of another type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3826">
            <see langword="true" />, wenn der <see cref="T:System.Type" /> in einem anderen Typ geschachtelt ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3826">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested inside another type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3827">Die <xref:System.Type.IsNested%2A> -Eigenschaft gibt `true` für alle geschachtelten Typen unabhängig von der Sichtbarkeit.</span><span class="sxs-lookup"><span data-stu-id="2da29-3827">The <xref:System.Type.IsNested%2A> property returns `true` for all nested types, regardless of visibility.</span></span> <span data-ttu-id="2da29-3828">Um zur gleichen Zeit Schachtelung und Sichtbarkeit zu testen, verwenden Sie die verwandten Eigenschaften <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, oder <xref:System.Type.IsNestedPublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-3828">To test for nesting and visibility at the same time, use the related properties <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, or <xref:System.Type.IsNestedPublic%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-3829">Die <xref:System.Reflection.TypeAttributes.VisibilityMask> Enumerationsmember wählt die Sichtbarkeitsattribute für einen Typ aus.</span><span class="sxs-lookup"><span data-stu-id="2da29-3829">The <xref:System.Reflection.TypeAttributes.VisibilityMask> enumeration member selects the visibility attributes for a type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3830">Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Fehlertypen Sichtbarkeit verfügen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3830">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="2da29-3831">Dann wird der Wert einer Reihe von Sichtbarkeit bezogene abgerufen <xref:System.Type> Eigenschaften für den übergeordneten Typ und den geschachtelten Typen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3831">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3832">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> geschachtelt und nur innerhalb der eigenen Assembly sichtbar ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3832">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3833">
            <see langword="true" />, wenn <see cref="T:System.Type" /> geschachtelt und nur innerhalb der eigenen Assembly sichtbar ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3833">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only within its own assembly; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3834">Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3834">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="2da29-3835"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wählt die Sichtbarkeitsattribute an.</span><span class="sxs-lookup"><span data-stu-id="2da29-3835"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3836">Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Fehlertypen Sichtbarkeit verfügen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3836">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="2da29-3837">Dann wird der Wert einer Reihe von Sichtbarkeit bezogene abgerufen <xref:System.Type> Eigenschaften für den übergeordneten Typ und den geschachtelten Typen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3837">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3838">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> geschachtelt und ausschließlich für Klassen sichtbar ist, die sowohl zur eigenen Familie als auch zur eigenen Assembly gehören.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3838">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and its own assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3839">
            <see langword="true" />, wenn <see cref="T:System.Type" /> geschachtelt und ausschließlich für Klassen sichtbar ist, die sowohl zur eigenen Familie als auch zur eigenen Assembly gehören, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3839">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and its own assembly; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3840">Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3840">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="2da29-3841"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wählt die Sichtbarkeitsattribute an.</span><span class="sxs-lookup"><span data-stu-id="2da29-3841"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-3842">Die Sprachen c# und Visual Basic enthalten keine Semantik, mit denen Sie einen geschachtelten Typ definieren, der nur für geschützte Typen in der eigenen Assembly sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3842">The C# and Visual Basic languages do not include semantics that allow you to define a nested type that is visible only to protected types in its own assembly.</span></span> <span data-ttu-id="2da29-3843">`protected internal` Sichtbarkeit in C# geschrieben und `Protected Friend` Sichtbarkeit in Visual Basic definieren einen geschachtelten Typ, der sowohl für geschützte Typen und Typen in der gleichen Assembly sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3843">`protected internal` visibility in C# and `Protected Friend` visibility in Visual Basic define a nested type that is visible both to protected types and to types in the same assembly.</span></span>  
  
 <span data-ttu-id="2da29-3844">Ein <xref:System.Type> objektspezifischen Familie wird definiert, wie alle Objekte des gleichen <xref:System.Type> und seiner Untertypen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3844">A <xref:System.Type> object's family is defined as all objects of the same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3845">Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Fehlertypen Sichtbarkeit verfügen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3845">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="2da29-3846">Dann wird der Wert einer Reihe von Sichtbarkeit bezogene abgerufen <xref:System.Type> Eigenschaften für den übergeordneten Typ und den geschachtelten Typen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3846">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3847">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> geschachtelt und nur innerhalb der eigenen Familie sichtbar ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3847">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own family.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3848">
            <see langword="true" />, wenn <see cref="T:System.Type" /> geschachtelt und nur innerhalb der eigenen Familie sichtbar ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3848">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only within its own family; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3849">Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3849">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="2da29-3850"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wählt die Sichtbarkeitsattribute an.</span><span class="sxs-lookup"><span data-stu-id="2da29-3850"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
 <span data-ttu-id="2da29-3851">Ein <xref:System.Type> objektspezifischen Familie wird definiert, wie alle Objekte der genauen gleichen <xref:System.Type> und seiner Untertypen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3851">A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3852">Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Fehlertypen Sichtbarkeit verfügen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3852">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="2da29-3853">Dann wird der Wert einer Reihe von Sichtbarkeit bezogene abgerufen <xref:System.Type> Eigenschaften für den übergeordneten Typ und den geschachtelten Typen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3853">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3854">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> geschachtelt und ausschließlich für Klassen sichtbar ist, die zur eigenen Familie oder zur eigenen Assembly gehören.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3854">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to either its own family or to its own assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3855">
            <see langword="true" />, wenn <see cref="T:System.Type" /> geschachtelt und ausschließlich für Klassen sichtbar ist, die zur eigenen Familie oder zur eigenen Assembly gehören, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3855">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only to classes that belong to its own family or to its own assembly; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3856">Wenn die Sichtbarkeit eines Typs ist `protected internal` in c# oder `Protected Friend` in Visual Basic die <xref:System.Type.IsNestedFamORAssem%2A> -Eigenschaft gibt `true`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3856">If the visibility of a type is `protected internal` in C# or `Protected Friend` in Visual Basic, the <xref:System.Type.IsNestedFamORAssem%2A> property returns `true`.</span></span>  
  
 <span data-ttu-id="2da29-3857">Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3857">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="2da29-3858"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wählt die Sichtbarkeitsattribute an.</span><span class="sxs-lookup"><span data-stu-id="2da29-3858"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
 <span data-ttu-id="2da29-3859">Ein <xref:System.Type> objektspezifischen Familie wird definiert, wie alle Objekte der genauen gleichen <xref:System.Type> und seiner Untertypen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3859">A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3860">Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Fehlertypen Sichtbarkeit verfügen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3860">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="2da29-3861">Dann wird der Wert einer Reihe von Sichtbarkeit bezogene abgerufen <xref:System.Type> Eigenschaften für den übergeordneten Typ und den geschachtelten Typen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3861">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3862">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> geschachtelt und als privat deklariert ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3862">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and declared private.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3863">
            <see langword="true" />, wenn <see cref="T:System.Type" /> geschachtelt und als privat deklariert ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3863">
              <see langword="true" /> if the <see cref="T:System.Type" /> is nested and declared private; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3864">Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3864">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="2da29-3865"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wählt die Sichtbarkeitsattribute an.</span><span class="sxs-lookup"><span data-stu-id="2da29-3865"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3866">Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Fehlertypen Sichtbarkeit verfügen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3866">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="2da29-3867">Dann wird der Wert einer Reihe von Sichtbarkeit bezogene abgerufen <xref:System.Type> Eigenschaften für den übergeordneten Typ und den geschachtelten Typen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3867">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3868">Ruft einen Wert ab, der angibt, ob eine Klasse geschachtelt und als öffentlich deklariert ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3868">Gets a value indicating whether a class is nested and declared public.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3869">
            <see langword="true" />, wenn die Klasse geschachtelt und als öffentlich deklariert ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3869">
              <see langword="true" /> if the class is nested and declared public; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3870">Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3870">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="2da29-3871"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wählt die Sichtbarkeitsattribute an.</span><span class="sxs-lookup"><span data-stu-id="2da29-3871"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3872">Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Fehlertypen Sichtbarkeit verfügen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3872">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="2da29-3873">Dann wird der Wert einer Reihe von Sichtbarkeit bezogene abgerufen <xref:System.Type> Eigenschaften für den übergeordneten Typ und den geschachtelten Typen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3873">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3874">Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Type" /> nicht als öffentlich deklariert ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3874">Gets a value indicating whether the <see cref="T:System.Type" /> is not declared public.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3875">
            <see langword="true" />, wenn der <see cref="T:System.Type" /> nicht als öffentlich deklariert und kein geschachtelter Typ ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3875">
              <see langword="true" /> if the <see cref="T:System.Type" /> is not declared public and is not a nested type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3876">Verwenden Sie diese Eigenschaft nicht mit geschachtelten Typen. Verwenden Sie die <xref:System.Type.IsNestedPublic%2A> Eigenschaft stattdessen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3876">Do not use this property with nested types; use the <xref:System.Type.IsNestedPublic%2A> property instead.</span></span>  
  
 <span data-ttu-id="2da29-3877">Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3877">If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3878">Dieses Beispiel verwenden bewirkt, dassdie `IsNotPublic` Eigenschaft, um die Sichtbarkeit des Typs abzurufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3878">This example usesthe `IsNotPublic` property to get the visibility of the type.</span></span>  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 <span data-ttu-id="2da29-3879">Im folgenden Codebeispiel wird veranschaulicht, warum Sie nicht verwenden können `IsPublic` und `IsNotPublic` für geschachtelte Klassen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3879">The following code example demonstrates why you cannot use `IsPublic` and `IsNotPublic` for nested classes.</span></span>  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 <span data-ttu-id="2da29-3880">Für geschachtelte Klassen, ignorieren Sie die Ergebnisse der `IsPublic` und `IsNotPublic` und achten Sie darauf, nur für die Ergebnisse der `IsNestedPublic` und `IsNestedPrivate`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3880">For nested classes, ignore the results of `IsPublic` and `IsNotPublic` and pay attention only to the results of `IsNestedPublic` and `IsNestedPrivate`.</span></span> <span data-ttu-id="2da29-3881">Die Ausgabe der Reflektion für dieses Codefragment würde wie folgt lauten:</span><span class="sxs-lookup"><span data-stu-id="2da29-3881">The reflection output for this code fragment would be as follows:</span></span>  
  
|<span data-ttu-id="2da29-3882">Klasse</span><span class="sxs-lookup"><span data-stu-id="2da29-3882">Class</span></span>|<span data-ttu-id="2da29-3883">IsNotPublic</span><span class="sxs-lookup"><span data-stu-id="2da29-3883">IsNotPublic</span></span>|<span data-ttu-id="2da29-3884">IsPublic</span><span class="sxs-lookup"><span data-stu-id="2da29-3884">IsPublic</span></span>|<span data-ttu-id="2da29-3885">IsNestedPublic</span><span class="sxs-lookup"><span data-stu-id="2da29-3885">IsNestedPublic</span></span>|<span data-ttu-id="2da29-3886">IsNestedPrivate</span><span class="sxs-lookup"><span data-stu-id="2da29-3886">IsNestedPrivate</span></span>|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|<span data-ttu-id="2da29-3887">A</span><span class="sxs-lookup"><span data-stu-id="2da29-3887">A</span></span>|<span data-ttu-id="2da29-3888">false</span><span class="sxs-lookup"><span data-stu-id="2da29-3888">FALSE</span></span>|<span data-ttu-id="2da29-3889">true</span><span class="sxs-lookup"><span data-stu-id="2da29-3889">TRUE</span></span>|<span data-ttu-id="2da29-3890">false</span><span class="sxs-lookup"><span data-stu-id="2da29-3890">FALSE</span></span>|<span data-ttu-id="2da29-3891">false</span><span class="sxs-lookup"><span data-stu-id="2da29-3891">FALSE</span></span>|  
|<span data-ttu-id="2da29-3892">B</span><span class="sxs-lookup"><span data-stu-id="2da29-3892">B</span></span>|<span data-ttu-id="2da29-3893">false</span><span class="sxs-lookup"><span data-stu-id="2da29-3893">FALSE</span></span>|<span data-ttu-id="2da29-3894">false</span><span class="sxs-lookup"><span data-stu-id="2da29-3894">FALSE</span></span>|<span data-ttu-id="2da29-3895">true</span><span class="sxs-lookup"><span data-stu-id="2da29-3895">TRUE</span></span>|<span data-ttu-id="2da29-3896">false</span><span class="sxs-lookup"><span data-stu-id="2da29-3896">FALSE</span></span>|  
|<span data-ttu-id="2da29-3897">A</span><span class="sxs-lookup"><span data-stu-id="2da29-3897">C</span></span>|<span data-ttu-id="2da29-3898">false</span><span class="sxs-lookup"><span data-stu-id="2da29-3898">FALSE</span></span>|<span data-ttu-id="2da29-3899">false</span><span class="sxs-lookup"><span data-stu-id="2da29-3899">FALSE</span></span>|<span data-ttu-id="2da29-3900">false</span><span class="sxs-lookup"><span data-stu-id="2da29-3900">FALSE</span></span>|<span data-ttu-id="2da29-3901">true</span><span class="sxs-lookup"><span data-stu-id="2da29-3901">TRUE</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3902">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> ein Zeiger ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3902">Gets a value indicating whether the <see cref="T:System.Type" /> is a pointer.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3903">
            <see langword="true" />, wenn <see cref="T:System.Type" /> ein Zeiger ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3903">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3904">Wenn die aktuelle <xref:System.Type> stellt einen generischen Typ oder Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Eigenschaft gibt immer `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3904">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="2da29-3905">Diese Eigenschaft ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3905">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3906">Das folgende Beispiel veranschaulicht die Verwendung von der `IsPointer` Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-3906">The following example shows a use of the `IsPointer` property.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3907">Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.IsPointer" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> ein Zeiger ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3907">When overridden in a derived class, implements the <see cref="P:System.Type.IsPointer" /> property and determines whether the <see cref="T:System.Type" /> is a pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3908">
            <see langword="true" />, wenn <see cref="T:System.Type" /> ein Zeiger ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3908">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3909">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> zu den primitiven Typen gehört.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3909">Gets a value indicating whether the <see cref="T:System.Type" /> is one of the primitive types.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3910">
            <see langword="true" />, wenn <see cref="T:System.Type" /> zu den primitiven Typen gehört, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3910">
              <see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3911">Primitive Typen sind <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, und <xref:System.Single>.</span><span class="sxs-lookup"><span data-stu-id="2da29-3911">The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.</span></span>  
  
 <span data-ttu-id="2da29-3912">Wenn die aktuelle <xref:System.Type> stellt einen generischen Typ oder Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Eigenschaft gibt immer `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3912">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3913">Das folgende Beispiel veranschaulicht die `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, und <xref:System.Type.IsPrimitive%2A> Eigenschaften der <xref:System.Type> Klasse.</span><span class="sxs-lookup"><span data-stu-id="2da29-3913">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="2da29-3914">Er überprüft, ob der angegebene Typ in den Kontext aufgenommen werden kann, ob er als Verweis gemarshallt werden kann und ob der Typ ein primitiver Datentyp ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3914">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3915">Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.IsPrimitive" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> zu den primitiven Typen gehört.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3915">When overridden in a derived class, implements the <see cref="P:System.Type.IsPrimitive" /> property and determines whether the <see cref="T:System.Type" /> is one of the primitive types.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-3916">
            <see langword="true" />, wenn <see cref="T:System.Type" /> zu den primitiven Typen gehört, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3916">
              <see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3917">Primitive Typen sind <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, und <xref:System.Single>.</span><span class="sxs-lookup"><span data-stu-id="2da29-3917">The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3918">Im folgenden Beispiel wird bestimmt, ob der angegebene Typ ein primitiver Typ ist, und das Ergebnis wird angezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3918">The following example determines whether the given type is a primitive type and displays the result.</span></span>  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3919">Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Type" /> als öffentlich deklariert ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3919">Gets a value indicating whether the <see cref="T:System.Type" /> is declared public.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3920">
            <see langword="true" />, wenn der <see cref="T:System.Type" /> als öffentlich deklariert und kein geschachtelter Typ ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3920">
              <see langword="true" /> if the <see cref="T:System.Type" /> is declared public and is not a nested type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3921">Verwenden Sie keine geschachtelten Typen. Verwenden Sie <xref:System.Type.IsNestedPublic%2A> stattdessen.</span><span class="sxs-lookup"><span data-stu-id="2da29-3921">Do not use with nested types; use <xref:System.Type.IsNestedPublic%2A> instead.</span></span>  
  
 <span data-ttu-id="2da29-3922">Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft `true`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3922">If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `true`.</span></span>  
  
 <span data-ttu-id="2da29-3923"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Wählt die Sichtbarkeitsattribute an.</span><span class="sxs-lookup"><span data-stu-id="2da29-3923"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3924">Das folgende Beispiel erstellt eine Instanz des `MyTestClass`, überprüft, ob die `IsPublic` -Eigenschaft, und das Ergebnis wird angezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3924">The following example creates an instance of `MyTestClass`, checks for the `IsPublic` property, and displays the result.</span></span>  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 <span data-ttu-id="2da29-3925">Für geschachtelte Klassen, ignorieren Sie die Ergebnisse der `IsPublic` und `IsNotPublic` und achten Sie darauf, nur für die Ergebnisse der <xref:System.Type.IsNestedPublic%2A> und <xref:System.Type.IsNestedPrivate%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-3925">For nested classes, ignore the results of `IsPublic` and `IsNotPublic` and pay attention only to the results of <xref:System.Type.IsNestedPublic%2A> and <xref:System.Type.IsNestedPrivate%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3926">Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Type" /> als versiegelt deklariert ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3926">Gets a value indicating whether the <see cref="T:System.Type" /> is declared sealed.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3927">
            <see langword="true" />, wenn <see cref="T:System.Type" /> als versiegelt deklariert ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3927">
              <see langword="true" /> if the <see cref="T:System.Type" /> is declared sealed; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3928">Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer `true`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3928">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3929">Das folgende Beispiel erstellt eine Instanz von einem `sealed` Klasse, sucht der `IsSealed` -Eigenschaft, und das Ergebnis wird angezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3929">The following example creates an instance of a `sealed` class, checks for the `IsSealed` property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3930">Ruft einen Wert ab, der angibt, ob der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitsrelevant ist und daher wichtige Vorgänge ausführen darf.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3930">Gets a value that indicates whether the current type is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3931">
            <see langword="true" />, wenn der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitsrelevant ist, <see langword="false" />, wenn er sicherheitstransparent ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3931">
              <see langword="true" /> if the current type is security-critical or security-safe-critical at the current trust level; <see langword="false" /> if it is transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3932">Die <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, und <xref:System.Type.IsSecurityTransparent%2A> Eigenschaften melden die Transparenzebene eines Typs mit der aktuellen Vertrauensebene, wie von der common Language Runtime (CLR) bestimmt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3932">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="2da29-3933">In der folgenden Tabelle werden die Kombinationen dieser Eigenschaften gezeigt:</span><span class="sxs-lookup"><span data-stu-id="2da29-3933">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="2da29-3934">Sicherheitsstufe</span><span class="sxs-lookup"><span data-stu-id="2da29-3934">Security level</span></span>|<span data-ttu-id="2da29-3935">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="2da29-3935">IsSecurityCritical</span></span>|<span data-ttu-id="2da29-3936">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="2da29-3936">IsSecuritySafeCritical</span></span>|<span data-ttu-id="2da29-3937">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="2da29-3937">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="2da29-3938">Kritisch</span><span class="sxs-lookup"><span data-stu-id="2da29-3938">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="2da29-3939">Safe ist kritisch</span><span class="sxs-lookup"><span data-stu-id="2da29-3939">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="2da29-3940">Transparent</span><span class="sxs-lookup"><span data-stu-id="2da29-3940">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="2da29-3941">Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-3941">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="2da29-3942">Für teilweise vertrauenswürdige Assemblys ist der Wert dieser Eigenschaft hängt von der aktuellen Vertrauensebene der Assembly.</span><span class="sxs-lookup"><span data-stu-id="2da29-3942">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="2da29-3943">Wenn die Assembly in einer teilweise vertrauenswürdigen Anwendungsdomäne (z. B. in einer Sandkastenanwendungsdomäne) geladen wird, ignoriert die Common Language Runtime die sicherheitsanmerkungen der Assembly.</span><span class="sxs-lookup"><span data-stu-id="2da29-3943">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="2da29-3944">Die Assembly und alle zugehörigen Typen werden als transparent behandelt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3944">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="2da29-3945">Die Common Language Runtime zahlt Beachtung der sicherheitsanmerkungen einer teilweise vertrauenswürdigen Assembly nur, wenn diese Assembly in eine voll vertrauenswürdige Anwendungsdomäne (z. B. in der Standardanwendungsdomäne einer Desktopanwendung) geladen wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-3945">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="2da29-3946">Dagegen ist eine vertrauenswürdige Assembly (d. h. eine Assembly mit starkem Namen, die im globalen Assemblycache installiert ist) immer mit voller Vertrauenswürdigkeit unabhängig von der Vertrauensebene der Anwendungsdomäne geladen, damit der aktuellen Vertrauensebene immer voll vertrauenswürdig ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3946">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="2da29-3947">Sie können die aktuellen Vertrauensebenen von Assemblys und Anwendungsdomänen bestimmen, indem Sie mit der <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> und <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="2da29-3947">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="2da29-3948">Weitere Informationen über Reflektion und Transparenz finden Sie unter [Sicherheitsüberlegungen für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="2da29-3948">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="2da29-3949">Informationen zur Transparenz finden Sie unter [Sicherheitsänderungen](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="2da29-3949">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3950">Ruft einen Wert ab, der angibt, ob der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitsrelevant ist, d. h. ob er wichtige Vorgänge ausführen darf und ob von transparentem Code auf ihn zugegriffen werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3950">Gets a value that indicates whether the current type is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3951">
            <see langword="true" />, wenn der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitsrelevant ist, <see langword="false" /> wenn er sicherheitstransparent oder sicherheitsrelevant ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3951">
              <see langword="true" /> if the current type is security-safe-critical at the current trust level; <see langword="false" /> if it is security-critical or transparent.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3952">Die <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, und <xref:System.Type.IsSecurityTransparent%2A> Eigenschaften melden die Transparenzebene eines Typs mit der aktuellen Vertrauensebene, wie von der common Language Runtime (CLR) bestimmt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3952">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="2da29-3953">In der folgenden Tabelle werden die Kombinationen dieser Eigenschaften gezeigt:</span><span class="sxs-lookup"><span data-stu-id="2da29-3953">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="2da29-3954">Sicherheitsstufe</span><span class="sxs-lookup"><span data-stu-id="2da29-3954">Security level</span></span>|<span data-ttu-id="2da29-3955">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="2da29-3955">IsSecurityCritical</span></span>|<span data-ttu-id="2da29-3956">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="2da29-3956">IsSecuritySafeCritical</span></span>|<span data-ttu-id="2da29-3957">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="2da29-3957">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="2da29-3958">Kritisch</span><span class="sxs-lookup"><span data-stu-id="2da29-3958">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="2da29-3959">Safe ist kritisch</span><span class="sxs-lookup"><span data-stu-id="2da29-3959">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="2da29-3960">Transparent</span><span class="sxs-lookup"><span data-stu-id="2da29-3960">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="2da29-3961">Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-3961">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="2da29-3962">Für teilweise vertrauenswürdige Assemblys ist der Wert dieser Eigenschaft hängt von der aktuellen Vertrauensebene der Assembly.</span><span class="sxs-lookup"><span data-stu-id="2da29-3962">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="2da29-3963">Wenn die Assembly in einer teilweise vertrauenswürdigen Anwendungsdomäne (z. B. in einer Sandkastenanwendungsdomäne) geladen wird, ignoriert die Common Language Runtime die sicherheitsanmerkungen der Assembly.</span><span class="sxs-lookup"><span data-stu-id="2da29-3963">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="2da29-3964">Die Assembly und alle zugehörigen Typen werden als transparent behandelt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3964">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="2da29-3965">Die Common Language Runtime zahlt Beachtung der sicherheitsanmerkungen einer teilweise vertrauenswürdigen Assembly nur, wenn diese Assembly in eine voll vertrauenswürdige Anwendungsdomäne (z. B. in der Standardanwendungsdomäne einer Desktopanwendung) geladen wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-3965">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="2da29-3966">Dagegen ist eine vertrauenswürdige Assembly (d. h. eine Assembly mit starkem Namen, die im globalen Assemblycache installiert ist) immer mit voller Vertrauenswürdigkeit unabhängig von der Vertrauensebene der Anwendungsdomäne geladen, damit der aktuellen Vertrauensebene immer voll vertrauenswürdig ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3966">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="2da29-3967">Sie können die aktuellen Vertrauensebenen von Assemblys und Anwendungsdomänen bestimmen, indem Sie mit der <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> und <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="2da29-3967">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="2da29-3968">Weitere Informationen über Reflektion und Transparenz finden Sie unter [Sicherheitsüberlegungen für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="2da29-3968">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="2da29-3969">Informationen zur Transparenz finden Sie unter [Sicherheitsänderungen](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="2da29-3969">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3970">Ruft einen Wert ab, der angibt, ob der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitstransparent ist und daher keine wichtigen Vorgänge ausführen kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3970">Gets a value that indicates whether the current type is transparent at the current trust level, and therefore cannot perform critical operations.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3971">
            <see langword="true" />, wenn der Typ auf der aktuellen Vertrauensebene sicherheitstransparent ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3971">
              <see langword="true" /> if the type is security-transparent at the current trust level; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3972">Wenn diese Eigenschaft gibt `true`, <xref:System.Type.IsSecurityCritical%2A> und <xref:System.Type.IsSecuritySafeCritical%2A> Eigenschaften zurückgeben `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3972">If this property returns `true`, the <xref:System.Type.IsSecurityCritical%2A> and <xref:System.Type.IsSecuritySafeCritical%2A> properties return `false`.</span></span>  
  
 <span data-ttu-id="2da29-3973">Die <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, und <xref:System.Type.IsSecurityTransparent%2A> Eigenschaften melden die Transparenzebene eines Typs mit der aktuellen Vertrauensebene, wie von der common Language Runtime (CLR) bestimmt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3973">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="2da29-3974">Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-3974">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="2da29-3975">Für teilweise vertrauenswürdige Assemblys ist der Wert dieser Eigenschaft hängt von der aktuellen Vertrauensebene der Assembly.</span><span class="sxs-lookup"><span data-stu-id="2da29-3975">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="2da29-3976">Wenn die Assembly in einer teilweise vertrauenswürdigen Anwendungsdomäne (z. B. in einer Sandkastenanwendungsdomäne) geladen wird, ignoriert die Common Language Runtime die sicherheitsanmerkungen der Assembly.</span><span class="sxs-lookup"><span data-stu-id="2da29-3976">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="2da29-3977">Die Assembly und alle zugehörigen Typen werden als transparent behandelt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3977">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="2da29-3978">Die Common Language Runtime zahlt Beachtung der sicherheitsanmerkungen einer teilweise vertrauenswürdigen Assembly nur, wenn diese Assembly in eine voll vertrauenswürdige Anwendungsdomäne (z. B. in der Standardanwendungsdomäne einer Desktopanwendung) geladen wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-3978">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="2da29-3979">Dagegen ist eine vertrauenswürdige Assembly (d. h. eine Assembly mit starkem Namen, die im globalen Assemblycache installiert ist) immer mit voller Vertrauenswürdigkeit unabhängig von der Vertrauensebene der Anwendungsdomäne geladen, damit der aktuellen Vertrauensebene immer voll vertrauenswürdig ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3979">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="2da29-3980">Sie können die aktuellen Vertrauensebenen von Assemblys und Anwendungsdomänen bestimmen, indem Sie mit der <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> und <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="2da29-3980">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="2da29-3981">Weitere Informationen über Reflektion und Transparenz finden Sie unter [Sicherheitsüberlegungen für die Reflektion](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="2da29-3981">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="2da29-3982">Informationen zur Transparenz finden Sie unter [Sicherheitsänderungen](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="2da29-3982">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3983">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> serialisierbar ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3983">Gets a value indicating whether the <see cref="T:System.Type" /> is serializable.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3984">
            <see langword="true" />, wenn <see cref="T:System.Type" /> serialisierbar ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3984">
              <see langword="true" /> if the <see cref="T:System.Type" /> is serializable; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="2da29-3985">In .NET Standard definierte Typen sind nicht mit markierten <xref:System.SerializableAttribute>.</span><span class="sxs-lookup"><span data-stu-id="2da29-3985">Types that are defined in the .NET Standard are not marked with <xref:System.SerializableAttribute>.</span></span> <span data-ttu-id="2da29-3986">Jede Implementierung .NET bestimmt stattdessen, ob ein Typ serialisierbar ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-3986">Instead, each .NET implementation determines whether a type is serializable.</span></span> <span data-ttu-id="2da29-3987">Zur Laufzeit können Sie die <xref:System.Type.IsSerializable%2A> Eigenschaft, um zu bestimmen, ob diese Implementierung die Serialisierung einer Instanz des Typs unterstützt.</span><span class="sxs-lookup"><span data-stu-id="2da29-3987">At run time, you can use the <xref:System.Type.IsSerializable%2A> property to determine whether that implementation supports serialization of an instance of the type.</span></span> <span data-ttu-id="2da29-3988">Weitere Informationen und ein Beispiel finden Sie unter [Vorgehensweise zu bestimmen, ob ein .NET Standard Objekt serialisierbar ist](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).</span><span class="sxs-lookup"><span data-stu-id="2da29-3988">For more information and an example, see [How to determine if a .NET Standard object is serializable](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).</span></span>
  
 <span data-ttu-id="2da29-3989">Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde.</span><span class="sxs-lookup"><span data-stu-id="2da29-3989">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="2da29-3990">Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3990">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="2da29-3991">Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3991">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-3992">Das folgende Beispiel erstellt eine Instanz des `MyTestClass` -Klasse, das [Serializable]-Attribut festgelegt, und überprüft die `IsSerializable` -Eigenschaft für `true` oder `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3992">The following example creates an instance of `MyTestClass` class, sets the [Serializable] attribute, and checks the `IsSerializable` property for `true` or `false`.</span></span>  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-3993">Ruft einen Wert ab, der angibt, ob der Typ einen Namen besitzt, der eine Sonderbehandlung erfordert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3993">Gets a value indicating whether the type has a name that requires special handling.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-3994">
            <see langword="true" />, wenn der Typ einen Namen besitzt, der eine Sonderbehandlung erfordert, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3994">
              <see langword="true" /> if the type has a name that requires special handling; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-3995">Namen, die beginnen mit einem Unterstrich (_), Eigenschaftenaccessoren und Operatoren überladen von Methoden enthalten sind Beispiele für Typen, die von einigen Compilern möglicherweise eine besondere Behandlung erfordern.</span><span class="sxs-lookup"><span data-stu-id="2da29-3995">Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.</span></span>  
  
 <span data-ttu-id="2da29-3996">Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde.</span><span class="sxs-lookup"><span data-stu-id="2da29-3996">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="2da29-3997">Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3997">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="2da29-3998">Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-3998">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c">
          <span data-ttu-id="2da29-3999">Der Typ, der mit dem aktuellen Typ verglichen werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-3999">The type to compare with the current type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-4000">Bestimmt, ob der aktuelle <see cref="T:System.Type" /> vom angegebenen <see cref="T:System.Type" /> abgeleitet ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4000">Determines whether the current <see cref="T:System.Type" /> derives from the specified <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-4001">
            <see langword="true" />, wenn der aktuelle <see langword="Type" /> von <paramref name="c" /> abgeleitet ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4001">
              <see langword="true" /> if the current <see langword="Type" /> derives from <paramref name="c" />; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="2da29-4002">Diese Methode gibt auch dann <see langword="false" /> zurück, wenn <paramref name="c" /> und der aktuelle <see langword="Type" /> gleich sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4002">This method also returns <see langword="false" /> if <paramref name="c" /> and the current <see langword="Type" /> are equal.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-4003">Sie erreichen die <xref:System.Type.IsSubclassOf%2A> Methode, um Folgendes festzulegen:</span><span class="sxs-lookup"><span data-stu-id="2da29-4003">You can call the <xref:System.Type.IsSubclassOf%2A> method to determine any of the following:</span></span>  
  
-   <span data-ttu-id="2da29-4004">Gibt an, ob eine Klasse von einem anderen abgeleitet ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-4004">Whether one class derives from another.</span></span>  
  
-   <span data-ttu-id="2da29-4005">Ob ein Typ abgeleitet <xref:System.ValueType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-4005">Whether a type derives from <xref:System.ValueType>.</span></span> <span data-ttu-id="2da29-4006">Allerdings die <xref:System.Type.IsValueType%2A> effizienter lässt sich bestimmen, ob ein Typ ein Werttyp ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-4006">However, the <xref:System.Type.IsValueType%2A> is a more efficient way to determine whether a type is a value type.</span></span>  
  
-   <span data-ttu-id="2da29-4007">Ob ein Typ abgeleitet <xref:System.Enum>.</span><span class="sxs-lookup"><span data-stu-id="2da29-4007">Whether a type derives from <xref:System.Enum>.</span></span> <span data-ttu-id="2da29-4008">Allerdings die <xref:System.Type.IsEnum%2A> Methode ist eine effizientere Methode zum bestimmen, ob ein Typ eine Enumeration ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-4008">However, the <xref:System.Type.IsEnum%2A> method is a more efficient way to determine whether a type is an enumeration.</span></span>  
  
-   <span data-ttu-id="2da29-4009">Gibt an, ob ein Typ ein Delegat ist, ob er entweder abgeleitet <xref:System.Delegate> oder <xref:System.MulticastDelegate>.</span><span class="sxs-lookup"><span data-stu-id="2da29-4009">Whether a type is a delegate, that is, whether it derives from either <xref:System.Delegate> or <xref:System.MulticastDelegate>.</span></span>  
  
 <span data-ttu-id="2da29-4010">Die <xref:System.Type.IsSubclassOf%2A> Methode kann nicht verwendet werden, um zu bestimmen, ob eine Schnittstelle von einer anderen Schnittstelle abgeleitet wird, oder gibt an, ob eine Klasse eine Schnittstelle implementiert.</span><span class="sxs-lookup"><span data-stu-id="2da29-4010">The <xref:System.Type.IsSubclassOf%2A> method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface.</span></span> <span data-ttu-id="2da29-4011">Verwenden der <xref:System.Type.IsAssignableFrom%2A> Methode für diesen Zweck, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-4011">Use the <xref:System.Type.IsAssignableFrom%2A> method for that purpose, as the following example shows.</span></span>  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 <span data-ttu-id="2da29-4012">Wenn das aktuelle <xref:System.Type> jedoch einen Typparameter darstellt, in der Definition einer generischen Typ- oder Methodendefinition, abgeleitet aus seiner Class-Einschränkung oder <xref:System.Object?displayProperty=nameWithType> hat keine klasseneinschränkung.</span><span class="sxs-lookup"><span data-stu-id="2da29-4012">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, it derives from its class constraint or from <xref:System.Object?displayProperty=nameWithType> if it has no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-4013">Außer in Verbindung mit Schnittstellen, <xref:System.Type.IsSubclassOf%2A> ist das Gegenteil von <xref:System.Type.IsAssignableFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-4013">Except when used with interfaces, <xref:System.Type.IsSubclassOf%2A> is the converse of <xref:System.Type.IsAssignableFrom%2A>.</span></span> <span data-ttu-id="2da29-4014">D. h. wenn `t1.IsSubclassOf(t2)` ist `true`, klicken Sie dann `t2.IsAssignableFrom(t1)` ist auch `true`.</span><span class="sxs-lookup"><span data-stu-id="2da29-4014">That is, if `t1.IsSubclassOf(t2)` is `true`, then `t2.IsAssignableFrom(t1)` is also `true`.</span></span>  
  
 <span data-ttu-id="2da29-4015">Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-4015">This method can be overridden by a derived class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-4016">Das folgende Beispiel erstellt eine Klasse namens `Class1` und eine abgeleitete Klasse mit dem Namen `DerivedC1`.</span><span class="sxs-lookup"><span data-stu-id="2da29-4016">The following example creates a class named `Class1` and a derived class named `DerivedC1`.</span></span> <span data-ttu-id="2da29-4017">Ruft die <xref:System.Type.IsSubclassOf%2A> Methode, um anzugeben, dass `DerivedC1` ist eine Unterklasse von `Class1`.</span><span class="sxs-lookup"><span data-stu-id="2da29-4017">It calls the <xref:System.Type.IsSubclassOf%2A> method to show that `DerivedC1` is a subclass of `Class1`.</span></span>  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-4018">
            <paramref name="c" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4018">
              <paramref name="c" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-4019">Ruft einen Wert ab, der angibt, ob für <see langword="UnicodeClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4019">Gets a value indicating whether the string format attribute <see langword="UnicodeClass" /> is selected for the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-4020">
            <see langword="true" />, wenn für <see langword="UnicodeClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4020">
              <see langword="true" /> if the string format attribute <see langword="UnicodeClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-4021">Die <xref:System.Reflection.TypeAttributes.StringFormatMask> wird verwendet, um die Zeichenfolge Formatattribute auszuwählen.</span><span class="sxs-lookup"><span data-stu-id="2da29-4021">The <xref:System.Reflection.TypeAttributes.StringFormatMask> is used to select the string format attributes.</span></span> <span data-ttu-id="2da29-4022">Die Zeichenfolge Formatattribute zur Verbesserung der Interoperabilität von definieren, wie Zeichenfolgen interpretiert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="2da29-4022">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="2da29-4023">Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde.</span><span class="sxs-lookup"><span data-stu-id="2da29-4023">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="2da29-4024">Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="2da29-4024">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="2da29-4025">Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-4025">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-4026">Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> ein Werttyp ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4026">Gets a value indicating whether the <see cref="T:System.Type" /> is a value type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-4027">
            <see langword="true" />, wenn <see cref="T:System.Type" /> ein Werttyp ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4027">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a value type; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-4028">Werttypen sind Typen, die als Sequenzen von Bits dargestellt werden. Werttypen sind nicht Klassen oder Schnittstellen.</span><span class="sxs-lookup"><span data-stu-id="2da29-4028">Value types are types that are represented as sequences of bits; value types are not classes or interfaces.</span></span> <span data-ttu-id="2da29-4029">Werttypen werden in einigen Programmiersprachen als "Strukturen" bezeichnet.</span><span class="sxs-lookup"><span data-stu-id="2da29-4029">Value types are referred to as "structs" in some programming languages.</span></span> <span data-ttu-id="2da29-4030">Enumerationen sind ein besonderer Fall von Werttypen.</span><span class="sxs-lookup"><span data-stu-id="2da29-4030">Enums are a special case of value types.</span></span>  
  
 <span data-ttu-id="2da29-4031">Diese Eigenschaft gibt `false` für die <xref:System.ValueType> Klasse, da <xref:System.ValueType> ist kein Werttyp selbst.</span><span class="sxs-lookup"><span data-stu-id="2da29-4031">This property returns `false` for the <xref:System.ValueType> class, because <xref:System.ValueType> is not a value type itself.</span></span> <span data-ttu-id="2da29-4032">Es ist die Basisklasse für alle Werttypen und aus diesem Grund zu einem beliebigen Werttyp zugewiesen werden kann.</span><span class="sxs-lookup"><span data-stu-id="2da29-4032">It is the base class for all value types, and therefore any value type can be assigned to it.</span></span> <span data-ttu-id="2da29-4033">Dies ist nicht möglich, wenn <xref:System.ValueType> selbst wurde ein Werttyp.</span><span class="sxs-lookup"><span data-stu-id="2da29-4033">This would not be possible if <xref:System.ValueType> itself was a value type.</span></span> <span data-ttu-id="2da29-4034">Werttypen sind geschachtelt, wenn sie ein Feld des Typs zugewiesen werden <xref:System.ValueType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-4034">Value types are boxed when they are assigned to a field of type <xref:System.ValueType>.</span></span>  
  
 <span data-ttu-id="2da29-4035">Diese Eigenschaft gibt `true` für Enumerationen, jedoch nicht für die <xref:System.Enum> -Typ selbst.</span><span class="sxs-lookup"><span data-stu-id="2da29-4035">This property returns `true` for enumerations, but not for the <xref:System.Enum> type itself.</span></span> <span data-ttu-id="2da29-4036">Ein Beispiel für dieses Verhalten finden Sie unter <xref:System.Type.IsEnum%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-4036">For an example that demonstrates this behavior, see <xref:System.Type.IsEnum%2A>.</span></span>  
  
 <span data-ttu-id="2da29-4037">Diese Eigenschaft ist schreibgeschützt.</span><span class="sxs-lookup"><span data-stu-id="2da29-4037">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-4038">Das folgende Beispiel erstellt eine Variable vom Typ `MyEnum`, überprüft, ob die `IsValueType` -Eigenschaft, und das Ergebnis wird angezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-4038">The following example creates a variable of type `MyEnum`, checks for the `IsValueType` property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-4039">Implementiert die <see cref="P:System.Type.IsValueType" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> ein Werttyp ist, also weder eine Klasse noch eine Schnittstelle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4039">Implements the <see cref="P:System.Type.IsValueType" /> property and determines whether the <see cref="T:System.Type" /> is a value type; that is, not a class or an interface.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-4040">
            <see langword="true" />, wenn <see cref="T:System.Type" /> ein Werttyp ist, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4040">
              <see langword="true" /> if the <see cref="T:System.Type" /> is a value type; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-4041">Diese Methode wird bereitgestellt, um die Implementierung von alternativen Typsysteme zu aktivieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-4041">This method is provided to enable the implementation of alternate type systems.</span></span> <span data-ttu-id="2da29-4042">Es wird im Allgemeinen nicht im Anwendungscode verwendet.</span><span class="sxs-lookup"><span data-stu-id="2da29-4042">It is not generally used in application code.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-4043">Ruft einen Wert ab, der angibt, ob auf den <see cref="T:System.Type" /> aus Code von außerhalb der Assembly zugegriffen werden kann.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4043">Gets a value indicating whether the <see cref="T:System.Type" /> can be accessed by code outside the assembly.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-4044">
            <see langword="true" />, wenn der aktuelle <see cref="T:System.Type" /> ein öffentlicher Typ oder ein öffentlicher geschachtelter Typ ist, sodass alle einschließenden Typen öffentlich sind, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4044">
              <see langword="true" /> if the current <see cref="T:System.Type" /> is a public type or a public nested type such that all the enclosing types are public; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-4045">Verwenden Sie diese Eigenschaft, um zu bestimmen, ob ein Teil der öffentlichen Schnittstelle einer Komponente-Assembly ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-4045">Use this property to determine whether a type is part of the public interface of a component assembly.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-4046">Im folgenden Codebeispiel wird testet zwei Klassen, von denen nur, die eine außerhalb der Assembly sichtbar ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-4046">The following code example tests two classes, only one of which is visible outside the assembly.</span></span>  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-4047">Gibt ein <see cref="T:System.Type" />-Objekt zurück, das ein Array des aktuellen Typs darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4047">Returns a <see cref="T:System.Type" /> object that represents an array of the current type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-4048">Gibt ein <see cref="T:System.Type" />-Objekt zurück, das ein eindimensionales Array vom aktuellen Typ mit einer unteren Grenze von 0 (null) darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4048">Returns a <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-4049">Ein <see cref="T:System.Type" />-Objekt, das ein eindimensionales Array vom aktuellen Typ mit einer unteren Grenze von 0 (null) darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4049">A <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-4050">Die <xref:System.Type.MakeArrayType%2A> Methode bietet eine Möglichkeit zum Arraytypen generieren, deren Elementtypen zur Laufzeit berechnet werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-4050">The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.</span></span>  
  
 <span data-ttu-id="2da29-4051">**Hinweis** die common Language Runtime unterscheidet zwischen Vektoren (d. h. eindimensionale Arrays, die immer nullbasiert sind) und mehrdimensionale Arrays.</span><span class="sxs-lookup"><span data-stu-id="2da29-4051">**Note** The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</span></span> <span data-ttu-id="2da29-4052">Ein Vektor, der immer nur eine Dimension hat, ist nicht identisch mit einem mehrdimensionalen Array, das ausgeführt wird, nur eine Dimension aufweisen.</span><span class="sxs-lookup"><span data-stu-id="2da29-4052">A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</span></span> <span data-ttu-id="2da29-4053">Überladung dieser Methode kann nur verwendet werden, um vektortypen zu erstellen, und es ist die einzige Möglichkeit, einen Vector-Typ zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="2da29-4053">This method overload can only be used to create vector types, and it is the only way to create a vector type.</span></span> <span data-ttu-id="2da29-4054">Verwenden der <xref:System.Type.MakeArrayType%28System.Int32%29> -methodenüberladung, um mehrdimensionale von Arraytypen zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="2da29-4054">Use the <xref:System.Type.MakeArrayType%28System.Int32%29> method overload to create multidimensional array types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-4055">Im folgenden Codebeispiel wird erstellt, Array, `ref` (`ByRef` in Visual Basic), und Zeigertypen für die `Test` Klasse.</span><span class="sxs-lookup"><span data-stu-id="2da29-4055">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2da29-4056">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4056">The invoked method is not supported in the base class.</span>
          </span>
          <span data-ttu-id="2da29-4057">Abgeleitete Klassen müssen eine Implementation angeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4057">Derived classes must provide an implementation.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="2da29-4058">Der aktuelle Typ ist <see cref="T:System.TypedReference" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4058">The current type is <see cref="T:System.TypedReference" />.</span>
          </span>
          <span data-ttu-id="2da29-4059">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4059">-or-</span>
          </span>
          <span data-ttu-id="2da29-4060">Der aktuelle Typ ist ein <see langword="ByRef" />-Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4060">The current type is a <see langword="ByRef" /> type.</span>
          </span>
          <span data-ttu-id="2da29-4061">Das heißt, <see cref="P:System.Type.IsByRef" /> gibt <see langword="true" /> zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4061">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank">
          <span data-ttu-id="2da29-4062">Die Anzahl von Dimensionen für das Array.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4062">The number of dimensions for the array.</span>
          </span>
          <span data-ttu-id="2da29-4063">Diese Zahl muss kleiner oder gleich 32 sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4063">This number must be less than or equal to 32.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-4064">Gibt ein <see cref="T:System.Type" />-Objekt zurück, das ein Array vom aktuellen Typ mit der angegebenen Anzahl von Dimensionen darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4064">Returns a <see cref="T:System.Type" /> object representing an array of the current type, with the specified number of dimensions.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-4065">Ein Objekt, das ein Array vom aktuellen Typ mit der angegebenen Anzahl von Dimensionen darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4065">An object representing an array of the current type, with the specified number of dimensions.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-4066">Die <xref:System.Type.MakeArrayType%2A> Methode bietet eine Möglichkeit zum Arraytypen generieren, deren Elementtypen zur Laufzeit berechnet werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-4066">The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-4067">Die common Language Runtime unterscheidet zwischen Vektoren (d. h. eindimensionale Arrays, die immer nullbasiert sind) und mehrdimensionale Arrays.</span><span class="sxs-lookup"><span data-stu-id="2da29-4067">The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</span></span> <span data-ttu-id="2da29-4068">Ein Vektor, der immer nur eine Dimension hat, ist nicht identisch mit einem mehrdimensionalen Array, das ausgeführt wird, nur eine Dimension aufweisen.</span><span class="sxs-lookup"><span data-stu-id="2da29-4068">A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</span></span> <span data-ttu-id="2da29-4069">Überladung dieser Methode können Sie um einen Vector-Typ zu erstellen. Wenn `rank` beträgt 1, Überladung dieser Methode gibt einen mehrdimensionales Array-Typ, der an eine Dimension über zurück.</span><span class="sxs-lookup"><span data-stu-id="2da29-4069">You cannot use this method overload to create a vector type; if `rank` is 1, this method overload returns a multidimensional array type that happens to have one dimension.</span></span> <span data-ttu-id="2da29-4070">Verwenden der <xref:System.Type.MakeArrayType> -methodenüberladung vektortypen zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="2da29-4070">Use the <xref:System.Type.MakeArrayType> method overload to create vector types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-4071">Im folgenden Codebeispiel wird erstellt, Array, `ref` (`ByRef` in Visual Basic), und Zeigertypen für die `Test` Klasse.</span><span class="sxs-lookup"><span data-stu-id="2da29-4071">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="2da29-4072">
            <paramref name="rank" /> ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4072">
              <paramref name="rank" /> is invalid.</span>
          </span>
          <span data-ttu-id="2da29-4073">Beispielsweise 0 oder ein negativer Wert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4073">For example, 0 or negative.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2da29-4074">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4074">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="2da29-4075">Der aktuelle Typ ist <see cref="T:System.TypedReference" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4075">The current type is <see cref="T:System.TypedReference" />.</span>
          </span>
          <span data-ttu-id="2da29-4076">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4076">-or-</span>
          </span>
          <span data-ttu-id="2da29-4077">Der aktuelle Typ ist ein <see langword="ByRef" />-Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4077">The current type is a <see langword="ByRef" /> type.</span>
          </span>
          <span data-ttu-id="2da29-4078">Das heißt, <see cref="P:System.Type.IsByRef" /> gibt <see langword="true" /> zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4078">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span>
          </span>
          <span data-ttu-id="2da29-4079">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4079">-or-</span>
          </span>
          <span data-ttu-id="2da29-4080">
            <paramref name="rank" /> ist größer als 32.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4080">
              <paramref name="rank" /> is greater than 32.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-4081">Gibt ein <see cref="T:System.Type" />-Objekt zurück, das beim Übergeben als <see langword="ref" />-Parameter (<see langword="ByRef" />-Parameter in Visual Basic) den aktuellen Typ darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4081">Returns a <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> parameter in Visual Basic).</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-4082">Ein <see cref="T:System.Type" />-Objekt, das beim Übergeben als <see langword="ref" />-Parameter (<see langword="ByRef" />-Parameter in Visual Basic) den aktuellen Typ darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4082">A <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> parameter in Visual Basic).</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-4083">Die <xref:System.Type.MakeByRefType%2A> Methode bietet eine Möglichkeit zum Generieren von `ref` Typen (`ByRef` in Visual Basic) für Parameter aufgeführt sind.</span><span class="sxs-lookup"><span data-stu-id="2da29-4083">The <xref:System.Type.MakeByRefType%2A> method provides a way to generate `ref` types (`ByRef` in Visual Basic) for parameter lists.</span></span>  
  
 <span data-ttu-id="2da29-4084">Verwenden die Syntax der Microsoft intermediate Language (MSIL), wenn die aktuelle <xref:System.Type> -Objekt stellt <xref:System.Int32>, gibt diese Methode eine <xref:System.Type> Objekt darstellt `Int32&`.</span><span class="sxs-lookup"><span data-stu-id="2da29-4084">Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32&`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-4085">Im folgenden Codebeispiel wird erstellt, Array, `ref` (`ByRef` in Visual Basic), und Zeigertypen für die `Test` Klasse.</span><span class="sxs-lookup"><span data-stu-id="2da29-4085">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2da29-4086">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4086">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="2da29-4087">Der aktuelle Typ ist <see cref="T:System.TypedReference" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4087">The current type is <see cref="T:System.TypedReference" />.</span>
          </span>
          <span data-ttu-id="2da29-4088">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4088">-or-</span>
          </span>
          <span data-ttu-id="2da29-4089">Der aktuelle Typ ist ein <see langword="ByRef" />-Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4089">The current type is a <see langword="ByRef" /> type.</span>
          </span>
          <span data-ttu-id="2da29-4090">Das heißt, <see cref="P:System.Type.IsByRef" /> gibt <see langword="true" /> zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4090">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">
          <span data-ttu-id="2da29-4091">Ein Array von Typen, die die Typparameter des aktuellen generischen Typs ersetzen sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4091">An array of types to be substituted for the type parameters of the current generic type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-4092">Ersetzt die Typparameter der aktuellen generischen Typdefinition durch die Elemente eines Arrays von Typen und gibt ein <see cref="T:System.Type" />-Objekt zurück, das den resultierenden konstruierten Typ darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4092">Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <see cref="T:System.Type" /> object representing the resulting constructed type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-4093">Ein <see cref="T:System.Type" />, der den konstruierten Typ darstellt, der durch Ersetzen der Typparameter des aktuellen generischen Typs durch die Elemente von <paramref name="typeArguments" /> erstellt wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4093">A <see cref="T:System.Type" /> representing the constructed type formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-4094">Die <xref:System.Type.MakeGenericType%2A> Methode können Sie Code schreiben, der spezifische Typen zugewiesen werden, um die Typparameter einer generischen Typdefinition, wodurch eine <xref:System.Type> -Objekt, das einen bestimmten konstruierten Typ darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-4094">The <xref:System.Type.MakeGenericType%2A> method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <xref:System.Type> object that represents a particular constructed type.</span></span> <span data-ttu-id="2da29-4095">Sie können dies <xref:System.Type> Objekt, das zur Laufzeit Instanzen des konstruierten Typs zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="2da29-4095">You can use this <xref:System.Type> object to create run-time instances of the constructed type.</span></span>  
  
 <span data-ttu-id="2da29-4096">Typen mit erstellt <xref:System.Type.MakeGenericType%2A> geöffnet sein können, d. h. einige ihrer Typargumente Typparameter von einschließenden generischen Methoden und Typen werden können.</span><span class="sxs-lookup"><span data-stu-id="2da29-4096">Types constructed with <xref:System.Type.MakeGenericType%2A> can be open, that is, some of their type arguments can be type parameters of enclosing generic methods or types.</span></span> <span data-ttu-id="2da29-4097">Sie können solche offen konstruierten Typen verwenden, wenn Ausgeben von dynamischen Assemblys.</span><span class="sxs-lookup"><span data-stu-id="2da29-4097">You might use such open constructed types when you emit dynamic assemblies.</span></span> <span data-ttu-id="2da29-4098">Betrachten Sie beispielsweise die Klassen `Base` und `Derived` in den folgenden Code.</span><span class="sxs-lookup"><span data-stu-id="2da29-4098">For example, consider the classes `Base` and `Derived` in the following code.</span></span>  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="2da29-4099">Zum generieren `Derived` in einer dynamischen Assembly zum Erstellen von seinem Basistyps erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-4099">To generate `Derived` in a dynamic assembly, it is necessary to construct its base type.</span></span> <span data-ttu-id="2da29-4100">Rufen Sie hierzu die <xref:System.Type.MakeGenericType%2A> Methode auf eine <xref:System.Type> Objekt, das die Klasse darstellt `Base`, verwenden die generischen Typargumente <xref:System.Int32> und die Typparameter `V` aus `Derived`.</span><span class="sxs-lookup"><span data-stu-id="2da29-4100">To do this, call the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object representing the class `Base`, using the generic type arguments <xref:System.Int32> and the type parameter `V` from `Derived`.</span></span> <span data-ttu-id="2da29-4101">Da die Typen und generischen Typparameter von dargestellt sind <xref:System.Type> Objekte aufweist, ein Array mit diesen beiden kann übergeben werden, um die <xref:System.Type.MakeGenericType%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-4101">Because types and generic type parameters are both represented by <xref:System.Type> objects, an array containing both can be passed to the <xref:System.Type.MakeGenericType%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-4102">Einen konstruierten Typ wie z. B. `Base<int, V>` ist nützlich, wenn Code ausgeben, jedoch nicht die <xref:System.Type.MakeGenericType%2A> Methode für diesen Typ, da es sich nicht um eine generische Typdefinition ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-4102">A constructed type such as `Base<int, V>` is useful when emitting code, but you cannot call the <xref:System.Type.MakeGenericType%2A> method on this type because it is not a generic type definition.</span></span> <span data-ttu-id="2da29-4103">Um einen geschlossenen konstruierten Typ zu erstellen, der instanziiert werden kann, rufen Sie zuerst die <xref:System.Type.GetGenericTypeDefinition%2A> Methode zum Abrufen einer <xref:System.Type> Objekt, das die generische Typdefinition darstellt, und rufen dann <xref:System.Type.MakeGenericType%2A> mit den gewünschten Typargumenten.</span><span class="sxs-lookup"><span data-stu-id="2da29-4103">To create a closed constructed type that can be instantiated, first call the <xref:System.Type.GetGenericTypeDefinition%2A> method to get a <xref:System.Type> object representing the generic type definition and then call <xref:System.Type.MakeGenericType%2A> with the desired type arguments.</span></span>  
  
 <span data-ttu-id="2da29-4104">Die <xref:System.Type> zurückgegebenes Objekt <xref:System.Type.MakeGenericType%2A> ist identisch mit der <xref:System.Type> abgerufen, indem die <xref:System.Object.GetType%2A> Methode den resultierenden konstruierten Typ, oder die <xref:System.Object.GetType%2A> -Methode einer jeglichen konstruierter Typ, der aus der gleichen generischen erstellt wurde mit den gleichen Typargumenten Typdefinition.</span><span class="sxs-lookup"><span data-stu-id="2da29-4104">The <xref:System.Type> object returned by <xref:System.Type.MakeGenericType%2A> is the same as the <xref:System.Type> obtained by calling the <xref:System.Object.GetType%2A> method of the resulting constructed type, or the <xref:System.Object.GetType%2A> method of any constructed type that was created from the same generic type definition using the same type arguments.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="2da29-4105">Ein Array von generischen Typen nicht selbst ein generischer Typ ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-4105">An array of generic types is not itself a generic type.</span></span> <span data-ttu-id="2da29-4106">Sie können nicht aufrufen <xref:System.Type.MakeGenericType%2A> Geben Sie auf ein Array wie z. B. `C<T>[]` (`Dim ac() As C(Of T)` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-4106">You cannot call <xref:System.Type.MakeGenericType%2A> on an array type such as `C<T>[]` (`Dim ac() As C(Of T)` in Visual Basic).</span></span> <span data-ttu-id="2da29-4107">So erstellen Sie einen geschlossenen generischen Typs aus `C<T>[]`, rufen Sie <xref:System.Type.GetElementType%2A> zum Abrufen der generischen Typdefinition `C<T>`; Aufrufen <xref:System.Type.MakeGenericType%2A> für die generische Typdefinition, erstellen den konstruierten Typ aus, und rufen Sie schließlich die <xref:System.Type.MakeArrayType%2A> Methode auf den konstruierten Typ zum Erstellen des Arraytyps.</span><span class="sxs-lookup"><span data-stu-id="2da29-4107">To construct a closed generic type from `C<T>[]`, call <xref:System.Type.GetElementType%2A> to obtain the generic type definition `C<T>`; call <xref:System.Type.MakeGenericType%2A> on the generic type definition to create the constructed type; and finally call the <xref:System.Type.MakeArrayType%2A> method on the constructed type to create the array type.</span></span> <span data-ttu-id="2da29-4108">Dasselbe gilt für Zeigertypen und `ref` Typen (`ByRef` in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="2da29-4108">The same is true of pointer types and `ref` types (`ByRef` in Visual Basic).</span></span>  
  
 <span data-ttu-id="2da29-4109">Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="2da29-4109">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
## <a name="nested-types"></a><span data-ttu-id="2da29-4110">Geschachtelte Typen</span><span class="sxs-lookup"><span data-stu-id="2da29-4110">Nested Types</span></span>  
 <span data-ttu-id="2da29-4111">Wenn ein generischer Typ mit c#, C++ oder Visual Basic definiert ist, sind seine geschachtelten Typen alle generisch.</span><span class="sxs-lookup"><span data-stu-id="2da29-4111">If a generic type is defined using C#, C++, or Visual Basic, then its nested types are all generic.</span></span> <span data-ttu-id="2da29-4112">Dies gilt auch, wenn die geschachtelten Typen keine eigenen Typparameter verfügen, da alle drei Sprachen die Typparameter von einschließenden Typen in der Typparameterliste des geschachtelten Typen enthalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-4112">This is true even if the nested types have no type parameters of their own, because all three languages include the type parameters of enclosing types in the type parameter lists of nested types.</span></span> <span data-ttu-id="2da29-4113">Betrachten Sie die folgenden Klassen:</span><span class="sxs-lookup"><span data-stu-id="2da29-4113">Consider the following classes:</span></span>  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 <span data-ttu-id="2da29-4114">Der Typparameterliste der geschachtelten Klasse `Inner` verfügt über zwei Typparameter `T` und `U`, das erste ist der Typparameter seiner einschließenden Klasse.</span><span class="sxs-lookup"><span data-stu-id="2da29-4114">The type parameter list of the nested class `Inner` has two type parameters, `T` and `U`, the first of which is the type parameter of its enclosing class.</span></span> <span data-ttu-id="2da29-4115">Auf ähnliche Weise der Typparameterliste der geschachtelten Klasse `Innermost1` verfügt über drei Typparameter, `T`, `U`, und `V`, mit `T` und `U` aus den einschließenden Klassen stammen.</span><span class="sxs-lookup"><span data-stu-id="2da29-4115">Similarly, the type parameter list of the nested class `Innermost1` has three type parameters, `T`, `U`, and `V`, with `T` and `U` coming from its enclosing classes.</span></span> <span data-ttu-id="2da29-4116">Die geschachtelte Klasse `Innermost2` verfügt über zwei Typparameter `T` und `U`, die aus den einschließenden Klassen stammen.</span><span class="sxs-lookup"><span data-stu-id="2da29-4116">The nested class `Innermost2` has two type parameters, `T` and `U`, which come from its enclosing classes.</span></span>  
  
 <span data-ttu-id="2da29-4117">Wenn die Parameterliste des einschließenden Typs mehrere Typparameter aufweist, werden alle Typparameter in der Reihenfolge in der Typparameterliste des geschachtelten Typs enthalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-4117">If the parameter list of the enclosing type has more than one type parameter, all the type parameters in order are included in the type parameter list of the nested type.</span></span>  
  
 <span data-ttu-id="2da29-4118">Um einen generischen Typ aus der generischen Typdefinition für einen geschachtelten Typ zu konstruieren, rufen Sie die <xref:System.Type.MakeGenericType%2A> Methode mit dem Array gebildet durch Verketten der Typ Argument Arrays aller einschließenden Typen, ab der äußersten generische Typ, und endet mit der Geben Sie Argumentarray des geschachtelten Typs selbst verfügt über eigene Typparameter.</span><span class="sxs-lookup"><span data-stu-id="2da29-4118">To construct a generic type from the generic type definition for a nested type, call the <xref:System.Type.MakeGenericType%2A> method with the array formed by concatenating the type argument arrays of all the enclosing types, beginning with the outermost generic type, and ending with the type argument array of the nested type itself, if it has type parameters of its own.</span></span> <span data-ttu-id="2da29-4119">Zum Erstellen einer Instanz des `Innermost1`, rufen Sie die <xref:System.Type.MakeGenericType%2A> Methode mit einem Array mit drei Typen, T, U und V zugewiesen werden. Zum Erstellen einer Instanz von `Innermost2`, rufen Sie die <xref:System.Type.MakeGenericType%2A> Methode mit einem Array mit zwei Typen, zuzuweisenden T "und" U.</span><span class="sxs-lookup"><span data-stu-id="2da29-4119">To create an instance of `Innermost1`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing three types, to be assigned to T, U, and V. To create an instance of `Innermost2`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing two types, to be assigned to T and U.</span></span>  
  
 <span data-ttu-id="2da29-4120">Die Sprachen weitergegeben, die Typparameter von einschließenden Typen auf diese Weise, sodass Sie die Typparameter eines einschließenden Typs verwenden können, um Felder von geschachtelten Typen zu definieren.</span><span class="sxs-lookup"><span data-stu-id="2da29-4120">The languages propagate the type parameters of enclosing types in this fashion so you can use the type parameters of an enclosing type to define fields of nested types.</span></span> <span data-ttu-id="2da29-4121">Andernfalls würde die Typparameter nicht im Gültigkeitsbereich innerhalb des Texts der geschachtelten Typen sein.</span><span class="sxs-lookup"><span data-stu-id="2da29-4121">Otherwise, the type parameters would not be in scope within the bodies of the nested types.</span></span> <span data-ttu-id="2da29-4122">Es ist möglich, geschachtelte Typen definieren, ohne die Weitergabe der Typparameter von einschließenden Typen durch Ausgeben von Code in dynamischen Assemblys oder mithilfe der [Ilasm.exe (IL-Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="2da29-4122">It is possible to define nested types without propagating the type parameters of enclosing types, by emitting code in dynamic assemblies or by using the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span> <span data-ttu-id="2da29-4123">Betrachten Sie folgenden Code für die MSIL-Assembler:</span><span class="sxs-lookup"><span data-stu-id="2da29-4123">Consider the following code for the MSIL assembler:</span></span>  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 <span data-ttu-id="2da29-4124">In diesem Beispiel ist es nicht möglich, definieren Sie ein Feld vom Typ `T` oder `U` in Klasse `Innermost`, da die Typparameter nicht im Gültigkeitsbereich befinden.</span><span class="sxs-lookup"><span data-stu-id="2da29-4124">In this example, it is not possible to define a field of type `T` or `U` in class `Innermost`, because those type parameters are not in scope.</span></span> <span data-ttu-id="2da29-4125">Der folgende Assemblercode definiert geschachtelte Klassen, die die Verhaltensweise, wäre in C++, Visual Basic und c# definiert:</span><span class="sxs-lookup"><span data-stu-id="2da29-4125">The following assembler code defines nested classes that behave the way they would if defined in C++, Visual Basic, and C#:</span></span>  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 <span data-ttu-id="2da29-4126">Sie können die [Ildasm.exe (IL-Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) geschachtelte Klassen definiert, in hoch entwickelter Sprachen und untersuchen diese Benennungsschema.</span><span class="sxs-lookup"><span data-stu-id="2da29-4126">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine nested classes defined in the high-level languages and observe this naming scheme.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-4127">Im folgenden Beispiel wird die <xref:System.Type.MakeGenericType%2A> Methode so erstellen Sie einen konstruierten Typ aus der Definition des generischen Typs für die <xref:System.Collections.Generic.Dictionary%602> Typ.</span><span class="sxs-lookup"><span data-stu-id="2da29-4127">The following example uses the <xref:System.Type.MakeGenericType%2A> method to create a constructed type from the generic type definition for the <xref:System.Collections.Generic.Dictionary%602> type.</span></span> <span data-ttu-id="2da29-4128">Den konstruierte Typ darstellt, ein <xref:System.Collections.Generic.Dictionary%602> von `Test` Objekte mit Zeichenfolgenschlüssel.</span><span class="sxs-lookup"><span data-stu-id="2da29-4128">The constructed type represents a <xref:System.Collections.Generic.Dictionary%602> of `Test` objects with string keys.</span></span>  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="2da29-4129">Der aktuelle Typ stellt keine generische Typdefinition dar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4129">The current type does not represent a generic type definition.</span>
          </span>
          <span data-ttu-id="2da29-4130">Das heißt, <see cref="P:System.Type.IsGenericTypeDefinition" /> gibt <see langword="false" /> zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4130">That is, <see cref="P:System.Type.IsGenericTypeDefinition" /> returns <see langword="false" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-4131">
            <paramref name="typeArguments" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4131">
              <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2da29-4132">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4132">-or-</span>
          </span>
          <span data-ttu-id="2da29-4133">Ein beliebiges Element von <paramref name="typeArguments" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4133">Any element of <paramref name="typeArguments" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-4134">Die Anzahl von Elementen in <paramref name="typeArguments" /> entspricht nicht der Anzahl von Typparametern in der aktuellen generischen Typdefinition.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4134">The number of elements in <paramref name="typeArguments" /> is not the same as the number of type parameters in the current generic type definition.</span>
          </span>
          <span data-ttu-id="2da29-4135">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4135">-or-</span>
          </span>
          <span data-ttu-id="2da29-4136">Eines der Elemente von <paramref name="typeArguments" /> entspricht nicht den für den entsprechenden Typparameter des aktuellen generischen Typs angegebenen Einschränkungen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4136">Any element of <paramref name="typeArguments" /> does not satisfy the constraints specified for the corresponding type parameter of the current generic type.</span>
          </span>
          <span data-ttu-id="2da29-4137">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4137">-or-</span>
          </span>
          <span data-ttu-id="2da29-4138">
            <paramref name="typeArguments" /> enthält ein Element, das ein Zeigertyp (<see cref="P:System.Type.IsPointer" /> gibt <see langword="true" /> zurück), ein by-ref-Typ (<see cref="P:System.Type.IsByRef" /> gibt <see langword="true" /> zurück) oder <see cref="T:System.Void" /> ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4138">
              <paramref name="typeArguments" /> contains an element that is a pointer type (<see cref="P:System.Type.IsPointer" /> returns <see langword="true" />), a by-ref type (<see cref="P:System.Type.IsByRef" /> returns <see langword="true" />), or <see cref="T:System.Void" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2da29-4139">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4139">The invoked method is not supported in the base class.</span>
          </span>
          <span data-ttu-id="2da29-4140">Abgeleitete Klassen müssen eine Implementation angeben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4140">Derived classes must provide an implementation.</span>
          </span>
        </exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-4141">Gibt ein <see cref="T:System.Type" />-Objekt zurück, das einen Zeiger auf den aktuellen Typ darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4141">Returns a <see cref="T:System.Type" /> object that represents a pointer to the current type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-4142">Ein <see cref="T:System.Type" />-Objekt, das einen Zeiger auf den aktuellen Typ darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4142">A <see cref="T:System.Type" /> object that represents a pointer to the current type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-4143">Die <xref:System.Type.MakePointerType%2A> Methode bietet eine Möglichkeit zum Generieren von Zeigertypen für Parameterlisten.</span><span class="sxs-lookup"><span data-stu-id="2da29-4143">The <xref:System.Type.MakePointerType%2A> method provides a way to generate pointer types for parameter lists.</span></span>  
  
 <span data-ttu-id="2da29-4144">Verwenden die Syntax der Microsoft intermediate Language (MSIL), wenn die aktuelle <xref:System.Type> -Objekt stellt <xref:System.Int32>, gibt diese Methode eine <xref:System.Type> Objekt darstellt `Int32*`.</span><span class="sxs-lookup"><span data-stu-id="2da29-4144">Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32*`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-4145">Im folgenden Codebeispiel wird erstellt, Array, `ref` (`ByRef` in Visual Basic), und Zeigertypen für die `Test` Klasse.</span><span class="sxs-lookup"><span data-stu-id="2da29-4145">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2da29-4146">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4146">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="2da29-4147">Der aktuelle Typ ist <see cref="T:System.TypedReference" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4147">The current type is <see cref="T:System.TypedReference" />.</span>
          </span>
          <span data-ttu-id="2da29-4148">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4148">-or-</span>
          </span>
          <span data-ttu-id="2da29-4149">Der aktuelle Typ ist ein <see langword="ByRef" />-Typ.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4149">The current type is a <see langword="ByRef" /> type.</span>
          </span>
          <span data-ttu-id="2da29-4150">Das heißt, <see cref="P:System.Type.IsByRef" /> gibt <see langword="true" /> zurück.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4150">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-4151">Ruft einen <see cref="T:System.Reflection.MemberTypes" />-Wert ab, der angibt, dass dieser Member ein Typ oder ein geschachtelter Typ ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4151">Gets a <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a type or a nested type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-4152">Ein <see cref="T:System.Reflection.MemberTypes" />-Wert, der angibt, dass dieser Member ein Typ oder ein geschachtelter Typ ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4152">A <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a type or a nested type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-4153">Diese Eigenschaft überschreibt <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-4153">This property overrides <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2da29-4154">Wenn Sie daher eine Reihe von untersuchen <xref:System.Reflection.MemberInfo> Objekte – z. B. das zurückgegebene Array <xref:System.Type.GetMembers%2A>– die <xref:System.Reflection.MemberInfo.MemberType%2A> -Eigenschaft gibt <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> Wenn ein angegebenes Element ein geschachtelter Typ ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-4154">Therefore, when you examine a set of <xref:System.Reflection.MemberInfo> objects—for example, the array returned by <xref:System.Type.GetMembers%2A>—the <xref:System.Reflection.MemberInfo.MemberType%2A> property returns <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> when a given member is a nested type.</span></span>  
  
 <span data-ttu-id="2da29-4155">Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde.</span><span class="sxs-lookup"><span data-stu-id="2da29-4155">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="2da29-4156">Z. B. wenn die aktuelle <xref:System.Type> stellt `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), der Wert dieser Eigenschaft richtet sich nach `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="2da29-4156">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="2da29-4157">Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="2da29-4157">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-4158">Das folgende Codebeispiel zeigt die `MemberType` Feld als Parameter an die `GetMember` Methode:</span><span class="sxs-lookup"><span data-stu-id="2da29-4158">The following code example shows the `MemberType` field as a parameter to the `GetMember` method:</span></span>  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-4159">Stellt einen in den <see cref="T:System.Type" />-Informationen fehlenden Wert dar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4159">Represents a missing value in the <see cref="T:System.Type" /> information.</span>
          </span>
          <span data-ttu-id="2da29-4160">Dieses Feld ist schreibgeschützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4160">This field is read-only.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-4161">Verwenden der `Missing` Feld für den Aufruf durch Reflektion auf den Standardwert eines Parameters zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="2da29-4161">Use the `Missing` field for invocation through reflection to obtain the default value of a parameter.</span></span> <span data-ttu-id="2da29-4162">Wenn die `Missing` Feld für den Parameterwert übergeben wird, und es ist kein Standardwert für diesen Parameter ein <xref:System.ArgumentException> ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="2da29-4162">If the `Missing` field is passed in for a parameter value and there is no default value for that parameter, an <xref:System.ArgumentException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-4163">Das folgende Codebeispiel veranschaulicht die Verwendung von der `Missing` Feld zum Aufrufen einer Methode mit den Standardargumenten.</span><span class="sxs-lookup"><span data-stu-id="2da29-4163">The following code example shows the use of the `Missing` field to invoke a method with its default arguments.</span></span>  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 <span data-ttu-id="2da29-4164">Dieser Code erzeugt die folgende Ausgabe:</span><span class="sxs-lookup"><span data-stu-id="2da29-4164">This code produces the following output:</span></span>  
  
 <span data-ttu-id="2da29-4165">eine = 10 b = 55.3 c = 12</span><span class="sxs-lookup"><span data-stu-id="2da29-4165">a = 10 b = 55.3 c = 12</span></span>  
  
 <span data-ttu-id="2da29-4166">eine = 10 b 1.3 c = 1 =</span><span class="sxs-lookup"><span data-stu-id="2da29-4166">a = 10 b = 1.3 c = 1</span></span>  
  
 <span data-ttu-id="2da29-4167">eine = 10 b 1.2 c = 1 =</span><span class="sxs-lookup"><span data-stu-id="2da29-4167">a = 10 b = 1.2 c = 1</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-4168">Ruft das Modul (die DLL) ab, in dem der aktuelle <see cref="T:System.Type" /> definiert ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4168">Gets the module (the DLL) in which the current <see cref="T:System.Type" /> is defined.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-4169">Das Modul, in dem der aktuelle <see cref="T:System.Type" /> definiert ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4169">The module in which the current <see cref="T:System.Type" /> is defined.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-4170">Wenn die aktuelle <xref:System.Type> stellt ein konstruierter generischer Typ, diese Eigenschaft gibt das Modul, in dem die generische Typdefinition definiert wurde.</span><span class="sxs-lookup"><span data-stu-id="2da29-4170">If the current <xref:System.Type> represents a constructed generic type, this property returns the module in which the generic type definition was defined.</span></span> <span data-ttu-id="2da29-4171">Angenommen, Sie erstellen eine Instanz von `MyGenericStack<int>`, die <xref:System.Type.Module%2A> -Eigenschaft für den konstruierten Typ gibt das Modul, in dem `MyGenericStack<T>` definiert ist.</span><span class="sxs-lookup"><span data-stu-id="2da29-4171">For example, if you create an instance of `MyGenericStack<int>`, the <xref:System.Type.Module%2A> property for the constructed type returns the module in which `MyGenericStack<T>` is defined.</span></span>  
  
 <span data-ttu-id="2da29-4172">Auf ähnliche Weise, wenn die aktuelle <xref:System.Type> stellt einen generischen Parameter `T`, diese Eigenschaft gibt die Assembly, die den generischen Typ enthält, definiert `T`.</span><span class="sxs-lookup"><span data-stu-id="2da29-4172">Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-4173">Im folgenden Beispiel veranschaulicht die <xref:System.Type.Namespace%2A> und `Module` Eigenschaften und die <xref:System.Type.ToString%2A> Methode <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="2da29-4173">This following example demonstrates a use of the <xref:System.Type.Namespace%2A> and `Module` properties and the <xref:System.Type.ToString%2A> method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-4174">Ruft den Namespace von <see cref="T:System.Type" /> ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4174">Gets the namespace of the <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-4175">Der Namespace des <see cref="T:System.Type" />; <see langword="null" />, wenn die aktuelle Instanz über keinen Namespace verfügt oder einen generischen Parameter darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4175">The namespace of the <see cref="T:System.Type" />; <see langword="null" /> if the current instance has no namespace or represents a generic parameter.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-4176">Ein Namespace ist eine logische zur Entwurfszeit naming Annehmlichkeit, hauptsächlich zum Definieren von Bereich in einer Anwendung, und Organisieren von Klassen und anderen Typen in einer hierarchischen Struktur verwendet.</span><span class="sxs-lookup"><span data-stu-id="2da29-4176">A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure.</span></span> <span data-ttu-id="2da29-4177">Vom Standpunkt der Laufzeit gibt es keine Namespaces.</span><span class="sxs-lookup"><span data-stu-id="2da29-4177">From the viewpoint of the runtime, there are no namespaces.</span></span>  
  
 <span data-ttu-id="2da29-4178">Wenn die aktuelle <xref:System.Type> einen konstruierter generischen Typ darstellt, gibt diese Eigenschaft den Namespace, die generische Typdefinition enthält.</span><span class="sxs-lookup"><span data-stu-id="2da29-4178">If the current <xref:System.Type> represents a constructed generic type, this property returns the namespace that contains the generic type definition.</span></span> <span data-ttu-id="2da29-4179">Auf ähnliche Weise, wenn die aktuelle <xref:System.Type> stellt einen generischen Parameter `T`, diese Eigenschaft gibt den Namespace, die generische Typdefinition enthält, die definiert `T`.</span><span class="sxs-lookup"><span data-stu-id="2da29-4179">Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the namespace that contains the generic type definition that defines `T`.</span></span>  
  
 <span data-ttu-id="2da29-4180">Wenn die aktuelle <xref:System.Type> -Objekt einen generischen Parameter darstellt, gibt diese Eigenschaft zurück `null`.</span><span class="sxs-lookup"><span data-stu-id="2da29-4180">If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-4181">Im folgenden Beispiel veranschaulicht die `Namespace` und <xref:System.Type.Module%2A> Eigenschaften und die <xref:System.Type.ToString%2A> Methode <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="2da29-4181">This following example demonstrates a use of the `Namespace` and <xref:System.Type.Module%2A> properties and the <xref:System.Type.ToString%2A> method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="2da29-4182">Das erste zu vergleichende Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4182">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="2da29-4183">Das zweite zu vergleichende Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4183">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-4184">Gibt an, ob zwei <see cref="T:System.Type" />-Objekte gleich sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4184">Indicates whether two <see cref="T:System.Type" /> objects are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-4185">
            <see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> gleich sind, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4185">
              <see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="2da29-4186">Das erste zu vergleichende Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4186">The first object to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="2da29-4187">Das zweite zu vergleichende Objekt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4187">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-4188">Gibt an, ob zwei <see cref="T:System.Type" />-Objekte ungleich sind.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4188">Indicates whether two <see cref="T:System.Type" /> objects are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-4189">
            <see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4189">
              <see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-4190">Ruft das Klassenobjekt ab, über das dieser Member abgerufen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4190">Gets the class object that was used to obtain this member.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-4191">Das <see langword="Type" />-Objekt, über das dieses <see cref="T:System.Type" />-Objekt abgerufen wurde.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4191">The <see langword="Type" /> object through which this <see cref="T:System.Type" /> object was obtained.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-4192">Für <xref:System.Type> Objekte, die der Wert dieser Eigenschaft entspricht immer der Wert von der <xref:System.Type.DeclaringType%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-4192">For <xref:System.Type> objects, the value of this property is always the same as the value of the <xref:System.Type.DeclaringType%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-4193">Dieses Beispiel zeigt den reflektierten Typ einer geschachtelten Klasse.</span><span class="sxs-lookup"><span data-stu-id="2da29-4193">This example displays the reflected type of a nested class.</span></span>  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">
          <span data-ttu-id="2da29-4194">Der durch die Assembly bezeichnete Name des abzurufenden <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4194">The assembly-qualified name of the <see cref="T:System.Type" /> to get.</span>
          </span>
        </param>
        <param name="throwIfNotFound">
          <span data-ttu-id="2da29-4195">
            <see langword="true" />, damit eine <see cref="T:System.TypeLoadException" /> ausgelöst wird, wenn der Typ nicht gefunden wird. <see langword="false" />, damit <see langword="null" /> zurückgegeben wird, wenn der Typ nicht gefunden wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4195">
              <see langword="true" /> to throw a <see cref="T:System.TypeLoadException" /> if the type cannot be found; <see langword="false" /> to return <see langword="null" /> if the type cannot be found.</span>
          </span>
          <span data-ttu-id="2da29-4196">Die Angabe von <see langword="false" /> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4196">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span>
          </span>
          <span data-ttu-id="2da29-4197">Informationen finden Sie im Abschnitt für Ausnahmen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4197">See the Exceptions section.</span>
          </span>
        </param>
        <param name="ignoreCase">
          <span data-ttu-id="2da29-4198">
            <see langword="true" />, um ohne Beachtung der Groß-/Kleinschreibung nach <c>typeName</c> zu suchen; <see langword="false" />, um mit Beachtung der Groß-/Kleinschreibung nach <c>typeName</c> zu suchen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4198">
              <see langword="true" /> to perform a case-insensitive search for <c>typeName</c>; <see langword="false" /> to perform a case-sensitive search for <c>typeName</c>.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-4199">Ruft den <see cref="T:System.Type" /> mit dem angegebenen Namen ab. Dabei wird angegeben, ob bei der Suche die Groß- und Kleinschreibung berücksichtigt werden soll und ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4199">Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found.</span>
          </span>
          <span data-ttu-id="2da29-4200">Der Typ wird für die Reflektion, nicht für Ausführung geladen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4200">The type is loaded for reflection only, not for execution.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-4201">Der Typ mit dem angegebenen Namen, sofern gefunden, andernfalls <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4201">The type with the specified name, if found; otherwise, <see langword="null" />.</span>
          </span>
          <span data-ttu-id="2da29-4202">Wenn der Typ nicht gefunden wird, gibt der <paramref name="throwIfNotFound" />-Parameter an, ob <see langword="null" /> zurückgegeben oder eine Ausnahme ausgelöst wird.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4202">If the type is not found, the <paramref name="throwIfNotFound" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span>
          </span>
          <span data-ttu-id="2da29-4203">In einigen Fällen wird unabhängig vom Wert von <paramref name="throwIfNotFound" /> eine Ausnahme ausgelöst.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4203">In some cases, an exception is thrown regardless of the value of <paramref name="throwIfNotFound" />.</span>
          </span>
          <span data-ttu-id="2da29-4204">Informationen finden Sie im Abschnitt für Ausnahmen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4204">See the Exceptions section.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-4205">Wenn die Assembly mit dem Typ nicht in den reflektionsbezogenen Kontext geladen ist, mithilfe der <xref:System.Type.ReflectionOnlyGetType%2A> Methode ist gleichbedeutend mit dem ersten Laden der Assembly für die Reflektion, mit der <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> -Methode, und Laden Sie dann durch Aufrufen des Typs der der Assembly <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-4205">If the assembly containing the type is not already loaded into the reflection-only context, using the <xref:System.Type.ReflectionOnlyGetType%2A> method is equivalent to first loading the assembly for reflection only, using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> method, and then loading the type by calling the assembly's <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="2da29-4206">Informationen über qualifizierte Assemblynamen finden Sie unter der <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="2da29-4206">For information about assembly-qualified names, see the <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="2da29-4207">Weitere Informationen zum Angeben der Typnamen finden Sie unter der <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> -methodenüberladung.</span><span class="sxs-lookup"><span data-stu-id="2da29-4207">For additional details on specifying type names, see the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
 <span data-ttu-id="2da29-4208">Wenn die Assembly bereits für Ausführung geladen wird, wird eine weitere Kopie in den reflektionsbezogenen Kontext geladen.</span><span class="sxs-lookup"><span data-stu-id="2da29-4208">If the assembly is already loaded for execution, another copy is loaded into the reflection-only context.</span></span>  
  
 <span data-ttu-id="2da29-4209">Die `throwIfNotFound` Parameter gibt an, was geschieht, wenn der Typ nicht gefunden wird, und auch bestimmte andere Ausnahmebedingungen unterdrückt, wie im Abschnitt für Ausnahmen beschrieben.</span><span class="sxs-lookup"><span data-stu-id="2da29-4209">The `throwIfNotFound` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="2da29-4210">Einige Ausnahmen werden ausgelöst, unabhängig vom Wert der `throwIfNotFound`.</span><span class="sxs-lookup"><span data-stu-id="2da29-4210">Some exceptions are thrown regardless of the value of `throwIfNotFound`.</span></span> <span data-ttu-id="2da29-4211">Wenn die Assembly nicht gültig ist, z. B. eine <xref:System.BadImageFormatException> wird ausgelöst, selbst wenn `throwIfNotFound` ist `false`.</span><span class="sxs-lookup"><span data-stu-id="2da29-4211">For example, if the assembly is not valid, a <xref:System.BadImageFormatException> is thrown even if `throwIfNotFound` is `false`.</span></span>  
  
 <span data-ttu-id="2da29-4212">Weitere Informationen zu den ReflectionOnly Kontext verwenden, finden Sie unter [wie: Laden von Assemblys in den Reflection-Kontext](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span><span class="sxs-lookup"><span data-stu-id="2da29-4212">For more information about using the reflection-only context, see [How to: Load Assemblies into the Reflection-Only Context](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="2da29-4213">
            <paramref name="typeName" /> ist <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4213">
              <paramref name="typeName" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Reflection.TargetInvocationException">
          <span data-ttu-id="2da29-4214">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4214">A class initializer is invoked and throws an exception.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeLoadException">
          <span data-ttu-id="2da29-4215">
            <paramref name="throwIfNotFound" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4215">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and the type is not found.</span>
          </span>
          <span data-ttu-id="2da29-4216">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4216">-or-</span>
          </span>
          <span data-ttu-id="2da29-4217">
            <paramref name="throwIfNotFound" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4217">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span>
          </span>
          <span data-ttu-id="2da29-4218">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4218">-or-</span>
          </span>
          <span data-ttu-id="2da29-4219">
            <paramref name="throwIfNotFound" /> ist <see langword="true" />, und <paramref name="typeName" /> ist eine leere Zeichenfolge.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4219">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span>
          </span>
          <span data-ttu-id="2da29-4220">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4220">-or-</span>
          </span>
          <span data-ttu-id="2da29-4221">
            <paramref name="throwIfNotFound" /> ist <see langword="true" />, und <paramref name="typeName" /> stellt einen Arraytyp mit einer ungültigen Größe dar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4221">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span>
          </span>
          <span data-ttu-id="2da29-4222">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4222">-or-</span>
          </span>
          <span data-ttu-id="2da29-4223">
            <paramref name="typeName" /> stellt ein Array mit <see cref="T:System.TypedReference" />-Objekten dar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4223">
              <paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" /> objects.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="2da29-4224">
            <paramref name="typeName" /> enthält keinen Assemblynamen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4224">
              <paramref name="typeName" /> does not include the assembly name.</span>
          </span>
          <span data-ttu-id="2da29-4225">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4225">-or-</span>
          </span>
          <span data-ttu-id="2da29-4226">
            <paramref name="throwIfNotFound" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Syntax (z.B. „MyType[,\*,]“).</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4226">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax; for example, "MyType[,\*,]".</span>
          </span>
          <span data-ttu-id="2da29-4227">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4227">-or-</span>
          </span>
          <span data-ttu-id="2da29-4228">
            <paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4228">
              <paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span>
          </span>
          <span data-ttu-id="2da29-4229">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4229">-or-</span>
          </span>
          <span data-ttu-id="2da29-4230">
            <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4230">
              <paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span>
          </span>
          <span data-ttu-id="2da29-4231">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4231">-or-</span>
          </span>
          <span data-ttu-id="2da29-4232">
            <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4232">
              <paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <span data-ttu-id="2da29-4233">
            <paramref name="throwIfNotFound" /> ist <see langword="true" />, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4233">
              <paramref name="throwIfNotFound" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span>
          </span>
        </exception>
        <exception cref="T:System.IO.FileLoadException">
          <span data-ttu-id="2da29-4234">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4234">The assembly or one of its dependencies was found, but could not be loaded.</span>
          </span>
        </exception>
        <exception cref="T:System.BadImageFormatException">
          <span data-ttu-id="2da29-4235">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4235">The assembly or one of its dependencies is not valid.</span>
          </span>
          <span data-ttu-id="2da29-4236">- oder - </span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4236">-or-</span>
          </span>
          <span data-ttu-id="2da29-4237">Die Assembly wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4237">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span>
          </span>
        </exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-4238">Ruft ein <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> ab, der das Layout des aktuellen Typs beschreibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4238">Gets a <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> that describes the layout of the current type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-4239">Ruft ein <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> ab, das den allgemeinen Layoutaufbau des aktuellen Typs beschreibt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4239">Gets a <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> that describes the gross layout features of the current type.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-4240"><xref:System.Runtime.InteropServices.StructLayoutAttribute> wird nicht zurückgegeben, durch die <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="2da29-4240"><xref:System.Runtime.InteropServices.StructLayoutAttribute> is not returned by the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method.</span></span> <span data-ttu-id="2da29-4241">Verwenden Sie stattdessen diese Eigenschaft zum Abrufen.</span><span class="sxs-lookup"><span data-stu-id="2da29-4241">Instead, use this property to get it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-4242">Das folgende Codebeispiel definiert zuerst eine Klasse, eine Struktur und eine Struktur mit speziellen Layoutattribute (innerhalb der Klasse werden die Strukturen geschachtelt).</span><span class="sxs-lookup"><span data-stu-id="2da29-4242">The following code example first defines a class, a structure, and a structure with special layout attributes (the structures are nested within the class).</span></span> <span data-ttu-id="2da29-4243">Anschließend wird die <xref:System.Type.StructLayoutAttribute%2A> -Eigenschaft zum Abrufen einer <xref:System.Runtime.InteropServices.StructLayoutAttribute> für jeden Typ, und zeigt die Eigenschaften der Attribute.</span><span class="sxs-lookup"><span data-stu-id="2da29-4243">The example then uses the <xref:System.Type.StructLayoutAttribute%2A> property to obtain a <xref:System.Runtime.InteropServices.StructLayoutAttribute> for each type, and displays the properties of the attributes.</span></span>  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2da29-4244">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4244">The invoked method is not supported in the base class.</span>
          </span>
        </exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">
          <span data-ttu-id="2da29-4245">Für zukünftige Verwendung reserviert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4245">Reserved for future use.</span>
          </span>
          <span data-ttu-id="2da29-4246">Muss IID_NULL sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4246">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="rgszNames">
          <span data-ttu-id="2da29-4247">Das übergebene Array von zuzuordnenden Namen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4247">Passed-in array of names to be mapped.</span>
          </span>
        </param>
        <param name="cNames">
          <span data-ttu-id="2da29-4248">Die Anzahl der zuzuordnenden Namen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4248">Count of the names to be mapped.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="2da29-4249">Der Gebietsschemakontext, in dem die Namen interpretiert werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4249">The locale context in which to interpret the names.</span>
          </span>
        </param>
        <param name="rgDispId">
          <span data-ttu-id="2da29-4250">Das vom Aufrufer zugewiesene Array, das die IDs entsprechend den Namen empfängt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4250">Caller-allocated array which receives the IDs corresponding to the names.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-4251">Ordnet eine Reihe von Namen einer entsprechenden Reihe von Dispatchbezeichnern zu.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4251">Maps a set of names to a corresponding set of dispatch identifiers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-4252">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-4252">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="2da29-4253">Weitere Informationen zu `IDispatch::GetIDsOfNames`, finden Sie in der MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="2da29-4253">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="2da29-4254">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4254">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">
          <span data-ttu-id="2da29-4255">Die zurückzugebenden Typinformationen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4255">The type information to return.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="2da29-4256">Der Gebietsschemabezeichner für die Typinformationen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4256">The locale identifier for the type information.</span>
          </span>
        </param>
        <param name="ppTInfo">
          <span data-ttu-id="2da29-4257">Ein Zeiger auf das angeforderte Objekt mit den Typinformationen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4257">A pointer to the requested type information object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-4258">Ruft die Typinformationen für ein Objekt ab, die dann zum Abrufen der Typinformationen für eine Schnittstelle verwendet werden können.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4258">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-4259">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-4259">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="2da29-4260">Weitere Informationen zu `IDispatch::GetTypeInfo`, finden Sie in der MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="2da29-4260">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="2da29-4261">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4261">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">
          <span data-ttu-id="2da29-4262">Zeigt auf einen Speicherort, der die Anzahl der Schnittstellen mit Typinformationen empfängt, die vom Objekt bereitgestellt werden.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4262">Points to a location that receives the number of type information interfaces provided by the object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-4263">Ruft die Anzahl der Schnittstellen mit Typinformationen ab, die von einem Objekt bereitgestellt werden (0 oder 1).</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4263">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-4264">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-4264">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="2da29-4265">Weitere Informationen zu `IDispatch::GetTypeInfoCount`, finden Sie in der MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="2da29-4265">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="2da29-4266">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4266">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">
          <span data-ttu-id="2da29-4267">Bezeichnet den Member.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4267">Identifies the member.</span>
          </span>
        </param>
        <param name="riid">
          <span data-ttu-id="2da29-4268">Für zukünftige Verwendung reserviert.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4268">Reserved for future use.</span>
          </span>
          <span data-ttu-id="2da29-4269">Muss IID_NULL sein.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4269">Must be IID_NULL.</span>
          </span>
        </param>
        <param name="lcid">
          <span data-ttu-id="2da29-4270">Der Gebietsschemakontext, in dem Argumente interpretiert werden sollen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4270">The locale context in which to interpret arguments.</span>
          </span>
        </param>
        <param name="wFlags">
          <span data-ttu-id="2da29-4271">Flags, die den Kontext des Aufrufs beschreiben.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4271">Flags describing the context of the call.</span>
          </span>
        </param>
        <param name="pDispParams">
          <span data-ttu-id="2da29-4272">Ein Zeiger auf eine Struktur, die ein Array von Argumenten und ein Array von Argument-DISPIDs für benannte Argumente sowie Zähler für die Anzahl der Elemente in jedem Array enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4272">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span>
          </span>
        </param>
        <param name="pVarResult">
          <span data-ttu-id="2da29-4273">Ein Verweis auf den Speicherort, an dem das Ergebnis gespeichert werden soll.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4273">Pointer to the location where the result is to be stored.</span>
          </span>
        </param>
        <param name="pExcepInfo">
          <span data-ttu-id="2da29-4274">Ein Zeiger auf eine Struktur mit Ausnahmeinformationen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4274">Pointer to a structure that contains exception information.</span>
          </span>
        </param>
        <param name="puArgErr">
          <span data-ttu-id="2da29-4275">Der Index des ersten Arguments mit einem Fehler.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4275">The index of the first argument that has an error.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="2da29-4276">Stellt den Zugriff auf von einem Objekt verfügbar gemachte Eigenschaften und Methoden bereit.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4276">Provides access to properties and methods exposed by an object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-4277">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-4277">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="2da29-4278">Weitere Informationen zu `IDispatch::Invoke`, finden Sie in der MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="2da29-4278">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="2da29-4279">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4279">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="2da29-4280">Gibt einen <see langword="String" /> zurück, der den Namen des aktuellen <see langword="Type" /> darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4280">Returns a <see langword="String" /> representing the name of the current <see langword="Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="2da29-4281">Ein <see cref="T:System.String" />, der den Namen des aktuellen <see cref="T:System.Type" /> darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4281">A <see cref="T:System.String" /> representing the name of the current <see cref="T:System.Type" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-4282">Diese Methode gibt den voll gekennzeichneten common Language Runtime-Namespace und den Namen für alle primitiven Typen.</span><span class="sxs-lookup"><span data-stu-id="2da29-4282">This method returns the fully qualified common language runtime namespace and name for all primitive types.</span></span> <span data-ttu-id="2da29-4283">Angenommen, die C#-Anweisung, `(long)0.Type().ToString()` "System. Int64" anstelle von "Int64" zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="2da29-4283">For example, the C# instruction, `(long)0.Type().ToString()` returns "System.Int64" instead of merely "Int64".</span></span>  
  
 <span data-ttu-id="2da29-4284">Wenn die aktuelle <xref:System.Type> stellt einen generischen Typ, den Typ und ihre Typargumente durch den Namespace und durch den geschachtelten Typ, aber nicht durch die Assembly qualifiziert werden.</span><span class="sxs-lookup"><span data-stu-id="2da29-4284">If the current <xref:System.Type> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly.</span></span> <span data-ttu-id="2da29-4285">Wenn die aktuelle <xref:System.Type> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode gibt den nicht qualifizierten Namen des Typparameters zurück.</span><span class="sxs-lookup"><span data-stu-id="2da29-4285">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-4286">Im folgenden Beispiel veranschaulicht die <xref:System.Type.Namespace%2A> und <xref:System.Type.Module%2A> Eigenschaften und die `ToString` Methode <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="2da29-4286">This following example demonstrates a use of the <xref:System.Type.Namespace%2A> and <xref:System.Type.Module%2A> properties and the `ToString` method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 <span data-ttu-id="2da29-4287">Das folgende Beispiel vergleicht die zurückgegebene Zeichenfolgen die <xref:System.Type.ToString%2A> Methode und die `Name`, <xref:System.Type.FullName%2A>, und <xref:System.Type.AssemblyQualifiedName%2A> Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="2da29-4287">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-4288">Ruft das Handle für den aktuellen <see cref="T:System.Type" /> ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4288">Gets the handle for the current <see cref="T:System.Type" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-4289">Das Handle für den aktuellen <see cref="T:System.Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4289">The handle for the current <see cref="T:System.Type" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-4290">`TypeHandle` Kapselt einen Zeiger auf eine interne Datenstruktur, die den Typ darstellt.</span><span class="sxs-lookup"><span data-stu-id="2da29-4290">`TypeHandle` encapsulates a pointer to an internal data structure that represents the type.</span></span> <span data-ttu-id="2da29-4291">Dieses Handle ist während der Prozesslebensdauer eindeutig.</span><span class="sxs-lookup"><span data-stu-id="2da29-4291">This handle is unique during the process lifetime.</span></span> <span data-ttu-id="2da29-4292">Das Handle ist gültig, nur in der Anwendungsdomäne, in der sie abgerufen wurden.</span><span class="sxs-lookup"><span data-stu-id="2da29-4292">The handle is valid only in the application domain in which it was obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="2da29-4293">Im folgenden Beispiel gibt das Handle des entsprechenden Typs zurück, und übergibt das Handle für eine Methode, die den Typ aus dem Handle abgerufen und angezeigt.</span><span class="sxs-lookup"><span data-stu-id="2da29-4293">The following example returns the handle of the corresponding type and passes the handle to a method that gets the type from the handle and displays it.</span></span>  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="2da29-4294">Diese Eigenschaft wird von .NET Compact Framework derzeit nicht unterstützt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4294">The .NET Compact Framework does not currently support this property.</span>
          </span>
        </exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-4295">Ruft den Initialisierer für den Typ ab.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4295">Gets the initializer for the type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-4296">Ein Objekt, das den Namen des Klassenkonstruktors von <see cref="T:System.Type" /> enthält.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4296">An object that contains the name of the class constructor for the <see cref="T:System.Type" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="2da29-4297">Klasseninitialisierer stehen auch über die <xref:System.Type.FindMembers%2A> -Methode, oder über Überladungen des der <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, und <xref:System.Type.GetConstructors%2A> Methoden, die <xref:System.Reflection.BindingFlags> als Parameter.</span><span class="sxs-lookup"><span data-stu-id="2da29-4297">Class initializers are also available through the <xref:System.Type.FindMembers%2A> method, or through overloads of the <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, and <xref:System.Type.GetConstructors%2A> methods that take <xref:System.Reflection.BindingFlags> as a parameter.</span></span>  
  
 <span data-ttu-id="2da29-4298">Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, gibt diese Eigenschaft `null`.</span><span class="sxs-lookup"><span data-stu-id="2da29-4298">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="2da29-4299">Gibt den von der Common Language Runtime bereitgestellten Typ an, der diesen Typ darstellt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4299">Indicates the type provided by the common language runtime that represents this type.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="2da29-4300">Der Systemtyp, der <see cref="T:System.Type" />zugrunde liegt.</span>
          <span class="sxs-lookup">
            <span data-stu-id="2da29-4300">The underlying system type for the <see cref="T:System.Type" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>