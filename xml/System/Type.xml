<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Type.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5a40925048dd06746d1e1cda2a76aa4ecaae1b916.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">a40925048dd06746d1e1cda2a76aa4ecaae1b916</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.</source>
          <target state="translated">Stellt Typdeklarationen dar: Klassentypen, Schnittstellentypen, Arraytypen, Werttypen, Enumerationstypen, Typparameter, generische Typdefinitionen und offen oder geschlossen konstruierte generische Typen.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><ph id="ph1">`Type`</ph> is the root of the <ph id="ph2">&lt;xref:System.Reflection&gt;</ph> functionality and is the primary way to access metadata.</source>
          <target state="translated"><ph id="ph1">`Type`</ph> Stellt den Stamm der <ph id="ph2">&lt;xref:System.Reflection&gt;</ph> Funktionalität und ist die primäre Methode Zugriff auf Metadaten.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Use the members of <ph id="ph1">&lt;xref:System.Type&gt;</ph> to get information about a type declaration, about the members of a type (such as the constructors, methods, fields, properties, and events of a class), as well as the module and the assembly in which the class is deployed.</source>
          <target state="translated">Verwenden Sie die Elemente der <ph id="ph1">&lt;xref:System.Type&gt;</ph> beim Abrufen von Informationen über die Typdeklaration, über die Elemente eines Typs (z. B. die Konstruktoren, Methoden, Felder, Eigenschaften und Ereignisse einer Klasse), sowie das Modul und die Assembly, in der die Klasse bereitgestellt wird.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>No permissions are required for code to use reflection to get information about types and their members, regardless of their access levels.</source>
          <target state="translated">Es sind keine Berechtigungen erforderlich, damit der Code die Reflexion zum Abrufen von Informationen zu Typen und Member, unabhängig von deren Zugriffsebenen verwenden.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>No permissions are required for code to use reflection to access public members, or other members whose access levels would make them visible during normal compilation.</source>
          <target state="translated">Es sind keine Berechtigungen erforderlich, damit Code Reflektion verwenden, um Zugriff auf öffentliche Member oder andere Elemente, deren Zugriffsebenen sie während der normalen Kompilierung sichtbar wäre.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>However, in order for your code to use reflection to access members that would normally be inaccessible, such as private or internal methods, or protected fields of a type your class does not inherit, your code must have <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</source>
          <target state="translated">Damit Ihr Code auch mithilfe der Reflektion, um auf Member zuzugreifen, die normalerweise nicht zugegriffen werden kann, z. B. private oder interne Methoden werden, oder geschützte Felder eines Typs kann die Klasse erbt nicht, der Code benötigen jedoch <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">Finden Sie unter <bpt id="p1">[</bpt>Sicherheitsüberlegungen für die Reflektion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><ph id="ph1">`Type`</ph> is an abstract base class that allows multiple implementations.</source>
          <target state="translated"><ph id="ph1">`Type`</ph> ist eine abstrakte Basisklasse, die mehrere Implementierungen ermöglicht.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The system will always provide the derived class <ph id="ph1">`RuntimeType`</ph>.</source>
          <target state="translated">Das System wird immer die abgeleitete Klasse bereitstellen <ph id="ph1">`RuntimeType`</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.</source>
          <target state="translated">In der Reflektion werden alle Klassen, die mit dem Wort Runtime ab nur einmal pro Objekt in der System- und Unterstützung Vergleichsvorgängen erstellt.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>In multithreading scenarios, do not lock <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects in order to synchronize access to <ph id="ph2">`static`</ph> data.</source>
          <target state="translated">Multithreading Szenarien nicht sperren <ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekte zum Synchronisieren des Zugriffs auf <ph id="ph2">`static`</ph> Daten.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Other code, over which you have no control, might also lock your class type.</source>
          <target state="translated">Anderer Code, über den Sie keine Kontrolle haben kann möglicherweise auch Ihr Klassentyp gesperrt.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>This might result in a deadlock.</source>
          <target state="translated">Dies kann zu einem Deadlock führen.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Instead, synchronize access to static data by locking a private <ph id="ph1">`static`</ph> object.</source>
          <target state="translated">Synchronisieren Sie den Zugriff auf statische Daten stattdessen durch Sperren eines privaten <ph id="ph1">`static`</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>A derived class can access protected members of the calling code's base classes.</source>
          <target state="translated">Eine abgeleitete Klasse kann geschützte Member der Basisklassen des aufrufenden Codes zugreifen.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Also, access is allowed to assembly members of the calling code's assembly.</source>
          <target state="translated">Darüber hinaus wird der Zugriff auf Assemblymember der Assembly des aufrufenden Codes zugelassen.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>As a rule, if you are allowed access in early-bound code, then you are also allowed access in late-bound code.</source>
          <target state="translated">Wenn es im Code früh gebundene Zugriff zulässig ist er in der Regel auch in spät gebundenem Code zulässig.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.</source>
          <target state="translated">Schnittstellen, die das Erweitern von anderen Schnittstellen erben nicht die Methoden, die in die erweiterten Schnittstellen definiert.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>In this section:</source>
          <target state="translated">In diesem Abschnitt</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><bpt id="p1">[</bpt>What types does a Type object represent?<ept id="p1">](#WhatTypes)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Welche Typen stellt ein Objekt vom Typ dar?<ept id="p1">](#WhatTypes)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><bpt id="p1">[</bpt>Retrieving a Type object<ept id="p1">](#Retrieve)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Ein Objekt vom Typ abrufen<ept id="p1">](#Retrieve)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><bpt id="p1">[</bpt>Comparing type objects for equality<ept id="p1">](#Equality)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Vergleichen von Objekten auf Gleichheit<ept id="p1">](#Equality)</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>What types does a Type object represent?</source>
          <target state="translated">Welche Typen stellt ein Objekt vom Typ dar?</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>This class is thread safe; multiple threads can concurrently read from an instance of this type.</source>
          <target state="translated">Diese Klasse ist threadsicher. eine Instanz dieses Typs können mehrere Threads gleichzeitig gelesen werden.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Type&gt;</ph> class can represent any of the following types:</source>
          <target state="translated">Eine Instanz von der <ph id="ph1">&lt;xref:System.Type&gt;</ph> -Klasse kann eines der folgenden Typen darstellen:</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Classes</source>
          <target state="translated">Klassen</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Value types</source>
          <target state="translated">Werttypen</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Arrays</source>
          <target state="translated">Arrays</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Interfaces</source>
          <target state="translated">Schnittstellen</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Enumerations</source>
          <target state="translated">Enumerationen</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Delegates</source>
          <target state="translated">Delegaten</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Constructed generic types and generic type definitions</source>
          <target state="translated">Konstruierte generische Typen und generische Typdefinitionen</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions</source>
          <target state="translated">Typargumenten Sie und Typparametern Sie konstruierte generische Typen, generische Typdefinitionen und generischen Methodendefinitionen</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Retrieving a Type object</source>
          <target state="translated">Ein Objekt vom Typ abrufen</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type&gt;</ph> object associated with a particular type can be obtained in the following ways:</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekt zugewiesen ist, mit einem bestimmten Typ kann auf folgende Weise abgerufen werden:</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The instance <ph id="ph1">&lt;xref:System.Object.GetType%2A?displayProperty=nameWithType&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents the type of an instance.</source>
          <target state="translated">Die Instanz <ph id="ph1">&lt;xref:System.Object.GetType%2A?displayProperty=nameWithType&gt;</ph> Methode gibt ein <ph id="ph2">&lt;xref:System.Type&gt;</ph> -Objekt, das den Typ einer Instanz darstellt.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Because all managed types derive from <ph id="ph1">&lt;xref:System.Object&gt;</ph>, the <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> method can be called on an instance of any type.</source>
          <target state="translated">Da alle verwaltete Typen abgeleitet sein <ph id="ph1">&lt;xref:System.Object&gt;</ph>die <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> für eine Instanz eines beliebigen Typs können Methoden aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Object.GetType%2A?displayProperty=nameWithType&gt;</ph> method to determine the runtime type of each object in an object array.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.Object.GetType%2A?displayProperty=nameWithType&gt;</ph> Methode, um den Laufzeittyp der einzelnen Objekte in einem Objektarray festzulegen.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The static <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> methods return a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents a type specified by its fully qualified name.</source>
          <target state="translated">Die statische <ph id="ph1">&lt;xref:System.Type.GetType%2A?displayProperty=nameWithType&gt;</ph> -Methoden zurückgeben einer <ph id="ph2">&lt;xref:System.Type&gt;</ph> -Objekt, das einen durch den vollqualifizierten Namen angegebenen Typ darstellt.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType&gt;</ph> methods return <ph id="ph4">`Type`</ph> objects that represent the types defined in a module.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType&gt;</ph>, und <ph id="ph3">&lt;xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType&gt;</ph> -Methoden zurückgeben <ph id="ph4">`Type`</ph> Objekte, die in einem Modul definierten Typen darstellen.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The first method can be used to obtain an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects for all the public and private types defined in a module.</source>
          <target state="translated">Die erste Methode verwendet werden kann, zum Abrufen eines Arrays von <ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekte für alle öffentlichen und privaten Typen, die in einem Modul definiert.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>(You can obtain an instance of <ph id="ph1">`Module`</ph> through the <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType&gt;</ph> method, or through the <ph id="ph4">&lt;xref:System.Type.Module%2A?displayProperty=nameWithType&gt;</ph> property.)</source>
          <target state="translated">(Sie erhalten eine Instanz von <ph id="ph1">`Module`</ph> über die <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType&gt;</ph> -Methode, oder über die <ph id="ph4">&lt;xref:System.Type.Module%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft.)</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Assembly?displayProperty=nameWithType&gt;</ph> object contains a number of methods to retrieve the classes defined in an assembly, including <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType&gt;</ph>, and <ph id="ph4">&lt;xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Assembly?displayProperty=nameWithType&gt;</ph> Objekt enthält eine Reihe von Methoden zum Abrufen der Klassen in einer Assembly, einschließlich definiert <ph id="ph2">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType&gt;</ph>, und <ph id="ph4">&lt;xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> method returns a filtered list of interface types supported by a type.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> Methode gibt eine gefilterte Liste von Schnittstellentypen, die von einem Typ unterstützt.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetElementType%2A&gt;</ph> method returns a <ph id="ph2">`Type`</ph> object that represents the element.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetElementType%2A&gt;</ph> Methode gibt ein <ph id="ph2">`Type`</ph> Objekt, das das Element darstellt.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetInterface%2A&gt;</ph> methods return <ph id="ph3">&lt;xref:System.Type&gt;</ph> objects representing the interface types supported by a type.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Type.GetInterface%2A&gt;</ph> -Methoden zurückgeben <ph id="ph3">&lt;xref:System.Type&gt;</ph> Objekte, die von einem Typ unterstützten Schnittstellentypen darstellt.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeArray%2A&gt;</ph> method returns an array of <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects representing the types specified by an arbitrary set of objects.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetTypeArray%2A&gt;</ph> Methode gibt ein Array von <ph id="ph2">&lt;xref:System.Type&gt;</ph> Objekten, die von einer beliebigen Gruppe von Objekten angegebenen Typen darstellen.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The objects are specified with an array of type <ph id="ph1">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated">Die Objekte sind mit einem Array des Typs angegeben <ph id="ph1">&lt;xref:System.Object&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> methods are provided for COM interoperability.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> Methoden für COM-Interoperabilität bereitgestellt werden.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>They return a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the type specified by a <ph id="ph2">`ProgID`</ph> or <ph id="ph3">`CLSID`</ph>.</source>
          <target state="translated">Diese Zurückgeben einer <ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekt, das den vom angegebenen Typ darstellt eine <ph id="ph2">`ProgID`</ph> oder <ph id="ph3">`CLSID`</ph>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromHandle%2A&gt;</ph> method is provided for interoperability.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetTypeFromHandle%2A&gt;</ph> Methode wird bereitgestellt, für die Interoperabilität.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>It returns a <ph id="ph1">`Type`</ph> object that represents the type specified by a class handle.</source>
          <target state="translated">Es gibt eine <ph id="ph1">`Type`</ph> Objekt, das durch ein Klassenhandle angegebenen Typ darstellt.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The C# <ph id="ph1">`typeof`</ph> operator, the C++ <ph id="ph2">`typeid`</ph> operator, and the Visual Basic <ph id="ph3">`GetType`</ph> operator obtain the <ph id="ph4">`Type`</ph> object for a type.</source>
          <target state="translated">Die C#- <ph id="ph1">`typeof`</ph> -Operator, der C++ <ph id="ph2">`typeid`</ph> Operator und die Visual Basic <ph id="ph3">`GetType`</ph> Operator erhalten die <ph id="ph4">`Type`</ph> Objekt für einen Typ.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method returns a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object representing a constructed generic type, which is an open constructed type if its <ph id="ph3">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph4">`true`</ph>, and a closed constructed type otherwise.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> Methode gibt ein <ph id="ph2">&lt;xref:System.Type&gt;</ph> Objekt einen konstruierten generischen Typ, der einen offenen konstruierten Typ ist, darstellt, seine <ph id="ph3">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> -Eigenschaft gibt <ph id="ph4">`true`</ph>, und einem geschlossenen konstruierten Typ andernfalls.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>A generic type can be instantiated only if it is closed.</source>
          <target state="translated">Ein generischer Typ kann instanziiert werden, nur dann, wenn er geschlossen wurde.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.MakePointerType%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph> methods return <ph id="ph4">&lt;xref:System.Type&gt;</ph> objects that represent, respectively, an array of a specified type, a pointer to a specified type, and the type of a reference parameter (<ph id="ph5">`ref`</ph> in C#, <ph id="ph6">`ByRef`</ph> in Visual Basic).</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.MakePointerType%2A&gt;</ph>, und <ph id="ph3">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph> -Methoden zurückgeben <ph id="ph4">&lt;xref:System.Type&gt;</ph> Objekte, die, die ein Array des angegebenen Typs, der einen Zeiger auf einen angegebenen Typ und den Typ des Verweisparameters darstellen (<ph id="ph5">`ref`</ph> in c# <ph id="ph6">`ByRef`</ph>in Visual Basic).</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>Comparing type objects for equality</source>
          <target state="translated">Vergleichen von Objekten auf Gleichheit</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>A <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents a type is unique; that is, two <ph id="ph2">&lt;xref:System.Type&gt;</ph> object references refer to the same object if and only if they represent the same type.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Type&gt;</ph> -Objekt, stellt ein Typ eindeutig ist, d. h. zwei <ph id="ph2">&lt;xref:System.Type&gt;</ph> Objektverweise auf dasselbe Objekt verweisen, wenn sie denselben Typ darstellen.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>This allows for comparison of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects using reference equality.</source>
          <target state="translated">Dies ermöglicht den Vergleich von <ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekte mithilfe von Verweisgleichheit.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The following example compares the <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects that represent a number of integer values to determine whether they are of the same type.</source>
          <target state="translated">Das folgende Beispiel vergleicht die <ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekte, die als von ganzzahligen Werten Zahl, um zu bestimmen, ob sie vom selben Typ sind.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The following  example shows a few representative features of <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Das folgende Beispiel zeigt einige repräsentative Features von <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The C# <ph id="ph1">`typeof`</ph> operator (<ph id="ph2">`GetType`</ph> operator in Visual Basic, <ph id="ph3">`typeid`</ph> operator in Visual C++) is used to get a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object representing <ph id="ph5">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated">Die C#- <ph id="ph1">`typeof`</ph> Operator (<ph id="ph2">`GetType`</ph> Operator in Visual Basic <ph id="ph3">`typeid`</ph> -Operator in Visual C++) Dient zum Abrufen einer <ph id="ph4">&lt;xref:System.Type&gt;</ph> Objekt darstellt <ph id="ph5">&lt;xref:System.String&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>From this <ph id="ph1">&lt;xref:System.Type&gt;</ph> object, the <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method is used to get a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> representing the <ph id="ph4">&lt;xref:System.String.Substring%2A&gt;</ph> overload that takes a starting location and a length.</source>
          <target state="translated">Aus diesem <ph id="ph1">&lt;xref:System.Type&gt;</ph> -Objekt, das <ph id="ph2">&lt;xref:System.Type.GetMethod%2A&gt;</ph> Methode zum Abrufen einer <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> darstellt der <ph id="ph4">&lt;xref:System.String.Substring%2A&gt;</ph> Überladung mit einer Anfangsposition und einer Länge.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>To identify the overload signature, the code example creates a temporary array containing two <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects representing <ph id="ph2">`int`</ph> (<ph id="ph3">`Integer`</ph> in Visual Basic).</source>
          <target state="translated">Um die Überladungssignatur zu identifizieren, das Codebeispiel erstellt ein temporäres Array mit zwei <ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekte darstellt <ph id="ph2">`int`</ph> (<ph id="ph3">`Integer`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>To be precise, the array contains two references to the instance of <ph id="ph1">&lt;xref:System.Type&gt;</ph> that represents <ph id="ph2">`int`</ph> in the current application domain.</source>
          <target state="translated">Um genau zu sein, das Array enthält zwei Verweise auf die Instanz von <ph id="ph1">&lt;xref:System.Type&gt;</ph> darstellt, die <ph id="ph2">`int`</ph> in der aktuellen Anwendungsdomäne.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>For any type, there is only one instance of <ph id="ph1">&lt;xref:System.Type&gt;</ph> per application domain.</source>
          <target state="translated">Für jeden Typ, es ist nur eine Instanz des <ph id="ph1">&lt;xref:System.Type&gt;</ph> pro Anwendungsdomäne.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>The code example uses the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> to invoke the <ph id="ph2">&lt;xref:System.String.Substring%2A&gt;</ph> method on the string "Hello, World!", and displays the result.</source>
          <target state="translated">Das Codebeispiel verwendet die <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> zum Aufrufen der <ph id="ph2">&lt;xref:System.String.Substring%2A&gt;</ph> -Methode mit der Zeichenfolge "Hello, World!", und das Ergebnis wird angezeigt.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>This type is thread safe.</source>
          <target state="translated">Dieser Typ ist threadsicher.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source>When you inherit from <ph id="ph1">&lt;see langword="Type" /&gt;</ph>, you must override the following members:</source>
          <target state="translated">Beim Erben von <ph id="ph1">&lt;see langword="Type" /&gt;</ph>, müssen Sie die folgenden Member überschreiben:</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Type">
          <source><ph id="ph1">&lt;see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /&gt;</ph> ,</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" /&gt;</ph> ,</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Type.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.#ctor">
          <source>This constructor is invoked by derived classes during the construction of type objects.</source>
          <target state="translated">Dieser Konstruktor wird von abgeleiteten Klassen aufgerufen, während der Erstellung von Type-Objekten.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" uid="P:System.Type.Assembly">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> in which the type is declared.</source>
          <target state="translated">Ruft die <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> ab, in der der Typ deklariert ist.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" uid="P:System.Type.Assembly">
          <source>For generic types, gets the <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> in which the generic type is defined.</source>
          <target state="translated">Ruft bei generischen Typen die <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> ab, in der der generische Typ definiert ist.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>An <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph> instance that describes the assembly containing the current type.</source>
          <target state="translated">Eine <ph id="ph1">&lt;see cref="T:System.Reflection.Assembly" /&gt;</ph>-Instanz, die die Assembly mit dem aktuellen Typ beschreibt.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>For generic types, the instance describes the assembly that contains the generic type definition, not the assembly that creates and uses a particular constructed type.</source>
          <target state="translated">Bei generischen Typen beschreibt die Instanz die Assembly, die die generische Typdefinition enthält, nicht die Assembly, in der ein bestimmter konstruierter Typ erstellt und verwendet wird.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a constructed generic type, this property returns the assembly that contains the generic type definition.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekt einen konstruierten generischen Typ darstellt, gibt diese Eigenschaft die Assembly, die generische Typdefinition enthält.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>For example, suppose you create an assembly named MyGenerics.dll that contains the generic type definition <ph id="ph1">`MyGenericStack&lt;T&gt;`</ph> (<ph id="ph2">`MyGenericStack(Of T)`</ph> in Visual Basic, <ph id="ph3">`generic&lt;T&gt; ref class MyGenericStack`</ph> in C++).</source>
          <target state="translated">Nehmen wir beispielsweise an, die Sie erstellen eine Assembly mit dem Namen MyGenerics.dll, die die generische Typdefinition enthält <ph id="ph1">`MyGenericStack&lt;T&gt;`</ph> (<ph id="ph2">`MyGenericStack(Of T)`</ph> in Visual Basic <ph id="ph3">`generic&lt;T&gt; ref class MyGenericStack`</ph> in C++).</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>If you create an instance of <ph id="ph1">`MyGenericStack&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericStack(Of Integer)`</ph> in Visual Basic) in another assembly, the <ph id="ph3">&lt;xref:System.Type.Assembly%2A&gt;</ph> property for the constructed type returns an <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> object that represents MyGenerics.dll.</source>
          <target state="translated">Bei der Erstellung einer Instanz von <ph id="ph1">`MyGenericStack&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericStack(Of Integer)`</ph> in Visual Basic) in einer anderen Assembly die <ph id="ph3">&lt;xref:System.Type.Assembly%2A&gt;</ph> -Eigenschaft für den konstruierten Typ gibt eine <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> -Objekt, das MyGenerics.dll darstellt.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>Similarly, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents an unassigned generic parameter <ph id="ph2">`T`</ph>, this property returns the assembly that contains the generic type that defines <ph id="ph3">`T`</ph>.</source>
          <target state="translated">Auf ähnliche Weise, wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekt stellt einen nicht zugewiesenen generischen Parameter <ph id="ph2">`T`</ph>, diese Eigenschaft gibt die Assembly, die den generischen Typ enthält, definiert <ph id="ph3">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>If the <ph id="ph1">&lt;xref:System.Type.Assembly%2A?displayProperty=nameWithType&gt;</ph> property is not available on a particular .NET implementation, such as .NET Core or the Universal Windows Platform, use the <ph id="ph2">&lt;xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType&gt;</ph> property instead.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Type.Assembly%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft nicht auf eine bestimmte Implementierung der .NET, z. B. .NET Core oder universellen Windows-Plattform verfügbar ist, verwenden Sie die <ph id="ph2">&lt;xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType&gt;</ph> Eigenschaft stattdessen.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>This property is read-only.</source>
          <target state="translated">Diese Eigenschaft ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Assembly">
          <source>The following example displays the assembly name associated with the class and the fully qualified name of the type.</source>
          <target state="translated">Das folgende Beispiel zeigt den Assemblynamen, die die Klasse zugeordnet und der vollqualifizierte Name des Typs.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="P:System.Type.AssemblyQualifiedName">
          <source>Gets the assembly-qualified name of the type, which includes the name of the assembly from which this <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object was loaded.</source>
          <target state="translated">Ruft den durch die Assembly qualifizierten Namen des Typs ab, der den Namen der Assembly enthält, aus der der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> geladen wurde.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>The assembly-qualified name of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, which includes the name of the assembly from which the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> was loaded, or <ph id="ph3">&lt;see langword="null" /&gt;</ph> if the current instance represents a generic type parameter.</source>
          <target state="translated">Der durch die Assembly qualifizierte Name des <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, der den Namen der Assembly enthält, aus der der <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> geladen wurde, oder <ph id="ph3">&lt;see langword="null" /&gt;</ph>, wenn die aktuelle Instanz einen generischen Typparameter darstellt.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>The assembly-qualified name of a type consists of the type name, including its namespace, followed by a comma, followed by the display name of the assembly.</source>
          <target state="translated">Die Assembly qualifizierte Name eines Typs besteht aus den Typnamen, einschließlich des Namespaces, gefolgt von einem Komma, gefolgt von den Anzeigenamen der Assembly.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>The display name of an assembly is obtained using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Der Anzeigename einer Assembly abgerufen wird, mit der <ph id="ph1">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">In .NET Framework, Version 2.0 Prozessorarchitektur Assemblyidentität hinzugefügt und kann als Teil der Assembly-Zeichenfolgen angegeben werden.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>For example, "ProcessorArchitecture=msil".</source>
          <target state="translated">Z. B. "ProcessorArchitecture = Msil".</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.</source>
          <target state="translated">Ist jedoch nicht in die zurückgegebene Zeichenfolge enthalten die <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> Eigenschaft, aus Gründen der Kompatibilität.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Siehe <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>All compilers that support the common language runtime emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</source>
          <target state="translated">Alle Compiler, die die common Language Runtime unterstützen, geben den einfachen Namen einer geschachtelten Klasse und Reflektion erstellt einen ergänzten Namen bei einer Abfrage in Übereinstimmung mit den folgenden Konventionen.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Delimiter</source>
          <target state="translated">Trennzeichen</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Meaning</source>
          <target state="translated">Bedeutung</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Backslash (<ph id="ph1">\\</ph>)</source>
          <target state="translated">Umgekehrter Schrägstrich (<ph id="ph1">\\</ph>)</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Escape character.</source>
          <target state="translated">Escape-Zeichen.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Comma (,)</source>
          <target state="translated">Komma (,)</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Precedes the Assembly name.</source>
          <target state="translated">Ist der Name der Assembly vorangestellt.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Plus sign (+)</source>
          <target state="translated">Pluszeichen (+)</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Precedes a nested class.</source>
          <target state="translated">Ist eine geschachtelte Klasse vorangestellt.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Period (.)</source>
          <target state="translated">Punkt (.)</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Denotes namespace identifiers.</source>
          <target state="translated">Gibt die Namespacebezeichner.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Brackets ([])</source>
          <target state="translated">Klammern ([])</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>After a type name, denotes an array of that type.</source>
          <target state="translated">Nach einem Typnamen gibt Sie ein Array dieses Typs an.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>For a generic type, encloses the generic type argument list.</source>
          <target state="translated">Für einen generischen Typ umschließt die Liste der generischen Typargumente.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Within a type argument list, encloses an assembly-qualified type.</source>
          <target state="translated">In einer Liste der Typargumente schließt eine Assembly qualifizierten Typnamen.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>For example, the assembly-qualified name for a class might look like this:</source>
          <target state="translated">Beispielsweise kann die Assembly qualifizierte Name für eine Klasse wie folgt aussehen:</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (<ph id="ph1">\\</ph>) to prevent it from being interpreted as a nesting separator.</source>
          <target state="translated">Wenn der Namespace enthalten ein Pluszeichen (+), z. B. TopNamespace.Sub, würde das Pluszeichen (+) ein Escapezeichen vorangestellt werden (<ph id="ph1">\\</ph>) zu verhindern, dass er als schachteln Trennzeichen interpretiert wird.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Reflection would emit this string as follows:</source>
          <target state="translated">Diese Zeichenfolge würde wie folgt Reflektionsausgabe:</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</source>
          <target state="translated">Ein "++" wird "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", und ein "<ph id="ph4">\\</ph>"wird"<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>This qualified name can be persisted and later used to load the <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Dieser qualifizierte Name kann beibehalten und später zum Laden der <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>To search for and load a <ph id="ph1">&lt;xref:System.Type&gt;</ph>, use <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.</source>
          <target state="translated">Suchen und Laden einer <ph id="ph1">&lt;xref:System.Type&gt;</ph>, verwenden Sie <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> entweder mit dem Typ oder einen Namen geben nur mit der Assembly qualifizierten Typnamen.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> mit dem Namen nur sieht für den <ph id="ph2">&lt;xref:System.Type&gt;</ph> in der Assembly des Aufrufers, und klicken Sie dann in der System-Assembly.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in any assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> mit der Assembly qualifizierten Typnamen für sieht die <ph id="ph2">&lt;xref:System.Type&gt;</ph> in jeder beliebigen Assembly.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</source>
          <target state="translated">Geben Sie die Namen eventuell nachfolgende Zeichen, die zusätzliche über den Typ Informationen, z. B., ob der Typ ein Verweistyp, ein Zeigertyp oder ein Arraytyp ist.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>To retrieve the type name without these trailing characters, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, where <ph id="ph2">`t`</ph> is the type.</source>
          <target state="translated">Verwenden Sie zum Abrufen der Typname ohne diese nachfolgenden Zeichen <ph id="ph1">`t.GetElementType().ToString()`</ph>, wobei <ph id="ph2">`t`</ph> ist der Typ.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Spaces are relevant in all type name components except the assembly name.</source>
          <target state="translated">Leerzeichen sind in allen Komponenten von Typnamen mit Ausnahme der Assemblyname relevant.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</source>
          <target state="translated">In der Assemblyname Leerzeichen vor dem Trennzeichen "," relevant sind, aber nach dem Trennzeichen "," Leerzeichen werden ignoriert.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>Generic arguments of generic types are themselves qualified by assembly name.</source>
          <target state="translated">Generische Argumente von generischen Typen werden selbst durch Name der Assembly gekennzeichnet wird.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>For example, in the assembly-qualified type name for <ph id="ph1">`MyGenericClass&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericClass(Of Integer)`</ph> in Visual Basic), <ph id="ph3">`int`</ph> is expanded to the assembly-qualified type name for <ph id="ph4">&lt;xref:System.Int32&gt;</ph>.</source>
          <target state="translated">Beispielsweise ist in der Assembly qualifizierte Typname für <ph id="ph1">`MyGenericClass&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericClass(Of Integer)`</ph> in Visual Basic), <ph id="ph3">`int`</ph> wird erweitert, um die Assembly qualifizierten Typnamen für <ph id="ph4">&lt;xref:System.Int32&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a generic parameter, this property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> -Objekt einen generischen Parameter darstellt, gibt diese Eigenschaft zurück <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>The following example displays the assembly name associated with the class and the fully qualified name of the type.</source>
          <target state="translated">Das folgende Beispiel zeigt den Assemblynamen, die die Klasse zugeordnet und der vollqualifizierte Name des Typs.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.AssemblyQualifiedName">
          <source>The following example compares the strings returned by the <ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph> method and the <ph id="ph2">`Name`</ph>, <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> properties.</source>
          <target state="translated">Das folgende Beispiel vergleicht die zurückgegebene Zeichenfolgen die <ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph> Methode und die <ph id="ph2">`Name`</ph>, <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>, und <ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> Eigenschaften.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="P:System.Type.Attributes">
          <source>Gets the attributes associated with the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft die dem <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> zugeordneten Attribute ab.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.TypeAttributes" /&gt;</ph> object representing the attribute set of the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, unless the <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> represents a generic type parameter, in which case the value is unspecified.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Reflection.TypeAttributes" /&gt;</ph>-Objekt, das die Attributgruppe von <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> darstellt. Falls <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> jedoch einen generischen Typparameter darstellt, ist der Wert nicht festgelegt.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>Some members of the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeration are masks that represent a group of values.</source>
          <target state="translated">Einige Member der <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> Enumeration sind Masken, die eine Gruppe von Werten darstellen.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>Each group includes one member whose underlying value is zero.</source>
          <target state="translated">Jede Gruppe enthält ein Element, dessen zugrunde liegenden Wert 0 (null) ist.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>For example, the underlying value of the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType&gt;</ph> member in the <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> group is zero, as is the <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph> member in the <ph id="ph4">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> group.</source>
          <target state="translated">Z. B. den zugrunde liegenden Wert von der <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType&gt;</ph> Element in der <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> Gruppe ist 0 (null), ist die <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph> Element in der <ph id="ph4">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> Gruppe.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>Because of this, you must use the mask before testing for those values.</source>
          <target state="translated">Aus diesem Grund müssen Sie die Maske verwenden, bevor Sie für diese Werte testen.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>The example provides an illustration.</source>
          <target state="translated">Dies wird im Beispiel veranschaulicht.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>For most purposes, properties like <ph id="ph1">&lt;xref:System.Type.IsClass%2A&gt;</ph>,<ph id="ph2">&lt;xref:System.Type.IsAutoLayout%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsSpecialName%2A&gt;</ph> are easier to use than type attributes.</source>
          <target state="translated">Für die meisten Zwecke Eigenschaften wie <ph id="ph1">&lt;xref:System.Type.IsClass%2A&gt;</ph>,<ph id="ph2">&lt;xref:System.Type.IsAutoLayout%2A&gt;</ph>, und <ph id="ph3">&lt;xref:System.Type.IsSpecialName%2A&gt;</ph> sind einfacher zu verwenden als Attribute des Typs.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns the attributes of the generic type definition.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein konstruierter generischer Typ, diese Eigenschaft gibt die Attribute der generischen Typdefinition.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>For example, the attributes returned for <ph id="ph1">`MyGenericClass&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericClass(Of Integer)`</ph> in Visual Basic) are the attributes of <ph id="ph3">`MyGenericClass&lt;T&gt;`</ph> (<ph id="ph4">`MyGenericClass(Of T)`</ph> in Visual Basic).</source>
          <target state="translated">Z. B. die Attribute, die für die zurückgegebenen <ph id="ph1">`MyGenericClass&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericClass(Of Integer)`</ph> in Visual Basic) sind die Attribute des <ph id="ph3">`MyGenericClass&lt;T&gt;`</ph> (<ph id="ph4">`MyGenericClass(Of T)`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type parameter — that is, if the <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id="ph3">`true`</ph> — the <ph id="ph4">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> value returned by this property is unspecified.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen generischen Typparameter darstellt – d. h. wenn die <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> -Eigenschaft gibt <ph id="ph3">`true`</ph> – die <ph id="ph4">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> von dieser Eigenschaft zurückgegebene Wert ist nicht angegeben.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Attributes">
          <source>The following example usesthe <ph id="ph1">&lt;xref:System.Type.Attributes%2A&gt;</ph> property.</source>
          <target state="translated">Das folgende Beispiel verwenden bewirkt, dassdie <ph id="ph1">&lt;xref:System.Type.Attributes%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="P:System.Type.BaseType">
          <source>Gets the type from which the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> directly inherits.</source>
          <target state="translated">Ruft den Typ ab, von dem der aktuelle <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> direkt vererbt wird.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> from which the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> directly inherits, or <ph id="ph3">&lt;see langword="null" /&gt;</ph> if the current <ph id="ph4">&lt;see langword="Type" /&gt;</ph> represents the <ph id="ph5">&lt;see cref="T:System.Object" /&gt;</ph> class or an interface.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, von dem der aktuelle <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> direkt erbt, oder <ph id="ph3">&lt;see langword="null" /&gt;</ph>, wenn der aktuelle <ph id="ph4">&lt;see langword="Type" /&gt;</ph> die <ph id="ph5">&lt;see cref="T:System.Object" /&gt;</ph>-Klasse oder eine Schnittstelle darstellt.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The base type is the type from which the current type directly inherits.</source>
          <target state="translated">Der Basistyp ist der Typ, von dem der aktuelle Typ direkt erbt.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source><ph id="ph1">&lt;xref:System.Object&gt;</ph> is the only type that does not have a base type, therefore <ph id="ph2">`null`</ph> is returned as the base type of <ph id="ph3">&lt;xref:System.Object&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object&gt;</ph> ist die einzige Art, die aus diesem Grund keinen Basistyp <ph id="ph2">`null`</ph> wird zurückgegeben, als der Basistyp des <ph id="ph3">&lt;xref:System.Object&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>Interfaces inherit from zero or more base interfaces; therefore, this property returns <ph id="ph1">`null`</ph> if the <ph id="ph2">`Type`</ph> object represents an interface.</source>
          <target state="translated">Schnittstellen werden von keinem oder mehreren Basisschnittstellen erben. Diese Eigenschaft daher gibt <ph id="ph1">`null`</ph> Wenn die <ph id="ph2">`Type`</ph> Objekt stellt eine Schnittstelle dar.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The base interfaces can be determined with <ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph>.</source>
          <target state="translated">Die Basisschnittstellen können bestimmt werden, mit <ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, the base type reflects the generic arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierter generischen Typ darstellt, die der Basistyp Version stellt die generische Argumente.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>For example, consider the following declarations:</source>
          <target state="translated">Betrachten Sie beispielsweise die folgenden Deklarationen:</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>For the constructed type <ph id="ph1">`C&lt;int&gt;`</ph> (<ph id="ph2">`C(Of Integer)`</ph> in Visual Basic), the <ph id="ph3">&lt;xref:System.Type.BaseType%2A&gt;</ph> property returns <ph id="ph4">`B&lt;int&gt;`</ph>.</source>
          <target state="translated">Für den konstruierten Typ <ph id="ph1">`C&lt;int&gt;`</ph> (<ph id="ph2">`C(Of Integer)`</ph> in Visual Basic), wird die <ph id="ph3">&lt;xref:System.Type.BaseType%2A&gt;</ph> -Eigenschaft gibt <ph id="ph4">`B&lt;int&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type definition, <ph id="ph2">&lt;xref:System.Type.BaseType%2A&gt;</ph> returns the class constraint, that is, the class the type parameter must inherit.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen Typparameter einer generischen Typdefinition <ph id="ph2">&lt;xref:System.Type.BaseType%2A&gt;</ph> gibt die Class-Einschränkung, d. h. die Klasse, die die Typparameter erben muss.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>If there is no class constraint, <ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph> returns <ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Es ist keine klasseneinschränkung <ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph> gibt <ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>This property is read-only.</source>
          <target state="translated">Diese Eigenschaft ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The following example demonstrates using the <ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph> property.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung der <ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The following example uses recursion to list the complete inheritance hierarchy of each class found in an assembly.</source>
          <target state="translated">Im folgenden Beispiel wird die Rekursion zum Auflisten der vollständige Vererbungshierarchie jede Klasse in einer Assembly gefunden.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.BaseType">
          <source>The example defines a class named <ph id="ph1">`C`</ph> that derives from a class named <ph id="ph2">`B`</ph>, which, in turn, derives from a class named <ph id="ph3">`A`</ph>.</source>
          <target state="translated">Im Beispiel definiert eine Klasse namens <ph id="ph1">`C`</ph> abgeleitet, die eine Klasse namens <ph id="ph2">`B`</ph>, das wiederum leitet sich von einer Klasse mit dem Namen <ph id="ph3">`A`</ph>.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="P:System.Type.ContainsGenericParameters">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object has type parameters that have not been replaced by specific types.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob das aktuelle <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt über Typparameter verfügt, die nicht durch bestimmte Typen ersetzt wurden.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object is itself a generic type parameter or has type parameters for which specific types have not been supplied; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn das <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt selbst ein generischer Parametertyp ist oder über Typparameter verfügt, für die keine bestimmten Typen angegeben wurden, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>In order to create an instance of a type, there must be no generic type definitions or open constructed types in the type arguments of the type itself, in any enclosing generic types, or in any elements of the type.</source>
          <target state="translated">Um eine Instanz eines Typs zu erstellen, muss keine generischen Typdefinitionen oder offen konstruierte Typen in den Typargumenten des Typs selbst und alle einschließenden generischen Typen und Elemente des Typs vorhanden sein.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>Another way of saying this is that when examined recursively, the type must contain no generic type parameters.</source>
          <target state="translated">Anders ausgedrückt: Dies ist bei überprüft rekursiv, der Typ darf keine generische Typparameter.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>Since types can be arbitrarily complex, making this determination is difficult.</source>
          <target state="translated">Da Typen beliebig komplex sein können, ist dieser Feststellung schwierig.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>For convenience and to reduce the chance of error, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property provides a standard way to distinguish between closed constructed types, which can be instantiated, and open constructed types, which cannot.</source>
          <target state="translated">Der Einfachheit halber und reduziert die Wahrscheinlichkeit des Fehlers, der <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> Eigenschaft bietet eine standardmöglichkeit zum unterscheiden von geschlossener konstruierter Typen, die instanziiert werden kann, und offen konstruierte Typen, die nicht.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>If the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>, the type cannot be instantiated.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> -Eigenschaft gibt <ph id="ph2">`true`</ph>, der Typ kann nicht instanziiert werden.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>The <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property searches recursively for type parameters.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> -Eigenschaft sucht rekursiv für Typparameter angegeben.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>For example, it returns <ph id="ph1">`true`</ph> for an array whose elements are type <ph id="ph2">`A&lt;T&gt;`</ph> (<ph id="ph3">`A(Of T)`</ph> in Visual Basic), even though the array is not itself generic.</source>
          <target state="translated">Es gibt z. B. <ph id="ph1">`true`</ph> für ein Array, dessen Elemente sind <ph id="ph2">`A&lt;T&gt;`</ph> (<ph id="ph3">`A(Of T)`</ph> in Visual Basic), auch wenn das Array selbst nicht generisch ist.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>Contrast this with the behavior of the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property, which returns <ph id="ph2">`false`</ph> for arrays.</source>
          <target state="translated">Vergleichen Sie dies mit dem Verhalten von der <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> Eigenschaft, die zurückgibt <ph id="ph2">`false`</ph> für Arrays.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>For a set of example classes and a table showing the values of the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property, see <ph id="ph2">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</source>
          <target state="translated">Für eine Gruppe von Beispielklassen und eine Tabelle, die Werte der <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> Eigenschaft finden Sie unter <ph id="ph2">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>The following example defines a generic class with two type parameters and then defines a second generic class that derives from the first class.</source>
          <target state="translated">Im folgenden Beispiel wird eine generische Klasse mit zwei Typparametern und definiert dann eine zweite generische Klasse, die von der ersten Klasse abgeleitet ist.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>The derived class's base class has two type arguments: the first is <ph id="ph1">&lt;xref:System.Int32&gt;</ph> and the second is a type parameter of the derived type.</source>
          <target state="translated">Die Basis der abgeleiteten Klasse verfügt über zwei Typargumente: Erstens <ph id="ph1">&lt;xref:System.Int32&gt;</ph> und das zweite ist ein Typparameter des abgeleiteten Typs.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ContainsGenericParameters">
          <source>The example displays information about these generic classes, including the positions reported by the <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property.</source>
          <target state="translated">Das Beispiel zeigt Informationen zu diesen generischen Klassen, von gemeldeten einschließlich die Positionen der <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="P:System.Type.DeclaringMethod">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> that represents the declaring method, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> represents a type parameter of a generic method.</source>
          <target state="translated">Ruft eine <ph id="ph1">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> ab, die die deklarierende Methode darstellt, wenn der aktuelle <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> einen Typparameter einer generischen Methode darstellt.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>If the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a type parameter of a generic method, a <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph> that represents declaring method; otherwise, <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Wenn der aktuelle <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> einen Typparameter einer generischen Methode darstellt, eine <ph id="ph2">&lt;see cref="T:System.Reflection.MethodBase" /&gt;</ph>, die die deklarierende Methode darstellt, andernfalls <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>The declaring method is a generic method definition.</source>
          <target state="translated">Die deklarierende Methode ist eine generische Methodendefinition.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>That is, if <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> does not return <ph id="ph2">`null`</ph>, then <ph id="ph3">`DeclaringMethod.IsGenericMethodDefinition`</ph> returns <ph id="ph4">`true`</ph>.</source>
          <target state="translated">D. h. wenn <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> keinen zurückgibt <ph id="ph2">`null`</ph>, klicken Sie dann <ph id="ph3">`DeclaringMethod.IsGenericMethodDefinition`</ph> gibt <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>The <ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> Eigenschaften zu identifizieren, die generische Typdefinition oder generische Methodendefinition, die in der der generische Typparameter ursprünglich definiert wurde:</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, that <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> represents a generic method definition, and the current <ph id="ph4">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic method definition.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> Eigenschaft gibt eine <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> stellt eine generische Methodendefinition und der aktuelle <ph id="ph4">&lt;xref:System.Type&gt;</ph> -Objekt einen Typparameter der generischen Methodendefinition darstellt.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns <ph id="ph2">`null`</ph>, then the <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property always returns a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object representing a generic type definition, and the current <ph id="ph5">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic type definition.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> -Eigenschaft gibt <ph id="ph2">`null`</ph>, und klicken Sie dann die <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> -Eigenschaft gibt immer eine <ph id="ph4">&lt;xref:System.Type&gt;</ph> Objekt, das eine generische Typdefinition ist, und das aktuelle darstellt <ph id="ph5">&lt;xref:System.Type&gt;</ph> Objekt einen Typparameter eines generischen Typs darstellt Definition.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>Getting the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property on a type whose <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property is <ph id="ph3">`false`</ph> throws an <ph id="ph4">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">Abrufen der <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> Eigenschaft für einen Typ, dessen <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> Eigenschaft <ph id="ph3">`false`</ph> löst eine <ph id="ph4">&lt;xref:System.InvalidOperationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> that is returned by the <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property is either a <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> in the case of a generic method, or a <ph id="ph4">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> in the case of a generic constructor.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> der zurückgegeben wird, indem die <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> Eigenschaft ist entweder eine <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> im Fall einer generischen Methode oder eine <ph id="ph4">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> bei einem generischen Konstruktor.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>In the .NET Framework version 2.0, generic constructors are not supported.</source>
          <target state="translated">In .NET Framework, Version 2.0 sind generische Konstruktoren nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>The following code example defines a class that has a generic method, assigns a type argument to the method, and invokes the resulting constructed generic method.</source>
          <target state="translated">Das folgende Codebeispiel definiert eine Klasse, die eine generische Methode und weist ein Type-Argument an die Methode aufruft, die sich ergebende konstruierte generische Methode.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>It also displays information about the generic method definition and the constructed method.</source>
          <target state="translated">Es zeigt auch Informationen zur Definition der generischen Methode und die konstruierte Methode.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringMethod">
          <source>When displaying information about the type parameters of the generic method definition, in the <ph id="ph1">`DisplayGenericMethodInfo`</ph> method, the example code shows the value of the <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property for the method's generic type parameter.</source>
          <target state="translated">Beim Anzeigen von Informationen über die Typparameter der generischen Methodendefinition, in der <ph id="ph1">`DisplayGenericMethodInfo`</ph> -Methode der Beispielcode zeigt den Wert von der <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> -Eigenschaft für generische Typparameter der Methode.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="P:System.Type.DeclaringType">
          <source>Gets the type that declares the current nested type or generic type parameter.</source>
          <target state="translated">Ruft den Typ ab, der den aktuellen geschachtelten oder generischen Typparameter deklariert.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the enclosing type, if the current type is a nested type; or the generic type definition, if the current type is a type parameter of a generic type; or the type that declares the generic method, if the current type is a type parameter of a generic method; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt, das den einschließenden Typ darstellt, wenn es sich bei dem aktuellen Typ um einen geschachtelten Typ handelt. Die generische Typdefinition, wenn es sich bei dem aktuellen Typ um einen Typparameter eines generischen Typs handelt. Der Typ, der die generische Methode deklariert, wenn es sich bei dem aktuellen Typ um einen Typparameter einer generischen Methode handelt. Andernfalls <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a type parameter of a generic type, this property returns the generic type definition.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> -Objekt einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft die generische Typdefinition.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a type parameter of a generic method, this property returns the type that contains the generic method definition.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> -Objekt einen Typparameter einer generischen Methode darstellt, gibt diese Eigenschaft den Typ, die generischen Methodendefinition enthält.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the type is generic, the generic type definition is returned.</source>
          <target state="translated">Wenn der Typ generisch ist, wird die generische Typdefinition zurückgegeben.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>That is, the following code returns the generic type definition of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> generic class, which contains the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.ConvertAll%2A&gt;</ph> generic method:</source>
          <target state="translated">Der folgende Code gibt also die generische Typdefinition von der <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> generische Klasse, die enthält die <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.ConvertAll%2A&gt;</ph> generische Methode:</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, the <ph id="ph2">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, die <ph id="ph2">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> und <ph id="ph3">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> Eigenschaften zu identifizieren, die generische Typdefinition oder generische Methodendefinition, in dem der generische Typparameter, ursprünglich definiert wurde:</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, that <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> represents a generic method definition, and the current <ph id="ph4">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic method definition.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> Eigenschaft gibt eine <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> stellt eine generische Methodendefinition und der aktuelle <ph id="ph4">&lt;xref:System.Type&gt;</ph> -Objekt einen Typparameter der generischen Methodendefinition darstellt.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns <ph id="ph2">`null`</ph>, then the <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property always returns a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object representing a generic type definition, and the current <ph id="ph5">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic type definition.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> -Eigenschaft gibt <ph id="ph2">`null`</ph>, und klicken Sie dann die <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> -Eigenschaft gibt immer eine <ph id="ph4">&lt;xref:System.Type&gt;</ph> Objekt, das eine generische Typdefinition ist, und das aktuelle darstellt <ph id="ph5">&lt;xref:System.Type&gt;</ph> Objekt einen Typparameter eines generischen Typs darstellt Definition.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>Getting the <ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property on a type whose <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property is <ph id="ph3">`false`</ph> throws an <ph id="ph4">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
          <target state="translated">Abrufen der <ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> Eigenschaft für einen Typ, dessen <ph id="ph2">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> Eigenschaft <ph id="ph3">`false`</ph> löst eine <ph id="ph4">&lt;xref:System.InvalidOperationException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DeclaringType">
          <source>This example displays the declaring type of a method in a derived class.</source>
          <target state="translated">In diesem Beispiel wird den deklarierenden Typ von einer Methode in einer abgeleiteten Klasse angezeigt.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="P:System.Type.DefaultBinder">
          <source>Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph>.</source>
          <target state="translated">Ruft einen Verweis auf den Standardbinder ab, der interne Regeln für die Auswahl der passenden Member implementiert, die von <ph id="ph1">&lt;see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /&gt;</ph> aufgerufen werden sollen.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>A reference to the default binder used by the system.</source>
          <target state="translated">Ein Verweis auf den vom System verwendeten Standardbinder.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>The default binder provided with the common language runtime is applicable in all but the most specialized circumstances.</source>
          <target state="translated">Der Standardbinder bereitgestellt, mit der common Language Runtime ist außer den speziellen Umständen anwendbar.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <ph id="ph1">&lt;xref:System.Reflection.Binder&gt;</ph> class and pass an instance of that type using the <ph id="ph2">`binder`</ph> parameter of one of the <ph id="ph3">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> overloads.</source>
          <target state="translated">Wenn Sie benötigen einen Binder, mit denen folgt Regeln, die von den von der angegebenen Standardbinder unterscheiden definiert einen abgeleiteten Typ aus der <ph id="ph1">&lt;xref:System.Reflection.Binder&gt;</ph> Klasse, und übergeben Sie eine Instanz dieses Typs unter Verwendung der <ph id="ph2">`binder`</ph> Parameter eines der <ph id="ph3">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> Überladungen.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Reflection models the accessibility rules of the common type system.</source>
          <target state="translated">Reflektion modelliert die Zugriffsregeln des allgemeinen Typsystems.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>For example, if the caller is in the same assembly, the caller does not need special permissions for internal members.</source>
          <target state="translated">Z. B. wenn der Aufrufer in der gleichen Assembly befindet, benötigt der Aufrufer keine besondere Berechtigungen für interne Member.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Otherwise, the caller needs <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</source>
          <target state="translated">Andernfalls muss der Aufrufer <ph id="ph1">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>This is consistent with lookup of members that are protected, private, and so on.</source>
          <target state="translated">Dies ist konsistent mit der Suche nach Membern, die geschützt werden, private und usw. ein.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>The general principle is that <ph id="ph1">&lt;xref:System.Reflection.Binder.ChangeType%2A&gt;</ph> should perform only widening conversions, which never lose data.</source>
          <target state="translated">Im Allgemeinen gilt <ph id="ph1">&lt;xref:System.Reflection.Binder.ChangeType%2A&gt;</ph> sollten ausführen, nur erweiternde Konvertierungen, die keine Daten verloren gehen.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>An example of a widening conversion is converting a value that is a 32-bit signed integer to a value that is a 64-bit signed integer.</source>
          <target state="translated">Ein Beispiel für eine erweiternde Konvertierung ist eine Umwandlung einer 32-Bit-Ganzzahl mit Vorzeichen in einen Wert einer 64-Bit-Ganzzahl mit Vorzeichen.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>This is distinguished from a narrowing conversion, which may lose data.</source>
          <target state="translated">Dies ist von der eine einschränkende Konvertierung unterschieden, die Daten verloren gehen können.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>An example of a narrowing conversion is converting a 64-bit signed integer to a 32-bit signed integer.</source>
          <target state="translated">Ein Beispiel für eine einschränkende Konvertierung ist eine 64-Bit-Ganzzahl mit Vorzeichen in eine 32-Bit-Ganzzahl mit Vorzeichen konvertiert werden.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>The following table lists the conversions supported by the default binder.</source>
          <target state="translated">Die folgende Tabelle enthält die Konvertierungen, die von der Standardbinder unterstützt.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Source Type</source>
          <target state="translated">Quelltyp</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Target Type</source>
          <target state="translated">Zieltyp</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Any type</source>
          <target state="translated">Beliebiger Typ</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Its base type.</source>
          <target state="translated">Der Basistyp.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Any type</source>
          <target state="translated">Beliebiger Typ</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>The interface it implements.</source>
          <target state="translated">Die Schnittstelle implementiert.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Char</source>
          <target state="translated">Char</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Unt16, UInt32, Int32, UInt64, Int64, Single, Double</source>
          <target state="translated">Unt16, UInt32, Int32, UInt64, Int64, Single, Double</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Byte</source>
          <target state="translated">Byte</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</source>
          <target state="translated">Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>SByte</source>
          <target state="translated">SByte</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int16, Int32, Int64, Single, Double</source>
          <target state="translated">Int16, Int32, Int64, Single, Double</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>UInt16</source>
          <target state="translated">UInt16</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>UInt32, Int32, UInt64, Int64, Single, Double</source>
          <target state="translated">UInt32, Int32, UInt64, Int64, Single, Double</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int16</source>
          <target state="translated">Int16</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int32, Int64, Single, Double</source>
          <target state="translated">Int32, Int64, Single, Double</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>UInt32</source>
          <target state="translated">UInt32</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>UInt64, Int64, Single, Double</source>
          <target state="translated">UInt64, Int64, Single, Double</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int32</source>
          <target state="translated">Int32</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int64, Single, Double</source>
          <target state="translated">Int64, Single, Double</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>UInt64</source>
          <target state="translated">UInt64</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Single, Double</source>
          <target state="translated">Single, Double</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Int64</source>
          <target state="translated">Int64</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Single, Double</source>
          <target state="translated">Single, Double</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Single</source>
          <target state="translated">Single</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Double</source>
          <target state="translated">Double</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>Non-reference</source>
          <target state="translated">Ohne Verweis</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>By-reference.</source>
          <target state="translated">Per-Verweis.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.DefaultBinder">
          <source>The following example gets the default binder from the <ph id="ph1">`DefaultBinder`</ph> property, and invokes a member of MyClass by passing the <ph id="ph2">`DefaultBinder`</ph> value as a parameter to <ph id="ph3">&lt;xref:System.Type.InvokeMember%2A&gt;</ph>.</source>
          <target state="translated">Im folgenden Beispiel wird den Standardbinder aus der <ph id="ph1">`DefaultBinder`</ph> -Eigenschaft, und ruft Sie ein Mitglied MyClass durch Übergeben der <ph id="ph2">`DefaultBinder`</ph> Wert als Parameter an <ph id="ph3">&lt;xref:System.Type.InvokeMember%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" uid="F:System.Type.Delimiter">
          <source>Separates names in the namespace of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Trennt Namen im Namespace des <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" uid="F:System.Type.Delimiter">
          <source>This field is read-only.</source>
          <target state="translated">Dieses Feld ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="F:System.Type.EmptyTypes">
          <source>Represents an empty array of type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Stellt ein leeres Array vom <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Typ dar.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="F:System.Type.EmptyTypes">
          <source>This field is read-only.</source>
          <target state="translated">Dieses Feld ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.EmptyTypes">
          <source>The following code example shows the <ph id="ph1">`EmptyTypes`</ph> field used in one of the <ph id="ph2">`GetConstructor`</ph> methods to get a constructor that takes no parameters.</source>
          <target state="translated">Das folgende Codebeispiel zeigt die <ph id="ph1">`EmptyTypes`</ph> Feld verwendet wird, in einem von der <ph id="ph2">`GetConstructor`</ph> Methoden zum Abrufen eines Konstruktors, der keine Parameter akzeptiert.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Determines if the underlying system type of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is the same as the underlying system type of the specified <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> or <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Bestimmt, ob der zugrunde liegende Systemtyp des aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> mit dem zugrunde liegende Systemtyp des angegebenen <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> oder <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> übereinstimmt.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source>The object whose underlying system type is to be compared with the underlying system type of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Das Objekt, dessen zugrunde liegender Systemtyp mit dem zugrunde liegenden Systemtyp des aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> verglichen werden soll.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source>For the comparison to succeed, <bpt id="p1">&lt;c&gt;</bpt>o<ept id="p1">&lt;/c&gt;</ept> must be able to be cast or converted to an object of type   <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>o<ept id="p1">&lt;/c&gt;</ept> muss in ein Objekt vom Typ <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> umgewandelt oder konvertiert werden können, damit der Vergleich erfolgreich durchgeführt werden kann.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source>Determines if the underlying system type of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object is the same as the underlying system type of the specified <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">Bestimmt, ob der zugrunde liegende Systemtyp des aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekts mit dem zugrunde liegenden Systemtyp des angegebenen <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>-Objekts übereinstimmt</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the underlying system type of <ph id="ph2">&lt;paramref name="o" /&gt;</ph> is the same as the underlying system type of the current <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der zugrunde liegende Systemtyp von <ph id="ph2">&lt;paramref name="o" /&gt;</ph> mit dem zugrunde liegenden Systemtyp des aktuellen <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> übereinstimmt, andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source>This method also returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if: .</source>
          <target state="translated">Diese Methode gibt auch <ph id="ph1">&lt;see langword="false" /&gt;</ph> zurück, wenn:</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> cannot be cast or converted to a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> nicht in ein <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt umgewandelt oder konvertiert werden kann.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Diese Methode überschreibt <ph id="ph1">&lt;xref:System.Object.Equals%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>It casts <ph id="ph1">`o`</ph> to an object of type <ph id="ph2">&lt;xref:System.Type&gt;</ph> and calls the <ph id="ph3">&lt;xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Seinem Schattenwurf <ph id="ph1">`o`</ph> auf ein Objekt des Typs <ph id="ph2">&lt;xref:System.Type&gt;</ph> und ruft die <ph id="ph3">&lt;xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Type.Equals%28System.Object%29&gt;</ph> to compare various <ph id="ph2">&lt;xref:System.Type&gt;</ph> object instances with various <ph id="ph3">&lt;xref:System.Object&gt;</ph> instances.</source>
          <target state="translated">Im folgenden Beispiel wird <ph id="ph1">&lt;xref:System.Type.Equals%28System.Object%29&gt;</ph> verschiedenen vergleichen <ph id="ph2">&lt;xref:System.Type&gt;</ph> Objektinstanzen mit verschiedenen <ph id="ph3">&lt;xref:System.Object&gt;</ph> Instanzen.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>Two things are particularly worth noting about the example:</source>
          <target state="translated">Zwei Dinge sind besonders erwähnenswert zum Beispiel:</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>The comparison of a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents an integer with a <ph id="ph2">&lt;xref:System.Reflection.TypeInfo&gt;</ph> object that represents an integer return <ph id="ph3">`true`</ph> because <ph id="ph4">&lt;xref:System.Reflection.TypeInfo&gt;</ph> is derived from <ph id="ph5">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Beim Vergleich von einer <ph id="ph1">&lt;xref:System.Type&gt;</ph> -Objekt, das eine ganze Zahl mit darstellt eine <ph id="ph2">&lt;xref:System.Reflection.TypeInfo&gt;</ph> -Objekt, das eine ganze Zahl zurückgegeben darstellt <ph id="ph3">`true`</ph> da <ph id="ph4">&lt;xref:System.Reflection.TypeInfo&gt;</ph> stammt aus <ph id="ph5">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Object)">
          <source>The comparison of a  <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents a <ph id="ph2">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> object (an open generic type) with a <ph id="ph3">`List(Of String)`</ph> object (a closed generic type) returns <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Beim Vergleich von einer <ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekt, das darstellt eine <ph id="ph2">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> Objekt (ein offener generischer Typ) mit einer <ph id="ph3">`List(Of String)`</ph> -Objekt (einen geschlossenen generischen Typs) zurückgibt <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Type)">
          <source>The object whose underlying system type is to be compared with the underlying system type of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Das Objekt, dessen zugrunde liegender Systemtyp mit dem zugrunde liegenden Systemtyp des aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> verglichen werden soll.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Type)">
          <source>Determines if the underlying system type of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is the same as the underlying system type of the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Bestimmt, ob der zugrunde liegende Systemtyp des aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> mit dem zugrunde liegenden Systemtyp des angegebenen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> übereinstimmt.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Type.Equals(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the underlying system type of <ph id="ph2">&lt;paramref name="o" /&gt;</ph> is the same as the underlying system type of the current <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der zugrunde liegende Systemtyp von <ph id="ph2">&lt;paramref name="o" /&gt;</ph> mit dem zugrunde liegenden Systemtyp des aktuellen <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> übereinstimmt, andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.Equals(System.Type)">
          <source>The following example uses <ph id="ph1">`Equals`</ph> to compare two types.</source>
          <target state="translated">Im folgenden Beispiel wird <ph id="ph1">`Equals`</ph> , zwei Typen verglichen werden soll.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="F:System.Type.FilterAttribute">
          <source>Represents the member filter used on attributes.</source>
          <target state="translated">Stellt den für Attribute verwendeten Memberfilter dar.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="F:System.Type.FilterAttribute">
          <source>This field is read-only.</source>
          <target state="translated">Dieses Feld ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>This field holds a reference to the delegate used by the <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method.</source>
          <target state="translated">Dieses Feld enthält einen Verweis auf den Delegaten verwendet werden, indem Sie die <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>The method encapsulated by this delegate takes two parameters: the first is a <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object and the second is an <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">Von diesem Delegaten gekapselte Methode akzeptiert zwei Parameter: das erste ist ein <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> Objekt und das zweite ist ein <ph id="ph2">`Object`</ph>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>The method determines whether the <ph id="ph1">`MemberInfo`</ph> object matches the criteria specified by the <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">Die Methode bestimmt, ob die <ph id="ph1">`MemberInfo`</ph> Objekt übereinstimmt, die vom angegebenen Kriterien die <ph id="ph2">`Object`</ph>.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>The <ph id="ph1">`Object`</ph> may be assigned the value of any one of the fields on the classes <ph id="ph2">&lt;xref:System.Reflection.FieldAttributes&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>, or <ph id="ph4">&lt;xref:System.Reflection.MethodImplAttributes&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">`Object`</ph> möglicherweise den Wert eines der Felder in den Klassen zugeordnet <ph id="ph2">&lt;xref:System.Reflection.FieldAttributes&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>, oder <ph id="ph4">&lt;xref:System.Reflection.MethodImplAttributes&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>For example, the <ph id="ph1">`Object`</ph> can be assigned the value of a field from <ph id="ph2">`FieldAttributes`</ph> such as Public.</source>
          <target state="translated">Z. B. die <ph id="ph1">`Object`</ph> kann der Wert eines Felds aus zugewiesen werden <ph id="ph2">`FieldAttributes`</ph> wie "Public".</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>In that case, when the <ph id="ph1">`FilterAttribute`</ph> delegate is invoked, it will return <ph id="ph2">`true`</ph> only if the method represented by the <ph id="ph3">`MemberInfo`</ph> object is decorated with the public field attribute in metadata.</source>
          <target state="translated">In diesem Fall, wenn die <ph id="ph1">`FilterAttribute`</ph> Delegat aufgerufen wird, wird zurückgegeben, die <ph id="ph2">`true`</ph> nur, wenn die Methode über dargestellt die <ph id="ph3">`MemberInfo`</ph> Objekt mit dem öffentlichen Feldattribut in den Metadaten ergänzt wird.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterAttribute">
          <source>The following example gets the <ph id="ph1">`FilterAttribute`</ph> delegate, passes it as a parameter to the <ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method, and displays the specified members and their attributes.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">`FilterAttribute`</ph> delegieren, übergibt sie als Parameter an die <ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph> -Methode, und zeigt die angegebenen Elemente und ihre Attribute.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="F:System.Type.FilterName">
          <source>Represents the case-sensitive member filter used on names.</source>
          <target state="translated">Stellt den für Namen verwendeten Memberfilter mit Beachtung der Groß-/Kleinschreibung dar.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="F:System.Type.FilterName">
          <source>This field is read-only.</source>
          <target state="translated">Dieses Feld ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>This field holds a reference to the delegate used by the <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method.</source>
          <target state="translated">Dieses Feld enthält einen Verweis auf den Delegaten verwendet werden, indem Sie die <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>The method encapsulated by this delegate takes two parameters: the first is a <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object and the second is an <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">Von diesem Delegaten gekapselte Methode akzeptiert zwei Parameter: das erste ist ein <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> Objekt und das zweite ist ein <ph id="ph2">`Object`</ph>.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>The method determines whether the <ph id="ph1">`MemberInfo`</ph> object matches the criteria specified by the <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">Die Methode bestimmt, ob die <ph id="ph1">`MemberInfo`</ph> Objekt übereinstimmt, die vom angegebenen Kriterien die <ph id="ph2">`Object`</ph>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>The <ph id="ph1">`Object`</ph> is assigned a string value, which may include a trailing "*" wildcard character.</source>
          <target state="translated">Die <ph id="ph1">`Object`</ph> ist einen Zeichenfolgenwert, darunter ein nachstehender möglicherweise zugewiesen "*" Platzhalterzeichen.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>Only wildcard end string matching is supported.</source>
          <target state="translated">Nur Ende Zeichenfolge mit Platzhalterzeichen werden unterstützt.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>For example, the <ph id="ph1">`Object`</ph> may be assigned the value "Byte*".</source>
          <target state="translated">Z. B. die <ph id="ph1">`Object`</ph> kann den Wert "Byte *" zugewiesen werden.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>In that case, when the <ph id="ph1">`FilterName`</ph> delegate is invoked, it will return <ph id="ph2">`true`</ph> only if the method represented by the <ph id="ph3">`MemberInfo`</ph> object has a name that begins with "Byte".</source>
          <target state="translated">In diesem Fall, wenn die <ph id="ph1">`FilterName`</ph> Delegat aufgerufen wird, wird zurückgegeben, die <ph id="ph2">`true`</ph> nur, wenn die Methode über dargestellt die <ph id="ph3">`MemberInfo`</ph> Objekt verfügt über einen Namen, die mit "Byte" beginnt.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterName">
          <source>The following code example gets the methods associated with the user-defined <ph id="ph1">`Application`</ph> type.</source>
          <target state="translated">Im folgenden Codebeispiel ruft die zugeordneten die benutzerdefinierten Methoden <ph id="ph1">`Application`</ph> Typ.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="F:System.Type.FilterNameIgnoreCase">
          <source>Represents the case-insensitive member filter used on names.</source>
          <target state="translated">Stellt den für Namen verwendeten Memberfilter ohne Beachtung der Groß-/Kleinschreibung dar.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="F:System.Type.FilterNameIgnoreCase">
          <source>This field is read-only.</source>
          <target state="translated">Dieses Feld ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>This field holds a reference to the delegate used by the <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method.</source>
          <target state="translated">Dieses Feld enthält einen Verweis auf den Delegaten verwendet werden, indem Sie die <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>The method encapsulated by this delegate takes two parameters: the first is a <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object and the second is an <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">Von diesem Delegaten gekapselte Methode akzeptiert zwei Parameter: das erste ist ein <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> Objekt und das zweite ist ein <ph id="ph2">`Object`</ph>.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>The method determines whether the <ph id="ph1">`MemberInfo`</ph> object matches the criteria specified by the <ph id="ph2">`Object`</ph>.</source>
          <target state="translated">Die Methode bestimmt, ob die <ph id="ph1">`MemberInfo`</ph> Objekt übereinstimmt, die vom angegebenen Kriterien die <ph id="ph2">`Object`</ph>.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>The <ph id="ph1">`Object`</ph> is assigned a string value, which may include a trailing "*" wildcard character.</source>
          <target state="translated">Die <ph id="ph1">`Object`</ph> ist einen Zeichenfolgenwert, darunter ein nachstehender möglicherweise zugewiesen "*" Platzhalterzeichen.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>Only wildcard end string matching is supported.</source>
          <target state="translated">Nur Ende Zeichenfolge mit Platzhalterzeichen werden unterstützt.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>For example, the <ph id="ph1">`Object`</ph> may be assigned the value "ByTe*".</source>
          <target state="translated">Z. B. die <ph id="ph1">`Object`</ph> kann den Wert "ByTe *" zugewiesen werden.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>In that case, when the <ph id="ph1">`FilterName`</ph> delegate is invoked, it will return true only if the method represented by the <ph id="ph2">`MemberInfo`</ph> object has a name that begins with "byte", ignoring case.</source>
          <target state="translated">In diesem Fall, wenn die <ph id="ph1">`FilterName`</ph> Delegat wird aufgerufen, es wird nur dann true zurück, wenn die Methode von dargestellt die <ph id="ph2">`MemberInfo`</ph> Objekt besitzt einen Namen, die mit "Byte", ignorieren Groß-/Kleinschreibung beginnt.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.FilterNameIgnoreCase">
          <source>The following example gets the <ph id="ph1">`MemberFilter`</ph> delegate, passes it as a parameter to the <ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method, and displays the methods and their attributes of the <ph id="ph3">`String`</ph> class that begin with the letter "c", disregarding the case.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">`MemberFilter`</ph> delegieren, übergibt sie als Parameter an die <ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph> -Methode, und zeigt die Methoden und deren Attribute von der <ph id="ph3">`String`</ph> -Klasse, die mit dem Buchstaben "c", die Groß-/Kleinschreibung Basiseigenschaft beginnen.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>The delegate that compares the interfaces against <bpt id="p1">&lt;c&gt;</bpt>filterCriteria<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Der Delegat, der die Schnittstellen anhand der Kriterien <bpt id="p1">&lt;c&gt;</bpt>filterCriteria<ept id="p1">&lt;/c&gt;</ept> vergleicht.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>The search criteria that determines whether an interface should be included in the returned array.</source>
          <target state="translated">Die Suchkriterien, die bestimmen, ob eine Schnittstelle in das zurückgegebene Array aufgenommen wird.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing a filtered list of interfaces implemented or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Gibt ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten zurück, die eine gefilterte Liste von Schnittstellen darstellen, die vom aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> implementiert oder geerbt wurden.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing a filtered list of the interfaces implemented or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, or an empty array of type <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> if no interfaces matching the filter are implemented or inherited by the current <ph id="ph4">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die eine gefilterte Liste von Schnittstellen darstellt, die durch den aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> implementiert oder geerbt wurden, oder ein leeres Array vom Typ <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>, wenn der aktuelle <ph id="ph4">&lt;see cref="T:System.Type" /&gt;</ph> keine dem Filter entsprechenden Schnittstellen implementiert oder erbt.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType&gt;</ph> delegates supplied by the <ph id="ph3">&lt;xref:System.Reflection.Module?displayProperty=nameWithType&gt;</ph> class may also be used, in lieu of the <ph id="ph4">&lt;xref:System.Reflection.TypeFilter?displayProperty=nameWithType&gt;</ph> delegate.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType&gt;</ph> und <ph id="ph2">&lt;xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType&gt;</ph> Delegaten angegeben wird, indem Sie die <ph id="ph3">&lt;xref:System.Reflection.Module?displayProperty=nameWithType&gt;</ph> Klasse kann auch verwendet werden, und in anstelle der der <ph id="ph4">&lt;xref:System.Reflection.TypeFilter?displayProperty=nameWithType&gt;</ph> delegieren.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.</source>
          <target state="translated">Alle von dieser Klasse implementierten Schnittstellen werden während der Suche berücksichtigt, ob von einer Basisklasse oder von der Klasse selbst deklariert.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned).</source>
          <target state="translated">Diese Methode sucht in der Basisklasse-Hierarchie, die Rückgabe aller der entsprechenden Schnittstellen, die jede Klasse, sowie alle entsprechenden implementiert Schnittstellen für jede von diesen Schnittstellen implementiert (d. h. der transitive Abschluss von übereinstimmenden Schnittstellen wird zurückgegeben).</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>No duplicate interfaces are returned.</source>
          <target state="translated">Es sind keine doppelten Schnittstellen zurückgegeben.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> sucht alle Schnittstellen, die in die Einschränkungen für den Typparameter deklariert, und alle Schnittstellen geerbt wird, über die Schnittstellen in der die Einschränkungen deklariert.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type argument of a generic type, <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> searches all the interfaces implemented by the type, whether or not they match constraints.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein Typargument eines generischen Typs <ph id="ph2">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> sucht alle Schnittstellen, die durch den Typ implementiert, und zwar unabhängig davon, ob sie Einschränkungen entsprechen.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> can return generic interfaces, even on types that are not generic.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> können generische Schnittstellen, auch auf Typen zurückgeben, die nicht generische sind.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>For example, a nongeneric type might implement <ph id="ph1">`IEnumerable&lt;int&gt;`</ph> (<ph id="ph2">`IEnumerable(Of Integer)`</ph> in Visual Basic).</source>
          <target state="translated">Beispielsweise kann ein nicht generischer Typ implementieren <ph id="ph1">`IEnumerable&lt;int&gt;`</ph> (<ph id="ph2">`IEnumerable(Of Integer)`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>The following example finds the specified interface implemented or inherited by the specified type, and then displays the interface names.</source>
          <target state="translated">Das folgende Beispiel sucht die angegebene Schnittstelle implementiert oder geerbt werden, durch den angegebenen Typ und zeigt dann die Schnittstellennamen.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source><ph id="ph1">&lt;paramref name="filter" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="filter" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" uid="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)">
          <source>A static initializer is invoked and throws an exception.</source>
          <target state="translated">Ein statischer Initialisierer wird aufgerufen und löst eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>An object that indicates the type of member to search for.</source>
          <target state="translated">Ein Objekt, das den Typ der gesuchten Member angibt.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">0 (null), damit <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The delegate that does the comparisons, returning <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the member currently being inspected matches the <bpt id="p1">&lt;c&gt;</bpt>filterCriteria<ept id="p1">&lt;/c&gt;</ept> and <ph id="ph2">&lt;see langword="false" /&gt;</ph> otherwise.</source>
          <target state="translated">Der Delegat, der die Vergleiche durchführt. Der Rückgabewert ist <ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der gerade betrachtete Member den <bpt id="p1">&lt;c&gt;</bpt>filterCriteria<ept id="p1">&lt;/c&gt;</ept> entspricht, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>You can use the <ph id="ph1">&lt;see langword="FilterAttribute" /&gt;</ph>, <ph id="ph2">&lt;see langword="FilterName" /&gt;</ph>, and <ph id="ph3">&lt;see langword="FilterNameIgnoreCase" /&gt;</ph> delegates supplied by this class.</source>
          <target state="translated">Sie können die Delegaten <ph id="ph1">&lt;see langword="FilterAttribute" /&gt;</ph>, <ph id="ph2">&lt;see langword="FilterName" /&gt;</ph> und <ph id="ph3">&lt;see langword="FilterNameIgnoreCase" /&gt;</ph> dieser Klasse verwenden.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The first uses the fields of <ph id="ph1">&lt;see langword="FieldAttributes" /&gt;</ph>, <ph id="ph2">&lt;see langword="MethodAttributes" /&gt;</ph>, and <ph id="ph3">&lt;see langword="MethodImplAttributes" /&gt;</ph> as search criteria, and the other two delegates use <ph id="ph4">&lt;see langword="String" /&gt;</ph> objects as the search criteria.</source>
          <target state="translated">Der erste Delegat verwendet als Suchkriterien die Felder von <ph id="ph1">&lt;see langword="FieldAttributes" /&gt;</ph>, <ph id="ph2">&lt;see langword="MethodAttributes" /&gt;</ph> und <ph id="ph3">&lt;see langword="MethodImplAttributes" /&gt;</ph>, die anderen beiden Delegaten verwenden <ph id="ph4">&lt;see langword="String" /&gt;</ph>-Objekte als Suchkriterien.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The search criteria that determines whether a member is returned in the array of <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph> objects.</source>
          <target state="translated">Die Suchkriterien, die bestimmen, ob ein Member im Array von <ph id="ph1">&lt;see langword="MemberInfo" /&gt;</ph>-Objekten zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The fields of <ph id="ph1">&lt;see langword="FieldAttributes" /&gt;</ph>, <ph id="ph2">&lt;see langword="MethodAttributes" /&gt;</ph>, and <ph id="ph3">&lt;see langword="MethodImplAttributes" /&gt;</ph> can be used in conjunction with the <ph id="ph4">&lt;see langword="FilterAttribute" /&gt;</ph> delegate supplied by this class.</source>
          <target state="translated">Die Felder von <ph id="ph1">&lt;see langword="FieldAttributes" /&gt;</ph>, <ph id="ph2">&lt;see langword="MethodAttributes" /&gt;</ph> und <ph id="ph3">&lt;see langword="MethodImplAttributes" /&gt;</ph> können zusammen mit dem <ph id="ph4">&lt;see langword="FilterAttribute" /&gt;</ph>-Delegaten dieser Klasse verwendet werden.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Returns a filtered array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects of the specified member type.</source>
          <target state="translated">Gibt ein gefiltertes Array von <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>-Objekten mit dem angegebenen Membertyp zurück.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>A filtered array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects of the specified member type.</source>
          <target state="translated">Ein gefiltertes Array von <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>-Objekten vom angegebenen Membertyp.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have members of type <ph id="ph3">&lt;paramref name="memberType" /&gt;</ph> that match the filter criteria.</source>
          <target state="translated">Ein leeres Array vom <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>-Typ, wenn der aktuelle <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> keine den Filterkriterien entsprechenden Member vom <ph id="ph3">&lt;paramref name="memberType" /&gt;</ph>-Typ besitzt.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">Member enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Filterkennzeichnungen genutzt werden, welche Member in die Suche einbezogen werden:</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Instance`</ph> oder <ph id="ph2">`BindingFlags.Static`</ph> ändern, um einen Rückgabewert zu erhalten.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Specify <ph id="ph1">`BindingFlags.Instance`</ph> to include instance members in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Instance`</ph> Instanzmember in die Suche eingeschlossen.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Specify <ph id="ph1">`BindingFlags.Static`</ph> to include static members in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Static`</ph> auf statische Member in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Public`</ph> auf öffentliche Member in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.NonPublic`</ph> auf nicht öffentliche Member (d. h. private, interne und geschützte Member) in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> Suche nur die deklarierten Member der <ph id="ph2">&lt;xref:System.Type&gt;</ph>, nicht die Elemente, die nur geerbt wurden.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>Valid values for <ph id="ph1">&lt;xref:System.Type.MemberType%2A&gt;</ph> are defined in <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph>.</source>
          <target state="translated">Gültige Werte für <ph id="ph1">&lt;xref:System.Type.MemberType%2A&gt;</ph> im definiert <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>If no such members are found, an empty array is returned.</source>
          <target state="translated">Wenn keine solchen Member gefunden werden, wird ein leeres Array zurückgegeben.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>To get the class initializer (.cctor) using this method, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Um die klasseninitialisierung (".cctor"), die mit dieser Methode zu erhalten, müssen Sie angeben <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph4">`Or`</ph> <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type or generic method, <ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph> processes any members declared by the class constraint and the interface constraints of the type parameter.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen Typparameter einer generischen Typ- oder Methodendefinition, <ph id="ph2">&lt;xref:System.Type.FindMembers%2A&gt;</ph> verarbeitet alle Member deklariert, indem der Class-Einschränkung und die schnittstelleneinschränkungen des Typparameters.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source>The following example finds all the members in a class that match the specified search criteria, and then displays the matched members.</source>
          <target state="translated">Das folgende Beispiel findet alle Elemente in einer Klasse, die die angegebenen Suchkriterien entsprechen, und zeigt dann die übereinstimmenden Elemente.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" uid="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)">
          <source><ph id="ph1">&lt;paramref name="filter" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="filter" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" uid="P:System.Type.FullName">
          <source>Gets the fully qualified name of the type, including its namespace but not its assembly.</source>
          <target state="translated">Ruft den voll vollqualifizierten Namen des Typs ab. Dies beinhaltet den Namespace, nicht jedoch die Assembly.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The fully qualified name of the type, including its namespace but not its assembly; or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the current instance represents a generic type parameter, an array type, pointer type, or <ph id="ph2">&lt;see langword="byref" /&gt;</ph> type based on a type parameter, or a generic type that is not a generic type definition but contains unresolved type parameters.</source>
          <target state="translated">Der vollqualifizierte Name des Typs, einschließlich des Namespace, jedoch ausschließlich der Assembly, oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn die aktuelle Instanz einen auf einem Typparameter basierenden generischen Typparameter, Arraytyp, Zeigertyp oder <ph id="ph2">&lt;see langword="byref" /&gt;</ph>-Typ oder einen generischen Typ darstellt, der keine generische Typdefinition ist, jedoch nicht aufgelöste Typparameter enthält.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>For example, the fully qualified name of the <ph id="ph1">&lt;xref:System.String&gt;</ph> type is <ph id="ph2">`System.String`</ph>.</source>
          <target state="translated">Z. B. den vollqualifizierten Namen des der <ph id="ph1">&lt;xref:System.String&gt;</ph> ist <ph id="ph2">`System.String`</ph>.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>Contrast this with the assembly-qualified name returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, which consists of the full name plus the full assembly name.</source>
          <target state="translated">Vergleichen Sie dies mit der Assembly qualifizierte Name zurückgegeben werden, indem Sie die <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> -Eigenschaft, die den vollständigen Namen sowie den vollen Assemblynamens besteht.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>If the current type represents a closed generic type, the type arguments in the string returned by the <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph> property are qualified by their full assembly name, even though the string representation of the generic type itself is not qualified by its full assembly name.</source>
          <target state="translated">Wenn der aktuelle Typ einen geschlossenen generischen Typ darstellt, die Typargumente in der Zeichenfolge zurückgegeben, durch die <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph> Eigenschaft sind, obwohl die Darstellung des generischen Typparameters selbst nicht von seiner voll qualifiziert wird anhand des Assemblynamens vollständige qualifiziert der Name der Assembly.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The following example illustrates the difference in the FullName property for a type that represents generic type definition and one that represents a closed generic type.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht den Unterschied in der FullName-Eigenschaft für einen Typ, der generische Typdefinition darstellt, und eine, die einen geschlossenen generischen Typs darstellt.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>This property returns <ph id="ph1">`null`</ph> if:</source>
          <target state="translated">Diese Eigenschaft gibt <ph id="ph1">`null`</ph> wenn:</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a type parameter of a generic type.</source>
          <target state="translated">Die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> -Objekt einen Typparameter eines generischen Typs darstellt.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The following example retrieves the type parameter of the <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> type and attempts to display its <ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph> property.</source>
          <target state="translated">Das folgende Beispiel ruft die Typparameter der <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> Typ und die Versuche zum Anzeigen seiner <ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents an array type, a pointer  type, or a <ph id="ph2">`byref`</ph> type that is based on a generic type parameter.</source>
          <target state="translated">Die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekt stellt einen Arraytyp, ein Zeigertyp oder ein <ph id="ph2">`byref`</ph> Typ, der einen generischen Typparameter basiert.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The following example defines a generic type, <ph id="ph1">`Generictype1&lt;T&gt;`</ph>, with three methods: <ph id="ph2">`Display(T[])`</ph>, which is passed an array of type T; <ph id="ph3">`HandleT(T)`</ph>, which is passed a T object; and <ph id="ph4">`ChangeValue(ref T)`</ph>, which is passed a T object by reference.</source>
          <target state="translated">Das folgende Beispiel definiert einen generischen Typ <ph id="ph1">`Generictype1&lt;T&gt;`</ph>, mit drei Methoden: <ph id="ph2">`Display(T[])`</ph>, der übergeben wird, ein Array vom Typ T enthalten ist <ph id="ph3">`HandleT(T)`</ph>, die ein Objekt auf T übergeben wird und <ph id="ph4">`ChangeValue(ref T)`</ph>, die ein T-Objekt als Verweis übergeben wird.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>Because C# and Visual Basic do not allow us to define T as a pointer in the <ph id="ph1">`HandleT`</ph> method, we have to call the <ph id="ph2">&lt;xref:System.Type.MakePointerType%2A&gt;</ph> method on the <ph id="ph3">&lt;xref:System.Type&gt;</ph> object that represents the method's parameter type to create a pointer to a generic type.</source>
          <target state="translated">Da (c# und Visual Basic nicht als Zeiger in T definieren zulässt, führen Sie die <ph id="ph1">`HandleT`</ph> -Methode aufrufen, müssen die <ph id="ph2">&lt;xref:System.Type.MakePointerType%2A&gt;</ph> Methode auf die <ph id="ph3">&lt;xref:System.Type&gt;</ph> Objekt, das Parametertyp der Methode, um einen Zeiger auf einen generischen Typ erstellen darstellt.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The output from the example shows that in all three cases, the <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph> property is <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Die Ausgabe des Beispiels zeigt, dass in allen drei Fällen die <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph> Eigenschaft ist <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The current type contains generic type parameters that have not been replaced by specific types (that is, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>), but the type is not a generic type definition (that is, the <ph id="ph3">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property returns <ph id="ph4">`false`</ph></source>
          <target state="translated">Der aktuelle Typ enthält generische Typparameter, die nicht durch bestimmte Typen ersetzt wurden (d. h. die <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> -Eigenschaft gibt <ph id="ph2">`true`</ph>), ist jedoch keine generische Typdefinition (, also die <ph id="ph3">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> Eigenschaft gibt <ph id="ph4">`false`</ph></target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>In the following example, <ph id="ph1">`Derived&lt;T&gt;`</ph> inherits from <ph id="ph2">`Base&lt;T&gt;`</ph>.</source>
          <target state="translated">Im folgenden Beispiel <ph id="ph1">`Derived&lt;T&gt;`</ph> erbt von <ph id="ph2">`Base&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The <ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph> property obtains the  <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents the base type of <ph id="ph3">`Derived&lt;T&gt;`</ph>, and its <ph id="ph4">&lt;xref:System.Type.FullName%2A&gt;</ph> property returns <ph id="ph5">`null`</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.BaseType%2A&gt;</ph> Eigenschaft ruft die <ph id="ph2">&lt;xref:System.Type&gt;</ph> Objekt, das den Basistyp des darstellt <ph id="ph3">`Derived&lt;T&gt;`</ph>, und die zugehörige <ph id="ph4">&lt;xref:System.Type.FullName%2A&gt;</ph> -Eigenschaft gibt <ph id="ph5">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>To get a <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph> that is not <ph id="ph2">`null`</ph>, you can use the <ph id="ph3">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method to get the generic type definition, as the example illustrates.</source>
          <target state="translated">Zum Abrufen einer <ph id="ph1">&lt;xref:System.Type.FullName%2A&gt;</ph> , die sich nicht <ph id="ph2">`null`</ph>, können Sie die <ph id="ph3">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> Methode, um die generische Typdefinition abzurufen, wie im Beispiel veranschaulicht.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>This property is read-only.</source>
          <target state="translated">Diese Eigenschaft ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The following example displays the full name of the specified type.</source>
          <target state="translated">Das folgende Beispiel zeigt den vollständigen Namen des angegebenen Typs.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.FullName">
          <source>The following example compares the strings returned by the <ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph> method and the <ph id="ph2">`Name`</ph>, <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> properties.</source>
          <target state="translated">Das folgende Beispiel vergleicht die zurückgegebene Zeichenfolgen die <ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph> Methode und die <ph id="ph2">`Name`</ph>, <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>, und <ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> Eigenschaften.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterAttributes">
          <source>Gets a combination of <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph> flags that describe the covariance and special constraints of the current generic type parameter.</source>
          <target state="translated">Ruft eine Kombination von <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph>-Flags ab, die die Kovarianz und die speziellen Einschränkungen des aktuellen generischen Typparameters beschreiben.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph> values that describes the covariance and special constraints of the current generic type parameter.</source>
          <target state="translated">Eine bitweise Kombination von <ph id="ph1">&lt;see cref="T:System.Reflection.GenericParameterAttributes" /&gt;</ph>-Werten, die die Kovarianz und die speziellen Einschränkungen des aktuellen generischen Typparameters beschreiben.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>The value of this property contains flags that describe whether the current generic type parameter is covariant, and flags that describe any special constraints.</source>
          <target state="translated">Der Wert dieser Eigenschaft enthält Flags, die beschreiben, ob der aktuelle generische Typparameter kovariant ist und die Flags, die besonderen Einschränkungen beschreiben.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType&gt;</ph> value to select the covariance flags, and use the <ph id="ph2">&lt;xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType&gt;</ph> value to select the constraint flags.</source>
          <target state="translated">Verwenden Sie die <ph id="ph1">&lt;xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType&gt;</ph> Wert, der die Kovarianzflags auswählen, und Verwenden der <ph id="ph2">&lt;xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType&gt;</ph> Wert, der die Einschränkungsflags auswählen.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>The following code example defines a generic type <ph id="ph1">`Test`</ph> with two type parameters that have different constraints.</source>
          <target state="translated">Das folgende Codebeispiel definiert einen generischen Typ <ph id="ph1">`Test`</ph> mit zwei Typparametern, die verschiedene Einschränkungen aufweisen.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterAttributes">
          <source>When the program executes, the constraints are examined using the <ph id="ph1">&lt;xref:System.Type.GenericParameterAttributes%2A&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Type.GetGenericParameterConstraints%2A&gt;</ph> method.</source>
          <target state="translated">Wenn das Programm ausgeführt wird, die Einschränkungen werden untersucht, mit der <ph id="ph1">&lt;xref:System.Type.GenericParameterAttributes%2A&gt;</ph> Eigenschaft und die <ph id="ph2">&lt;xref:System.Type.GetGenericParameterConstraints%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterAttributes">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object is not a generic type parameter.</source>
          <target state="translated">Das aktuelle <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt ist kein generischer Typparameter.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterAttributes">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Das bedeutet, dass die <ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph>-Eigenschaft <ph id="ph2">&lt;see langword="false" /&gt;</ph> zurückgibt.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterAttributes">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterPosition">
          <source>Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type parameter of a generic type or a generic method.</source>
          <target state="translated">Ruft die Position des Typparameters in der Typparameterliste des generischen Typs oder der Methode ab, der bzw. die den Parameter deklariert hat, wenn das <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt einen Typparameter eines generischen Typs oder einer generischen Methode darstellt.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The position of a type parameter in the type parameter list of the generic type or method that defines the parameter.</source>
          <target state="translated">Die Position eines Typparameters in der Typparameterliste des generischen Typs oder der generischen Methode, der bzw. die den Parameter definiert.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>Position numbers begin at 0.</source>
          <target state="translated">Die Positionsnummern beginnen mit 0.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> -Eigenschaft gibt die Position eines Typparameters in der Parameterliste von der generischen Typ- oder Methodendefinition, in dem der Typparameter ursprünglich definiert wurde.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The <ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> properties identify the generic type or method definition:</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> Eigenschaften identifizieren den generischen Typ- oder Methodendefinition:</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns a <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, that <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> represents a generic method definition, and the current <ph id="ph4">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic method definition.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> Eigenschaft gibt eine <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> stellt eine generische Methodendefinition und der aktuelle <ph id="ph4">&lt;xref:System.Type&gt;</ph> -Objekt einen Typparameter der generischen Methodendefinition darstellt.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>If the <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns <ph id="ph2">`null`</ph>, then the <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property always returns a <ph id="ph4">&lt;xref:System.Type&gt;</ph> object representing a generic type definition, and the current <ph id="ph5">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic type definition.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> -Eigenschaft gibt <ph id="ph2">`null`</ph>, und klicken Sie dann die <ph id="ph3">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> -Eigenschaft gibt immer eine <ph id="ph4">&lt;xref:System.Type&gt;</ph> Objekt, das eine generische Typdefinition ist, und das aktuelle darstellt <ph id="ph5">&lt;xref:System.Type&gt;</ph> Objekt einen Typparameter eines generischen Typs darstellt Definition.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>To provide the correct context for the value of the <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property, it is necessary to identify the generic type or method a type parameter belongs to.</source>
          <target state="translated">Angeben des richtigen Kontexts für den Wert von der <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> -Eigenschaft, es ist notwendig, identifizieren Sie die generischen Typ oder Methode, die ein Typparameter gehört.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>For example, consider the return value of the generic method <ph id="ph1">`GetSomething`</ph> in the following code:</source>
          <target state="translated">Betrachten Sie beispielsweise den Rückgabewert der aufgerufenen generischen Methode <ph id="ph1">`GetSomething`</ph> in den folgenden Code:</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The type returned by <ph id="ph1">`GetSomething`</ph> depends on the type arguments supplied to class <ph id="ph2">`A`</ph> and to <ph id="ph3">`GetSomething`</ph> itself.</source>
          <target state="translated">Der zurückgegebene Typ <ph id="ph1">`GetSomething`</ph> richtet sich nach der angegebenen Klasse Typargumente <ph id="ph2">`A`</ph> und <ph id="ph3">`GetSomething`</ph> selbst.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>You can obtain a <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> for <ph id="ph2">`GetSomething`</ph>, and from that you can obtain the return type.</source>
          <target state="translated">Sie erhalten eine <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> für <ph id="ph2">`GetSomething`</ph>, und von dem Sie den Rückgabetyp erhalten.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>When you examine the type parameters of the return type, <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> returns 0 for both.</source>
          <target state="translated">Wenn Sie die Typparameter des Rückgabetyps, untersuchen <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> für beide 0 zurück.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The position of <ph id="ph1">`V`</ph> is 0 because <ph id="ph2">`V`</ph> is the first type parameter in the type parameter list for class <ph id="ph3">`A`</ph>.</source>
          <target state="translated">Die Position des <ph id="ph1">`V`</ph> ist 0, da <ph id="ph2">`V`</ph> ist der erste Typparameter in der Typparameterliste für die Klasse <ph id="ph3">`A`</ph>.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The position of <ph id="ph1">`X`</ph> is 0 because <ph id="ph2">`X`</ph> is the first type parameter in the type parameter list for <ph id="ph3">`GetSomething`</ph>.</source>
          <target state="translated">Die Position des <ph id="ph1">`X`</ph> ist 0, da <ph id="ph2">`X`</ph> ist der erste Typparameter in der Typparameterliste für <ph id="ph3">`GetSomething`</ph>.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>Calling the <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property causes an exception if the current <ph id="ph2">&lt;xref:System.Type&gt;</ph> does not represent a type parameter.</source>
          <target state="translated">Aufrufen der <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> -Eigenschaft löst eine Ausnahme aus, wenn die aktuelle <ph id="ph2">&lt;xref:System.Type&gt;</ph> stellt keinen Parameters für einen Typ dar.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>When you examine the type arguments of an open constructed type, use the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to tell which are type parameters and which are types.</source>
          <target state="translated">Verwenden Sie bei der Überprüfung die Typargumente einer offenen konstruierten Typ müssen die <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> Eigenschaft anzuweisen, die Typparameter und welche Typen sind.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> for a type parameter; you can then use the <ph id="ph3">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> method to obtain its position and use the <ph id="ph4">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> and <ph id="ph5">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> properties to determine the generic method or type definition that defines it.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> -Eigenschaft gibt <ph id="ph2">`true`</ph> für einen Typparameter, können Sie anschließend die <ph id="ph3">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> Methode, um seine Position abrufen und Verwenden der <ph id="ph4">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> und <ph id="ph5">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> Eigenschaften bestimmen die generische Methode oder die Typdefinition, der ihn definiert .</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The following example defines a generic class with two type parameters and defines a second generic class that derives from the first class.</source>
          <target state="translated">Im folgenden Beispiel wird eine generische Klasse mit zwei Typparametern und definiert eine zweite generische Klasse, die von der ersten Klasse abgeleitet ist.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The derived class's base class has two type arguments: the first is <ph id="ph1">&lt;xref:System.Int32&gt;</ph>, and the second is a type parameter of the derived type.</source>
          <target state="translated">Die Basis der abgeleiteten Klasse verfügt über zwei Typargumente: Erstens <ph id="ph1">&lt;xref:System.Int32&gt;</ph>, und die zweite ist ein Typparameter des abgeleiteten Typs.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericParameterPosition">
          <source>The example displays information about these generic classes, including the positions reported by the <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property.</source>
          <target state="translated">Das Beispiel zeigt Informationen zu diesen generischen Klassen, von gemeldeten einschließlich die Positionen der <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterPosition">
          <source>The current type does not represent a type parameter.</source>
          <target state="translated">Der aktuelle Typ stellt keinen Typparameter dar.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="P:System.Type.GenericParameterPosition">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Das heißt, <ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> gibt <ph id="ph2">&lt;see langword="false" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="P:System.Type.GenericTypeArguments">
          <source>Gets an array of the generic type arguments for this type.</source>
          <target state="translated">Ruft ein Array von generischen Typargumenten für diesen Typ ab.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>An array of the generic type arguments for this type.</source>
          <target state="translated">Ein Array von generischen Typargumenten für diesen Typ.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>This property gets only the generic type arguments; that is, the types that have been specified for the generic type parameters of the current type.</source>
          <target state="translated">Diese Eigenschaft ruft nur die generischen Typargumente an. d. h. Typen, die für die generischen Typparameter des aktuellen Typs angegeben wurden.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>If the current type is a generic type definition, this property returns an empty array.</source>
          <target state="translated">Wenn der aktuelle Typ eine generische Typdefinition ist, gibt diese Eigenschaft ein leeres Array zurück.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>If a generic type is used in a generic method or in another generic type, some of its generic type arguments might be generic type parameters of the enclosing method or type.</source>
          <target state="translated">Wenn ein generischer Typ in einer generischen Methode oder einem anderen generischen Typ verwendet wird, möglicherweise einige seiner generische Typargumente generischen Typparameter von einschließenden Methode oder Typ.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>To get the generic type parameters of a type that represents a generic type definition, use the <ph id="ph1">&lt;xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Um die generischen Typparameter eines Typs ab, das eine generische Typdefinition darstellt, verwenden Sie die <ph id="ph1">&lt;xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GenericTypeArguments">
          <source>To get a <ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> object for the current <ph id="ph2">&lt;xref:System.Type&gt;</ph> object, use the <ph id="ph3">&lt;xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType&gt;</ph> extension method.</source>
          <target state="translated">Zum Abrufen einer <ph id="ph1">&lt;xref:System.Reflection.TypeInfo&gt;</ph> -Objekt für die aktuelle <ph id="ph2">&lt;xref:System.Type&gt;</ph> -Objekts die <ph id="ph3">&lt;xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType&gt;</ph> Erweiterungsmethode.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" uid="M:System.Type.GetArrayRank">
          <source>Gets the number of dimensions in an array.</source>
          <target state="translated">Ruft die Anzahl der Dimensionen eines Arrays ab.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" uid="M:System.Type.GetArrayRank">
          <source>An integer that contains the number of dimensions in the current type.</source>
          <target state="translated">Eine Ganzzahl, die die Anzahl der Dimensionen im aktuellen Typ darstellt.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetArrayRank">
          <source>The following example displays the number of dimensions in an array.</source>
          <target state="translated">Das folgende Beispiel zeigt die Anzahl der Dimensionen in einem Array.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" uid="M:System.Type.GetArrayRank">
          <source>The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.</source>
          <target state="translated">Die Funktionalität dieser Methode wird in der Basisklasse nicht unterstützt und muss stattdessen in einer abgeleiteten Klasse implementiert werden.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" uid="M:System.Type.GetArrayRank">
          <source>The current type is not an array.</source>
          <target state="translated">Der aktuelle Typ ist kein Array.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" uid="M:System.Type.GetAttributeFlagsImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> property and gets a bitmask indicating the attributes associated with the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Implementiert beim Überschreiben in einer abgeleiteten Klasse die <ph id="ph1">&lt;see cref="P:System.Type.Attributes" /&gt;</ph>-Eigenschaft und ruft eine Bitmaske ab, die die <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> zugeordneten Attribute anzeigt.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Type.GetAttributeFlagsImpl">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.TypeAttributes" /&gt;</ph> object representing the attribute set of the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Reflection.TypeAttributes" /&gt;</ph>-Objekt, das die Attributgruppe von <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> darstellt.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific constructor of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft einen bestimmten Konstruktor des aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the desired constructor.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter des abzurufenden Konstruktors darstellt.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>An empty array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects, to get a constructor that takes no parameters.</source>
          <target state="translated">Ein leeres Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten zum Abrufen eines Konstruktors ohne Parameter.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>Such an empty array is provided by the <ph id="ph1">&lt;see langword="static" /&gt;</ph> field <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>.</source>
          <target state="translated">Das <ph id="ph1">&lt;see langword="static" /&gt;</ph>-Feld <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> stellt ein entsprechendes leeres Array bereit.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>Searches for a public instance constructor whose parameters match the types in the specified array.</source>
          <target state="translated">Sucht einen öffentlichen Instanzkonstruktor, dessen Parameter den Typen im angegebenen Array entsprechen.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>An object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das den öffentlichen Instanzkonstruktor darstellt, dessen Parameter den Typen im Parametertyparray entsprechen, sofern gefunden, andernfalls <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>This method overload looks for public instance constructors and cannot be used to obtain a class initializer (.cctor).</source>
          <target state="translated">Diese methodenüberladung sucht nach öffentlichen Instanzkonstruktoren und kann nicht verwendet werden, um ein Klasseninitialisierer (".cctor") zu erhalten.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>To get a class initializer, use an overload that takes <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Um ein Klasseninitialisierer zu erhalten, verwenden Sie eine Überladung mit <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, und geben Sie <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>If the requested constructor is non-public, this method returns <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Wenn der angeforderte Konstruktor nicht öffentlich ist, gibt diese Methode <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Sie können nur Parameter auslassen, aufrufen.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method always returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Methode gibt immer <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>The following example obtains the type of <ph id="ph1">`MyClass`</ph>, gets the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object, and displays the constructor signature.</source>
          <target state="translated">Das folgende Beispiel ruft den Typ der <ph id="ph1">`MyClass`</ph>, ruft der <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> -Objekt und zeigt die Signatur des Konstruktors.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Eines der Elemente in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">0 (null), damit <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Ein Nullverweis (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), wenn <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph> verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the constructor to get.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, das Anzahl, Reihenfolge und Typ der Parameter des abzurufenden Konstruktors darstellt.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</source>
          <target state="translated">Ein leeres Array vom <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Typ, d. h. Type[] types = new Type[0], zum Abrufen eines Konstruktors, der keine Parameter akzeptiert.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the parameter type array.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph>-Objekten, die die Attribute darstellen, die dem entsprechenden Element im Parametertyparray zugeordnet sind.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">Der Standardbinder verarbeitet diesen Parameter nicht.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
          <target state="translated">Sucht einen Konstruktor, dessen Parameter unter Verwendung der angegebenen Bindungseinschränkungen den angegebenen Argumenttypen und -modifizierern entsprechen.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> object representing the constructor that matches the specified requirements, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>-Objekt, das den Konstruktor darstellt, der den angegebenen Anforderungen entspricht, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn kein entsprechender Konstruktor gefunden wurde.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If an exact match does not exist, the <ph id="ph1">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id="ph2">`types`</ph> array in order to select a match.</source>
          <target state="translated">Wenn eine genaue Übereinstimmung nicht vorhanden ist, die <ph id="ph1">`binder`</ph> wird versucht, die im angegebenen Parametertypen zu konvertieren die <ph id="ph2">`types`</ph> Array um eine Übereinstimmung zu aktivieren.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the <ph id="ph1">`binder`</ph> is unable to select a match, then <ph id="ph2">`null`</ph> is returned.</source>
          <target state="translated">Wenn die <ph id="ph1">`binder`</ph> kann eine Übereinstimmung, wählen Sie dann <ph id="ph2">`null`</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Filterkennzeichnungen genutzt werden, welche Konstruktoren in die Suche einbezogen werden:</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Instance`</ph> oder <ph id="ph2">`BindingFlags.Static`</ph> ändern, um einen Rückgabewert zu erhalten.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public constructors in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Public`</ph> öffentliche Konstruktoren in die Suche eingeschlossen werden sollen.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.NonPublic`</ph> nicht öffentlichen Konstruktoren (d. h. private, interne und geschützte Konstruktoren) in die Suche eingeschlossen werden sollen.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To get the class initializer (.cctor) using this method overload, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Um die klasseninitialisierung (".cctor"), die Verwendung dieser methodenüberladung zu erhalten, müssen Sie angeben <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph4">`Or`</ph> <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Sie können nur Parameter auslassen, aufrufen.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method always returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Methode gibt immer <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following program obtains the type of <ph id="ph1">`MyClass1`</ph> class, gets the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object matching the specified binding flags, and displays the signature of the constructor.</source>
          <target state="translated">Das folgende Programm ruft den Typ der <ph id="ph1">`MyClass1`</ph> -Klasse ruft die <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> -Objekt den angegebenen Bindungsflags und zeigt die Signatur des Konstruktors.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Eines der Elemente in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> und <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> weisen nicht die gleiche Länge auf.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">0 (null), damit <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Ein Nullverweis (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), wenn <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph> verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</source>
          <target state="translated">Das Objekt, das die Regeln für die Reihenfolge und das Layout von Argumenten, die Art der Übergabe des Rückgabewerts, die für Argumente zu verwendenden Register und die Art der Stapelbereinigung angibt.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the constructor to get.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, das Anzahl, Reihenfolge und Typ der Parameter des abzurufenden Konstruktors darstellt.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</source>
          <target state="translated">Ein leeres Array vom <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Typ, d. h. Type[] types = new Type[0], zum Abrufen eines Konstruktors, der keine Parameter akzeptiert.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph>-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>-Array zugeordnet sind.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">Der Standardbinder verarbeitet diesen Parameter nicht.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
          <target state="translated">Sucht einen Konstruktor, dessen Parameter den angegebenen Argumenttypen und -modifizierern entsprechen, und berücksichtigt dabei die angegebenen Bindungseinschränkungen und die angegebene Aufrufkonvention.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the constructor that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das den Konstruktor darstellt, der den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Obwohl der Standardbinder nicht verarbeitet <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (die <ph id="ph2">`modifiers`</ph> Parameter), können Sie die abstrakte <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If an exact match does not exist, the <ph id="ph1">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id="ph2">`types`</ph> array in order to select a match.</source>
          <target state="translated">Wenn eine genaue Übereinstimmung nicht vorhanden ist, die <ph id="ph1">`binder`</ph> wird versucht, die im angegebenen Parametertypen zu konvertieren die <ph id="ph2">`types`</ph> Array um eine Übereinstimmung zu aktivieren.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the <ph id="ph1">`binder`</ph> is unable to select a match, then <ph id="ph2">`null`</ph> is returned.</source>
          <target state="translated">Wenn die <ph id="ph1">`binder`</ph> kann eine Übereinstimmung, wählen Sie dann <ph id="ph2">`null`</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Filterkennzeichnungen genutzt werden, welche Konstruktoren in die Suche einbezogen werden:</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Instance`</ph> oder <ph id="ph2">`BindingFlags.Static`</ph> ändern, um einen Rückgabewert zu erhalten.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public constructors in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Public`</ph> öffentliche Konstruktoren in die Suche eingeschlossen werden sollen.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.NonPublic`</ph> nicht öffentlichen Konstruktoren (d. h. private, interne und geschützte Konstruktoren) in die Suche eingeschlossen werden sollen.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To get the class initializer (.cctor) using this method, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Um die klasseninitialisierung (".cctor"), die mit dieser Methode zu erhalten, müssen Sie angeben <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph4">`Or`</ph> <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die <ph id="ph1">`Get`</ph> Methoden, wenn für einen Typ reflektieren.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Member Type</source>
          <target state="translated">Memberart</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Static</source>
          <target state="translated">Statisch</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Non-Static</source>
          <target state="translated">Nicht statische</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Constructor</source>
          <target state="translated">Konstruktor</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Field</source>
          <target state="translated">Feld</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Ein Feld ist immer nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Method</source>
          <target state="translated">Methode</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Nested Type</source>
          <target state="translated">Geschachtelten Typs</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Property</source>
          <target state="translated">Eigenschaft</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>This is a binary comparison.</source>
          <target state="translated">Dies ist ein binärer Vergleich.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Sie können nur Parameter auslassen, aufrufen.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method always returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Methode gibt immer <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following example obtains the type of <ph id="ph1">`MyClass1`</ph>, gets the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> object that matches the specified binding flags, and displays the constructor signature.</source>
          <target state="translated">Das folgende Beispiel ruft den Typ der <ph id="ph1">`MyClass1`</ph>, ruft der <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> Objekt, das den angegebenen Bindungsflags entspricht, und zeigt die Signatur des Konstruktors.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Eines der Elemente in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> und <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> weisen nicht die gleiche Länge auf.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">0 (null), damit <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Ein Nullverweis (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), wenn <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph> verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</source>
          <target state="translated">Das Objekt, das die Regeln für die Reihenfolge und das Layout von Argumenten, die Art der Übergabe des Rückgabewerts, die für Argumente zu verwendenden Register und die Art der Stapelbereinigung angibt.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the constructor to get.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, das Anzahl, Reihenfolge und Typ der Parameter des abzurufenden Konstruktors darstellt.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</source>
          <target state="translated">Ein leeres Array vom <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Typ, d. h. Type[] types = new Type[0], zum Abrufen eines Konstruktors, der keine Parameter akzeptiert.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph>-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>-Array zugeordnet sind.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">Der Standardbinder verarbeitet diesen Parameter nicht.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
          <target state="translated">Sucht beim Überschreiben in einer abgeleiteten Klasse, unter Verwendung der angegebenen Bindungseinschränkungen und der angegebenen Aufrufkonvention, nach einem Konstruktor, dessen Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> object representing the constructor that matches the specified requirements, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>-Objekt, das den Konstruktor darstellt, der den angegebenen Anforderungen entspricht, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn kein entsprechender Konstruktor gefunden wurde.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Obwohl der Standardbinder nicht verarbeitet <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (die <ph id="ph2">`modifiers`</ph> Parameter), können Sie die abstrakte <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If an exact match does not exist, the <ph id="ph1">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id="ph2">`types`</ph> array in order to select a match.</source>
          <target state="translated">Wenn eine genaue Übereinstimmung nicht vorhanden ist, die <ph id="ph1">`binder`</ph> wird versucht, die im angegebenen Parametertypen zu konvertieren die <ph id="ph2">`types`</ph> Array um eine Übereinstimmung zu aktivieren.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the <ph id="ph1">`binder`</ph> is unable to select a match, then <ph id="ph2">`null`</ph> is returned.</source>
          <target state="translated">Wenn die <ph id="ph1">`binder`</ph> kann eine Übereinstimmung, wählen Sie dann <ph id="ph2">`null`</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Filterkennzeichnungen genutzt werden, welche Konstruktoren in die Suche einbezogen werden:</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Instance`</ph> oder <ph id="ph2">`BindingFlags.Static`</ph> ändern, um einen Rückgabewert zu erhalten.</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public constructors in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Public`</ph> öffentliche Konstruktoren in die Suche eingeschlossen werden sollen.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.NonPublic`</ph> nicht öffentlichen Konstruktoren (d. h. private, interne und geschützte Konstruktoren) in die Suche eingeschlossen werden sollen.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>This method implements <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>.</source>
          <target state="translated">Diese Methode implementiert <ph id="ph1">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Eines der Elemente in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> und <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> weisen nicht die gleiche Länge auf.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The current type is a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>.</source>
          <target state="translated">Der aktuelle Typ ist ein <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> oder ein <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the constructors of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft die Konstruktoren des aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors">
          <source>Returns all the public constructors defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Gibt alle öffentlichen Konstruktoren zurück, die für den aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> definiert sind.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> objects representing all the public instance constructors defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, but not including the type initializer (static constructor).</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> -Objekten, die alle für den aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> definierten öffentlichen Instanzkonstruktoren mit Ausnahme des Typinitialisierers (statischer Konstruktor) darstellen.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors">
          <source>If no public instance constructors are defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, or if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> represents a type parameter in the definition of a generic type or generic method, an empty array of type <ph id="ph3">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> is returned.</source>
          <target state="translated">Wenn für den aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> keine öffentlichen Instanzkonstruktoren definiert sind oder der aktuelle <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> einen Typparameter einer generischen Typ- oder Methodendefinition darstellt, wird ein leeres Array vom Typ <ph id="ph3">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> zurückgegeben.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method does not return constructors in a particular order, such as declaration order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> Methode gibt keinen Konstruktoren in einer bestimmten Reihenfolge, z. B. die Reihenfolge der Deklaration zurück.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Your code must not depend on the order in which constructors are returned, because that order varies.</source>
          <target state="translated">Code muss nicht abhängig von der Reihenfolge, in der Konstruktoren zurückgegeben werden, da, bei der Reihenfolge.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die <ph id="ph1">`Get`</ph> Methoden, wenn für einen Typ reflektieren.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Member Type</source>
          <target state="translated">Memberart</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Static</source>
          <target state="translated">Statisch</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Non-Static</source>
          <target state="translated">Nicht statische</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Constructor</source>
          <target state="translated">Konstruktor</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Field</source>
          <target state="translated">Feld</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Ein Feld ist immer nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Method</source>
          <target state="translated">Methode</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Nested Type</source>
          <target state="translated">Geschachtelten Typs</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Property</source>
          <target state="translated">Eigenschaft</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>This is a binary comparison.</source>
          <target state="translated">Dies ist ein binärer Vergleich.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>This method overload calls the <ph id="ph1">&lt;xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29&gt;</ph> method overload, with <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Diese methodenüberladung Ruft die <ph id="ph1">&lt;xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29&gt;</ph> -methodenüberladung mit <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>It will not find class initializers (.cctor).</source>
          <target state="translated">Es findet keine Klasseninitialisierer (".cctor").</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>To find class initializers, use an overload that takes <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Um Klasseninitialisierer zu ermitteln, verwenden Sie eine Überladung mit <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, und geben Sie <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>For example, if class <ph id="ph1">`C&lt;T&gt;`</ph> has a constructor <ph id="ph2">`C(T t1)`</ph> (<ph id="ph3">`Sub New(ByVal t1 As T)`</ph> in Visual Basic), calling <ph id="ph4">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> on <ph id="ph5">`C&lt;int&gt;`</ph> returns a <ph id="ph6">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> that represents <ph id="ph7">`C(int t1)`</ph> in C# (<ph id="ph8">`Sub New(ByVal t1 As Integer)`</ph> in Visual Basic).</source>
          <target state="translated">Z. B. Wenn Klasse <ph id="ph1">`C&lt;T&gt;`</ph> verfügt über einen Konstruktor <ph id="ph2">`C(T t1)`</ph> (<ph id="ph3">`Sub New(ByVal t1 As T)`</ph> in Visual Basic) wird beim Aufrufen <ph id="ph4">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> auf <ph id="ph5">`C&lt;int&gt;`</ph> gibt eine <ph id="ph6">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> darstellt, die <ph id="ph7">`C(int t1)`</ph> in c# (<ph id="ph8">`Sub New(ByVal t1 As Integer)`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type parameter, the <ph id="ph2">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method returns an empty array.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen generischen Typparameter der <ph id="ph2">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> Methode ein leeres Array zurück.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>This example shows the output of the <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> overload from a class that has two instance constructors and one static constructor.</source>
          <target state="translated">Dieses Beispiel zeigt die Ausgabe der <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> Überladen von einer Klasse, die zwei Instanzkonstruktoren und einen statischen Konstruktor verfügt.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>The output of this code is:</source>
          <target state="translated">Die Ausgabe dieses Codes lautet:</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Because the <ph id="ph1">&lt;xref:System.Type.GetConstructors&gt;</ph> overload uses only <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>, the static constructor is neither counted by the <ph id="ph4">`for`</ph> expression nor evaluated by <ph id="ph5">`IsStatic`</ph>.</source>
          <target state="translated">Da die <ph id="ph1">&lt;xref:System.Type.GetConstructors&gt;</ph> Überladung verwendet nur <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> und <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>, der statische Konstruktor ist weder gezählt, indem die <ph id="ph4">`for`</ph> Ausdruck noch ausgewertet, indem <ph id="ph5">`IsStatic`</ph>.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>To find static constructors, use the <ph id="ph1">&lt;xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29&gt;</ph> overload, and pass the combination (logical <ph id="ph2">`OR`</ph>) of <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>, as shown in the following code example:</source>
          <target state="translated">Um statische Konstruktoren zu ermitteln, verwenden Sie die <ph id="ph1">&lt;xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29&gt;</ph> überladen, und übergeben Sie die Kombination (logische <ph id="ph2">`OR`</ph>) des <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>, <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>, wie im folgenden Codebeispiel wird gezeigt:</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>Now the output is:</source>
          <target state="translated">Jetzt ist die Ausgabe:</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>True</source>
          <target state="translated">True</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">0 (null), damit <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the constructors defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified <ph id="ph2">&lt;see langword="BindingFlags" /&gt;</ph>.</source>
          <target state="translated">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> die für den aktuellen <ph id="ph2">&lt;see langword="BindingFlags" /&gt;</ph> definierten Konstruktoren.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> objects representing all constructors defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints, including the type initializer if it is defined.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph>-Objekten, die sämtliche für den aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> definierten Konstruktoren, einschließlich eines ggf. definierten Typinitialisierers, darstellen, die den angegebenen Bindungseinschränkungen entsprechen.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Returns an empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> if no constructors are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, if none of the defined constructors match the binding constraints, or if the current <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> represents a type parameter in the definition of a generic type or generic method.</source>
          <target state="translated">Gibt ein leeres Array vom Typ <ph id="ph1">&lt;see cref="T:System.Reflection.ConstructorInfo" /&gt;</ph> zurück, wenn für den aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> keine Konstruktoren definiert sind, keiner der definierten Konstruktoren den Bindungseinschränkungen entspricht oder der aktuelle <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> einen Typparameter einer generischen Typ- oder Methodendefinition darstellt.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method does not return constructors in a particular order, such as declaration order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> Methode gibt keinen Konstruktoren in einer bestimmten Reihenfolge, z. B. die Reihenfolge der Deklaration zurück.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which constructors are returned, because that order varies.</source>
          <target state="translated">Code muss nicht abhängig von der Reihenfolge, in der Konstruktoren zurückgegeben werden, da, bei der Reihenfolge.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`bindingAttr`</ph> can be used to specify whether to return only public constructors or both public and non-public constructors.</source>
          <target state="translated"><ph id="ph1">`bindingAttr`</ph> kann verwendet werden, um anzugeben, ob nur öffentliche oder öffentlichen und nicht öffentlichen Konstruktoren zurück.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>If an exact match does not exist, the <ph id="ph1">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id="ph2">`types`</ph> array in order to select a match.</source>
          <target state="translated">Wenn eine genaue Übereinstimmung nicht vorhanden ist, die <ph id="ph1">`binder`</ph> wird versucht, die im angegebenen Parametertypen zu konvertieren die <ph id="ph2">`types`</ph> Array um eine Übereinstimmung zu aktivieren.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>If the <ph id="ph1">`binder`</ph> is unable to select a match, then <ph id="ph2">`null`</ph> is returned.</source>
          <target state="translated">Wenn die <ph id="ph1">`binder`</ph> kann eine Übereinstimmung, wählen Sie dann <ph id="ph2">`null`</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Filterkennzeichnungen genutzt werden, welche Konstruktoren in die Suche einbezogen werden:</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Instance`</ph> oder <ph id="ph2">`BindingFlags.Static`</ph> ändern, um einen Rückgabewert zu erhalten.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public constructors in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Public`</ph> öffentliche Konstruktoren in die Suche eingeschlossen werden sollen.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.NonPublic`</ph> nicht öffentlichen Konstruktoren (d. h. private, interne und geschützte Konstruktoren) in die Suche eingeschlossen werden sollen.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Constructors of base classes are not returned.</source>
          <target state="translated">Konstruktoren von Basisklassen werden nicht zurückgegeben.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>To get the class initializer (.cctor) using this method overload, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Um die klasseninitialisierung (".cctor"), die Verwendung dieser methodenüberladung zu erhalten, müssen Sie angeben <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph4">`Or`</ph> <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>For example, if class <ph id="ph1">`C&lt;T&gt;`</ph> has a constructor <ph id="ph2">`C(T t1)`</ph> (<ph id="ph3">`Sub New(ByVal t1 As T)`</ph> in Visual Basic), calling <ph id="ph4">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> on <ph id="ph5">`C&lt;int&gt;`</ph> returns a <ph id="ph6">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> that represents <ph id="ph7">`C(int t1)`</ph> in C# (<ph id="ph8">`Sub New(ByVal t1 As Integer)`</ph> in Visual Basic).</source>
          <target state="translated">Z. B. Wenn Klasse <ph id="ph1">`C&lt;T&gt;`</ph> verfügt über einen Konstruktor <ph id="ph2">`C(T t1)`</ph> (<ph id="ph3">`Sub New(ByVal t1 As T)`</ph> in Visual Basic) wird beim Aufrufen <ph id="ph4">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> auf <ph id="ph5">`C&lt;int&gt;`</ph> gibt eine <ph id="ph6">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> darstellt, die <ph id="ph7">`C(int t1)`</ph> in c# (<ph id="ph8">`Sub New(ByVal t1 As Integer)`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type parameter, the <ph id="ph2">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method returns an empty array.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen generischen Typparameter der <ph id="ph2">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> Methode ein leeres Array zurück.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>This example shows the output of the <ph id="ph1">&lt;xref:System.Type.GetConstructors&gt;</ph> overload from a class that has two instance constructors and one static constructor.</source>
          <target state="translated">Dieses Beispiel zeigt die Ausgabe der <ph id="ph1">&lt;xref:System.Type.GetConstructors&gt;</ph> Überladen von einer Klasse, die zwei Instanzkonstruktoren und einen statischen Konstruktor verfügt.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>The output of this code is:</source>
          <target state="translated">Die Ausgabe dieses Codes lautet:</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>2</source>
          <target state="translated">2</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Because the <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> overload uses only <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance&gt;</ph>, the static constructor is neither counted by the <ph id="ph4">`for`</ph> expression nor evaluated by <ph id="ph5">`IsStatic`</ph>.</source>
          <target state="translated">Da die <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> Überladung verwendet nur <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public&gt;</ph> und <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance&gt;</ph>, der statische Konstruktor ist weder gezählt, indem die <ph id="ph4">`for`</ph> Ausdruck noch ausgewertet, indem <ph id="ph5">`IsStatic`</ph>.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>To find static constructors, use the <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> overload, and pass it the combination (logical OR) of <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>, as shown in the following code example:</source>
          <target state="translated">Um statische Konstruktoren zu ermitteln, verwenden Sie die <ph id="ph1">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> überladen, und übergeben sie die Kombination (logisches OR) von <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph>, <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph>, <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph>, <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>, wie im folgenden Codebeispiel gezeigt:</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>Now the output is:</source>
          <target state="translated">Jetzt ist die Ausgabe:</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>3</source>
          <target state="translated">3</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>True</source>
          <target state="translated">True</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetConstructors(System.Reflection.BindingFlags)">
          <source>False</source>
          <target state="translated">False</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" uid="M:System.Type.GetDefaultMembers">
          <source>Searches for the members defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> whose <ph id="ph2">&lt;see cref="T:System.Reflection.DefaultMemberAttribute" /&gt;</ph> is set.</source>
          <target state="translated">Sucht nach den für den aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> definierten Membern, deren <ph id="ph2">&lt;see cref="T:System.Reflection.DefaultMemberAttribute" /&gt;</ph> festgelegt ist.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" uid="M:System.Type.GetDefaultMembers">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing all default members of the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>-Objekten, die alle Standardmember des aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> darstellen.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" uid="M:System.Type.GetDefaultMembers">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" uid="M:System.Type.GetDefaultMembers">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have default members.</source>
          <target state="translated">Ein leeres Array vom <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>-Typ, wenn der aktuelle <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> keine Standardmember besitzt.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetDefaultMembers%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetDefaultMembers%2A&gt;</ph> Methode gibt keinen zurück Mitglieder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">Der Code muss nicht richten sich nach der Reihenfolge, in der Elemente zurückgegeben werden, da, bei der Reihenfolge.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">Member enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die <ph id="ph1">`Get`</ph> Methoden, wenn für einen Typ reflektieren.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Member Type</source>
          <target state="translated">Memberart</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Static</source>
          <target state="translated">Statisch</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Non-Static</source>
          <target state="translated">Nicht statische</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Constructor</source>
          <target state="translated">Konstruktor</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Field</source>
          <target state="translated">Feld</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Ein Feld ist immer nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Method</source>
          <target state="translated">Methode</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Nested Type</source>
          <target state="translated">Geschachtelten Typs</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Property</source>
          <target state="translated">Eigenschaft</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>This is a binary comparison.</source>
          <target state="translated">Dies ist ein binärer Vergleich.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>For example, if class <ph id="ph1">`C&lt;T&gt;`</ph> has a property <ph id="ph2">`P`</ph> that returns <ph id="ph3">`T`</ph>, calling <ph id="ph4">&lt;xref:System.Type.GetDefaultMembers%2A&gt;</ph> on <ph id="ph5">`C&lt;int&gt;`</ph> returns <ph id="ph6">`int P`</ph> in C# (<ph id="ph7">`Property P As Integer`</ph> in Visual Basic).</source>
          <target state="translated">Z. B. Wenn Klasse <ph id="ph1">`C&lt;T&gt;`</ph> verfügt über eine Eigenschaft <ph id="ph2">`P`</ph> zurückgibt <ph id="ph3">`T`</ph>Aufrufen <ph id="ph4">&lt;xref:System.Type.GetDefaultMembers%2A&gt;</ph> auf <ph id="ph5">`C&lt;int&gt;`</ph> gibt <ph id="ph6">`int P`</ph> in c# (<ph id="ph7">`Property P As Integer`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Mitglieder der Class-Einschränkung oder die Elemente der <ph id="ph2">&lt;xref:System.Object&gt;</ph> Wenn ohne klasseneinschränkung ist.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetDefaultMembers">
          <source>The following example obtains the default member information of <ph id="ph1">`MyClass`</ph> and displays the default members.</source>
          <target state="translated">Das folgende Beispiel ruft Informationen über das Element der <ph id="ph1">`MyClass`</ph> und die Standardelemente angezeigt.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" uid="M:System.Type.GetElementType">
          <source>When overridden in a derived class, returns the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the object encompassed or referred to by the current array, pointer or reference type.</source>
          <target state="translated">Gibt beim Überschreiben in einer abgeleiteten Klasse den <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> des Objekts zurück, das der aktuelle Array-, Zeiger- oder Verweistyp einschließt bzw. auf das er verweist.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" uid="M:System.Type.GetElementType">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the object encompassed or referred to by the current array, pointer, or reference type, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the current <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> des eingeschlossenen Objekts bzw. des Objekts, auf das durch den aktuellen Array-, Zeiger- oder Verweistyp verwiesen wird, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn der aktuelle <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> kein Array oder Zeiger ist, nicht als Verweis übergeben wurde oder einen generischen Typ oder Typparameter einer generischen Typ- oder Methodendefinition darstellt.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetElementType">
          <source>This method returns <ph id="ph1">`null`</ph> for the <ph id="ph2">&lt;xref:System.Array&gt;</ph> class.</source>
          <target state="translated">Diese Methode gibt <ph id="ph1">`null`</ph> für die <ph id="ph2">&lt;xref:System.Array&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetElementType">
          <source>The following example demonstrates using the <ph id="ph1">`GetElementType`</ph> method.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung der <ph id="ph1">`GetElementType`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source>The value whose name is to be retrieved.</source>
          <target state="translated">Der Wert, dessen Name abgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source>Returns the name of the constant that has the specified value, for the current enumeration type.</source>
          <target state="translated">Gibt den Namen der Konstanten für den aktuellen Enumerationstyp zurück, die den angegebenen Wert aufweist.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source>The name of the member of the current enumeration type that has the specified value, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no such constant is found.</source>
          <target state="translated">Der Name des Members des aktuellen Enumerationstyps, der über den angegebenen Wert verfügt, oder<ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn keine solche Konstante gefunden wird.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source>The current type is not an enumeration.</source>
          <target state="translated">Der aktuelle Typ ist keine Enumeration.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is neither of the current type nor does it have the same underlying type as the current type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist weder vom aktuellen Typ noch er hat den gleichen zugrunde liegenden Typ wie der aktuelle Typ.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumName(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumNames">
          <source>Returns the names of the members of the current enumeration type.</source>
          <target state="translated">Gibt die Namen der Member des aktuellen Enumerationstyps zurück.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumNames">
          <source>An array that contains the names of the members of the enumeration.</source>
          <target state="translated">Ein Array, das die Namen der Member der Enumeration enthält.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEnumNames">
          <source>The elements of the return value array are sorted by the binary values (that is, the unsigned values) of the enumerated constants.</source>
          <target state="translated">Die Elemente des Arrays Rückgabewert sind nach den Binärwerten (d. h. aus den Werten ohne Vorzeichen) der Enumerationskonstanten sortiert.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEnumNames">
          <source>If the array contains enumerated constants with the same value, the order of their corresponding names is unspecified.</source>
          <target state="translated">Wenn das Array Enumerationskonstanten mit demselben Wert enthält, ist die Reihenfolge der entsprechenden Namen nicht angegeben.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumNames">
          <source>The current type is not an enumeration.</source>
          <target state="translated">Der aktuelle Typ ist keine Enumeration.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumUnderlyingType">
          <source>Returns the underlying type of the current enumeration type.</source>
          <target state="translated">Gibt den zugrunde liegenden Typ des aktuellen Enumerationstyps zurück.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumUnderlyingType">
          <source>The underlying type of the current enumeration.</source>
          <target state="translated">Der zugrunde liegende Typ der aktuellen Enumeration.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEnumUnderlyingType">
          <source>By default, the underlying type of an enumeration in C# and Visual Basic is <ph id="ph1">&lt;xref:System.Int32&gt;</ph>.</source>
          <target state="translated">Standardmäßig ist der zugrunde liegende Typ einer Enumeration in c# und Visual Basic <ph id="ph1">&lt;xref:System.Int32&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEnumUnderlyingType">
          <source>Other integer types can be specified.</source>
          <target state="translated">Andere ganzzahlige Typen können angegeben werden.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumUnderlyingType">
          <source>The current type is not an enumeration.</source>
          <target state="translated">Der aktuelle Typ ist keine Enumeration.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumUnderlyingType">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumUnderlyingType">
          <source>The enumeration type is not valid, because it contains more than one instance field.</source>
          <target state="translated">Der Enumerationstyp ist ungültig, da er mehr als ein Instanzfeld enthält.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumValues">
          <source>Returns an array of the values of the constants in the current enumeration type.</source>
          <target state="translated">Gibt ein Array mit den Werten der Konstanten im aktuellen Enumerationstyp zurück.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumValues">
          <source>An array that contains the values.</source>
          <target state="translated">Ein Array, das die Werte enthält.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumValues">
          <source>The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.</source>
          <target state="translated">Die Elemente des Arrays sind nach den Binärwerten (den Werten ohne Vorzeichen) der Enumerationskonstanten sortiert.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.Type.GetEnumValues">
          <source>The current type is not an enumeration.</source>
          <target state="translated">Der aktuelle Typ ist keine Enumeration.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific event declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft ein bestimmtes Ereignis ab, das vom aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> deklariert oder geerbt wurde.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String)">
          <source>The string containing the name of an event that is declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Die Zeichenfolge, die den Namen eines vom aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> deklarierten oder geerbten Ereignisses enthält.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String)">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> object representing the specified public event.</source>
          <target state="translated">Gibt das <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>-Objekt zurück, das das angegebene öffentliche Ereignis darstellt.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String)">
          <source>The object representing the specified public event that is declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Das Objekt, das das angegebene vom aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> deklarierte oder geerbte öffentliche Ereignis darstellt, sofern gefunden, andernfalls <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>An event is considered public to reflection if it has at least one method or accessor that is public.</source>
          <target state="translated">Ein Ereignis ist Reflektion als öffentlich betrachtet, wenn sie verfügt über mindestens eine Methode oder Accessor, der öffentlich ist.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Otherwise the event is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">Andernfalls wird das Ereignis als privat betrachtet, und Sie müssen <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, kombinieren Sie die Werte mit <ph id="ph4">`Or`</ph>) zum Abrufen.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">Die Suche nach <ph id="ph1">`name`</ph> Groß-/Kleinschreibung beachtet.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The search includes public static and public instance events.</source>
          <target state="translated">Die Suche enthält öffentliche statisch und öffentlich Instanz Ereignisse.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die <ph id="ph1">`Get`</ph> Methoden, wenn für einen Typ reflektieren.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Member Type</source>
          <target state="translated">Memberart</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Static</source>
          <target state="translated">Statisch</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Non-Static</source>
          <target state="translated">Nicht statische</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Constructor</source>
          <target state="translated">Konstruktor</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Field</source>
          <target state="translated">Feld</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Ein Feld ist immer nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Method</source>
          <target state="translated">Methode</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Nested Type</source>
          <target state="translated">Geschachtelten Typs</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Property</source>
          <target state="translated">Eigenschaft</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>This is a binary comparison.</source>
          <target state="translated">Dies ist ein binärer Vergleich.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Ereignisse der Class-Einschränkung.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String)">
          <source>The following example creates an <ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph> object and gets the event for a button class for the specified event.</source>
          <target state="translated">Das folgende Beispiel erstellt ein <ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph> -Objekt und ruft das Ereignis für eine Schaltfläche für das angegebene Ereignis ab.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of an event which is declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Die Zeichenfolge, die den Namen eines vom aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> deklarierten oder geerbten Ereignisses enthält.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">0 (null), damit <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, returns the <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> object representing the specified event, using the specified binding constraints.</source>
          <target state="translated">Gibt beim Überschreiben in einer abgeleiteten Klasse das <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>-Objekt zurück, das das angegebene Ereignis unter Verwendung der angegebenen Bindungseinschränkungen darstellt.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The object representing the specified event that is declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Das Objekt, das das angegebene vom aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> deklarierte oder geerbte Ereignis darstellt, sofern gefunden, andernfalls <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which events to include in the search:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Filterkennzeichnungen genutzt werden, welche Ereignisse in die Suche einbezogen werden:</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Instance`</ph> oder <ph id="ph2">`BindingFlags.Static`</ph> ändern, um einen Rückgabewert zu erhalten.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public events in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Public`</ph> öffentlichen Ereignisse in die Suche eingeschlossen.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public events (that is, private, internal, and protected events) in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.NonPublic`</ph> an nicht öffentlichen Ereignisse (d. h. private, interne und geschützte) in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> einschließen <ph id="ph2">`public`</ph> und <ph id="ph3">`protected`</ph> statische Member der Hierarchie; nach oben <ph id="ph4">`private`</ph> statische Member in geerbten Klassen sind nicht eingeschlossen.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> um die Groß-/Kleinschreibung ignorieren <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the events declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not events that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> Suchen Sie nur die Ereignisse, die deklariert wird, auf die <ph id="ph2">&lt;xref:System.Type&gt;</ph>, nicht die Ereignisse, die nur geerbt wurden.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>An event is considered public to reflection if it has at least one method or accessor that is public.</source>
          <target state="translated">Ein Ereignis ist Reflektion als öffentlich betrachtet, wenn sie verfügt über mindestens eine Methode oder Accessor, der öffentlich ist.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>Otherwise the event is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">Andernfalls wird das Ereignis als privat betrachtet, und Sie müssen <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, kombinieren Sie die Werte mit <ph id="ph4">`Or`</ph>) zum Abrufen.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Ereignisse der Class-Einschränkung.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> method to search a type for a public or non-public event named "Click" that is not <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</source>
          <target state="translated">Im folgenden Codebeispiel wird mit der <ph id="ph1">&lt;xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> Methode, um einen Typ für einen öffentlichen oder nicht öffentlichen-Ereignis mit dem Namen "Klicken Sie auf" suchen, die nicht <ph id="ph2">`static`</ph> (<ph id="ph3">`Shared`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the events that are declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft die vom aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> deklarierten oder geerbten Ereignisse ab.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents">
          <source>Returns all the public events that are declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Gibt sämtliche vom aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> deklarierten oder geerbten öffentlichen Ereignisse zurück.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> objects representing all the public events which are declared or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Gibt ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>-Objekten zurück, die sämtliche vom aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> deklarierten oder geerbten öffentlichen Ereignisse darstellen.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have public events.</source>
          <target state="translated">Ein leeres Array vom <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>-Typ, wenn der aktuelle <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> keine öffentlichen Ereignisse besitzt.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>An event is considered public to reflection if it has at least one method or accessor that is public.</source>
          <target state="translated">Ein Ereignis ist Reflektion als öffentlich betrachtet, wenn sie verfügt über mindestens eine Methode oder Accessor, der öffentlich ist.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Otherwise the event is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">Andernfalls wird das Ereignis als privat betrachtet, und Sie müssen <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, kombinieren Sie die Werte mit <ph id="ph4">`Or`</ph>) zum Abrufen.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetEvents%2A&gt;</ph> method does not return events in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetEvents%2A&gt;</ph> Methode gibt keinen zurück Ereignisse in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Your code must not depend on the order in which events are returned, because that order varies.</source>
          <target state="translated">Der Code muss nicht richten sich nach der Reihenfolge, in der Ereignisse zurückgegeben werden, da, bei der Reihenfolge.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die <ph id="ph1">`Get`</ph> Methoden, wenn für einen Typ reflektieren.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Member Type</source>
          <target state="translated">Memberart</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Static</source>
          <target state="translated">Statisch</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Non-Static</source>
          <target state="translated">Nicht statische</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Constructor</source>
          <target state="translated">Konstruktor</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Field</source>
          <target state="translated">Feld</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Ein Feld ist immer nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Method</source>
          <target state="translated">Methode</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Nested Type</source>
          <target state="translated">Geschachtelten Typs</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Property</source>
          <target state="translated">Eigenschaft</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>This is a binary comparison.</source>
          <target state="translated">Dies ist ein binärer Vergleich.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Ereignisse der Class-Einschränkung.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>The following example obtains an array of <ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph> objects, gets all the events for a <ph id="ph2">`Button`</ph> class, and displays the event names.</source>
          <target state="translated">Im folgende Beispiel ruft ein Array von <ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph> Objekte, ruft die Ereignisse für eine <ph id="ph2">`Button`</ph> Klasse, und die Ereignisnamen angezeigt.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents">
          <source>To compile the Visual Basic example, use the following command line:</source>
          <target state="translated">Um die Visual Basic-Beispiel zu kompilieren, verwenden Sie die folgende Befehlszeile ein:</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">0 (null), damit <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for events that are declared or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen nach vom aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> definierten oder geerbten Ereignissen.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph> objects representing all events that are declared or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>-Objekten, die sämtliche vom aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> deklarierten oder geerbten Ereignisse darstellen, die den angegebenen Bindungseinschränkungen entsprechen.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have events, or if none of the events match the binding constraints.</source>
          <target state="translated">Ein leeres Array vom <ph id="ph1">&lt;see cref="T:System.Reflection.EventInfo" /&gt;</ph>-Typ, wenn der aktuelle <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> keine Ereignisse besitzt oder keines der Ereignisse den Bindungseinschränkungen entspricht.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetEvents%2A&gt;</ph> method does not return events in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetEvents%2A&gt;</ph> Methode gibt keinen zurück Ereignisse in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which events are returned, because that order varies.</source>
          <target state="translated">Der Code muss nicht richten sich nach der Reihenfolge, in der Ereignisse zurückgegeben werden, da, bei der Reihenfolge.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which events to include in the search:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Filterkennzeichnungen genutzt werden, welche Ereignisse in die Suche einbezogen werden:</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Instance`</ph> oder <ph id="ph2">`BindingFlags.Static`</ph> ändern, um einen Rückgabewert zu erhalten.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public events in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Public`</ph> öffentlichen Ereignisse in die Suche eingeschlossen.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public events (that is, private, internal, and protected events) in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.NonPublic`</ph> an nicht öffentlichen Ereignisse (d. h. private, interne und geschützte) in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Only protected and internal events on base classes are returned; private events on base classes are not returned.</source>
          <target state="translated">Nur geschützte und interne Ereignisse für Basisklassen werden zurückgegeben. Private Ereignisse für Basisklassen werden nicht zurückgegeben.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> einschließen <ph id="ph2">`public`</ph> und <ph id="ph3">`protected`</ph> statische Member der Hierarchie; nach oben <ph id="ph4">`private`</ph> statische Member in geerbten Klassen sind nicht eingeschlossen.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the events declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not events that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> Suchen Sie nur die Ereignisse, die deklariert wird, auf die <ph id="ph2">&lt;xref:System.Type&gt;</ph>, nicht die Ereignisse, die nur geerbt wurden.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>An event is considered public to reflection if it has at least one method or accessor that is public.</source>
          <target state="translated">Ein Ereignis ist Reflektion als öffentlich betrachtet, wenn sie verfügt über mindestens eine Methode oder Accessor, der öffentlich ist.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>Otherwise the event is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">Andernfalls wird das Ereignis als privat betrachtet, und Sie müssen <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, kombinieren Sie die Werte mit <ph id="ph4">`Or`</ph>) zum Abrufen.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.EventInfo&gt;</ph> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Ereignisse der Class-Einschränkung.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>The following example obtains an array of <ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph> objects that match the specified binding flags, gets all the events for a <ph id="ph2">`Button`</ph> class, and displays the event names.</source>
          <target state="translated">Im folgende Beispiel ruft ein Array von <ph id="ph1">&lt;xref:System.Reflection.EventInfo&gt;</ph> Objekte, die den angegebenen Bindungsflags übereinstimmen Ruft alle Ereignisse für eine <ph id="ph2">`Button`</ph> Klasse, und die Ereignisnamen angezeigt.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetEvents(System.Reflection.BindingFlags)">
          <source>To compile the Visual Basic example, use the following command line:</source>
          <target state="translated">Um die Visual Basic-Beispiel zu kompilieren, verwenden Sie die folgende Befehlszeile ein:</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific field of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft ein bestimmtes Feld des aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String)">
          <source>The string containing the name of the data field to get.</source>
          <target state="translated">Die Zeichenfolge, die den Namen des abzurufenden Datenfelds enthält.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String)">
          <source>Searches for the public field with the specified name.</source>
          <target state="translated">Sucht das öffentliche Feld mit dem angegebenen Namen.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String)">
          <source>An object representing the public field with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das das öffentliche Feld mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">Die Suche nach <ph id="ph1">`name`</ph> Groß-/Kleinschreibung beachtet.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String)">
          <source>The search includes public static and public instance fields.</source>
          <target state="translated">Die Suche enthält öffentliche statisch und öffentlich Instanzfelder.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Felder der Class-Einschränkung.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String)">
          <source>The following example gets the <ph id="ph1">`Type`</ph> object for the specified class, obtains the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object for the field, and displays the value of the field.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">`Type`</ph> -Objekt für die angegebene Klasse, erhält der <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> Objekt für das Feld und der Wert des Felds angezeigt.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String)">
          <source>This <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object is a <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> whose <ph id="ph3">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph> method has not yet been called.</source>
          <target state="translated">Dieses <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt ist ein <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>, dessen <ph id="ph3">&lt;see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /&gt;</ph>-Methode noch nicht aufgerufen wurde.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of the data field to get.</source>
          <target state="translated">Die Zeichenfolge, die den Namen des abzurufenden Datenfelds enthält.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">0 (null), damit <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Searches for the specified field, using the specified binding constraints.</source>
          <target state="translated">Sucht das angegebene Feld unter Verwendung der angegebenen Bindungseinschränkungen.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>An object representing the field that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das das Feld darstellt, das den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die <ph id="ph1">`Get`</ph> Methoden, wenn für einen Typ reflektieren.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Member Type</source>
          <target state="translated">Memberart</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Static</source>
          <target state="translated">Statisch</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Non-Static</source>
          <target state="translated">Nicht statische</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Constructor</source>
          <target state="translated">Konstruktor</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Field</source>
          <target state="translated">Feld</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Ein Feld ist immer nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Method</source>
          <target state="translated">Methode</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Nested Type</source>
          <target state="translated">Geschachtelten Typs</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Property</source>
          <target state="translated">Eigenschaft</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>This is a binary comparison.</source>
          <target state="translated">Dies ist ein binärer Vergleich.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which fields to include in the search:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Filterkennzeichnungen genutzt werden, welche Felder in die Suche einbezogen werden:</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Instance`</ph> oder <ph id="ph2">`BindingFlags.Static`</ph> ändern, um einen Rückgabewert zu erhalten.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public fields in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Public`</ph> öffentliche Felder in die Suche eingeschlossen werden sollen.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public fields (that is, private, internal, and protected fields) in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.NonPublic`</ph> nicht öffentlichen Felder (d. h. private, interne und geschützte Felder) in die Suche eingeschlossen werden sollen.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> einschließen <ph id="ph2">`public`</ph> und <ph id="ph3">`protected`</ph> statische Member der Hierarchie; nach oben <ph id="ph4">`private`</ph> statische Member in geerbten Klassen sind nicht eingeschlossen.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> um die Groß-/Kleinschreibung ignorieren <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the fields declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not fields that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> Suchen Sie nur die Felder, die deklariert wird, auf die <ph id="ph2">&lt;xref:System.Type&gt;</ph>, nicht nach Feldern, die nur geerbt wurden.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Felder der Class-Einschränkung.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source>The following example gets the <ph id="ph1">`Type`</ph> object for the specified class, obtains the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> object for the field that matches the specified binding flags, and displays the value of the field.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">`Type`</ph> -Objekt für die angegebene Klasse, erhält der <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> Objekt für das Feld, das den angegebenen Bindungsflags entspricht, und zeigt den Wert des Felds.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the fields of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft die Felder des aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields">
          <source>Returns all the public fields of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Gibt sämtliche öffentlichen Felder des aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> objects representing all the public fields defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>-Objekten, die alle für den aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> definierten öffentlichen Felder darstellen.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>, if no public fields are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ein leeres Array vom <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>-Typ, wenn für den aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> keine öffentlichen Felder definiert sind.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetFields%2A&gt;</ph> Methode gibt keinen zurück Felder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Your code must not depend on the order in which fields are returned, because that order varies.</source>
          <target state="translated">Der Code muss nicht richten sich nach der Reihenfolge, in der Felder zurückgegeben werden, da, bei der Reihenfolge.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die <ph id="ph1">`Get`</ph> Methoden, wenn für einen Typ reflektieren.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Member Type</source>
          <target state="translated">Memberart</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Static</source>
          <target state="translated">Statisch</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Non-Static</source>
          <target state="translated">Nicht statische</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Constructor</source>
          <target state="translated">Konstruktor</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Field</source>
          <target state="translated">Feld</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Ein Feld ist immer nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Method</source>
          <target state="translated">Methode</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Nested Type</source>
          <target state="translated">Geschachtelten Typs</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Property</source>
          <target state="translated">Eigenschaft</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>This is a binary comparison.</source>
          <target state="translated">Dies ist ein binärer Vergleich.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition diese Methode sucht die öffentlichen Felder von der Class-Einschränkung.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields">
          <source>The following example shows a use of the <ph id="ph1">`GetFields()`</ph> method.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung von der <ph id="ph1">`GetFields()`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">0 (null), damit <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the fields defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die für den aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> definierten Felder.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph> objects representing all fields defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>-Objekten, die sämtliche für den aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> definierten öffentlichen Felder darstellen, die den angegebenen Bindungseinschränkungen entsprechen.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>, if no fields are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, or if none of the defined fields match the binding constraints.</source>
          <target state="translated">Ein leeres Array vom <ph id="ph1">&lt;see cref="T:System.Reflection.FieldInfo" /&gt;</ph>-Typ, wenn für den aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> keine Felder definiert sind oder keines der definierten Felder den Bindungseinschränkungen entspricht.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetFields%2A&gt;</ph> Methode gibt keinen zurück Felder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which fields are returned, because that order varies.</source>
          <target state="translated">Der Code muss nicht richten sich nach der Reihenfolge, in der Felder zurückgegeben werden, da, bei der Reihenfolge.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which fields to include in the search:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Filterkennzeichnungen genutzt werden, welche Felder in die Suche einbezogen werden:</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Instance`</ph> oder <ph id="ph2">`BindingFlags.Static`</ph> ändern, um einen Rückgabewert zu erhalten.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public fields in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Public`</ph> öffentliche Felder in die Suche eingeschlossen werden sollen.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public fields (that is, private, internal, and protected fields) in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.NonPublic`</ph> nicht öffentlichen Felder (d. h. private, interne und geschützte Felder) in die Suche eingeschlossen werden sollen.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Only protected and internal fields on base classes are returned; private fields on base classes are not returned.</source>
          <target state="translated">Nur geschützte und interne Felder für Basisklassen werden zurückgegeben. private Felder für Basisklassen werden nicht zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> einschließen <ph id="ph2">`public`</ph> und <ph id="ph3">`protected`</ph> statische Member der Hierarchie; nach oben <ph id="ph4">`private`</ph> statische Member in geerbten Klassen sind nicht eingeschlossen.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the fields declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not fields that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> Suchen Sie nur die Felder, die deklariert wird, auf die <ph id="ph2">&lt;xref:System.Type&gt;</ph>, nicht nach Feldern, die nur geerbt wurden.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.FieldInfo&gt;</ph> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition diese Methode sucht die öffentlichen Felder von der Class-Einschränkung.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetFields(System.Reflection.BindingFlags)">
          <source>The following example shows a use of the <ph id="ph1">`GetFields(BindingFlags)`</ph> method.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung von der <ph id="ph1">`GetFields(BindingFlags)`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericArguments">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a closed generic type or the type parameters of a generic type definition.</source>
          <target state="translated">Gibt ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten zurück, die die Typargumente eines geschlossenen generischen Typs oder die Typparameter einer generischen Typdefinition darstellen.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericArguments">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the type arguments of a generic type.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die die Typargumente eines generischen Typs darstellen.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericArguments">
          <source>Returns an empty array if the current type is not a generic type.</source>
          <target state="translated">Gibt ein leeres Array zurück, wenn der aktuelle Typ kein generischer Typ ist.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>The array elements are returned in the order in which they appear in the list of type arguments for the generic type.</source>
          <target state="translated">Die Elemente des Arrays werden in der Reihenfolge zurückgegeben, in denen sie in der Liste der Typargumente für den generischen Typ angezeigt werden.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>If the current type is a closed constructed type (that is, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`false`</ph>), the array returned by the <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> method contains the types that have been assigned to the generic type parameters of the generic type definition.</source>
          <target state="translated">Wenn der aktuelle Typ ein geschlossen konstruierter Typ ist (d. h. die <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> -Eigenschaft gibt <ph id="ph2">`false`</ph>), das zurückgegebene Array die <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> Methode enthält die Typen, die die generischen Typparameter der generischen Typdefinition zugewiesen wurden .</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>If the current type is a generic type definition, the array contains the type parameters.</source>
          <target state="translated">Wenn der aktuelle Typ eine generische Typdefinition ist, enthält das Array die Typparameter an.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>If the current type is an open constructed type (that is, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>) in which specific types have not been assigned to all of the type parameters and type parameters of enclosing generic types or methods, the array contains both types and type parameters.</source>
          <target state="translated">Wenn der aktuelle Typ ein offener konstruierten Typ ist (d. h. die <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> -Eigenschaft gibt <ph id="ph2">`true`</ph>) in denen bestimmten Typen nicht für alle Typparameter und die Typparameter von einschließenden generischen Typen oder Methoden zugewiesen wurden, enthält das Array Typen und Typparametern.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to tell them apart.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> Eigenschaft, um Sie voneinander zu unterscheiden.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>For a demonstration of this scenario, see the code example for the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property.</source>
          <target state="translated">Eine Demonstration dieses Szenarios, finden Sie im Codebeispiel für die <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> method to display the type arguments of a constructed type and the type parameters of its generic type definition.</source>
          <target state="translated">Im folgenden Codebeispiel wird mit der <ph id="ph1">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> Methode, um die Typargumente eines konstruierten Typs und die Typparameter der generischen Typdefinition anzuzeigen.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>This code example is part of a larger example provided for the <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property.</source>
          <target state="translated">Dieses Codebeispiel ist Teil eines umfangreicheren Beispiels für die <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericArguments">
          <source>See the larger example for sample output.</source>
          <target state="translated">Siehe das größere Beispiel für die Ausgabe des Beispiels.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericArguments">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericArguments">
          <source>Derived classes must provide an implementation.</source>
          <target state="translated">Abgeleitete Klassen müssen eine Implementation angeben.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericParameterConstraints">
          <source>Returns an array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the constraints on the current generic type parameter.</source>
          <target state="translated">Gibt ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten zurück, die die Einschränkungen für den aktuellen generischen Typparameter darstellen.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericParameterConstraints">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects that represent the constraints on the current generic type parameter.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die die Einschränkungen für den aktuellen generischen Typparameter darstellen.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>Each constraint on a generic type parameter is expressed as a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object.</source>
          <target state="translated">Jede Einschränkung für einen generischen Typparameter wird als eine <ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsClass%2A&gt;</ph> property to determine whether a constraint is the base class constraint; if the property returns <ph id="ph2">`false`</ph>, the constraint is an interface constraint.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Type.IsClass%2A&gt;</ph> -Eigenschaft können Sie bestimmen, ob eine Einschränkung der base Class-Einschränkung ist; wenn die Eigenschaft zurückgibt <ph id="ph2">`false`</ph>, die Einschränkung ist eine schnittstelleneinschränkung.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>If a type parameter has no class constraint and no interface constraints, an empty array is returned.</source>
          <target state="translated">Wenn ein Typparameter ohne klasseneinschränkung und keine schnittstelleneinschränkungen verfügt, wird ein leeres Array zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>The following code example defines a generic type <ph id="ph1">`Test`</ph> with two type parameters that have different constraints.</source>
          <target state="translated">Das folgende Codebeispiel definiert einen generischen Typ <ph id="ph1">`Test`</ph> mit zwei Typparametern, die verschiedene Einschränkungen aufweisen.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericParameterConstraints">
          <source>When the program executes, the constraints are examined using the <ph id="ph1">&lt;xref:System.Type.GenericParameterAttributes%2A&gt;</ph> property and the <ph id="ph2">&lt;xref:System.Type.GetGenericParameterConstraints%2A&gt;</ph> method.</source>
          <target state="translated">Wenn das Programm ausgeführt wird, die Einschränkungen werden untersucht, mit der <ph id="ph1">&lt;xref:System.Type.GenericParameterAttributes%2A&gt;</ph> Eigenschaft und die <ph id="ph2">&lt;xref:System.Type.GetGenericParameterConstraints%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericParameterConstraints">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object is not a generic type parameter.</source>
          <target state="translated">Das aktuelle <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt ist kein generischer Typparameter.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericParameterConstraints">
          <source>That is, the <ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Das bedeutet, dass die <ph id="ph1">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph>-Eigenschaft <ph id="ph2">&lt;see langword="false" /&gt;</ph> zurückgibt.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a generic type definition from which the current generic type can be constructed.</source>
          <target state="translated">Gibt ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt zurück, das eine generische Typdefinition darstellt, aus der der aktuelle generische Typ konstruiert werden kann.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing a generic type from which the current type can be constructed.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt, das einen generischen Typ darstellt, aus dem der aktuelle Typ konstruiert werden kann.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>A generic type definition is a template from which other types can be constructed.</source>
          <target state="translated">Eine generische Typdefinition ist eine Vorlage aus der anderen Typen konstruiert werden können.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>For example, from the generic type definition <ph id="ph1">`G&lt;T&gt;`</ph> (expressed in C# syntax; <ph id="ph2">`G(Of T)`</ph> in Visual Basic or <ph id="ph3">`generic &lt;typename T&gt; ref class G`</ph> in C++) you can construct and instantiate the type <ph id="ph4">`G&lt;int&gt;`</ph> (<ph id="ph5">`G(Of Integer)`</ph> in Visual Basic).</source>
          <target state="translated">Z. B. von der generischen Typdefinition <ph id="ph1">`G&lt;T&gt;`</ph> (ausgedrückt in C#-Syntax; <ph id="ph2">`G(Of T)`</ph> in Visual Basic oder <ph id="ph3">`generic &lt;typename T&gt; ref class G`</ph> in C++) können Sie erstellen und instanziieren Sie den Typ <ph id="ph4">`G&lt;int&gt;`</ph> (<ph id="ph5">`G(Of Integer)`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>Given a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing this constructed type, the <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method returns the generic type definition.</source>
          <target state="translated">Erhält eine <ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekt, das dies darstellt konstruierter Typ, der <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> Methodenrückgabe die generische Typdefinition.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>If two constructed types are created from the same generic type definition, using the same type arguments, the <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method returns the same <ph id="ph2">&lt;xref:System.Type&gt;</ph> object for both types.</source>
          <target state="translated">Wenn zwei konstruierte Typen aus der gleichen generischen Typdefinition erstellt werden, verwenden Sie die gleichen Typargumente, die <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> Methodenrückgabe identisch <ph id="ph2">&lt;xref:System.Type&gt;</ph> Objekt für beide Typen.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>If you call the <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that already represents a generic type definition, it returns the current <ph id="ph3">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen der <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> Methode auf eine <ph id="ph2">&lt;xref:System.Type&gt;</ph> Objekt, das bereits eine generische Typdefinition darstellt gibt das aktuelle <ph id="ph3">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>An array of generic types is not itself generic.</source>
          <target state="translated">Ein Array von generischen Typen ist nicht selbst generisch.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>In the C# code <ph id="ph1">`A&lt;int&gt;[] v;`</ph> or the Visual Basic code <ph id="ph2">`Dim v() As A(Of Integer)`</ph>, the type of variable <ph id="ph3">`v`</ph> is not generic.</source>
          <target state="translated">In der C#-Code <ph id="ph1">`A&lt;int&gt;[] v;`</ph> oder Visual Basic-Code <ph id="ph2">`Dim v() As A(Of Integer)`</ph>, den Typ der Variable <ph id="ph3">`v`</ph> ist nicht generisch.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>Use <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> to determine whether a type is generic before calling <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>.</source>
          <target state="translated">Verwendung <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> zu bestimmen, ob ein Typ generisch ist, vor dem Aufruf ist <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>The following code example creates an instance of a constructed type by using ordinary instance creation and then uses the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> methods to retrieve the constructed type and the generic type definition.</source>
          <target state="translated">Das folgende Codebeispiel erstellt eine Instanz eines konstruierten Typs mithilfe des normalen instanzerstellung und verwendet dann die <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> Methoden zum Abrufen von den konstruierten Typ und die generische Typdefinition.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetGenericTypeDefinition">
          <source>This example uses the generic <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> type; the constructed type represents a <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph3">`Test`</ph> objects with string keys.</source>
          <target state="translated">Dieses Beispiel verwendet die generische <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> Typ, der den konstruierten Typ darstellt eine <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> von <ph id="ph3">`Test`</ph> Objekte mit Zeichenfolgenschlüssel.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>The current type is not a generic type.</source>
          <target state="translated">Der aktuelle Typ ist kein generischer Typ.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsGenericType" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Das heißt, <ph id="ph1">&lt;see cref="P:System.Type.IsGenericType" /&gt;</ph> gibt <ph id="ph2">&lt;see langword="false" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" uid="M:System.Type.GetGenericTypeDefinition">
          <source>Derived classes must provide an implementation.</source>
          <target state="translated">Abgeleitete Klassen müssen eine Implementation angeben.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" uid="M:System.Type.GetHashCode">
          <source>Returns the hash code for this instance.</source>
          <target state="translated">Gibt den Hashcode für diese Instanz zurück.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" uid="M:System.Type.GetHashCode">
          <source>The hash code for this instance.</source>
          <target state="translated">Der Hashcode für diese Instanz.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetHashCode">
          <source>This method overrides <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Diese Methode überschreibt <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetHashCode">
          <source>The following example displays the hash code of the <ph id="ph1">`System.Windows.Forms.Button`</ph> class.</source>
          <target state="translated">Das folgende Beispiel zeigt den Hashcode für die <ph id="ph1">`System.Windows.Forms.Button`</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific interface implemented or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft eine bestimmte Schnittstelle ab, die vom aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> implementiert oder geerbt wurde.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source>The string containing the name of the interface to get.</source>
          <target state="translated">Die Zeichenfolge, die den Namen der abzurufenden Schnittstelle enthält.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source>For generic interfaces, this is the mangled name.</source>
          <target state="translated">Bei generischen Schnittstellen ist dies der ergänzte Name.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source>Searches for the interface with the specified name.</source>
          <target state="translated">Sucht die Schnittstelle mit dem angegebenen Namen.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source>An object representing the interface with the specified name, implemented or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das die vom aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> implementierte oder geerbte Schnittstelle mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">Die Suche nach <ph id="ph1">`name`</ph> Groß-/Kleinschreibung beachtet.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Type&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Type&gt;</ph> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht das schnittstelleneinschränkungen und alle Schnittstellen, die von der Klasse oder Schnittstelle Einschränkungen geerbt.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>For generic interfaces, the <ph id="ph1">`name`</ph> parameter is the mangled name, ending with a grave accent (<ph id="ph2">\`</ph>) and the number of type parameters.</source>
          <target state="translated">Bei generischen Schnittstellen die <ph id="ph1">`name`</ph> Parameter ist der ergänzte Name, endend mit einem Gravis-Akzent (<ph id="ph2">\`</ph>) und die Anzahl von Typparametern.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>This is true for both generic interface definitions and constructed generic interfaces.</source>
          <target state="translated">Dies gilt für generische Schnittstellendefinitionen und konstruierte generische Schnittstellen.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>For example, to find <ph id="ph1">`IExample&lt;T&gt;`</ph> (<ph id="ph2">`IExample(Of T)`</ph> in Visual Basic) or <ph id="ph3">`IExample&lt;string&gt;`</ph> (<ph id="ph4">`IExample(Of String)`</ph> in Visual Basic), search for <ph id="ph5">``"IExample`1"``</ph>.</source>
          <target state="translated">Z. B. mithilfe der Softwareoption <ph id="ph1">`IExample&lt;T&gt;`</ph> (<ph id="ph2">`IExample(Of T)`</ph> in Visual Basic) oder <ph id="ph3">`IExample&lt;string&gt;`</ph> (<ph id="ph4">`IExample(Of String)`</ph> in Visual Basic), suchen Sie nach <ph id="ph5">``"IExample`1"``</ph>.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%29&gt;</ph> method to search the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> class for the <ph id="ph3">&lt;xref:System.Runtime.Serialization.IDeserializationCallback&gt;</ph> interface, and lists the methods of the interface.</source>
          <target state="translated">Im folgenden Codebeispiel wird mit der <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%29&gt;</ph> Methode zum Suchen der <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> -Klasse für die <ph id="ph3">&lt;xref:System.Runtime.Serialization.IDeserializationCallback&gt;</ph> Schnittstelle und Listen die Methoden der Schnittstelle.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String)">
          <source>The code example also demonstrates the <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29&gt;</ph> method overload and the <ph id="ph2">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph> method.</source>
          <target state="translated">Im Codebeispiel wird veranschaulicht, die auch die <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29&gt;</ph> -methodenüberladung und die <ph id="ph2">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a type that implements the same generic interface with different type arguments.</source>
          <target state="translated">Der aktuelle <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> stellt einen Typ dar, der dieselbe generische Schnittstelle mit unterschiedlichen Typargumenten implementiert.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The string containing the name of the interface to get.</source>
          <target state="translated">Die Zeichenfolge, die den Namen der abzurufenden Schnittstelle enthält.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>For generic interfaces, this is the mangled name.</source>
          <target state="translated">Bei generischen Schnittstellen ist dies der ergänzte Name.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to ignore the case of that part of <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> that specifies the simple interface name (the part that specifies the namespace must be correctly cased).</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die Groß-/Kleinschreibung dieses Teils von <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept>, der den einfachen Schnittstellennamen angibt, ignoriert werden soll (Bei der Namespaceangabe im Namen muss die Groß-/Kleinschreibung immer beachtet werden)</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to perform a case-sensitive search for all parts of <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>, wenn nach allen Teilen von <bpt id="p1">&lt;c&gt;</bpt>name<ept id="p1">&lt;/c&gt;</ept> unter Beachtung der Groß-/Kleinschreibung gesucht werden soll.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.</source>
          <target state="translated">Sucht beim Überschreiben in einer abgeleiteten Klasse die angegebene Schnittstelle, wobei festgelegt wird, ob bei der Suche des Schnittstellennamens die Groß-/Kleinschreibung beachtet wird.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>An object representing the interface with the specified name, implemented or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if found; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das die vom aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> implementierte oder geerbte Schnittstelle mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The <ph id="ph1">`ignoreCase`</ph> parameter applies only to the simple interface name, not to the namespace.</source>
          <target state="translated">Die <ph id="ph1">`ignoreCase`</ph> Parameter gilt nur für den einfachen Schnittstellennamen, nicht für den Namespace.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The portion of <ph id="ph1">`name`</ph> that specifies the namespace must have the correct case, or the interface will not be found.</source>
          <target state="translated">Der Teil des <ph id="ph1">`name`</ph> , die angibt, der Namespace muss die korrekte Groß-/Kleinschreibung, oder die Schnittstelle nicht gefunden werden.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>For example, the string "System.icomparable" finds the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> interface, but the string "system.icomparable" does not.</source>
          <target state="translated">Z. B. die Zeichenfolge "System.icomparable" sucht nach der <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> -Schnittstelle, die Zeichenfolge "system.icomparable" hingegen nicht.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Type&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Type&gt;</ph> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht das schnittstelleneinschränkungen und alle Schnittstellen, die von der Klasse oder Schnittstelle Einschränkungen geerbt.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>For generic interfaces, the <ph id="ph1">`name`</ph> parameter is the mangled name, ending with a grave accent (<ph id="ph2">\`</ph>) and the number of type parameters.</source>
          <target state="translated">Bei generischen Schnittstellen die <ph id="ph1">`name`</ph> Parameter ist der ergänzte Name, endend mit einem Gravis-Akzent (<ph id="ph2">\`</ph>) und die Anzahl von Typparametern.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>This is true for both generic interface definitions and constructed generic interfaces.</source>
          <target state="translated">Dies gilt für generische Schnittstellendefinitionen und konstruierte generische Schnittstellen.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>For example, to find <ph id="ph1">`IExample&lt;T&gt;`</ph> (<ph id="ph2">`IExample(Of T)`</ph> in Visual Basic) or <ph id="ph3">`IExample&lt;string&gt;`</ph> (<ph id="ph4">`IExample(Of String)`</ph> in Visual Basic), search for <ph id="ph5">`"IExample`</ph>1"`.</source>
          <target state="translated">Z. B. mithilfe der Softwareoption <ph id="ph1">`IExample&lt;T&gt;`</ph> (<ph id="ph2">`IExample(Of T)`</ph> in Visual Basic) oder <ph id="ph3">`IExample&lt;string&gt;`</ph> (<ph id="ph4">`IExample(Of String)`</ph> in Visual Basic), suchen Sie nach <ph id="ph5">`"IExample`</ph>1"".</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The following code example uses the <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29&gt;</ph> method to perform a case-insensitive search of the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> class for the <ph id="ph3">&lt;xref:System.Collections.IEnumerable&gt;</ph> interface.</source>
          <target state="translated">Im folgenden Codebeispiel wird mit der <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29&gt;</ph> Methode Groß-/Kleinschreibung nicht beachtet werden soll von der <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> -Klasse für die <ph id="ph3">&lt;xref:System.Collections.IEnumerable&gt;</ph> Schnittstelle.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The code example also demonstrates the <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%29&gt;</ph> method overload and the <ph id="ph2">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph> method.</source>
          <target state="translated">Im Codebeispiel wird veranschaulicht, die auch die <ph id="ph1">&lt;xref:System.Type.GetInterface%28System.String%29&gt;</ph> -methodenüberladung und die <ph id="ph2">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterface(System.String,System.Boolean)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a type that implements the same generic interface with different type arguments.</source>
          <target state="translated">Der aktuelle <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> stellt einen Typ dar, der dieselbe generische Schnittstelle mit unterschiedlichen Typargumenten implementiert.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The interface type to retrieve a mapping for.</source>
          <target state="translated">Der Schnittstellentyp, für den eine Zuordnung abgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>Returns an interface mapping for the specified interface type.</source>
          <target state="translated">Gibt eine Schnittstellenzuordnung für den angegebenen Schnittstellentyp zurück.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>An object that represents the interface mapping for <ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das die Schnittstellenzuordnung für <ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> darstellt.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The interface map denotes how an interface is mapped into the actual members on a class that implements that interface.</source>
          <target state="translated">Die schnittstellenzuordnung gibt an, wie eine Schnittstelle zu den tatsächlichen Elementen auf einer Klasse zugeordnet ist, die diese Schnittstelle implementiert.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, type parameters are replaced by the appropriate type arguments in the elements of the <ph id="ph2">&lt;xref:System.Reflection.InterfaceMapping&gt;</ph> returned by this method.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen konstruierten generischen Typ, Typ, die Parameter werden durch die entsprechenden Typargumente in den Elementen ersetzt die <ph id="ph2">&lt;xref:System.Reflection.InterfaceMapping&gt;</ph> von dieser Methode zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph> method to determine how the <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> interface maps to <ph id="ph3">&lt;xref:System.Globalization.CultureInfo&gt;</ph> methods, and how the <ph id="ph4">&lt;xref:System.IAppDomainSetup&gt;</ph> interface maps to <ph id="ph5">&lt;xref:System.AppDomainSetup&gt;</ph> properties.</source>
          <target state="translated">Im folgenden Beispiel wird der <ph id="ph1">&lt;xref:System.Type.GetInterfaceMap%2A&gt;</ph> Methode, um zu bestimmen, wie die <ph id="ph2">&lt;xref:System.IFormatProvider&gt;</ph> Schnittstelle ordnet <ph id="ph3">&lt;xref:System.Globalization.CultureInfo&gt;</ph> Methoden, und wie die <ph id="ph4">&lt;xref:System.IAppDomainSetup&gt;</ph> Schnittstelle ordnet <ph id="ph5">&lt;xref:System.AppDomainSetup&gt;</ph> Eigenschaften.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>Note that, because the <ph id="ph1">&lt;xref:System.IAppDomainSetup&gt;</ph> interface defines a set of properties, the returned <ph id="ph2">&lt;xref:System.Reflection.InterfaceMapping&gt;</ph> object includes separate <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects for a property's get and set accessors.</source>
          <target state="translated">Beachten Sie Folgendes: Da die <ph id="ph1">&lt;xref:System.IAppDomainSetup&gt;</ph> -Schnittstelle definiert einen Satz von Eigenschaften dar, das zurückgegebene <ph id="ph2">&lt;xref:System.Reflection.InterfaceMapping&gt;</ph> Objekt enthält separate <ph id="ph3">&lt;xref:System.Reflection.MethodInfo&gt;</ph> Objekte für eine Eigenschaft Get- und Set-Accessoren.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> is not implemented by the current type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> wird nicht von dem aktuellen Typ implementiert.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The <ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> parameter does not refer to an interface.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph>-Parameter verweist auf keine Schnittstelle.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> is a generic interface, and the current type is an array type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> ist eine generische Schnittstelle, und der aktuelle Typ ist ein Arraytyp.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="interfaceType" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a generic type parameter; that is, <ph id="ph2">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> is <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Der aktuelle <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> stellt einen generischen Typparameter dar; d. h. <ph id="ph2">&lt;see cref="P:System.Type.IsGenericParameter" /&gt;</ph> ist <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaceMap(System.Type)">
          <source>Derived classes must provide an implementation.</source>
          <target state="translated">Abgeleitete Klassen müssen eine Implementation angeben.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaces">
          <source>When overridden in a derived class, gets all the interfaces implemented or inherited by the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft beim Überschreiben in einer abgeleiteten Klasse sämtliche Schnittstellen ab, die vom aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> implementiert oder geerbt wurden.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaces">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing all the interfaces implemented or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die sämtliche vom aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> implementierten oder geerbten Schnittstellen darstellen.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaces">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaces">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, if no interfaces are implemented or inherited by the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ein leeres Array vom <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Typ, wenn der aktuelle <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> keine Schnittstellen implementiert oder geerbt hat.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> method does not return interfaces in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> Methode gibt keinen zurück Schnittstellen in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>Your code must not depend on the order in which interfaces are returned, because that order varies.</source>
          <target state="translated">Der Code muss nicht richten sich nach der Reihenfolge, in der Schnittstellen zurückgegeben werden, da, bei der Reihenfolge.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Type&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Type&gt;</ph> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht das schnittstelleneinschränkungen und alle Schnittstellen, die von der Klasse oder Schnittstelle Einschränkungen geerbt.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>The following example gets the type of the specified class and displays all the interfaces that the type implements or inherits.</source>
          <target state="translated">Im folgenden Beispiel ruft den Typ der angegebenen Klasse ab und zeigt alle Schnittstellen, die der Typ implementiert oder erbt.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetInterfaces">
          <source>To compile the Visual Basic example, use the following compiler commands:</source>
          <target state="translated">Um die Visual Basic-Beispiel zu kompilieren, verwenden Sie die folgenden Compilerbefehle:</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" uid="M:System.Type.GetInterfaces">
          <source>A static initializer is invoked and throws an exception.</source>
          <target state="translated">Ein statischer Initialisierer wird aufgerufen und löst eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the specified members of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft die angegebenen Member des aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String)">
          <source>The string containing the name of the public members to get.</source>
          <target state="translated">Die Zeichenfolge, die den Namen des abzurufenden öffentlichen Members enthält.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String)">
          <source>Searches for the public members with the specified name.</source>
          <target state="translated">Sucht die öffentlichen Member mit dem angegebenen Namen.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing the public members with the specified name, if found; otherwise, an empty array.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>-Objekten, die die öffentlichen Member mit dem angegebenen Namen darstellen, sofern gefunden, andernfalls ein leeres Array.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">Die Suche nach <ph id="ph1">`name`</ph> Groß-/Kleinschreibung beachtet.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The search includes public static and public instance members.</source>
          <target state="translated">Die Suche enthält öffentliche statisch und öffentlich Instanzmember.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">Member enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> Methode gibt keinen zurück Mitglieder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">Der Code muss nicht richten sich nach der Reihenfolge, in der Elemente zurückgegeben werden, da, bei der Reihenfolge.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>This method overload will not find class initializers (.cctor).</source>
          <target state="translated">Diese methodenüberladung wird Klasseninitialisierer (".cctor") nicht gefunden werden.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>To find class initializers, use an overload that takes <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Um Klasseninitialisierer zu ermitteln, verwenden Sie eine Überladung mit <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, und geben Sie <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die <ph id="ph1">`Get`</ph> Methoden, wenn für einen Typ reflektieren.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Member Type</source>
          <target state="translated">Memberart</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Static</source>
          <target state="translated">Statisch</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Non-Static</source>
          <target state="translated">Nicht statische</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Constructor</source>
          <target state="translated">Konstruktor</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Field</source>
          <target state="translated">Feld</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Ein Feld ist immer nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Method</source>
          <target state="translated">Methode</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Nested Type</source>
          <target state="translated">Geschachtelten Typs</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Property</source>
          <target state="translated">Eigenschaft</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>This is a binary comparison.</source>
          <target state="translated">Dies ist ein binärer Vergleich.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Mitglieder der Class-Einschränkung oder die Elemente der <ph id="ph2">&lt;xref:System.Object&gt;</ph> Wenn ohne klasseneinschränkung ist.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Für generische Methoden enthalten nicht die Typargumente in <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Z. B. den C#-Code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> sucht ein Element mit dem Textnamen "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", anstatt für eine Methode namens <ph id="ph3">`MyMethod`</ph> , die ein generisches Argument des Typs hat <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String)">
          <source>The following example displays all the members of the <ph id="ph1">`String`</ph> class that start with the letter C.</source>
          <target state="translated">Das folgende Beispiel zeigt alle Member der <ph id="ph1">`String`</ph> -Klasse, die mit dem Buchstaben c beginnen</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of the members to get.</source>
          <target state="translated">Die Zeichenfolge, die den Namen der abzurufenden Member enthält.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return an empty array.</source>
          <target state="translated">0 (null), um ein leeres Array zurückzugeben.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Searches for the specified members, using the specified binding constraints.</source>
          <target state="translated">Sucht die angegebenen Member unter Verwendung der angegebenen Bindungseinschränkungen.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing the public members with the specified name, if found; otherwise, an empty array.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>-Objekten, die die öffentlichen Member mit dem angegebenen Namen darstellen, sofern gefunden, andernfalls ein leeres Array.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">Member enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> Methode gibt keinen zurück Mitglieder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">Der Code muss nicht richten sich nach der Reihenfolge, in der Elemente zurückgegeben werden, da, bei der Reihenfolge.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Filterkennzeichnungen genutzt werden, welche Member in die Suche einbezogen werden:</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Instance`</ph> oder <ph id="ph2">`BindingFlags.Static`</ph> ändern, um einen Rückgabewert zu erhalten.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Public`</ph> auf öffentliche Member in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.NonPublic`</ph> auf nicht öffentliche Member (d. h. private, interne und geschützte Member) in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> einschließen <ph id="ph2">`public`</ph> und <ph id="ph3">`protected`</ph> statische Member der Hierarchie; nach oben <ph id="ph4">`private`</ph> statische Member in geerbten Klassen sind nicht eingeschlossen.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> um die Groß-/Kleinschreibung ignorieren <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> Suche nur die deklarierten Member der <ph id="ph2">&lt;xref:System.Type&gt;</ph>, nicht die Elemente, die nur geerbt wurden.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for <ph id="ph1">`name`</ph>, and <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic) for <ph id="ph7">`bindingAttr`</ph>.</source>
          <target state="translated">Um die klasseninitialisierung (".cctor"), die Verwendung dieser methodenüberladung zu erhalten, müssen Sie ".cctor" angeben, für <ph id="ph1">`name`</ph>, und <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic) für <ph id="ph7">`bindingAttr`</ph>.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Mitglieder der Class-Einschränkung oder die Elemente der <ph id="ph2">&lt;xref:System.Object&gt;</ph> Wenn ohne klasseneinschränkung ist.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Für generische Methoden enthalten nicht die Typargumente in <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Z. B. den C#-Code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> sucht ein Element mit dem Textnamen "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", anstatt für eine Methode namens <ph id="ph3">`MyMethod`</ph> , die ein generisches Argument des Typs hat <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source>The following example displays all the public static members of the <ph id="ph1">`myString`</ph> class that start with the letter C.</source>
          <target state="translated">Das folgende Beispiel zeigt alle öffentlichen statischen Member der <ph id="ph1">`myString`</ph> -Klasse, die mit dem Buchstaben c beginnen</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The string containing the name of the members to get.</source>
          <target state="translated">Die Zeichenfolge, die den Namen der abzurufenden Member enthält.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The value to search for.</source>
          <target state="translated">Der zu suchende Wert.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Zero, to return an empty array.</source>
          <target state="translated">0 (null), um ein leeres Array zurückzugeben.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Searches for the specified members of the specified member type, using the specified binding constraints.</source>
          <target state="translated">Sucht die angegebenen Member des angegebenen Membertyps unter Verwendung der angegebenen Bindungseinschränkungen.</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing the public members with the specified name, if found; otherwise, an empty array.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>-Objekten, die die öffentlichen Member mit dem angegebenen Namen darstellen, sofern gefunden, andernfalls ein leeres Array.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">Member enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetMember%2A&gt;</ph> Methode gibt keinen zurück Mitglieder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">Der Code muss nicht richten sich nach der Reihenfolge, in der Elemente zurückgegeben werden, da, bei der Reihenfolge.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Filterkennzeichnungen genutzt werden, welche Member in die Suche einbezogen werden:</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Instance`</ph> oder <ph id="ph2">`BindingFlags.Static`</ph> ändern, um einen Rückgabewert zu erhalten.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Public`</ph> auf öffentliche Member in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.NonPublic`</ph> auf nicht öffentliche Member (d. h. private, interne und geschützte Member) in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> einschließen <ph id="ph2">`public`</ph> und <ph id="ph3">`protected`</ph> statische Member der Hierarchie; nach oben <ph id="ph4">`private`</ph> statische Member in geerbten Klassen sind nicht eingeschlossen.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> um die Groß-/Kleinschreibung ignorieren <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> Suche nur die deklarierten Member der <ph id="ph2">&lt;xref:System.Type&gt;</ph>, nicht die Elemente, die nur geerbt wurden.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for <ph id="ph1">`name`</ph>, <ph id="ph2">&lt;xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType&gt;</ph> for <ph id="ph3">`type`</ph>, and  <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph7">`Or`</ph><ph id="ph8">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic) for <ph id="ph9">`bindingAttr`</ph>.</source>
          <target state="translated">Um die klasseninitialisierung (".cctor"), die Verwendung dieser methodenüberladung zu erhalten, müssen Sie ".cctor" angeben, für <ph id="ph1">`name`</ph>, <ph id="ph2">&lt;xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType&gt;</ph> für <ph id="ph3">`type`</ph>, und <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph6">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph7">`Or`</ph> <ph id="ph8">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic) für <ph id="ph9">`bindingAttr`</ph>.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Mitglieder der Class-Einschränkung oder die Elemente der <ph id="ph2">&lt;xref:System.Object&gt;</ph> Wenn ohne klasseneinschränkung ist.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Für generische Methoden enthalten nicht die Typargumente in <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Z. B. den C#-Code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> sucht ein Element mit dem Textnamen "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", anstatt für eine Methode namens <ph id="ph3">`MyMethod`</ph> , die ein generisches Argument des Typs hat <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>The following example displays all the methods of the <ph id="ph1">`myString`</ph> class that start with the letter C.</source>
          <target state="translated">Das folgende Beispiel zeigt alle Methoden der <ph id="ph1">`myString`</ph> -Klasse, die mit dem Buchstaben c beginnen</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" uid="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)">
          <source>A derived class must provide an implementation.</source>
          <target state="translated">Eine abgeleitete Klasse muss eine Implementierung bereitstellen.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the members (properties, methods, fields, events, and so on) of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft die Member (Eigenschaften, Methoden, Felder, Ereignisse usw.) des aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers">
          <source>Returns all the public members of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Gibt sämtliche öffentlichen Member des aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing all the public members of the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>-Objekten, die sämtliche öffentlichen Member des aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> darstellen.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have public members.</source>
          <target state="translated">Ein leeres Array vom <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>-Typ, wenn der aktuelle <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> keine Standardmember besitzt.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">Member enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph> Methode gibt keinen zurück Mitglieder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">Der Code muss nicht richten sich nach der Reihenfolge, in der Elemente zurückgegeben werden, da, bei der Reihenfolge.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>This method overload calls the <ph id="ph1">&lt;xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29&gt;</ph> method overload, with <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (<ph id="ph5">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph><ph id="ph6">`Or`</ph><ph id="ph7">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph><ph id="ph8">`Or`</ph><ph id="ph9">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Diese methodenüberladung Ruft die <ph id="ph1">&lt;xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29&gt;</ph> -methodenüberladung mit <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (<ph id="ph5">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> <ph id="ph6">`Or`</ph> <ph id="ph7">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> <ph id="ph8">`Or`</ph> <ph id="ph9">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>It will not find class initializers (.cctor).</source>
          <target state="translated">Es findet keine Klasseninitialisierer (".cctor").</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>To find class initializers, use an overload that takes <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph5">`Or`</ph><ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Um Klasseninitialisierer zu ermitteln, verwenden Sie eine Überladung mit <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, und geben Sie <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph5">`Or`</ph> <ph id="ph6">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die <ph id="ph1">`Get`</ph> Methoden, wenn für einen Typ reflektieren.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Member Type</source>
          <target state="translated">Memberart</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Static</source>
          <target state="translated">Statisch</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Non-Static</source>
          <target state="translated">Nicht statische</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Constructor</source>
          <target state="translated">Konstruktor</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Field</source>
          <target state="translated">Feld</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Ein Feld ist immer nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Method</source>
          <target state="translated">Methode</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Nested Type</source>
          <target state="translated">Geschachtelten Typs</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Property</source>
          <target state="translated">Eigenschaft</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>This is a binary comparison.</source>
          <target state="translated">Dies ist ein binärer Vergleich.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.MemberInfo&gt;</ph> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Mitglieder der Class-Einschränkung oder die Elemente der <ph id="ph2">&lt;xref:System.Object&gt;</ph> Wenn ohne klasseneinschränkung ist.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers">
          <source>The following code example demonstrates how to use the <ph id="ph1">&lt;xref:System.Type.GetMembers&gt;</ph> method overload to collect information about all public members of a specified class.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie die <ph id="ph1">&lt;xref:System.Type.GetMembers&gt;</ph> -methodenüberladung, um die Erfassung von Informationen über alle öffentlichen Member einer bestimmten Klasse.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Zero (<ph id="ph1">&lt;see cref="F:System.Reflection.BindingFlags.Default" /&gt;</ph>), to return an empty array.</source>
          <target state="translated">0 (null), (<ph id="ph1">&lt;see cref="F:System.Reflection.BindingFlags.Default" /&gt;</ph>) um ein leeres Array zurückzugeben.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the members defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die für den aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> definierten Member.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph> objects representing all members defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>-Objekten, die sämtliche für den aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> definierten öffentlichen Member darstellen, die den angegebenen Bindungseinschränkungen entsprechen.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>, if no members are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, or if none of the defined members match the binding constraints.</source>
          <target state="translated">Ein leeres Array vom <ph id="ph1">&lt;see cref="T:System.Reflection.MemberInfo" /&gt;</ph>-Typ, wenn für den aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> keine Member definiert sind oder keiner der definierten Member den Bindungseinschränkungen entspricht.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Members include properties, methods, fields, events, and so on.</source>
          <target state="translated">Member enthalten Eigenschaften, Methoden, Felder, Ereignisse und So weiter.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetMembers%2A&gt;</ph> Methode gibt keinen zurück Mitglieder in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which members are returned, because that order varies.</source>
          <target state="translated">Der Code muss nicht richten sich nach der Reihenfolge, in der Elemente zurückgegeben werden, da, bei der Reihenfolge.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Filterkennzeichnungen genutzt werden, welche Member in die Suche einbezogen werden:</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Instance`</ph> oder <ph id="ph2">`BindingFlags.Static`</ph> ändern, um einen Rückgabewert zu erhalten.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Public`</ph> auf öffentliche Member in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.NonPublic`</ph> auf nicht öffentliche Member (d. h. private, interne und geschützte Member) in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Only protected and internal members on base classes are returned; private members on base classes are not returned.</source>
          <target state="translated">Nur geschützte und interne Member in Basisklassen werden zurückgegeben. Private Member in Basisklassen werden nicht zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> einschließen <ph id="ph2">`public`</ph> und <ph id="ph3">`protected`</ph> statische Member der Hierarchie; nach oben <ph id="ph4">`private`</ph> statische Member in geerbten Klassen sind nicht eingeschlossen.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> Suche nur die deklarierten Member der <ph id="ph2">&lt;xref:System.Type&gt;</ph>, nicht die Elemente, die nur geerbt wurden.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>Calling this method with only the <ph id="ph1">`Public`</ph> flag or only the <ph id="ph2">`NonPublic`</ph> flag will return the specified members and does not require any other flags.</source>
          <target state="translated">Beim Aufrufen dieser Methode nur mit der <ph id="ph1">`Public`</ph> Flag oder nur die <ph id="ph2">`NonPublic`</ph> Flag die angegebenen Member zurück, und alle anderen Flags sind nicht erforderlich.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>To get the class initializer (.cctor) using this method overload, you must specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph><ph id="ph4">`Or`</ph><ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</source>
          <target state="translated">Um die klasseninitialisierung (".cctor"), die Verwendung dieser methodenüberladung zu erhalten, müssen Sie angeben <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> (<ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> <ph id="ph4">`Or`</ph> <ph id="ph5">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>You can also get the class initializer using the <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.</source>
          <target state="translated">Außerdem erhalten Sie, dass die klasseninitialisierung verwenden die <ph id="ph1">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Mitglieder der Class-Einschränkung oder die Elemente der <ph id="ph2">&lt;xref:System.Object&gt;</ph> Wenn ohne klasseneinschränkung ist.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMembers(System.Reflection.BindingFlags)">
          <source>The following code example demonstrates how to use the <ph id="ph1">&lt;xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29&gt;</ph> method overload to collect information about all public instance members of a specified class.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie die <ph id="ph1">&lt;xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29&gt;</ph> -methodenüberladung, um Informationen zu allen öffentlicher Instanzmember einer bestimmten Klasse zu sammeln.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific method of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft eine bestimmte Methode des aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String)">
          <source>The string containing the name of the public method to get.</source>
          <target state="translated">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Methode enthält.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String)">
          <source>Searches for the public method with the specified name.</source>
          <target state="translated">Sucht die öffentliche Methode mit dem angegebenen Namen.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String)">
          <source>An object that represents the public method with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das die öffentliche Methode mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">Die Suche nach <ph id="ph1">`name`</ph> Groß-/Kleinschreibung beachtet.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>The search includes public static and public instance methods.</source>
          <target state="translated">Die Suche enthält öffentliche statisch und öffentlich Instanzmethoden.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>If a method is overloaded and has more than one public method, the <ph id="ph1">&lt;xref:System.Type.GetMethod%28System.String%29&gt;</ph> method throws an <ph id="ph2">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> exception.</source>
          <target state="translated">Wenn eine Methode überladen wird und verfügt über mehr als eine öffentliche Methode, die <ph id="ph1">&lt;xref:System.Type.GetMethod%28System.String%29&gt;</ph> -Methode löst eine <ph id="ph2">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> Ausnahme.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>In the following example, an exception is thrown because there is more than one public overload of the <ph id="ph1">&lt;xref:System.Int32.ToString%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Im folgenden Beispiel wird eine Ausnahme ausgelöst, da es mehr als eine öffentliche Überladung von ist der <ph id="ph1">&lt;xref:System.Int32.ToString%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>On the other hand, because the <ph id="ph1">`Person.ToString`</ph> method overrides  <ph id="ph2">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> and therefore is not overloaded, the <ph id="ph3">&lt;xref:System.Type.GetMethod%28System.String%29&gt;</ph> method is able to retrieve the <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
          <target state="translated">Andererseits, da die <ph id="ph1">`Person.ToString`</ph> methodenüberschreibungen <ph id="ph2">&lt;xref:System.Object.ToString%2A?displayProperty=nameWithType&gt;</ph> und ist daher nicht überladen, die <ph id="ph3">&lt;xref:System.Type.GetMethod%28System.String%29&gt;</ph> Methode kann zum Abrufen der <ph id="ph4">&lt;xref:System.Reflection.MethodInfo&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>You can do one of the following to retrieve a specific method:</source>
          <target state="translated">Sie können eine der folgenden zum Abrufen einer bestimmten Methode vorgehen:</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> method and specify a <ph id="ph2">`bindingAttr`</ph> argument that uniquely identifies the method.</source>
          <target state="translated">Rufen Sie die <ph id="ph1">&lt;xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> Methode, und geben Sie einen <ph id="ph2">`bindingAttr`</ph> Argument, das die Methode eindeutig identifiziert.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>For example, if the exception is thrown because a type has a static and an instance overload, you can specify a  <ph id="ph1">`bindingAttr`</ph> argument  of <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph><ph id="ph3">`Or`</ph><ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Beispielsweise, wenn die Ausnahme ausgelöst wird, da ein Typ eine statische und eine Überladung für die Instanz hat, können Sie angeben einer <ph id="ph1">`bindingAttr`</ph> Argument <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> <ph id="ph3">`Or`</ph> <ph id="ph4">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>Call an overload of the <ph id="ph1">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method that includes a <ph id="ph2">`types`</ph> parameter which defines the types of the method's parameters.</source>
          <target state="translated">Rufen Sie eine Überladung von der <ph id="ph1">&lt;xref:System.Type.GetMethod%2A&gt;</ph> Methode, enthält eine <ph id="ph2">`types`</ph> Parameter, die die Typen der Parameter der Methode definiert.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetMethods&gt;</ph> method to retrieve an array containing all of the public methods belonging to a type.</source>
          <target state="translated">Rufen Sie die <ph id="ph1">&lt;xref:System.Type.GetMethods&gt;</ph> Methode, um ein Array, das alle öffentlichen Methoden, die zu einem Typ gehören enthält abzurufen.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>You can then iterate it to identify the duplicate methods named <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Sie können dann durchlaufen, es zum Identifizieren von doppelten Methoden mit dem Namen <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <ph id="ph2">&lt;xref:System.Object&gt;</ph> Wenn ohne klasseneinschränkung ist.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Für generische Methoden enthalten nicht die Typargumente in <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Z. B. den C#-Code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> sucht ein Element mit dem Textnamen "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", anstatt für eine Methode namens <ph id="ph3">`MyMethod`</ph> , die ein generisches Argument des Typs hat <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String)">
          <source>The following example gets a method named <ph id="ph1">`MethodA`</ph>.</source>
          <target state="translated">Im folgenden Beispiel wird eine Methode namens <ph id="ph1">`MethodA`</ph>.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String)">
          <source>More than one method is found with the specified name.</source>
          <target state="translated">Es wurden mehrere Methoden mit dem angegebenen Namen gefunden.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of the method to get.</source>
          <target state="translated">Die Zeichenfolge, die den Namen der abzurufenden Methode enthält.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">0 (null), damit <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Searches for the specified method, using the specified binding constraints.</source>
          <target state="translated">Sucht die angegebene Methode unter Verwendung der angegebenen Bindungseinschränkungen.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>An object representing the method that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das die Methode darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Filterkennzeichnungen genutzt werden, welche Methoden in die Suche einbezogen werden:</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> in order to get a return.</source>
          <target state="translated">Geben Sie <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> ändern, um einen Rückgabewert zu erhalten.</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> to include public methods in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> um öffentliche Methoden in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> to include non-public methods (that is, private, internal, and protected methods) in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> auf nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType&gt;</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Geben Sie <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType&gt;</ph> einschließen <ph id="ph2">`public`</ph> und <ph id="ph3">`protected`</ph> statische Member der Hierarchie; nach oben <ph id="ph4">`private`</ph> statische Member in geerbten Klassen sind nicht eingeschlossen.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType&gt;</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType&gt;</ph> um die Groß-/Kleinschreibung ignorieren <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph> Um nur die deklarierten Methoden suchen die <ph id="ph2">&lt;xref:System.Type&gt;</ph>, nicht die Methoden, die nur geerbt wurden.</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>If a method is overloaded and more than one overload meets the constraints specified by the <ph id="ph1">`bindingAttr`</ph> argument, the method throws an <ph id="ph2">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> exception.</source>
          <target state="translated">Wenn eine Methode überladen wird und mehrere Überladungen die Einschränkungen erfüllt, angegeben durch die <ph id="ph1">`bindingAttr`</ph> Argument, löst die Methode eine <ph id="ph2">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> Ausnahme.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>In the following example, an exception is thrown because:</source>
          <target state="translated">Im folgenden Beispiel wird eine Ausnahme ausgelöst, da:</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">`TestClass`</ph> type has two public instance overloads of the <ph id="ph2">`DisplayValue`</ph> method, <ph id="ph3">`DisplayValue(String)`</ph> and <ph id="ph4">`DisplayValue(String, Object[])`</ph>.</source>
          <target state="translated">Die <ph id="ph1">`TestClass`</ph> Typ hat zwei öffentliche Instanz Überladungen der <ph id="ph2">`DisplayValue`</ph> Methode <ph id="ph3">`DisplayValue(String)`</ph> und <ph id="ph4">`DisplayValue(String, Object[])`</ph>.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">`TestClass`</ph> type has two public instance overloads of the <ph id="ph2">`Equals`</ph> method,  one of which is inherited from <ph id="ph3">&lt;xref:System.Object&gt;</ph>: <ph id="ph4">`Equals(TestClass)`</ph> and <ph id="ph5">`Equals(Object)`</ph>.</source>
          <target state="translated">Die <ph id="ph1">`TestClass`</ph> Typ hat zwei öffentliche Instanz Überladungen der <ph id="ph2">`Equals`</ph> -Methode, von denen geerbt wird, von <ph id="ph3">&lt;xref:System.Object&gt;</ph>: <ph id="ph4">`Equals(TestClass)`</ph> und <ph id="ph5">`Equals(Object)`</ph>.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>You can do one of the following to retrieve a specific method:</source>
          <target state="translated">Sie können eine der folgenden zum Abrufen einer bestimmten Methode vorgehen:</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Change the binding constraints.</source>
          <target state="translated">Ändern Sie die bindungseinschränkungen.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>In the previous example, attempting to retrieve a public instance <ph id="ph1">`Equals`</ph> method that is declared by the type and not inherited successfully retrieves <ph id="ph2">`Equals(TestClass)`</ph>.</source>
          <target state="translated">Im vorherigen Beispiel versucht, eine öffentliche Instanz abzurufen <ph id="ph1">`Equals`</ph> Methode, die vom Typ deklariert wird und nicht geerbt wurde erfolgreich abgerufen <ph id="ph2">`Equals(TestClass)`</ph>.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Call an overload of the <ph id="ph1">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method that includes a <ph id="ph2">`types`</ph> parameter which defines the types of the method's parameters.</source>
          <target state="translated">Rufen Sie eine Überladung von der <ph id="ph1">&lt;xref:System.Type.GetMethod%2A&gt;</ph> Methode, enthält eine <ph id="ph2">`types`</ph> Parameter, die die Typen der Parameter der Methode definiert.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>Call the <ph id="ph1">&lt;xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29&gt;</ph> method to retrieve an array containing all of the methods belonging to a type that have the specified binding attributes.</source>
          <target state="translated">Rufen Sie die <ph id="ph1">&lt;xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29&gt;</ph> Methode, um ein Array mit allen Methoden, die zu einem Typ gehören, die über die angegebene Bindungsattribute verfügen abzurufen.</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>You can then iterate it to identify the duplicate methods named <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Sie können dann durchlaufen, es zum Identifizieren von doppelten Methoden mit dem Namen <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>This approach is illustrated in the previous example's handler for the <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> exception.</source>
          <target state="translated">Dieser Ansatz wird veranschaulicht, in dem vorherigen Beispiel Handler für das <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> Ausnahme.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <ph id="ph2">&lt;xref:System.Object&gt;</ph> Wenn ohne klasseneinschränkung ist.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Für generische Methoden enthalten nicht die Typargumente in <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Z. B. den C#-Code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> sucht ein Element mit dem Textnamen "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", anstatt für eine Methode namens <ph id="ph3">`MyMethod`</ph> , die ein generisches Argument des Typs hat <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>The following example gets the method that matches the specified binding flags.</source>
          <target state="translated">Im folgenden Beispiel wird die Methode, die den angegebenen Bindungsflags entspricht.</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source>More than one method is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">Es wurden mehrere Methoden gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The string containing the name of the public method to get.</source>
          <target state="translated">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Methode enthält.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>An empty array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects (as provided by the <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> field) to get a method that takes no parameters.</source>
          <target state="translated">Ein leeres Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten (bereitgestellt vom <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>Searches for the specified public method whose parameters match the specified argument types.</source>
          <target state="translated">Sucht die angegebene öffentliche Methode, deren Parameter den angegebenen Argumenttypen entsprechen.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>An object representing the public method whose parameters match the specified argument types, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das die öffentliche Methode darstellt, deren Parameter den angegebenen Argumenttypen entsprechen, sofern gefunden, andernfalls <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">Die Suche nach <ph id="ph1">`name`</ph> Groß-/Kleinschreibung beachtet.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The search includes public static and public instance methods.</source>
          <target state="translated">Die Suche enthält öffentliche statisch und öffentlich Instanzmethoden.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Sie können nur Parameter auslassen, aufrufen.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <ph id="ph2">&lt;xref:System.Object&gt;</ph> Wenn ohne klasseneinschränkung ist.</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The <ph id="ph1">`name`</ph> parameter cannot include type arguments.</source>
          <target state="translated">Die <ph id="ph1">`name`</ph> Parameter kann keine Typargumente enthalten.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>For example, the C# code <ph id="ph1">`GetMethod("MyGenericMethod&lt;int&gt;")`</ph> searches for a method with the text name "<ph id="ph2">`MyGenericMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyGenericMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Z. B. den C#-Code <ph id="ph1">`GetMethod("MyGenericMethod&lt;int&gt;")`</ph> sucht eine Methode mit dem Textnamen "<ph id="ph2">`MyGenericMethod&lt;int&gt;`</ph>", anstatt für eine Methode namens <ph id="ph3">`MyGenericMethod`</ph> , die ein generisches Argument des Typs hat <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>Instead, use <ph id="ph1">`GetMethod("MyGenericMethod")`</ph> with the appropriate parameter in the <ph id="ph2">`types`</ph> array.</source>
          <target state="translated">Verwenden Sie stattdessen <ph id="ph1">`GetMethod("MyGenericMethod")`</ph> mit dem entsprechenden Parameter in der <ph id="ph2">`types`</ph> Array.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The following example finds specific overloads of <ph id="ph1">`MethodA`</ph>, specifying a variety of argument types.</source>
          <target state="translated">Das folgende Beispiel sucht nach bestimmten Überladungen der <ph id="ph1">`MethodA`</ph>, eine Vielzahl von Argumenttypen angeben.</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The <ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph> example requires the <ph id="ph2">`/unsafe`</ph> compiler option.</source>
          <target state="translated">Die <ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph> Beispiel benötigen Sie die <ph id="ph2">`/unsafe`</ph> -Compileroption.</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The following example retrieves <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects that represent the <ph id="ph2">`Add`</ph> methods  of a non-generic type (the <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> class), an open generic type (the <ph id="ph4">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class), and a closed generic type (the <ph id="ph5">`List(Of String)`</ph> type.</source>
          <target state="translated">Das folgende Beispiel ruft <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> Objekte, die darstellen, die <ph id="ph2">`Add`</ph> Methoden eines nicht generischen Typs (die <ph id="ph3">&lt;xref:System.Collections.ArrayList&gt;</ph> Klasse), ein offener generischer Typ (die <ph id="ph4">&lt;xref:System.Collections.Generic.List%601&gt;</ph> Klasse), und einen geschlossenen generischen Typs (die <ph id="ph5">`List(Of String)`</ph> Typ.</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>The example defines a <ph id="ph1">`GetAddMethod`</ph> method that retrieves the appropriate <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.</source>
          <target state="translated">Im Beispiel definiert eine <ph id="ph1">`GetAddMethod`</ph> Methode, die die entsprechende abruft <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>To provide the <ph id="ph1">`types`</ph> argument for an open generic type, it calls the <ph id="ph2">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Bereitstellen der <ph id="ph1">`types`</ph> Argument für einen offenen generischen Typ, ruft er die <ph id="ph2">&lt;xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>To provide the <ph id="ph1">`types`</ph> argument for a closed generic type, it retrieves the value of the <ph id="ph2">&lt;xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Bereitstellen der <ph id="ph1">`types`</ph> Argument für einen geschlossenen generischen Typs, ruft er den Wert des der <ph id="ph2">&lt;xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>More than one method is found with the specified name and specified parameters.</source>
          <target state="translated">Es wurden mehrere Methoden mit dem angegebenen Namen und den angegebenen Parametern gefunden.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Eines der Elemente in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the public method to get.</source>
          <target state="translated">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Methode enthält.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects (as provided by the <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> field) to get a method that takes no parameters.</source>
          <target state="translated">Ein leeres Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten (bereitgestellt vom <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph>-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>-Array zugeordnet sind.</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated">Darf nur bei Aufrufen über COM-Interop verwendet werden. Es werden außerdem nur Parameter berücksichtigt, die als Verweis übergeben werden.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">Der Standardbinder verarbeitet diesen Parameter nicht.</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified public method whose parameters match the specified argument types and modifiers.</source>
          <target state="translated">Sucht die angegebene öffentliche Methode, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the public method that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das die öffentliche Methode darstellt, die den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Obwohl der Standardbinder nicht verarbeitet <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (die <ph id="ph2">`modifiers`</ph> Parameter), können Sie die abstrakte <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">Die Suche nach <ph id="ph1">`name`</ph> Groß-/Kleinschreibung beachtet.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The search includes public static and public instance methods.</source>
          <target state="translated">Die Suche enthält öffentliche statisch und öffentlich Instanzmethoden.</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Sie können nur Parameter auslassen, aufrufen.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <ph id="ph2">&lt;xref:System.Object&gt;</ph> Wenn ohne klasseneinschränkung ist.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Für generische Methoden enthalten nicht die Typargumente in <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, the C# code <ph id="ph1">`GetMethod("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Z. B. den C#-Code <ph id="ph1">`GetMethod("MyMethod&lt;int&gt;")`</ph> sucht ein Element mit dem Textnamen "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", anstatt für eine Methode namens <ph id="ph3">`MyMethod`</ph> , die ein generisches Argument des Typs hat <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Instead, use <ph id="ph1">`GetMethod("MyMethod")`</ph> with the appropriate parameter in the <ph id="ph2">`types`</ph> array.</source>
          <target state="translated">Verwenden Sie stattdessen <ph id="ph1">`GetMethod("MyMethod")`</ph> mit dem entsprechenden Parameter in der <ph id="ph2">`types`</ph> Array.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one method is found with the specified name and specified parameters.</source>
          <target state="translated">Es wurden mehrere Methoden mit dem angegebenen Namen und den angegebenen Parametern gefunden.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Eines der Elemente in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the method to get.</source>
          <target state="translated">Die Zeichenfolge, die den Namen der abzurufenden Methode enthält.</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">0 (null), damit <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Ein Nullverweis (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), wenn <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph> verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects (as provided by the <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> field) to get a method that takes no parameters.</source>
          <target state="translated">Ein leeres Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten (bereitgestellt vom <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph>-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>-Array zugeordnet sind.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated">Darf nur bei Aufrufen über COM-Interop verwendet werden. Es werden außerdem nur Parameter berücksichtigt, die als Verweis übergeben werden.</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">Der Standardbinder verarbeitet diesen Parameter nicht.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
          <target state="translated">Sucht unter Verwendung der angegebenen Bindungseinschränkungen nach der angegebenen Methode, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the method that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das die Methode darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Obwohl der Standardbinder nicht verarbeitet <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (die <ph id="ph2">`modifiers`</ph> Parameter), können Sie die abstrakte <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Filterkennzeichnungen genutzt werden, welche Methoden in die Suche einbezogen werden:</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Instance`</ph> oder <ph id="ph2">`BindingFlags.Static`</ph> ändern, um einen Rückgabewert zu erhalten.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public methods in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Public`</ph> um öffentliche Methoden in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include nonpublic methods (that is, private, internal, and protected methods) in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.NonPublic`</ph> auf nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> einschließen <ph id="ph2">`public`</ph> und <ph id="ph3">`protected`</ph> statische Member der Hierarchie; nach oben <ph id="ph4">`private`</ph> statische Member in geerbten Klassen sind nicht eingeschlossen.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> um die Groß-/Kleinschreibung ignorieren <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> Um nur die deklarierten Methoden suchen die <ph id="ph2">&lt;xref:System.Type&gt;</ph>, nicht die Methoden, die nur geerbt wurden.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Sie können nur Parameter auslassen, aufrufen.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <ph id="ph2">&lt;xref:System.Object&gt;</ph> Wenn ohne klasseneinschränkung ist.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Für generische Methoden enthalten nicht die Typargumente in <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Z. B. den C#-Code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> sucht ein Element mit dem Textnamen "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", anstatt für eine Methode namens <ph id="ph3">`MyMethod`</ph> , die ein generisches Argument des Typs hat <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following example finds specific overloads of <ph id="ph1">`MethodA`</ph>, specifying binding constraints and a variety of argument types.</source>
          <target state="translated">Das folgende Beispiel sucht nach bestimmten Überladungen der <ph id="ph1">`MethodA`</ph>, bindungseinschränkungen sowie eine Vielzahl von Argumenttypen angeben.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The <ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph> example requires the <ph id="ph2">`/unsafe`</ph> compiler option.</source>
          <target state="translated">Die <ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph> Beispiel benötigen Sie die <ph id="ph2">`/unsafe`</ph> -Compileroption.</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one method is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">Es wurden mehrere Methoden gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Eines der Elemente in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the method to get.</source>
          <target state="translated">Die Zeichenfolge, die den Namen der abzurufenden Methode enthält.</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">0 (null), damit <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Ein Nullverweis (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), wenn <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph> verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.</source>
          <target state="translated">Das Objekt, das die Regeln für Reihenfolge und Layout der Argumente, die Art der Übergabe des Rückgabewerts, die für Argumente zu verwendenden Register und die Art der Stapelbereinigung angibt.</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects (as provided by the <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph> field) to get a method that takes no parameters.</source>
          <target state="translated">Ein leeres Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten (bereitgestellt vom <ph id="ph2">&lt;see cref="F:System.Type.EmptyTypes" /&gt;</ph>-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph>-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>-Array zugeordnet sind.</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated">Darf nur bei Aufrufen über COM-Interop verwendet werden. Es werden außerdem nur Parameter berücksichtigt, die als Verweis übergeben werden.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">Der Standardbinder verarbeitet diesen Parameter nicht.</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
          <target state="translated">Sucht nach der angegebenen Methode, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen, und verwendet dabei die angegebenen Bindungseinschränkungen und die angegebene Aufrufkonvention.</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the method that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das die Methode darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Obwohl der Standardbinder nicht verarbeitet <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (die <ph id="ph2">`modifiers`</ph> Parameter), können Sie die abstrakte <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`GetXXX`</ph> methods when reflecting on a type.</source>
          <target state="translated">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die <ph id="ph1">`GetXXX`</ph> Methoden, wenn für einen Typ reflektieren.</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Member Type</source>
          <target state="translated">Memberart</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Static</source>
          <target state="translated">Statisch</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Non-Static</source>
          <target state="translated">Nicht statische</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Constructor</source>
          <target state="translated">Konstruktor</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Field</source>
          <target state="translated">Feld</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Ein Feld ist immer nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Method</source>
          <target state="translated">Methode</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Nested Type</source>
          <target state="translated">Geschachtelten Typs</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Property</source>
          <target state="translated">Eigenschaft</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>This is a binary comparison.</source>
          <target state="translated">Dies ist ein binärer Vergleich.</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Filterkennzeichnungen genutzt werden, welche Methoden in die Suche einbezogen werden:</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Instance`</ph> oder <ph id="ph2">`BindingFlags.Static`</ph> ändern, um einen Rückgabewert zu erhalten.</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public methods in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Public`</ph> um öffentliche Methoden in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include nonpublic methods (that is, private, internal, and protected methods) in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.NonPublic`</ph> auf nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> einschließen <ph id="ph2">`public`</ph> und <ph id="ph3">`protected`</ph> statische Member der Hierarchie; nach oben <ph id="ph4">`private`</ph> statische Member in geerbten Klassen sind nicht eingeschlossen.</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> um die Groß-/Kleinschreibung ignorieren <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> Um nur die deklarierten Methoden suchen die <ph id="ph2">&lt;xref:System.Type&gt;</ph>, nicht die Methoden, die nur geerbt wurden.</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden.</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Sie können nur Parameter auslassen, aufrufen.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <ph id="ph2">&lt;xref:System.Object&gt;</ph> Wenn ohne klasseneinschränkung ist.</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For generic methods, do not include the type arguments in <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Für generische Methoden enthalten nicht die Typargumente in <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, the C# code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> searches for a member with the text name "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", rather than for a method named <ph id="ph3">`MyMethod`</ph> that has one generic argument of type <ph id="ph4">`int`</ph>.</source>
          <target state="translated">Z. B. den C#-Code <ph id="ph1">`GetMember("MyMethod&lt;int&gt;")`</ph> sucht ein Element mit dem Textnamen "<ph id="ph2">`MyMethod&lt;int&gt;`</ph>", anstatt für eine Methode namens <ph id="ph3">`MyMethod`</ph> , die ein generisches Argument des Typs hat <ph id="ph4">`int`</ph>.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following example finds specific overloads of <ph id="ph1">`MethodA`</ph>, specifying binding constraints, calling conventions, and a variety of argument types.</source>
          <target state="translated">Das folgende Beispiel sucht nach bestimmten Überladungen der <ph id="ph1">`MethodA`</ph>, bindungseinschränkungen angeben, das Aufrufen von Konventionen sowie eine Vielzahl von Argumenttypen.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The <ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph> example requires the <ph id="ph2">`/unsafe`</ph> compiler option.</source>
          <target state="translated">Die <ph id="ph1">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph> Beispiel benötigen Sie die <ph id="ph2">`/unsafe`</ph> -Compileroption.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one method is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">Es wurden mehrere Methoden gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Eines der Elemente in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the method to get.</source>
          <target state="translated">Die Zeichenfolge, die den Namen der abzurufenden Methode enthält.</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">0 (null), damit <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Ein Nullverweis (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), wenn <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph> verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.</source>
          <target state="translated">Das Objekt, das die Regeln für Reihenfolge und Layout der Argumente, die Art der Übergabe des Rückgabewerts, die für Argumente zu verwendenden Register und den Prozess angibt, der den Stapel bereinigt.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</source>
          <target state="translated">Ein leeres Array vom <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer Methode, die keine Parameter akzeptiert.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, arguments are not matched.</source>
          <target state="translated">Wenn <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> <ph id="ph1">&lt;see langword="null" /&gt;</ph> entspricht, wird keine Übereinstimmung von Argumenten überprüft.</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph>-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>-Array zugeordnet sind.</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">Der Standardbinder verarbeitet diesen Parameter nicht.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</source>
          <target state="translated">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen und der angegebenen Aufrufkonvention nach der angegebenen Methode, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the method that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das die Methode darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Obwohl der Standardbinder nicht verarbeitet <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (die <ph id="ph2">`modifiers`</ph> Parameter), können Sie die abstrakte <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If <ph id="ph1">`types`</ph> is <ph id="ph2">`null`</ph>, arguments are not matched.</source>
          <target state="translated">Wenn <ph id="ph1">`types`</ph> <ph id="ph2">`null`</ph> ist, wird keine Übereinstimmung von Argumenten überprüft.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Filterkennzeichnungen genutzt werden, welche Methoden in die Suche einbezogen werden:</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Instance`</ph> oder <ph id="ph2">`BindingFlags.Static`</ph> ändern, um einen Rückgabewert zu erhalten.</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public methods in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Public`</ph> um öffentliche Methoden in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public methods (that is, private, internal, and protected methods) in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.NonPublic`</ph> auf nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> einschließen <ph id="ph2">`public`</ph> und <ph id="ph3">`protected`</ph> statische Member der Hierarchie; nach oben <ph id="ph4">`private`</ph> statische Member in geerbten Klassen sind nicht eingeschlossen.</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> um die Groß-/Kleinschreibung ignorieren <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> Um nur die deklarierten Methoden suchen die <ph id="ph2">&lt;xref:System.Type&gt;</ph>, nicht die Methoden, die nur geerbt wurden.</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one method is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">Es wurden mehrere Methoden gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> und <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> weisen nicht die gleiche Länge auf.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The current type is a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>.</source>
          <target state="translated">Der aktuelle Typ ist ein <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph> oder ein <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the methods of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft die Methoden des aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods">
          <source>Returns all the public methods of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Gibt sämtliche öffentlichen Methoden des aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects representing all the public methods defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>-Objekten, die alle für den aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> definierten öffentlichen Member darstellen.</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, if no public methods are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ein leeres Array vom <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>-Typ, wenn für den aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> keine öffentlichen Methoden definiert sind.</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMethods%2A&gt;</ph> method does not return methods in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetMethods%2A&gt;</ph> Methode gibt keinen zurück Methoden in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Your code must not depend on the order in which methods are returned, because that order varies.</source>
          <target state="translated">Der Code muss nicht richten sich nach der Reihenfolge, in der Methoden zurückgegeben werden, da, bei der Reihenfolge.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Constructors are not included in the array of methods returned by this call.</source>
          <target state="translated">Konstruktoren sind nicht im Array der Methoden, die durch diesen Aufruf zurückgegebene enthalten.</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Make a separate call to <ph id="ph1">`GetConstructors()`</ph> to get the constructor methods.</source>
          <target state="translated">Stellen Sie einen separaten Aufruf von <ph id="ph1">`GetConstructors()`</ph> Konstruktormethoden abgerufen.</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die <ph id="ph1">`Get`</ph> Methoden, wenn für einen Typ reflektieren.</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Member Type</source>
          <target state="translated">Memberart</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Static</source>
          <target state="translated">Statisch</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Non-Static</source>
          <target state="translated">Nicht statische</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Constructor</source>
          <target state="translated">Konstruktor</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Field</source>
          <target state="translated">Feld</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Ein Feld ist immer nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Method</source>
          <target state="translated">Methode</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Nested Type</source>
          <target state="translated">Geschachtelten Typs</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Property</source>
          <target state="translated">Eigenschaft</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>This is a binary comparison.</source>
          <target state="translated">Dies ist ein binärer Vergleich.</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Sie können nur Parameter auslassen, aufrufen.</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <ph id="ph2">&lt;xref:System.Object&gt;</ph> Wenn ohne klasseneinschränkung ist.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">0 (null), damit <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the methods defined for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die für den aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> definierten Methoden.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph> objects representing all methods defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>-Objekten, die sämtliche für den aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> definierten öffentlichen Methoden darstellen, die den angegebenen Bindungseinschränkungen entsprechen.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>, if no methods are defined for the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>, or if none of the defined methods match the binding constraints.</source>
          <target state="translated">Ein leeres Array vom <ph id="ph1">&lt;see cref="T:System.Reflection.MethodInfo" /&gt;</ph>-Typ, wenn für den aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> keine Methoden definiert sind oder keine der definierten Methoden den Bindungseinschränkungen entspricht.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetMethods%2A&gt;</ph> method does not return methods in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetMethods%2A&gt;</ph> Methode gibt keinen zurück Methoden in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which methods are returned, because that order varies.</source>
          <target state="translated">Der Code muss nicht richten sich nach der Reihenfolge, in der Methoden zurückgegeben werden, da, bei der Reihenfolge.</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Filterkennzeichnungen genutzt werden, welche Methoden in die Suche einbezogen werden:</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Instance`</ph> oder <ph id="ph2">`BindingFlags.Static`</ph> ändern, um einen Rückgabewert zu erhalten.</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public methods in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Public`</ph> um öffentliche Methoden in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public methods (that is, private, internal, and protected methods) in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.NonPublic`</ph> auf nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Only protected and internal methods on base classes are returned; private methods on base classes are not returned.</source>
          <target state="translated">Nur geschützte und interne Methoden in Basisklassen werden zurückgegeben. private Methoden in Basisklassen werden nicht zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> einschließen <ph id="ph2">`public`</ph> und <ph id="ph3">`protected`</ph> statische Member der Hierarchie; nach oben <ph id="ph4">`private`</ph> statische Member in geerbten Klassen sind nicht eingeschlossen.</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> Um nur die deklarierten Methoden suchen die <ph id="ph2">&lt;xref:System.Type&gt;</ph>, nicht die Methoden, die nur geerbt wurden.</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>You cannot omit parameters when looking up constructors and methods.</source>
          <target state="translated">Sie können keine Parameter auslassen, beim Nachschlagen von Konstruktoren und Methoden.</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>You can only omit parameters when invoking.</source>
          <target state="translated">Sie können nur Parameter auslassen, aufrufen.</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id="ph2">&lt;xref:System.Object&gt;</ph> if there is no class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode sucht, die Methoden der klasseneinschränkung oder die Methoden der <ph id="ph2">&lt;xref:System.Object&gt;</ph> Wenn ohne klasseneinschränkung ist.</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetMethods(System.Reflection.BindingFlags)">
          <source>The following example creates a class with two public methods and one protected method, creates a <ph id="ph1">`Type`</ph> object corresponding to <ph id="ph2">`MyTypeClass`</ph>, gets all public and non-public methods, and displays their names.</source>
          <target state="translated">Das folgende Beispiel erstellt eine Klasse mit zwei öffentliche Methoden und einer geschützten Methode, erstellt eine <ph id="ph1">`Type`</ph> -Objekt entsprechende <ph id="ph2">`MyTypeClass`</ph>Ruft alle öffentliche und nicht öffentlichen Methoden und ihre Namen angezeigt.</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific type nested within the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft einen bestimmten Typ ab, der im aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> geschachtelt ist.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String)">
          <source>The string containing the name of the nested type to get.</source>
          <target state="translated">Die Zeichenfolge, die den Namen des abzurufenden geschachtelten Typs enthält.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String)">
          <source>Searches for the public nested type with the specified name.</source>
          <target state="translated">Sucht den öffentlichen geschachtelten Typ mit dem angegebenen Namen.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String)">
          <source>An object representing the public nested type with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das den öffentlichen geschachtelten Typ mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">Die Suche nach <ph id="ph1">`name`</ph> Groß-/Kleinschreibung beachtet.</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Use the simple name of the nested class for <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Verwenden Sie den einfachen Namen der geschachtelten Klasse für <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Do not qualify it with the name of the outer class.</source>
          <target state="translated">Qualifizieren Sie ihn nicht mit dem Namen der äußeren Klasse.</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>For a generic nested class, use the mangled name — that is, append a grave accent and the number of generic arguments.</source>
          <target state="translated">Verwenden Sie für eine generische geschachtelte Klasse der ergänzte Name – d. h. ein Graviszeichen und die Anzahl von generischen Argumenten angefügt werden soll.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>For example, use the string "Inner<ph id="ph1">\`</ph>1" to get the generic nested class <ph id="ph2">`Inner&lt;T&gt;`</ph> (<ph id="ph3">`Inner(Of T)`</ph> in Visual Basic).</source>
          <target state="translated">Verwenden Sie z. B. die Zeichenfolge "innere<ph id="ph1">\`</ph>1" zum Abrufen des generisches der geschachtelten Klasse <ph id="ph2">`Inner&lt;T&gt;`</ph> (<ph id="ph3">`Inner(Of T)`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Do not include language-specific syntax for type parameters.</source>
          <target state="translated">Verwenden Sie keine sprachspezifische Syntax für Typparameter angegeben.</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die <ph id="ph1">`Get`</ph> Methoden, wenn für einen Typ reflektieren.</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Member Type</source>
          <target state="translated">Memberart</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Static</source>
          <target state="translated">Statisch</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Non-Static</source>
          <target state="translated">Nicht statische</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Constructor</source>
          <target state="translated">Konstruktor</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Field</source>
          <target state="translated">Feld</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Ein Feld ist immer nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Method</source>
          <target state="translated">Methode</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Nested Type</source>
          <target state="translated">Geschachtelten Typs</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Property</source>
          <target state="translated">Eigenschaft</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>This is a binary comparison.</source>
          <target state="translated">Dies ist ein binärer Vergleich.</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die geschachtelte Typen von der Class-Einschränkung.</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>If a nested type is generic, this method returns its generic type definition.</source>
          <target state="translated">Wenn ein geschachtelter Typ generisch ist, gibt diese Methode die generische Typdefinition.</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>This is true even if the enclosing generic type is a closed constructed type.</source>
          <target state="translated">Dies gilt auch, wenn der einschließenden generischen Typs geschlossenen konstruierten Typs ist.</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen generischen Typ definiert, die in c#, Visual Basic oder C++ die geschachtelten Typen sind alle generisch, auch wenn sie keine eigenen generischen Parameter verfügen.</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
          <target state="translated">Dies gilt nicht unbedingt von geschachtelten Typen in dynamischen Assemblys definiert, oder Kompilieren mit der <bpt id="p1">[</bpt>Ilasm.exe (IL-Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String)">
          <source>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</source>
          <target state="translated">Informationen über geschachtelte generische Typen und zum Erstellen von geschachtelten generischer Typen von generischen Typdefinitionen finden Sie unter <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of the nested type to get.</source>
          <target state="translated">Die Zeichenfolge, die den Namen des abzurufenden geschachtelten Typs enthält.</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">0 (null), damit <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</source>
          <target state="translated">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen den angegebenen geschachtelten Typ.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>An object representing the nested type that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das den geschachtelten Typ darstellt, der den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls<ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Use the simple name of the nested class for <ph id="ph1">`name`</ph>.</source>
          <target state="translated">Verwenden Sie den einfachen Namen der geschachtelten Klasse für <ph id="ph1">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Do not qualify it with the name of the outer class.</source>
          <target state="translated">Qualifizieren Sie ihn nicht mit dem Namen der äußeren Klasse.</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>For a generic nested class, use the mangled name — that is, append a grave accent and the number of generic parameters.</source>
          <target state="translated">Verwenden Sie für eine generische geschachtelte Klasse der ergänzte Name – d. h. ein Graviszeichen und die Anzahl der generischen Parameter angefügt werden soll.</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>For example, use the string "Inner<ph id="ph1">\`</ph>1" to get the generic nested class <ph id="ph2">`Inner&lt;T&gt;`</ph> (<ph id="ph3">`Inner(Of T)`</ph> in Visual Basic).</source>
          <target state="translated">Verwenden Sie z. B. die Zeichenfolge "innere<ph id="ph1">\`</ph>1" zum Abrufen des generisches der geschachtelten Klasse <ph id="ph2">`Inner&lt;T&gt;`</ph> (<ph id="ph3">`Inner(Of T)`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Do not include language-specific syntax for type parameters.</source>
          <target state="translated">Verwenden Sie keine sprachspezifische Syntax für Typparameter angegeben.</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which nested types to include in the search:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Filter Flags können verwendet werden, um die definieren, welche geschachtelten Typen in die Suche einbeziehen:</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> to get a return.</source>
          <target state="translated">Geben Sie <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> ein Ergebnis zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> to include public nested types in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> öffentliche geschachtelten Typen in die Suche eingeschlossen.</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> an nicht öffentlichen geschachtelte Typen (d. h. private, interne und geschützte geschachtelte Typen) in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>This method returns only the nested types of the current type.</source>
          <target state="translated">Diese Methode gibt nur die geschachtelten Typen des aktuellen Typs zurück.</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>It does not search the base classes of the current type.</source>
          <target state="translated">Die Basisklassen des aktuellen Typs werden nicht durchsucht.</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <ph id="ph1">&lt;xref:System.Type.GetNestedType%2A&gt;</ph> at each level.</source>
          <target state="translated">Um Typen zu suchen, die geschachtelt sind in Basisklassen, führen Sie die Vererbungshierarchie Aufrufen <ph id="ph1">&lt;xref:System.Type.GetNestedType%2A&gt;</ph> auf jeder Ebene.</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> are ignored.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> und <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> werden ignoriert.</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>Calling this method with only the <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> flag or only the <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> flag will return the specified nested types and does not require any other flags.</source>
          <target state="translated">Beim Aufrufen dieser Methode nur mit der <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> Flag oder nur die <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> Flag zurück, den angegebenen geschachtelten Typen und alle anderen Flags sind nicht erforderlich.</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die geschachtelte Typen von der Class-Einschränkung.</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>If a nested type is generic, this method returns its generic type definition.</source>
          <target state="translated">Wenn ein geschachtelter Typ generisch ist, gibt diese Methode die generische Typdefinition.</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>This is true even if the enclosing generic type is a closed constructed type.</source>
          <target state="translated">Dies gilt auch, wenn der einschließenden generischen Typs geschlossenen konstruierten Typs ist.</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen generischen Typ definiert, die in c#, Visual Basic oder C++ die geschachtelten Typen sind alle generisch, auch wenn sie keine eigenen generischen Parameter verfügen.</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
          <target state="translated">Dies gilt nicht unbedingt von geschachtelten Typen in dynamischen Assemblys definiert, oder Kompilieren mit der <bpt id="p1">[</bpt>Ilasm.exe (IL-Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</source>
          <target state="translated">Informationen über geschachtelte generische Typen und zum Erstellen von geschachtelten generischer Typen von generischen Typdefinitionen finden Sie unter <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the types nested within the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft die im aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> geschachtelten Typen ab.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes">
          <source>Returns the public types nested in the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Gibt die im aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> geschachtelten öffentlichen Typen zurück.</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the public types nested in the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> (the search is not recursive), or an empty array of type <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> if no public types are nested in the current <ph id="ph4">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, das die im aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> geschachtelten öffentlichen Typen darstellt (die Suche ist nicht rekursiv) oder ein leeres Array vom Typ <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>, wenn im aktuellen <ph id="ph4">&lt;see cref="T:System.Type" /&gt;</ph> keine öffentlichen Typen geschachtelt sind.</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> method does not return types in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> Methode gibt keinen zurück Typen in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Your code must not depend on the order in which types are returned, because that order varies.</source>
          <target state="translated">Code muss nicht abhängig von der Reihenfolge, in der Typen zurückgegeben werden, da, bei der Reihenfolge.</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Only the public types immediately nested in the current type are returned; the search is not recursive.</source>
          <target state="translated">Es werden nur die sofort im aktuellen Typ geschachtelten öffentlichen Typen zurückgegeben. die Suche ist nicht rekursiv.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die <ph id="ph1">`Get`</ph> Methoden, wenn für einen Typ reflektieren.</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Member Type</source>
          <target state="translated">Memberart</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Static</source>
          <target state="translated">Statisch</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Non-Static</source>
          <target state="translated">Nicht statische</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Constructor</source>
          <target state="translated">Konstruktor</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Field</source>
          <target state="translated">Feld</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Ein Feld ist immer nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Method</source>
          <target state="translated">Methode</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Nested Type</source>
          <target state="translated">Geschachtelten Typs</target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Property</source>
          <target state="translated">Eigenschaft</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>This is a binary comparison.</source>
          <target state="translated">Dies ist ein binärer Vergleich.</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die geschachtelte Typen von der Class-Einschränkung.</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>If a nested type is generic, this method returns its generic type definition.</source>
          <target state="translated">Wenn ein geschachtelter Typ generisch ist, gibt diese Methode die generische Typdefinition.</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>This is true even if the enclosing generic type is a closed constructed type.</source>
          <target state="translated">Dies gilt auch, wenn der einschließenden generischen Typs geschlossenen konstruierten Typs ist.</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen generischen Typ definiert, die in c#, Visual Basic oder C++ die geschachtelten Typen sind alle generisch, auch wenn sie keine eigenen generischen Parameter verfügen.</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
          <target state="translated">Dies gilt nicht unbedingt von geschachtelten Typen in dynamischen Assemblys definiert, oder Kompilieren mit der <bpt id="p1">[</bpt>Ilasm.exe (IL-Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</source>
          <target state="translated">Informationen über geschachtelte generische Typen und zum Erstellen von geschachtelten generischer Typen von generischen Typdefinitionen finden Sie unter <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes">
          <source>The following example defines a nested class and a <ph id="ph1">`struct`</ph> in <ph id="ph2">`MyClass`</ph>, and then obtains objects of the nested types using the type of <ph id="ph3">`MyClass`</ph>.</source>
          <target state="translated">Das folgende Beispiel definiert eine geschachtelte Klasse und ein <ph id="ph1">`struct`</ph> in <ph id="ph2">`MyClass`</ph>, und klicken Sie dann ruft Objekte der geschachtelten Typen mit dem Typ der <ph id="ph3">`MyClass`</ph>.</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">0 (null), damit <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the types nested in the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die im aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> geschachtelten Typen.</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing all the types nested in the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints (the search is not recursive), or an empty array of type <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>, if no nested types are found that match the binding constraints.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, das alle im aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> geschachtelten Typen darstellt, die mit den angegebenen Bindungseinschränkungen übereinstimmen (die Suche ist nicht rekursiv) oder ein leeres Array vom Typ <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>, wenn keine geschachtelten Typen gefunden werden, die mit den Bindungseinschränkungen übereinstimmen.</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>The search for nested types is not recursive.</source>
          <target state="translated">Die Suche nach geschachtelten Typen ist nicht rekursiv.</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> method does not return types in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> Methode gibt keinen zurück Typen in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which types are returned, because that order varies.</source>
          <target state="translated">Code muss nicht abhängig von der Reihenfolge, in der Typen zurückgegeben werden, da, bei der Reihenfolge.</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which nested types to include in the search:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Filter Flags können verwendet werden, um die definieren, welche geschachtelten Typen in die Suche einbeziehen:</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> to get a return.</source>
          <target state="translated">Geben Sie <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> ein Ergebnis zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> to include public nested types in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> öffentliche geschachtelten Typen in die Suche eingeschlossen.</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> an nicht öffentlichen geschachtelte Typen (d. h. private, interne und geschützte geschachtelte Typen) in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>This method returns only the nested types of the current type.</source>
          <target state="translated">Diese Methode gibt nur die geschachtelten Typen des aktuellen Typs zurück.</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>It does not search the base classes of the current type.</source>
          <target state="translated">Die Basisklassen des aktuellen Typs werden nicht durchsucht.</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> at each level.</source>
          <target state="translated">Um Typen zu suchen, die geschachtelt sind in Basisklassen, führen Sie die Vererbungshierarchie Aufrufen <ph id="ph1">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> auf jeder Ebene.</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> are ignored.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> und <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> werden ignoriert.</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>Calling this method with only the <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> flag or only the <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> flag will return the specified nested types and does not require any other flags.</source>
          <target state="translated">Beim Aufrufen dieser Methode nur mit der <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType&gt;</ph> Flag oder nur die <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> Flag zurück, den angegebenen geschachtelten Typen und alle anderen Flags sind nicht erforderlich.</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die geschachtelte Typen von der Class-Einschränkung.</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>If a nested type is generic, this method returns its generic type definition.</source>
          <target state="translated">Wenn ein geschachtelter Typ generisch ist, gibt diese Methode die generische Typdefinition.</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>This is true even if the enclosing generic type is a closed constructed type.</source>
          <target state="translated">Dies gilt auch, wenn der einschließenden generischen Typs geschlossenen konstruierten Typs ist.</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen generischen Typ definiert, die in c#, Visual Basic oder C++ die geschachtelten Typen sind alle generisch, auch wenn sie keine eigenen generischen Parameter verfügen.</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
          <target state="translated">Dies gilt nicht unbedingt von geschachtelten Typen in dynamischen Assemblys definiert, oder Kompilieren mit der <bpt id="p1">[</bpt>Ilasm.exe (IL-Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</source>
          <target state="translated">Informationen über geschachtelte generische Typen und zum Erstellen von geschachtelten generischer Typen von generischen Typdefinitionen finden Sie unter <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)">
          <source>The following example creates two nested public classes and two nested protected classes, and displays information for classes that match the specified binding constraints.</source>
          <target state="translated">Das folgende Beispiel erstellt zwei geschachtelte öffentliche Klassen und zwei geschachtelte geschützten Klassen, und zeigt Informationen für Klassen, die die angegebenen bindungseinschränkungen entsprechen.</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the properties of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft die Eigenschaften des aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties">
          <source>Returns all the public properties of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Gibt sämtliche öffentlichen Eigenschaften des aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> objects representing all public properties of the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph>-Objekten, die alle öffentlichen Eigenschaften des aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> darstellen.</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have public properties.</source>
          <target state="translated">Ein leeres Array vom <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph>-Typ, wenn der aktuelle <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> keine öffentlichen Eigenschaften besitzt.</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Calling this overload is equivalent to calling the <ph id="ph1">&lt;xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29&gt;</ph> overload with a <ph id="ph2">`bindingAttr`</ph> argument equal to <ph id="ph3">`BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public`</ph> in C# and  <ph id="ph4">`BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public`</ph> in Visual Basic.</source>
          <target state="translated">Das Aufrufen dieser Überladung entspricht dem Aufrufen der <ph id="ph1">&lt;xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29&gt;</ph> -Überladung mit einer <ph id="ph2">`bindingAttr`</ph> Argument gleich <ph id="ph3">`BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public`</ph> in C# geschrieben und <ph id="ph4">`BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public`</ph> in Visual Basic.</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>It returns all public instance and static properties, both those defined by the type represented by the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object as well as those inherited from its base types.</source>
          <target state="translated">Gibt alle öffentlichen Instanz und statische Eigenschaften, die sowohl die vom aktuellen Typ definiert <ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekt als auch solche, die von dessen Basistypen geerbt.</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist.</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, kombinieren Sie die Werte mit <ph id="ph4">`Or`</ph>) zum Abrufen.</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetProperties%2A&gt;</ph> method does not return properties in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetProperties%2A&gt;</ph> Methode gibt keinen zurück Eigenschaften in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Your code must not depend on the order in which properties are returned, because that order varies.</source>
          <target state="translated">Der Code muss nicht richten sich nach der Reihenfolge, in der Eigenschaften zurückgegeben werden, da, bei der Reihenfolge.</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die <ph id="ph1">`Get`</ph> Methoden, wenn für einen Typ reflektieren.</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Member Type</source>
          <target state="translated">Memberart</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Static</source>
          <target state="translated">Statisch</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Non-Static</source>
          <target state="translated">Nicht statische</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Constructor</source>
          <target state="translated">Konstruktor</target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Field</source>
          <target state="translated">Feld</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Ein Feld ist immer nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Method</source>
          <target state="translated">Methode</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Nested Type</source>
          <target state="translated">Geschachtelten Typs</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Property</source>
          <target state="translated">Eigenschaft</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>This is a binary comparison.</source>
          <target state="translated">Dies ist ein binärer Vergleich.</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph1">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties">
          <source>The following example demonstrates the use of the <ph id="ph1">`GetProperties`</ph> method.</source>
          <target state="translated">Im folgenden Beispiel wird die Verwendung der <ph id="ph1">`GetProperties`</ph>-Methode gezeigt.</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">0 (null), damit <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>When overridden in a derived class, searches for the properties of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, using the specified binding constraints.</source>
          <target state="translated">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die Eigenschaften des aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph> objects representing all properties of the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> that match the specified binding constraints.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph>-Objekten, die sämtliche Eigenschaften des aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> darstellen, die den angegebenen Bindungseinschränkungen entsprechen.</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>An empty array of type <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph>, if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> does not have properties, or if none of the properties match the binding constraints.</source>
          <target state="translated">Ein leeres Array vom <ph id="ph1">&lt;see cref="T:System.Reflection.PropertyInfo" /&gt;</ph>-Typ, wenn der aktuelle <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> keine Eigenschaften besitzt oder keine der Eigenschaften den Bindungseinschränkungen entspricht.</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist.</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, kombinieren Sie die Werte mit <ph id="ph4">`Or`</ph>) zum Abrufen.</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetProperties%2A&gt;</ph> method does not return properties in a particular order, such as alphabetical or declaration order.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetProperties%2A&gt;</ph> Methode gibt keinen zurück Eigenschaften in einer bestimmten Reihenfolge, z. B. alphabetische oder Reihenfolge der Deklaration.</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Your code must not depend on the order in which properties are returned, because that order varies.</source>
          <target state="translated">Der Code muss nicht richten sich nach der Reihenfolge, in der Eigenschaften zurückgegeben werden, da, bei der Reihenfolge.</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which nested types to include in the search:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Filter Flags können verwendet werden, um die definieren, welche geschachtelten Typen in die Suche einbeziehen:</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Instance`</ph> oder <ph id="ph2">`BindingFlags.Static`</ph> ändern, um einen Rückgabewert zu erhalten.</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public properties in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Public`</ph> auf öffentliche Eigenschaften in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.NonPublic`</ph> an nicht öffentlichen Eigenschaften (d. h. private, interne und geschützte) in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Only protected and internal properties on base classes are returned; private properties on base classes are not returned.</source>
          <target state="translated">Nur geschützte und interne Eigenschaften für Basisklassen werden zurückgegeben. Private Eigenschaften für Basisklassen werden nicht zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> einschließen <ph id="ph2">`public`</ph> und <ph id="ph3">`protected`</ph> statische Member der Hierarchie; nach oben <ph id="ph4">`private`</ph> statische Member in geerbten Klassen sind nicht eingeschlossen.</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> Suche nur die deklarierten Eigenschaften der <ph id="ph2">&lt;xref:System.Type&gt;</ph>, nicht die Eigenschaften, die nur geerbt wurden.</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist.</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, kombinieren Sie die Werte mit <ph id="ph4">`Or`</ph>) zum Abrufen.</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>If the current T:System.Type represents a constructed generic type, this method returns the <ph id="ph1">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn der aktuelle t: System.Type einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph1">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> Objekte mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>The following example defines a class named <ph id="ph1">`PropertyClass`</ph> that includes six properties: two are public, one is private, one is protected, one is internal (<ph id="ph2">`Friend`</ph> in Visual Basic), and one is protected internal (<ph id="ph3">`Protected Friend`</ph> in Visual Basic).</source>
          <target state="translated">Das folgende Beispiel definiert eine Klasse namens <ph id="ph1">`PropertyClass`</ph> sechs Eigenschaften enthält: sind zwei öffentliche werden eine private ist, ist eine geschützt, interne (<ph id="ph2">`Friend`</ph> in Visual Basic), und eine interne geschützt ist (<ph id="ph3">`Protected Friend`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperties(System.Reflection.BindingFlags)">
          <source>It then displays some basic property information (the property name and type, whether it is read/write, and the visibility of its <ph id="ph1">`get`</ph> and <ph id="ph2">`set`</ph> accessors) for the properties that match the specified binding constraints.</source>
          <target state="translated">Es zeigt dann einige grundlegende Informationen (den Eigenschaftsnamen und den Typ, ob es sich um Lese-/Schreibzugriff und die Sichtbarkeit der seine <ph id="ph1">`get`</ph> und <ph id="ph2">`set`</ph> Accessoren) für die Eigenschaften, die die angegebenen bindungseinschränkungen entsprechen.</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a specific property of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft eine bestimmte Eigenschaft des aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String)">
          <source>The string containing the name of the public property to get.</source>
          <target state="translated">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String)">
          <source>Searches for the public property with the specified name.</source>
          <target state="translated">Sucht die öffentliche Eigenschaft mit dem angegebenen Namen.</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String)">
          <source>An object representing the public property with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das die öffentliche Eigenschaft mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">Die Suche nach <ph id="ph1">`name`</ph> Groß-/Kleinschreibung beachtet.</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>The search includes public static and public instance properties.</source>
          <target state="translated">Die Suche enthält öffentliche statische und öffentlichen Instanzeigenschaften.</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist.</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, kombinieren Sie die Werte mit <ph id="ph4">`Or`</ph>) zum Abrufen.</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Situations in which <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> occurs include the following:</source>
          <target state="translated">Situationen, in denen <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> tritt auf, umfassen Folgendes:</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>A type contains two indexed properties that have the same name but different numbers of parameters.</source>
          <target state="translated">Ein Typ enthält zwei indizierte Eigenschaften, die den gleichen Namen, jedoch eine unterschiedliche Anzahl von Parametern.</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>To resolve the ambiguity, use an overload of the <ph id="ph1">&lt;xref:System.Type.GetProperty%2A&gt;</ph> method that specifies parameter types.</source>
          <target state="translated">Um die Mehrdeutigkeit zu beheben, verwenden Sie eine Überladung der <ph id="ph1">&lt;xref:System.Type.GetProperty%2A&gt;</ph> Methode, die Parametertypen angibt.</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>A derived type declares a property that hides an inherited property with the same name, by using the <ph id="ph1">`new`</ph> modifier (<ph id="ph2">`Shadows`</ph> in Visual Basic).</source>
          <target state="translated">Ein abgeleiteter Typ deklariert eine Eigenschaft, die eine geerbte Eigenschaft mit dem gleichen Namen, blendet die <ph id="ph1">`new`</ph> Modifizierer (<ph id="ph2">`Shadows`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>To resolve the ambiguity, use the <ph id="ph1">&lt;xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> method overload and add the <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph> flag to restrict the search to members that are not inherited.</source>
          <target state="translated">Um die Mehrdeutigkeit zu beheben, verwenden die <ph id="ph1">&lt;xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> -methodenüberladung, und fügen die <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph> Flag, um die Suche auf Member zu beschränken, die nicht geerbt werden.</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Indexers and Default Properties</source>
          <target state="translated">Indexer und Standardeigenschaften</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, und <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft den Standardwert für seinen Datentyp sein.</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">Beispielsweise, wenn die Variable <ph id="ph1">`myList`</ph> bezieht sich auf eine <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, die Syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) Ruft das Element mit dem Index von 3.</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>You can overload the property.</source>
          <target state="translated">Sie können die Eigenschaft überladen.</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">In c# ist diese Funktion einen Indexer aufgerufen wird und nicht erteilt wurde, die anhand des Namens.</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">Standardmäßig wird als eine indizierte Eigenschaft mit dem Namen "Item" ein C#-Indexers in den Metadaten angezeigt.</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">Entwickeln einer Klassenbibliothek können jedoch die <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> Attribut zum Ändern des Namens des Indexers in den Metadaten.</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">Z. B. die <ph id="ph1">&lt;xref:System.String&gt;</ph> -Klasse verfügt über einen Indexer mit dem Namen <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">Indizierte Eigenschaften, die mit anderen Sprachen als c# erstellt können auch die Namen als Element haben.</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">Um zu bestimmen, ob ein Typ eine Standardeigenschaft vorhanden ist, verwenden die <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> -Methode zur Prüfung auf die <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> Attribut.</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">Wenn der Typ besitzt <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>die <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> Eigenschaft gibt den Namen der Standardeigenschaft zurück.</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>The following example retrieves the <ph id="ph1">`Type`</ph> object of a user-defined class, retrieves a property of that class, and displays the property name.</source>
          <target state="translated">Das folgende Beispiel ruft die <ph id="ph1">`Type`</ph> Objekt einer benutzerdefinierten Klasse ruft eine Eigenschaft dieser Klasse ab und zeigt den Namen der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Internally, this property is referred to in the metadata by the name "Item."</source>
          <target state="translated">Intern wird diese Eigenschaft in den Metadaten mit dem Namen "Item". bezeichnet</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String)">
          <source>Any attempt to get <ph id="ph1">`PropertyInfo`</ph> using reflection must specify this internal name in order to correctly return the <ph id="ph2">`PropertyInfo`</ph> property.</source>
          <target state="translated">Jeder Versuch zum Abrufen <ph id="ph1">`PropertyInfo`</ph> über Reflektion ermöglicht diesen internen Namen angeben muss, um ordnungsgemäß Zurückgeben der <ph id="ph2">`PropertyInfo`</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String)">
          <source>More than one property is found with the specified name.</source>
          <target state="translated">Es wurden mehrere Eigenschaften mit dem angegebenen Namen gefunden.</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>The string containing the name of the property to get.</source>
          <target state="translated">Die Zeichenfolge, die den Namen der abzurufenden Eigenschaft enthält.</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">0 (null), damit <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Searches for the specified property, using the specified binding constraints.</source>
          <target state="translated">Sucht die angegebene Eigenschaft unter Verwendung der angegebenen Bindungseinschränkungen.</target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>An object representing the property that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das die Eigenschaft darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist.</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, kombinieren Sie die Werte mit <ph id="ph4">`Or`</ph>) zum Abrufen.</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which properties to include in the search:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Filterkennzeichnungen genutzt werden, welche Eigenschaften in die Suche einbezogen werden:</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Instance`</ph> oder <ph id="ph2">`BindingFlags.Static`</ph> ändern, um einen Rückgabewert zu erhalten.</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public properties in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Public`</ph> auf öffentliche Eigenschaften in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.NonPublic`</ph> an nicht öffentlichen Eigenschaften (d. h. private, interne und geschützte) in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> einschließen <ph id="ph2">`public`</ph> und <ph id="ph3">`protected`</ph> statische Member der Hierarchie; nach oben <ph id="ph4">`private`</ph> statische Member in geerbten Klassen sind nicht eingeschlossen.</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> um die Groß-/Kleinschreibung ignorieren <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> Suche nur die deklarierten Eigenschaften der <ph id="ph2">&lt;xref:System.Type&gt;</ph>, nicht die Eigenschaften, die nur geerbt wurden.</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Situations in which <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> occurs include the following:</source>
          <target state="translated">Situationen, in denen <ph id="ph1">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> tritt auf, umfassen Folgendes:</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>A type contains two indexed properties that have the same name but different numbers of parameters.</source>
          <target state="translated">Ein Typ enthält zwei indizierte Eigenschaften, die den gleichen Namen, jedoch eine unterschiedliche Anzahl von Parametern.</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>To resolve the ambiguity, use an overload of the <ph id="ph1">&lt;xref:System.Type.GetProperty%2A&gt;</ph> method that specifies parameter types.</source>
          <target state="translated">Um die Mehrdeutigkeit zu beheben, verwenden Sie eine Überladung der <ph id="ph1">&lt;xref:System.Type.GetProperty%2A&gt;</ph> Methode, die Parametertypen angibt.</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>A derived type declares a property that hides an inherited property with the same name, using the <ph id="ph1">`new`</ph> modifier (<ph id="ph2">`Shadows`</ph> in Visual Basic).</source>
          <target state="translated">Ein abgeleiteter Typ deklariert eine Eigenschaft, die eine geerbte Eigenschaft mit dem gleichen Namen ausgeblendet mithilfe der <ph id="ph1">`new`</ph> Modifizierer (<ph id="ph2">`Shadows`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>To resolve the ambiguity, include <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph> to restrict the search to members that are not inherited.</source>
          <target state="translated">Um die Mehrdeutigkeit zu lösen, enthalten <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType&gt;</ph> um die Suche auf Member zu beschränken, die nicht geerbt werden.</target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Indexers and Default Properties</source>
          <target state="translated">Indexer und Standardeigenschaften</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, und <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft den Standardwert für seinen Datentyp sein.</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">Beispielsweise, wenn die Variable <ph id="ph1">`myList`</ph> bezieht sich auf eine <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, die Syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) Ruft das Element mit dem Index von 3.</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>You can overload the property.</source>
          <target state="translated">Sie können die Eigenschaft überladen.</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">In c# ist diese Funktion einen Indexer aufgerufen wird und nicht erteilt wurde, die anhand des Namens.</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">Standardmäßig wird als eine indizierte Eigenschaft mit dem Namen "Item" ein C#-Indexers in den Metadaten angezeigt.</target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">Entwickeln einer Klassenbibliothek können jedoch die <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> Attribut zum Ändern des Namens des Indexers in den Metadaten.</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">Z. B. die <ph id="ph1">&lt;xref:System.String&gt;</ph> -Klasse verfügt über einen Indexer mit dem Namen <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">Indizierte Eigenschaften, die mit anderen Sprachen als c# erstellt können auch die Namen als Element haben.</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">Um zu bestimmen, ob ein Typ eine Standardeigenschaft vorhanden ist, verwenden die <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> -Methode zur Prüfung auf die <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> Attribut.</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">Wenn der Typ besitzt <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>die <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> Eigenschaft gibt den Namen der Standardeigenschaft zurück.</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>The following example retrieves the type of a user-defined class, retrieves a property of that class and displays the property name in accordance with the specified binding constraints.</source>
          <target state="translated">Das folgende Beispiel ruft den Typ einer benutzerdefinierten Klasse ab, ruft eine Eigenschaft dieser Klasse ab und zeigt den Namen der Eigenschaft in Übereinstimmung mit der angegebenen bindungseinschränkungen.</target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source>More than one property is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>The string containing the name of the public property to get.</source>
          <target state="translated">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>The return type of the property.</source>
          <target state="translated">Der Rückgabetyp der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>Searches for the public property with the specified name and return type.</source>
          <target state="translated">Sucht die öffentliche Eigenschaft mit dem angegebenen Namen und Rückgabetyp.</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>An object representing the public property with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das die öffentliche Eigenschaft mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist.</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, kombinieren Sie die Werte mit <ph id="ph4">`Or`</ph>) zum Abrufen.</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">Die Suche nach <ph id="ph1">`name`</ph> Groß-/Kleinschreibung beachtet.</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>The search includes public static and public instance properties.</source>
          <target state="translated">Die Suche enthält öffentliche statische und öffentlichen Instanzeigenschaften.</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>Indexers and Default Properties</source>
          <target state="translated">Indexer und Standardeigenschaften</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, und <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft den Standardwert für seinen Datentyp sein.</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">Beispielsweise, wenn die Variable <ph id="ph1">`myList`</ph> bezieht sich auf eine <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, die Syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) Ruft das Element mit dem Index von 3.</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>You can overload the property.</source>
          <target state="translated">Sie können die Eigenschaft überladen.</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">In c# ist diese Funktion einen Indexer aufgerufen wird und nicht erteilt wurde, die anhand des Namens.</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">Standardmäßig wird als eine indizierte Eigenschaft mit dem Namen "Item" ein C#-Indexers in den Metadaten angezeigt.</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">Entwickeln einer Klassenbibliothek können jedoch die <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> Attribut zum Ändern des Namens des Indexers in den Metadaten.</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">Z. B. die <ph id="ph1">&lt;xref:System.String&gt;</ph> -Klasse verfügt über einen Indexer mit dem Namen <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">Indizierte Eigenschaften, die mit anderen Sprachen als c# erstellt können auch die Namen als Element haben.</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">Um zu bestimmen, ob ein Typ eine Standardeigenschaft vorhanden ist, verwenden die <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> -Methode zur Prüfung auf die <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> Attribut.</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">Wenn der Typ besitzt <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>die <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> Eigenschaft gibt den Namen der Standardeigenschaft zurück.</target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>The following example defines a class with one property and retrieves the name and type of the property.</source>
          <target state="translated">Im folgenden Beispiel definiert eine Klasse mit einer Eigenschaft, und ruft den Namen und Typ der Eigenschaft ab.</target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source>More than one property is found with the specified name.</source>
          <target state="translated">Es wurden mehrere Eigenschaften mit dem angegebenen Namen gefunden.</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type)">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>, or <ph id="ph3">&lt;paramref name="returnType" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>, oder <ph id="ph3">&lt;paramref name="returnType" /&gt;</ph> ist <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>The string containing the name of the public property to get.</source>
          <target state="translated">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
          <target state="translated">Ein leeres Array vom <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>Searches for the specified public property whose parameters match the specified argument types.</source>
          <target state="translated">Sucht die angegebene öffentliche Eigenschaft, deren Parameter den angegebenen Argumenttypen entsprechen.</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>An object representing the public property whose parameters match the specified argument types, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das die öffentliche Eigenschaft darstellt, deren Parameter den angegebenen Argumenttypen entsprechen, sofern gefunden, andernfalls <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist.</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, kombinieren Sie die Werte mit <ph id="ph4">`Or`</ph>) zum Abrufen.</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">Die Suche nach <ph id="ph1">`name`</ph> Groß-/Kleinschreibung beachtet.</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>The search includes public static and public instance properties.</source>
          <target state="translated">Die Suche enthält öffentliche statische und öffentlichen Instanzeigenschaften.</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>Indexers and Default Properties</source>
          <target state="translated">Indexer und Standardeigenschaften</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, und <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft den Standardwert für seinen Datentyp sein.</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">Beispielsweise, wenn die Variable <ph id="ph1">`myList`</ph> bezieht sich auf eine <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, die Syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) Ruft das Element mit dem Index von 3.</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>You can overload the property.</source>
          <target state="translated">Sie können die Eigenschaft überladen.</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">In c# ist diese Funktion einen Indexer aufgerufen wird und nicht erteilt wurde, die anhand des Namens.</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">Standardmäßig wird als eine indizierte Eigenschaft mit dem Namen "Item" ein C#-Indexers in den Metadaten angezeigt.</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">Entwickeln einer Klassenbibliothek können jedoch die <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> Attribut zum Ändern des Namens des Indexers in den Metadaten.</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">Z. B. die <ph id="ph1">&lt;xref:System.String&gt;</ph> -Klasse verfügt über einen Indexer mit dem Namen <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">Indizierte Eigenschaften, die mit anderen Sprachen als c# erstellt können auch die Namen als Element haben.</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">Um zu bestimmen, ob ein Typ eine Standardeigenschaft vorhanden ist, verwenden die <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> -Methode zur Prüfung auf die <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> Attribut.</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">Wenn der Typ besitzt <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>die <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> Eigenschaft gibt den Namen der Standardeigenschaft zurück.</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>The following example retrieves the <ph id="ph1">`Type`</ph> object of a user-defined class, retrieves the property of that class, and displays the property name and type of the property as specified by the arguments passed to <ph id="ph2">`GetProperty`</ph>.</source>
          <target state="translated">Das folgende Beispiel ruft die <ph id="ph1">`Type`</ph> Objekt einer benutzerdefinierten Klasse ruft die Eigenschaft dieser Klasse ab und zeigt die Eigenschaftsnamen und den Typ der Eigenschaft entsprechend den Angaben von übergebenen Argumente <ph id="ph2">`GetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>More than one property is found with the specified name and matching the specified argument types.</source>
          <target state="translated">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Argumenttypen entsprechen.</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type[])">
          <source>An element of <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Element von <ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>The string containing the name of the public property to get.</source>
          <target state="translated">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>The return type of the property.</source>
          <target state="translated">Der Rückgabetyp der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
          <target state="translated">Ein leeres Array vom <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>Searches for the specified public property whose parameters match the specified argument types.</source>
          <target state="translated">Sucht die angegebene öffentliche Eigenschaft, deren Parameter den angegebenen Argumenttypen entsprechen.</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>An object representing the public property whose parameters match the specified argument types, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das die öffentliche Eigenschaft darstellt, deren Parameter den angegebenen Argumenttypen entsprechen, sofern gefunden, andernfalls <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist.</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, kombinieren Sie die Werte mit <ph id="ph4">`Or`</ph>) zum Abrufen.</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">Die Suche nach <ph id="ph1">`name`</ph> Groß-/Kleinschreibung beachtet.</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>The search includes public static and public instance properties.</source>
          <target state="translated">Die Suche enthält öffentliche statische und öffentlichen Instanzeigenschaften.</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>Indexers and Default Properties</source>
          <target state="translated">Indexer und Standardeigenschaften</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, und <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft den Standardwert für seinen Datentyp sein.</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">Beispielsweise, wenn die Variable <ph id="ph1">`myList`</ph> bezieht sich auf eine <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, die Syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) Ruft das Element mit dem Index von 3.</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>You can overload the property.</source>
          <target state="translated">Sie können die Eigenschaft überladen.</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">In c# ist diese Funktion einen Indexer aufgerufen wird und nicht erteilt wurde, die anhand des Namens.</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">Standardmäßig wird als eine indizierte Eigenschaft mit dem Namen "Item" ein C#-Indexers in den Metadaten angezeigt.</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">Entwickeln einer Klassenbibliothek können jedoch die <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> Attribut zum Ändern des Namens des Indexers in den Metadaten.</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">Z. B. die <ph id="ph1">&lt;xref:System.String&gt;</ph> -Klasse verfügt über einen Indexer mit dem Namen <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">Indizierte Eigenschaften, die mit anderen Sprachen als c# erstellt können auch die Namen als Element haben.</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">Um zu bestimmen, ob ein Typ eine Standardeigenschaft vorhanden ist, verwenden die <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> -Methode zur Prüfung auf die <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> Attribut.</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">Wenn der Typ besitzt <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>die <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> Eigenschaft gibt den Namen der Standardeigenschaft zurück.</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>More than one property is found with the specified name and matching the specified argument types.</source>
          <target state="translated">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Argumenttypen entsprechen.</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[])">
          <source>An element of <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Element von <ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the public property to get.</source>
          <target state="translated">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The return type of the property.</source>
          <target state="translated">Der Rückgabetyp der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
          <target state="translated">Ein leeres Array vom <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph>-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>-Array zugeordnet sind.</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">Der Standardbinder verarbeitet diesen Parameter nicht.</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified public property whose parameters match the specified argument types and modifiers.</source>
          <target state="translated">Sucht die angegebene öffentliche Eigenschaft, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the public property that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das die öffentliche Eigenschaft darstellt, die den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist.</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, kombinieren Sie die Werte mit <ph id="ph4">`Or`</ph>) zum Abrufen.</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Obwohl der Standardbinder nicht verarbeitet <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (die <ph id="ph2">`modifiers`</ph> Parameter), können Sie die abstrakte <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The search for <ph id="ph1">`name`</ph> is case-sensitive.</source>
          <target state="translated">Die Suche nach <ph id="ph1">`name`</ph> Groß-/Kleinschreibung beachtet.</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The search includes public static and public instance properties.</source>
          <target state="translated">Die Suche enthält öffentliche statische und öffentlichen Instanzeigenschaften.</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Indexers and Default Properties</source>
          <target state="translated">Indexer und Standardeigenschaften</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, und <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft den Standardwert für seinen Datentyp sein.</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">Beispielsweise, wenn die Variable <ph id="ph1">`myList`</ph> bezieht sich auf eine <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, die Syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) Ruft das Element mit dem Index von 3.</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can overload the property.</source>
          <target state="translated">Sie können die Eigenschaft überladen.</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">In c# ist diese Funktion einen Indexer aufgerufen wird und nicht erteilt wurde, die anhand des Namens.</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">Standardmäßig wird als eine indizierte Eigenschaft mit dem Namen "Item" ein C#-Indexers in den Metadaten angezeigt.</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">Entwickeln einer Klassenbibliothek können jedoch die <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> Attribut zum Ändern des Namens des Indexers in den Metadaten.</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">Z. B. die <ph id="ph1">&lt;xref:System.String&gt;</ph> -Klasse verfügt über einen Indexer mit dem Namen <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">Indizierte Eigenschaften, die mit anderen Sprachen als c# erstellt können auch die Namen als Element haben.</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">Um zu bestimmen, ob ein Typ eine Standardeigenschaft vorhanden ist, verwenden die <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> -Methode zur Prüfung auf die <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> Attribut.</target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">Wenn der Typ besitzt <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>die <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> Eigenschaft gibt den Namen der Standardeigenschaft zurück.</target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following example obtains a <ph id="ph1">`Type`</ph> object corresponding to <ph id="ph2">`MyPropertyClass`</ph>, and the indexed property of this class is retrieved using the arguments passed to the <ph id="ph3">`GetProperty`</ph> method.</source>
          <target state="translated">Im folgenden Beispiel wird eine <ph id="ph1">`Type`</ph> -Objekt entsprechende <ph id="ph2">`MyPropertyClass`</ph>, und indizierte Eigenschaft dieser Klasse abgerufen wird, verwenden die Argumente an die <ph id="ph3">`GetProperty`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one property is found with the specified name and matching the specified argument types and modifiers.</source>
          <target state="translated">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Argumenttypen sowie Modifizierern entsprechen.</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> und <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> weisen nicht die gleiche Länge auf.</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An element of <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Element von <ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the property to get.</source>
          <target state="translated">Die Zeichenfolge, die den Namen der abzurufenden Eigenschaft enthält.</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">0 (null), damit <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Ein Nullverweis (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), wenn <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph> verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The return type of the property.</source>
          <target state="translated">Der Rückgabetyp der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
          <target state="translated">Ein leeres Array vom <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph>-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>-Array zugeordnet sind.</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">Der Standardbinder verarbeitet diesen Parameter nicht.</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
          <target state="translated">Sucht anhand der angegebenen Bindungseinschränkungen nach der angegebenen Eigenschaft, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the property that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das die Eigenschaft darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A property is considered public to reflection if it has at least one accessor that is public.</source>
          <target state="translated">Eine Eigenschaft ist öffentlich sein, um Reflektion betrachtet, wenn sie mindestens eine Zugriffsmethode aufweist, die öffentlich ist.</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Otherwise the property is considered private, and you must use <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, combine the values using <ph id="ph4">`Or`</ph>) to get it.</source>
          <target state="translated">Andernfalls wird die Eigenschaft als privat betrachtet, und Sie müssen <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType&gt;</ph> &amp;#124; <ph id="ph3">&lt;xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType&gt;</ph> (in Visual Basic, kombinieren Sie die Werte mit <ph id="ph4">`Or`</ph>) zum Abrufen.</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Obwohl der Standardbinder nicht verarbeitet <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (die <ph id="ph2">`modifiers`</ph> Parameter), können Sie die abstrakte <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die <ph id="ph1">`Get`</ph> Methoden, wenn für einen Typ reflektieren.</target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Member Type</source>
          <target state="translated">Memberart</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Static</source>
          <target state="translated">Statisch</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Non-Static</source>
          <target state="translated">Nicht statische</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Constructor</source>
          <target state="translated">Konstruktor</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Field</source>
          <target state="translated">Feld</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Ein Feld ist immer nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Method</source>
          <target state="translated">Methode</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Nested Type</source>
          <target state="translated">Geschachtelten Typs</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Property</source>
          <target state="translated">Eigenschaft</target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>This is a binary comparison.</source>
          <target state="translated">Dies ist ein binärer Vergleich.</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which properties to include in the search:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Filterkennzeichnungen genutzt werden, welche Eigenschaften in die Suche einbezogen werden:</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Instance`</ph> oder <ph id="ph2">`BindingFlags.Static`</ph> ändern, um einen Rückgabewert zu erhalten.</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public properties in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Public`</ph> auf öffentliche Eigenschaften in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.NonPublic`</ph> an nicht öffentlichen Eigenschaften (d. h. private, interne und geschützte) in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> einschließen <ph id="ph2">`public`</ph> und <ph id="ph3">`protected`</ph> statische Member der Hierarchie; nach oben <ph id="ph4">`private`</ph> statische Member in geerbten Klassen sind nicht eingeschlossen.</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> um die Groß-/Kleinschreibung ignorieren <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> Suche nur die deklarierten Eigenschaften der <ph id="ph2">&lt;xref:System.Type&gt;</ph>, nicht die Eigenschaften, die nur geerbt wurden.</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Methode die <ph id="ph2">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> mit Parametern für den durch die entsprechenden Typargumente ersetzt.</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Methode sucht die Eigenschaften der Class-Einschränkung.</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Indexers and Default Properties</source>
          <target state="translated">Indexer und Standardeigenschaften</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id="ph2">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, und <ph id="ph3">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft den Standardwert für seinen Datentyp sein.</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, if the variable <ph id="ph1">`myList`</ph> refers to an <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.</source>
          <target state="translated">Beispielsweise, wenn die Variable <ph id="ph1">`myList`</ph> bezieht sich auf eine <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph>, die Syntax <ph id="ph3">`myList[3]`</ph> (<ph id="ph4">`myList(3)`</ph> in Visual Basic) Ruft das Element mit dem Index von 3.</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You can overload the property.</source>
          <target state="translated">Sie können die Eigenschaft überladen.</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>In C#, this feature is called an indexer and cannot be refered to by name.</source>
          <target state="translated">In c# ist diese Funktion einen Indexer aufgerufen wird und nicht erteilt wurde, die anhand des Namens.</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>By default, a C# indexer appears in metadata as an indexed property named "Item".</source>
          <target state="translated">Standardmäßig wird als eine indizierte Eigenschaft mit dem Namen "Item" ein C#-Indexers in den Metadaten angezeigt.</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>However, a class library developer can use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.</source>
          <target state="translated">Entwickeln einer Klassenbibliothek können jedoch die <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> Attribut zum Ändern des Namens des Indexers in den Metadaten.</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>For example, the <ph id="ph1">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</source>
          <target state="translated">Z. B. die <ph id="ph1">&lt;xref:System.String&gt;</ph> -Klasse verfügt über einen Indexer mit dem Namen <ph id="ph2">&lt;xref:System.String.Chars%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Indexed properties created using languages other than C# can have names other than Item, as well.</source>
          <target state="translated">Indizierte Eigenschaften, die mit anderen Sprachen als c# erstellt können auch die Namen als Element haben.</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>To determine whether a type has a default property, use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.</source>
          <target state="translated">Um zu bestimmen, ob ein Typ eine Standardeigenschaft vorhanden ist, verwenden die <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> -Methode zur Prüfung auf die <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> Attribut.</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>If the type has <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.</source>
          <target state="translated">Wenn der Typ besitzt <ph id="ph1">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>die <ph id="ph2">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> Eigenschaft gibt den Namen der Standardeigenschaft zurück.</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one property is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> und <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> weisen nicht die gleiche Länge auf.</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" uid="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An element of <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Element von <ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The string containing the name of the property to get.</source>
          <target state="translated">Die Zeichenfolge, die den Namen der abzurufenden Eigenschaft enthält.</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Zero, to return <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">0 (null), damit <ph id="ph1">&lt;see langword="null" /&gt;</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl eines überladenen Members, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Ein Nullverweis (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), wenn <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph> verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The return type of the property.</source>
          <target state="translated">Der Rückgabetyp der Eigenschaft.</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An empty array of the type <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</source>
          <target state="translated">Ein leeres Array vom <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph>-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <bpt id="p1">&lt;c&gt;</bpt>types<ept id="p1">&lt;/c&gt;</ept>-Array zugeordnet sind.</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The default binder does not process this parameter.</source>
          <target state="translated">Der Standardbinder verarbeitet diesen Parameter nicht.</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</source>
          <target state="translated">Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen nach der angegebenen Eigenschaft, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>An object representing the property that matches the specified requirements, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das die Eigenschaft darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id="ph2">`modifiers`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`modifiers`</ph>.</source>
          <target state="translated">Obwohl der Standardbinder nicht verarbeitet <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (die <ph id="ph2">`modifiers`</ph> Parameter), können Sie die abstrakte <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden <ph id="ph4">`modifiers`</ph>.</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which properties to include in the search:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Filterkennzeichnungen genutzt werden, welche Eigenschaften in die Suche einbezogen werden:</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>You must specify either <ph id="ph1">`BindingFlags.Instance`</ph> or <ph id="ph2">`BindingFlags.Static`</ph> in order to get a return.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Instance`</ph> oder <ph id="ph2">`BindingFlags.Static`</ph> ändern, um einen Rückgabewert zu erhalten.</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public properties in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Public`</ph> auf öffentliche Eigenschaften in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.NonPublic`</ph> an nicht öffentlichen Eigenschaften (d. h. private, interne und geschützte) in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include <ph id="ph2">`public`</ph> and <ph id="ph3">`protected`</ph> static members up the hierarchy; <ph id="ph4">`private`</ph> static members in inherited classes are not included.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> einschließen <ph id="ph2">`public`</ph> und <ph id="ph3">`protected`</ph> statische Member der Hierarchie; nach oben <ph id="ph4">`private`</ph> statische Member in geerbten Klassen sind nicht eingeschlossen.</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> um die Groß-/Kleinschreibung ignorieren <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> Suche nur die deklarierten Eigenschaften der <ph id="ph2">&lt;xref:System.Type&gt;</ph>, nicht die Eigenschaften, die nur geerbt wurden.</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>More than one property is found with the specified name and matching the specified binding constraints.</source>
          <target state="translated">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="name" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>One of the elements in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Eines der Elemente in <ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> is multidimensional.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="modifiers" /&gt;</ph> ist mehrdimensional.</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source><ph id="ph1">&lt;paramref name="types" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="types" /&gt;</ph> und <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> weisen nicht die gleiche Länge auf.</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" uid="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])">
          <source>The current type is a <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>, <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.EnumBuilder" /&gt;</ph>, or <ph id="ph3">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>.</source>
          <target state="translated">Der aktuelle Typ ist ein <ph id="ph1">&lt;see cref="T:System.Reflection.Emit.TypeBuilder" /&gt;</ph>, ein <ph id="ph2">&lt;see cref="T:System.Reflection.Emit.EnumBuilder" /&gt;</ph> oder ein <ph id="ph3">&lt;see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the specified type.</source>
          <target state="translated">Ruft ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt ab, das den angegebenen Typ darstellt.</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" uid="M:System.Type.GetType">
          <source>Gets the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft den aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" uid="M:System.Type.GetType">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Der aktuelle <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" uid="M:System.Type.GetType">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>The assembly-qualified name of the type to get.</source>
          <target state="translated">Der durch die Assembly bezeichnete Name des abzurufenden Typs.</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>.</source>
          <target state="translated">Siehe <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">Wenn sich der Typ in der aktuell ausgeführten Assembly oder in Mscorlib.dll befindet, ist eine Angabe des Typnamens einschließlich des qualifizierenden Namespace ausreichend.</target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with the specified name, performing a case-sensitive search.</source>
          <target state="translated">Ruft den <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> mit dem angegebenen Namen ab. Bei der Suche wird die Groß-/Kleinschreibung beachtet.</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>The type with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der Typ mit dem angegebenen Namen, sofern gefunden, andernfalls <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method to obtain a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object for a type in another assembly, if you know its namespace-qualified name.</source>
          <target state="translated">Können Sie die <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> Methode zum Abrufen einer <ph id="ph2">&lt;xref:System.Type&gt;</ph> -Objekt für einen Typ in einer anderen Assembly, wenn Sie wissen, dass die Namespace-qualifizierten Namen.</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> causes loading of the assembly specified in <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> führt zum Laden der Assembly im angegebenen <ph id="ph2">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>You can also load an assembly using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method, and then use the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> methods of the <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> class to get <ph id="ph5">&lt;xref:System.Type&gt;</ph> objects.</source>
          <target state="translated">Sie können auch laden eine Assembly mit der <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> -Methode, und verwenden Sie dann die <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> Methoden die <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> Klasse abgerufen <ph id="ph5">&lt;xref:System.Type&gt;</ph> Objekte.</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If a type is in an assembly known to your program at compile time, it is more efficient to use  in C#, <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> in Visual Basic, or  in C++.</source>
          <target state="translated">Wenn ein Typ in einer Assembly, die für Ihr Programm zur Kompilierzeit bekannt ist, ist es effizienter, in c# verwenden <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> in Visual Basic oder c++.</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If <ph id="ph1">`typeName`</ph> cannot be found, the call to the <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%29&gt;</ph> method returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`typeName`</ph> kann nicht gefunden werden, den Aufruf der <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%29&gt;</ph> -Methode zurückkehrt <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>It does not throw an exception.</source>
          <target state="translated">Es wird keine Ausnahme auslöst.</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To control whether an exception is thrown, call an overload of the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method that has a <ph id="ph2">`throwOnError`</ph> parameter.</source>
          <target state="translated">Um zu steuern, ob eine Ausnahme ausgelöst, rufen Sie eine Überladung der <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> Methode, die eine <ph id="ph2">`throwOnError`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> only works on assemblies loaded from disk.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> funktioniert nur für Assemblys, die von der Festplatte geladen.</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If you call <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> to look up a type defined in a dynamic assembly defined using the <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> services, you might get inconsistent behavior.</source>
          <target state="translated">Beim Aufrufen <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> zum Nachschlagen eines Typs in eine dynamische Assembly mit definiert, definiert der <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> Services, erhalten Sie möglicherweise inkonsistentes Verhalten.</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The behavior depends on whether the dynamic assembly is persistent, that is, created using the <ph id="ph1">`RunAndSave`</ph> or <ph id="ph2">`Save`</ph> access modes of the <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Das Verhalten abhängig, ob die dynamische Assembly persistent, d. h., erstellt, mit der <ph id="ph1">`RunAndSave`</ph> oder <ph id="ph2">`Save`</ph> Zugriff auf die Modi für die <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph> Enumeration.</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If the dynamic assembly is persistent and has been written to disk before <ph id="ph1">`GetType`</ph> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</source>
          <target state="translated">Wenn die dynamische Assembly persistent ist und bevor Sie den Datenträger geschrieben wurden <ph id="ph1">`GetType`</ph> wird aufgerufen, das Ladeprogramm für die gespeicherte Assembly sucht, auf dem Datenträger, lädt die Assembly und ruft den Typ aus dieser Assembly ab.</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If the assembly has not been saved to disk when <ph id="ph1">`GetType`</ph> is called, the method returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Wenn die Assembly nicht gespeichert wurde, wenn auf den Datenträger <ph id="ph1">`GetType`</ph> aufgerufen wird, wird der Methodenrückgabe <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`GetType`</ph> does not understand transient dynamic assemblies; therefore, calling <ph id="ph2">`GetType`</ph> to retrieve a type in a transient dynamic assembly returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetType`</ph> flüchtige dynamische Assemblys versteht nicht; aus diesem Grund Aufrufen <ph id="ph2">`GetType`</ph> zum Abrufen eines Typs in eine flüchtige dynamische Assembly gibt <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To use <ph id="ph1">`GetType`</ph> on a dynamic module, subscribe to the <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph> event and call <ph id="ph3">`GetType`</ph> before saving.</source>
          <target state="translated">Mit <ph id="ph1">`GetType`</ph> für ein dynamisches Modul Abonnieren der <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph> Ereignis, und rufen <ph id="ph3">`GetType`</ph> vor dem Speichern.</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Otherwise, you will get two copies of the assembly in memory.</source>
          <target state="translated">Andernfalls erhalten Sie zwei Kopien der Assembly im Arbeitsspeicher.</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die <ph id="ph1">`Get`</ph> Methoden, wenn für einen Typ reflektieren.</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Member Type</source>
          <target state="translated">Memberart</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Static</source>
          <target state="translated">Statisch</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Non-Static</source>
          <target state="translated">Nicht statische</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Constructor</source>
          <target state="translated">Konstruktor</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Field</source>
          <target state="translated">Feld</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Ein Feld ist immer nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Method</source>
          <target state="translated">Methode</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Nested Type</source>
          <target state="translated">Geschachtelten Typs</target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Property</source>
          <target state="translated">Eigenschaft</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>This is a binary comparison.</source>
          <target state="translated">Dies ist ein binärer Vergleich.</target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</source>
          <target state="translated">Arrays oder COM-Typen werden nicht für durchsucht, es sei denn, sie bereits in der Tabelle der verfügbaren Klassen geladen wurden.</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`typeName`</ph> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</source>
          <target state="translated"><ph id="ph1">`typeName`</ph> Der Typname kann durch den Namespace oder ein Assembly qualifizierter Name, der eine Assembly namensspezifikation enthält qualifiziert werden.</target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>See <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</source>
          <target state="translated">Siehe <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If <ph id="ph1">`typeName`</ph> includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</source>
          <target state="translated">Wenn <ph id="ph1">`typeName`</ph> des Namespace, jedoch nicht den Assemblynamen eingeben, enthält diese Methode sucht nur die Assembly des aufrufenden Objekts und die Datei "mscorlib.dll", in dieser Reihenfolge.</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</source>
          <target state="translated">Wenn TypeName vollqualifizierten mit dem Assemblynamen teilweise oder vollständig ist, sucht diese Methode in der angegebenen Assembly.</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If the assembly has a strong name, a complete assembly name is required.</source>
          <target state="translated">Wenn die Assembly einen starken Namen besitzt, ist ein vollständige Assemblyname erforderlich.</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property returns a fully qualified type name including nested types, the assembly name, and generic type arguments.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> Eigenschaft gibt einen vollqualifizierten Typnamen einschließlich geschachtelter Typen, Assemblyname und generische Typargumente.</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</source>
          <target state="translated">Alle Compiler, die die common Language Runtime unterstützen, den einfachen Namen einer geschachtelten Klasse geben, und Reflektion erstellt einen ergänzten Namen bei einer Abfrage in Übereinstimmung mit den folgenden Konventionen.</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">In .NET Framework, Version 2.0 Prozessorarchitektur Assemblyidentität hinzugefügt und kann als Teil der Assembly-Zeichenfolgen angegeben werden.</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, "ProcessorArchitecture=msil".</source>
          <target state="translated">Z. B. "ProcessorArchitecture = Msil".</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.</source>
          <target state="translated">Ist jedoch nicht in die zurückgegebene Zeichenfolge enthalten die <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> Eigenschaft, aus Gründen der Kompatibilität.</target>       </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>You can also load types by creating an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and passing it to an appropriate overload of the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">Sie können Typen auch laden, indem Sie erstellen eine <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> -Objekt und übergibt dieses an eine entsprechende Überladung der der <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>You can then use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> method to load types from the assembly.</source>
          <target state="translated">Anschließend können Sie die <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> -Methode zum Laden von Typen aus der Assembly.</target>       </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>See also <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Siehe auch <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Delimiter</source>
          <target state="translated">Trennzeichen</target>       </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Meaning</source>
          <target state="translated">Bedeutung</target>       </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Backslash (<ph id="ph1">\\</ph>)</source>
          <target state="translated">Umgekehrter Schrägstrich (<ph id="ph1">\\</ph>)</target>       </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Escape character.</source>
          <target state="translated">Escape-Zeichen.</target>       </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Backtick (`)</source>
          <target state="translated">Umgekehrtes Apostroph (')</target>       </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</source>
          <target state="translated">Steht vor eine oder mehrere Ziffern, die die Anzahl von Typparametern, am Ende des Namens eines generischen Typs darstellt.</target>       </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Brackets ([])</source>
          <target state="translated">Klammern ([])</target>       </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</source>
          <target state="translated">Schließen Sie eine generische Liste der Typargumente, für einen konstruierten generischen Typ; Schließen Sie in einer Liste der Typargumente eine Assembly qualifizierten Typnamen an.</target>       </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Comma (,)</source>
          <target state="translated">Komma (,)</target>       </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Precedes the Assembly name.</source>
          <target state="translated">Ist der Name der Assembly vorangestellt.</target>       </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Period (.)</source>
          <target state="translated">Punkt (.)</target>       </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Denotes namespace identifiers.</source>
          <target state="translated">Gibt die Namespacebezeichner.</target>       </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Plus sign (+)</source>
          <target state="translated">Pluszeichen (+)</target>       </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Precedes a nested class.</source>
          <target state="translated">Ist eine geschachtelte Klasse vorangestellt.</target>       </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, the fully qualified name for a class might look like this:</source>
          <target state="translated">Beispielsweise kann der vollqualifizierte Name für eine Klasse wie folgt aussehen:</target>       </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (<ph id="ph1">\\</ph>) to prevent it from being interpreted as a nesting separator.</source>
          <target state="translated">Wenn der Namespace wurden TopNamespace.Sub, würde die Zeichenfolge auf das Pluszeichen (+) ein Escapezeichen vorangestellt haben (<ph id="ph1">\\</ph>) zu verhindern, dass er als schachteln Trennzeichen interpretiert wird.</target>       </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Reflection emits this string as follows:</source>
          <target state="translated">Reflektion wird diese Zeichenfolge wie folgt aus:</target>       </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</source>
          <target state="translated">Ein "++" wird "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", und ein "<ph id="ph4">\\</ph>"wird"<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</target>       </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>This qualified name can be persisted and later used to load the <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Dieser qualifizierte Name kann beibehalten und später zum Laden der <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To search for and load a <ph id="ph1">&lt;xref:System.Type&gt;</ph>, use <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.</source>
          <target state="translated">Suchen und Laden einer <ph id="ph1">&lt;xref:System.Type&gt;</ph>, verwenden Sie <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> entweder mit dem Typ oder einen Namen geben nur mit der Assembly qualifizierten Typnamen.</target>       </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> mit dem Namen nur sieht für den <ph id="ph2">&lt;xref:System.Type&gt;</ph> in der Assembly des Aufrufers, und klicken Sie dann in der System-Assembly.</target>       </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in any assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> mit der Assembly qualifizierten Typnamen für sieht die <ph id="ph2">&lt;xref:System.Type&gt;</ph> in jeder beliebigen Assembly.</target>       </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</source>
          <target state="translated">Geben Sie die Namen eventuell nachfolgende Zeichen, die zusätzliche über den Typ Informationen, z. B., ob der Typ ein Verweistyp, ein Zeigertyp oder ein Arraytyp ist.</target>       </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To retrieve the type name without these trailing characters, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, where <ph id="ph2">`t`</ph> is the type.</source>
          <target state="translated">Verwenden Sie zum Abrufen der Typname ohne diese nachfolgenden Zeichen <ph id="ph1">`t.GetElementType().ToString()`</ph>, wobei <ph id="ph2">`t`</ph> ist der Typ.</target>       </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Spaces are relevant in all type name components except the assembly name.</source>
          <target state="translated">Leerzeichen sind in allen Komponenten von Typnamen mit Ausnahme der Assemblyname relevant.</target>       </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</source>
          <target state="translated">In der Assemblyname Leerzeichen vor dem Trennzeichen "," relevant sind, aber nach dem Trennzeichen "," Leerzeichen werden ignoriert.</target>       </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The name of a generic type ends with a backtick (<ph id="ph1">\`</ph>) followed by digits representing the number of generic type arguments.</source>
          <target state="translated">Der Name eines generischen Typs endet mit der ein umgekehrtes Apostroph (<ph id="ph1">\`</ph>) gefolgt von Ziffern, die die Anzahl der Argumente des generischen Typs darstellt.</target>       </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</source>
          <target state="translated">Dieser Name-mangling dient zum Zulassen von Compilern zur Unterstützung von generischer Typen mit dem gleichen Namen, aber mit einer unterschiedlichen Anzahl von Typparametern, im selben Gültigkeitsbereich auftritt.</target>       </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, reflection returns the mangled names <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>Tuple<ph id="ph3">`2`</ph> from the generic methods <ph id="ph4">`Tuple(Of T)`</ph> and <ph id="ph5">`Tuple(Of T0, T1)`</ph> in Visual Basic, or <ph id="ph6">`Tuple&lt;T&gt;`</ph> and Tuple<ph id="ph7">`\&lt;T0, T1&gt;`</ph> in Visual C#.</source>
          <target state="translated">Reflektion gibt z. B. die ergänzten Namen <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>Tupel<ph id="ph3">`2`</ph> aus den generischen Methoden <ph id="ph4">`Tuple(Of T)`</ph> und <ph id="ph5">`Tuple(Of T0, T1)`</ph> in Visual Basic oder <ph id="ph6">`Tuple&lt;T&gt;`</ph> und Tupel<ph id="ph7">`\&lt;T0, T1&gt;`</ph> in Visual c#.</target>       </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</source>
          <target state="translated">Bei generischen Typen wird die Typargumentliste in Klammern gesetzt, und die Typargumente werden durch Kommas getrennt.</target>       </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, a generic <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> has two type parameters.</source>
          <target state="translated">Angenommen, eine generische <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> verfügt über zwei Typparameter.</target>       </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph> might be represented as follows:</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> von <ph id="ph2">`MyType`</ph> mit Schlüsseln des Typs <ph id="ph3">&lt;xref:System.String&gt;</ph> kann wie folgt dargestellt werden:</target>       </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</source>
          <target state="translated">Um eine Assembly qualifizierten Typnamen in einer Liste der Typargumente angeben, schließen Sie die Assembly qualifizierten Typnamen in Klammern ein.</target>       </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</source>
          <target state="translated">Andernfalls werden die Kommas, die trennen die Bestandteile der Assembly qualifizierte Name, als Trennzeichen für weitere Typargumente interpretiert.</target>       </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, a <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> fromMyAssembly.dll, with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph>, might be specified as follows:</source>
          <target state="translated">Z. B. eine <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> von <ph id="ph2">`MyType`</ph> fromMyAssembly.dll, mit Schlüsseln des Typs <ph id="ph3">&lt;xref:System.String&gt;</ph>, kann wie folgt angegeben werden:</target>       </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</source>
          <target state="translated">Eine Assembly qualifizierten Typnamen kann in Klammern eingeschlossen werden, nur, wenn es in einer Typparameterliste angezeigt wird.</target>       </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</source>
          <target state="translated">Die Regeln für das Suchen von Assemblys für qualifizierten und nicht qualifizierten Typen in Typparameterlisten sind identisch mit den Regeln für qualifizierte und nicht qualifizierte nicht generische Typen.</target>       </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Nullable types are a special case of generic types.</source>
          <target state="translated">Auf NULL festlegbare Typen sind ein besonderer Fall von generischen Typen.</target>       </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, a nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph> is represented by the string "System.Nullable`1[System.Int32]".</source>
          <target state="translated">Angenommen, ein NULL-Werte zulassen <ph id="ph1">&lt;xref:System.Int32&gt;</ph> wird durch die Zeichenfolge "System.Nullable'1[System.Int32]" dargestellt.</target>       </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>In C#, C++, and Visual Basic you can also get nullable types using type operators.</source>
          <target state="translated">In c#, C++ und Visual Basic können Sie auch auf NULL festlegbaren Typen, die mithilfe von Operatoren abrufen.</target>       </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, the nullable <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> type is returned by <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> in C#, by <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> in C++, and by <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> in Visual Basic.</source>
          <target state="translated">Angenommen, die NULL-Werte zulässt <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> zurückgegebene Typ <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> in c# durch <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> in C++ und in <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> in Visual Basic.</target>       </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The following table shows the syntax you use with <ph id="ph1">`GetType`</ph> for various types.</source>
          <target state="translated">Die folgende Tabelle zeigt die Syntax, die Sie mit <ph id="ph1">`GetType`</ph> für verschiedene Typen.</target>       </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>To Get</source>
          <target state="translated">Zum Abrufen</target>       </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Use</source>
          <target state="translated">Mit</target>       </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph></source>
          <target state="translated">Ein NULL-Werte zulässt <ph id="ph1">&lt;xref:System.Int32&gt;</ph></target>       </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</target>       </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An unmanaged pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Ein nicht verwalteter Zeiger auf <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An unmanaged pointer to a pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Ein nicht verwalteter Zeiger auf einen Zeiger auf <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A managed pointer or reference to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Ein verwalteter Zeiger oder Verweis auf <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>.</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyType&amp;")`</ph></target>       </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>Note that unlike pointers, references are limited to one level.</source>
          <target state="translated">Beachten Sie, dass Verweise im Gegensatz zu Zeigern auf eine Ebene beschränkt sind.</target>       </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A parent class and a nested class</source>
          <target state="translated">Eine übergeordnete Klasse und eine geschachtelte Klasse</target>       </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A one-dimensional array with a lower bound of 0</source>
          <target state="translated">Ein eindimensionales Array mit einer unteren Grenze von 0</target>       </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A one-dimensional array with an unknown lower bound</source>
          <target state="translated">Ein eindimensionales Array mit einer unbekannten Untergrenze</target>       </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An n-dimensional array</source>
          <target state="translated">Ein n-dimensionalen array</target>       </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A comma (,) inside the brackets a total of n-1 times.</source>
          <target state="translated">Ein Komma (,) innerhalb der Klammern eine insgesamt n-1 Mal.</target>       </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>For example, <ph id="ph1">`System.Object[,,]`</ph> represents a three-dimensional <ph id="ph2">`Object`</ph> array.</source>
          <target state="translated">Beispielsweise <ph id="ph1">`System.Object[,,]`</ph> stellt eine dreidimensionale <ph id="ph2">`Object`</ph> Array.</target>       </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An array of one-dimensional arrays</source>
          <target state="translated">Ein Array von eindimensionale arrays</target>       </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A rectangular two-dimensional array with unknown lower bounds</source>
          <target state="translated">Kein rechteckiges zweidimensionales Array mit unbekannten Untergrenzen</target>       </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A generic type with one type argument</source>
          <target state="translated">Ein generischer Typ mit einem Typargument</target>       </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</target>       </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A generic type with two type arguments</source>
          <target state="translated">Ein generischer Typ mit zwei Typargumenten</target>       </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</target>       </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A generic type with two assembly-qualified type arguments</source>
          <target state="translated">Ein generischer Typ mit zwei durch die Assembly qualifizierten Typargumenten</target>       </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")"</target>       </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>An assembly-qualified generic type with an assembly-qualified type argument</source>
          <target state="translated">Ein assemblyqualifizierten generischer Typ mit einem Assembly qualifizierten Typnamen-argument</target>       </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")"</target>       </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>A generic type whose type argument is a generic type with two type arguments</source>
          <target state="translated">Ein generischer Typ, dessen Type-Argument ein generischer Typ mit zwei Typargumenten ist</target>       </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></target>       </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String)">
          <source>The following example retrieves the type of <ph id="ph1">`System.Int32`</ph> and uses that type object to display the <ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph> property of <ph id="ph3">`System.Int32`</ph>.</source>
          <target state="translated">Das folgende Beispiel ruft den Typ des <ph id="ph1">`System.Int32`</ph> und verwendet diese Typobjekt zum Anzeigen der <ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph> Eigenschaft <ph id="ph3">`System.Int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt einen generischen Typ dar, der einen Zeigertyp, einen <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph>-Typ oder <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> als eines seiner Typargumente aufweist.</target>       </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.</target>       </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</target>       </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt ein Array von <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph> dar.</target>       </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, instead.</source>
          <target state="translated">Fangen Sie in <bpt id="p1">[</bpt>.NET für Windows Store-Apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> oder der <bpt id="p2">[</bpt>portablen Klassenbibliothek<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept> stattdessen die Basisklassenausnahme <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</target>       </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.</target>       </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String)">
          <source>Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</source>
          <target state="translated">Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und die Assembly wurde mit einer höheren Version kompiliert.</target>       </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The assembly-qualified name of the type to get.</source>
          <target state="translated">Der durch die Assembly bezeichnete Name des abzurufenden Typs.</target>       </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>.</source>
          <target state="translated">Siehe <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">Wenn sich der Typ in der aktuell ausgeführten Assembly oder in Mscorlib.dll befindet, ist eine Angabe des Typnamens einschließlich des qualifizierenden Namespace ausreichend.</target>       </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden werden kann, <ph id="ph2">&lt;see langword="false" /&gt;</ph>, damit <ph id="ph3">&lt;see langword="null" /&gt;</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Specifying <ph id="ph1">&lt;see langword="false" /&gt;</ph> also suppresses some other exception conditions, but not all of them.</source>
          <target state="translated">Die Angabe von <ph id="ph1">&lt;see langword="false" /&gt;</ph> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle.</target>       </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">Informationen finden Sie im Abschnitt für Ausnahmen.</target>       </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found.</source>
          <target state="translated">Ruft den <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> mit dem angegebenen Namen ab. Bei der Suche wird die Groß-/Kleinschreibung beachtet. Dabei wird angegeben, ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird.</target>       </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The type with the specified name.</source>
          <target state="translated">Der Typ mit dem angegebenen Namen.</target>       </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the type is not found, the <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> parameter specifies whether <ph id="ph2">&lt;see langword="null" /&gt;</ph> is returned or an exception is thrown.</source>
          <target state="translated">Wenn der Typ nicht gefunden wird, gibt der <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>-Parameter an, ob <ph id="ph2">&lt;see langword="null" /&gt;</ph> zurückgegeben oder eine Ausnahme ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>In some cases, an exception is thrown regardless of the value of <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</source>
          <target state="translated">In einigen Fällen wird unabhängig vom Wert von <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> eine Ausnahme ausgelöst.</target>       </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">Informationen finden Sie im Abschnitt für Ausnahmen.</target>       </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method to obtain a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object for a type in another assembly, if the you know its namespace-qualified name.</source>
          <target state="translated">Können Sie die <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> Methode zum Abrufen einer <ph id="ph2">&lt;xref:System.Type&gt;</ph> -Objekt für einen Typ in einer anderen Assembly, wenn Sie wissen, dass die Namespace-qualifizierten Namen.</target>       </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> causes loading of the assembly specified in <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> führt zum Laden der Assembly im angegebenen <ph id="ph2">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>You can also load an assembly using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method, and then use the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> methods of the <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> class to get <ph id="ph5">&lt;xref:System.Type&gt;</ph> objects.</source>
          <target state="translated">Sie können auch laden eine Assembly mit der <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> -Methode, und verwenden Sie dann die <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> Methoden die <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> Klasse abgerufen <ph id="ph5">&lt;xref:System.Type&gt;</ph> Objekte.</target>       </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If a type is in an assembly known to your program at compile time, it is more efficient to use <ph id="ph1">`typeof`</ph> in C#, <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> in Visual Basic, or <ph id="ph3">`typeid`</ph> in C++.</source>
          <target state="translated">Wenn ein Typ in einer Assembly, die für Ihr Programm zur Kompilierzeit bekannt ist, ist es effizienter, verwenden <ph id="ph1">`typeof`</ph> in c# <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> in Visual Basic oder <ph id="ph3">`typeid`</ph> in C++.</target>       </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`GetType`</ph> only works on assemblies loaded from disk.</source>
          <target state="translated"><ph id="ph1">`GetType`</ph> funktioniert nur für Assemblys, die von der Festplatte geladen.</target>       </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If you call <ph id="ph1">`GetType`</ph> to look up a type defined in a dynamic assembly defined using the <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> services, you might get inconsistent behavior.</source>
          <target state="translated">Beim Aufrufen <ph id="ph1">`GetType`</ph> zum Nachschlagen eines Typs in eine dynamische Assembly mit definiert, definiert der <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> Services, erhalten Sie möglicherweise inkonsistentes Verhalten.</target>       </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The behavior depends on whether the dynamic assembly is persistent, that is, created using the <ph id="ph1">`RunAndSave`</ph> or <ph id="ph2">`Save`</ph> access modes of the <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Das Verhalten abhängig, ob die dynamische Assembly persistent, d. h., erstellt, mit der <ph id="ph1">`RunAndSave`</ph> oder <ph id="ph2">`Save`</ph> Zugriff auf die Modi für die <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph> Enumeration.</target>       </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the dynamic assembly is persistent and has been written to disk before <ph id="ph1">`GetType`</ph> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</source>
          <target state="translated">Wenn die dynamische Assembly persistent ist und bevor Sie den Datenträger geschrieben wurden <ph id="ph1">`GetType`</ph> wird aufgerufen, das Ladeprogramm für die gespeicherte Assembly sucht, auf dem Datenträger, lädt die Assembly und ruft den Typ aus dieser Assembly ab.</target>       </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the assembly has not been saved to disk when <ph id="ph1">`GetType`</ph> is called, the method returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Wenn die Assembly nicht gespeichert wurde, wenn auf den Datenträger <ph id="ph1">`GetType`</ph> aufgerufen wird, wird der Methodenrückgabe <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`GetType`</ph> does not understand transient dynamic assemblies; therefore, calling <ph id="ph2">`GetType`</ph> to retrieve a type in a transient dynamic assembly returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetType`</ph> flüchtige dynamische Assemblys versteht nicht; aus diesem Grund Aufrufen <ph id="ph2">`GetType`</ph> zum Abrufen eines Typs in eine flüchtige dynamische Assembly gibt <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>To use <ph id="ph1">`GetType`</ph> on a dynamic module, subscribe to the <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph> event and call <ph id="ph3">`GetType`</ph> before saving.</source>
          <target state="translated">Mit <ph id="ph1">`GetType`</ph> für ein dynamisches Modul Abonnieren der <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph> Ereignis, und rufen <ph id="ph3">`GetType`</ph> vor dem Speichern.</target>       </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Otherwise, you will get two copies of the assembly in memory.</source>
          <target state="translated">Andernfalls erhalten Sie zwei Kopien der Assembly im Arbeitsspeicher.</target>       </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</source>
          <target state="translated">Die <ph id="ph1">`throwOnError`</ph> Parameter gibt an, was geschieht, wenn der Typ nicht gefunden wird, und auch bestimmte andere Ausnahmebedingungen unterdrückt, wie im Abschnitt für Ausnahmen beschrieben.</target>       </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Some exceptions are thrown regardless of the value of <ph id="ph1">`throwOnError`</ph>.</source>
          <target state="translated">Einige Ausnahmen werden ausgelöst, unabhängig vom Wert der <ph id="ph1">`throwOnError`</ph>.</target>       </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, if the type is found but cannot be loaded, a <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown even if <ph id="ph2">`throwOnError`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Wenn der Typ wurde gefunden, aber kann nicht geladen werden kann, z. B. eine <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> wird ausgelöst, selbst wenn <ph id="ph2">`throwOnError`</ph> ist <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die <ph id="ph1">`Get`</ph> Methoden, wenn für einen Typ reflektieren.</target>       </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Member Type</source>
          <target state="translated">Memberart</target>       </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Static</source>
          <target state="translated">Statisch</target>       </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Non-Static</source>
          <target state="translated">Nicht statische</target>       </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Constructor</source>
          <target state="translated">Konstruktor</target>       </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Field</source>
          <target state="translated">Feld</target>       </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Ein Feld ist immer nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Method</source>
          <target state="translated">Methode</target>       </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Nested Type</source>
          <target state="translated">Geschachtelten Typs</target>       </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Property</source>
          <target state="translated">Eigenschaft</target>       </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</target>       </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>This is a binary comparison.</source>
          <target state="translated">Dies ist ein binärer Vergleich.</target>       </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</target>       </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</target>       </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</source>
          <target state="translated">Arrays oder COM-Typen werden nicht für durchsucht, es sei denn, sie bereits in der Tabelle der verfügbaren Klassen geladen wurden.</target>       </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`typeName`</ph> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</source>
          <target state="translated"><ph id="ph1">`typeName`</ph> Der Typname kann durch den Namespace oder ein Assembly qualifizierter Name, der eine Assembly namensspezifikation enthält qualifiziert werden.</target>       </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</source>
          <target state="translated">Siehe <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</source>
          <target state="translated">Wenn <ph id="ph1">`typeName`</ph> des Namespace, jedoch nicht den Assemblynamen eingeben, enthält diese Methode sucht nur die Assembly des aufrufenden Objekts und die Datei "mscorlib.dll", in dieser Reihenfolge.</target>       </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</source>
          <target state="translated">Wenn TypeName vollqualifizierten mit dem Assemblynamen teilweise oder vollständig ist, sucht diese Methode in der angegebenen Assembly.</target>       </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the assembly has a strong name, a complete assembly name is required.</source>
          <target state="translated">Wenn die Assembly einen starken Namen besitzt, ist ein vollständige Assemblyname erforderlich.</target>       </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property returns a fully qualified type name including nested types, the assembly name, and generic arguments.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> -Eigenschaft gibt einen vollqualifizierten Typnamen einschließlich geschachtelter Typen, der Name der Assembly und die generische Argumente zurück.</target>       </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</source>
          <target state="translated">Alle Compiler, die die common Language Runtime unterstützen, den einfachen Namen einer geschachtelten Klasse geben, und Reflektion erstellt einen ergänzten Namen bei einer Abfrage in Übereinstimmung mit den folgenden Konventionen.</target>       </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">In .NET Framework, Version 2.0 Prozessorarchitektur Assemblyidentität hinzugefügt und kann als Teil der Assembly-Zeichenfolgen angegeben werden.</target>       </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, "ProcessorArchitecture=msil".</source>
          <target state="translated">Z. B. "ProcessorArchitecture = Msil".</target>       </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.</source>
          <target state="translated">Ist jedoch nicht in die zurückgegebene Zeichenfolge enthalten die <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> Eigenschaft, aus Gründen der Kompatibilität.</target>       </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>You can also load types by creating an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and passing it to an appropriate overload of the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">Sie können Typen auch laden, indem Sie erstellen eine <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> -Objekt und übergibt dieses an eine entsprechende Überladung der der <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>You can then use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> method to load types from the assembly.</source>
          <target state="translated">Anschließend können Sie die <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> -Methode zum Laden von Typen aus der Assembly.</target>       </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>See also <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Siehe auch <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Delimiter</source>
          <target state="translated">Trennzeichen</target>       </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Meaning</source>
          <target state="translated">Bedeutung</target>       </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Backslash (<ph id="ph1">\\</ph>)</source>
          <target state="translated">Umgekehrter Schrägstrich (<ph id="ph1">\\</ph>)</target>       </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Escape character.</source>
          <target state="translated">Escape-Zeichen.</target>       </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Backtick (`)</source>
          <target state="translated">Umgekehrtes Apostroph (')</target>       </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</source>
          <target state="translated">Steht vor eine oder mehrere Ziffern, die die Anzahl von Typparametern, am Ende des Namens eines generischen Typs darstellt.</target>       </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Brackets ([])</source>
          <target state="translated">Klammern ([])</target>       </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</source>
          <target state="translated">Schließen Sie eine generische Liste der Typargumente, für einen konstruierten generischen Typ; Schließen Sie in einer Liste der Typargumente eine Assembly qualifizierten Typnamen an.</target>       </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Comma (,)</source>
          <target state="translated">Komma (,)</target>       </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Precedes the Assembly name.</source>
          <target state="translated">Ist der Name der Assembly vorangestellt.</target>       </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Period (.)</source>
          <target state="translated">Punkt (.)</target>       </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Denotes namespace identifiers.</source>
          <target state="translated">Gibt die Namespacebezeichner.</target>       </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Plus sign (+)</source>
          <target state="translated">Pluszeichen (+)</target>       </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Precedes a nested class.</source>
          <target state="translated">Ist eine geschachtelte Klasse vorangestellt.</target>       </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, the fully qualified name for a class might look like this:</source>
          <target state="translated">Beispielsweise kann der vollqualifizierte Name für eine Klasse wie folgt aussehen:</target>       </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (<ph id="ph1">\\</ph>) to prevent it from being interpreted as a nesting separator.</source>
          <target state="translated">Wenn der Namespace wurden TopNamespace.Sub, würde die Zeichenfolge auf das Pluszeichen (+) ein Escapezeichen vorangestellt haben (<ph id="ph1">\\</ph>) zu verhindern, dass er als schachteln Trennzeichen interpretiert wird.</target>       </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Reflection emits this string as follows:</source>
          <target state="translated">Reflektion wird diese Zeichenfolge wie folgt aus:</target>       </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</source>
          <target state="translated">Ein "++" wird "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", und ein "<ph id="ph4">\\</ph>"wird"<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</target>       </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>This qualified name can be persisted and later used to load the <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Dieser qualifizierte Name kann beibehalten und später zum Laden der <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>To search for and load a <ph id="ph1">&lt;xref:System.Type&gt;</ph>, use <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.</source>
          <target state="translated">Suchen und Laden einer <ph id="ph1">&lt;xref:System.Type&gt;</ph>, verwenden Sie <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> entweder mit dem Typ oder einen Namen geben nur mit der Assembly qualifizierten Typnamen.</target>       </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> mit dem Namen nur sieht für den <ph id="ph2">&lt;xref:System.Type&gt;</ph> in der Assembly des Aufrufers, und klicken Sie dann in der System-Assembly.</target>       </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in any assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> mit der Assembly qualifizierten Typnamen für sieht die <ph id="ph2">&lt;xref:System.Type&gt;</ph> in jeder beliebigen Assembly.</target>       </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</source>
          <target state="translated">Geben Sie die Namen eventuell nachfolgende Zeichen, die zusätzliche über den Typ Informationen, z. B., ob der Typ ein Verweistyp, ein Zeigertyp oder ein Arraytyp ist.</target>       </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>To retrieve the type name without these trailing characters, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, where <ph id="ph2">`t`</ph> is the type.</source>
          <target state="translated">Verwenden Sie zum Abrufen der Typname ohne diese nachfolgenden Zeichen <ph id="ph1">`t.GetElementType().ToString()`</ph>, wobei <ph id="ph2">`t`</ph> ist der Typ.</target>       </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Spaces are relevant in all type name components except the assembly name.</source>
          <target state="translated">Leerzeichen sind in allen Komponenten von Typnamen mit Ausnahme der Assemblyname relevant.</target>       </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</source>
          <target state="translated">In der Assemblyname Leerzeichen vor dem Trennzeichen "," relevant sind, aber nach dem Trennzeichen "," Leerzeichen werden ignoriert.</target>       </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The name of a generic type ends with a backtick (<ph id="ph1">\`</ph>) followed by digits representing the number of generic type arguments.</source>
          <target state="translated">Der Name eines generischen Typs endet mit der ein umgekehrtes Apostroph (<ph id="ph1">\`</ph>) gefolgt von Ziffern, die die Anzahl der Argumente des generischen Typs darstellt.</target>       </trans-unit>
        <trans-unit id="2503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</source>
          <target state="translated">Dieser Name-mangling dient zum Zulassen von Compilern zur Unterstützung von generischer Typen mit dem gleichen Namen, aber mit einer unterschiedlichen Anzahl von Typparametern, im selben Gültigkeitsbereich auftritt.</target>       </trans-unit>
        <trans-unit id="2504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, reflection returns the mangled names <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>Tuple<ph id="ph3">`2`</ph> from the generic methods <ph id="ph4">`Tuple(Of T)`</ph> and <ph id="ph5">`Tuple(Of T0, T1)`</ph> in Visual Basic, or <ph id="ph6">`Tuple&lt;T&gt;`</ph> and Tuple<ph id="ph7">`\&lt;T0, T1&gt;`</ph> in Visual C#.</source>
          <target state="translated">Reflektion gibt z. B. die ergänzten Namen <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>Tupel<ph id="ph3">`2`</ph> aus den generischen Methoden <ph id="ph4">`Tuple(Of T)`</ph> und <ph id="ph5">`Tuple(Of T0, T1)`</ph> in Visual Basic oder <ph id="ph6">`Tuple&lt;T&gt;`</ph> und Tupel<ph id="ph7">`\&lt;T0, T1&gt;`</ph> in Visual c#.</target>       </trans-unit>
        <trans-unit id="2505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</source>
          <target state="translated">Bei generischen Typen wird die Typargumentliste in Klammern gesetzt, und die Typargumente werden durch Kommas getrennt.</target>       </trans-unit>
        <trans-unit id="2506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, a generic <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> has two type parameters.</source>
          <target state="translated">Angenommen, eine generische <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> verfügt über zwei Typparameter.</target>       </trans-unit>
        <trans-unit id="2507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph> might be represented as follows:</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> von <ph id="ph2">`MyType`</ph> mit Schlüsseln des Typs <ph id="ph3">&lt;xref:System.String&gt;</ph> kann wie folgt dargestellt werden:</target>       </trans-unit>
        <trans-unit id="2508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</source>
          <target state="translated">Um eine Assembly qualifizierten Typnamen in einer Liste der Typargumente angeben, schließen Sie die Assembly qualifizierten Typnamen in Klammern ein.</target>       </trans-unit>
        <trans-unit id="2509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</source>
          <target state="translated">Andernfalls werden die Kommas, die trennen die Bestandteile der Assembly qualifizierte Name, als Trennzeichen für weitere Typargumente interpretiert.</target>       </trans-unit>
        <trans-unit id="2510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, a <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> from MyAssembly.dll, with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph>, might be specified as follows:</source>
          <target state="translated">Z. B. eine <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> von <ph id="ph2">`MyType`</ph> aus MyAssembly.dll mit Schlüsseln des Typs <ph id="ph3">&lt;xref:System.String&gt;</ph>, kann wie folgt angegeben werden:</target>       </trans-unit>
        <trans-unit id="2511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</source>
          <target state="translated">Eine Assembly qualifizierten Typnamen kann in Klammern eingeschlossen werden, nur, wenn es in einer Typparameterliste angezeigt wird.</target>       </trans-unit>
        <trans-unit id="2512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</source>
          <target state="translated">Die Regeln für das Suchen von Assemblys für qualifizierten und nicht qualifizierten Typen in Typparameterlisten sind identisch mit den Regeln für qualifizierte und nicht qualifizierte nicht generische Typen.</target>       </trans-unit>
        <trans-unit id="2513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Nullable types are a special case of generic types.</source>
          <target state="translated">Auf NULL festlegbare Typen sind ein besonderer Fall von generischen Typen.</target>       </trans-unit>
        <trans-unit id="2514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, a nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph> is represented by the string "System.Nullable`1[System.Int32]".</source>
          <target state="translated">Angenommen, ein NULL-Werte zulassen <ph id="ph1">&lt;xref:System.Int32&gt;</ph> wird durch die Zeichenfolge "System.Nullable'1[System.Int32]" dargestellt.</target>       </trans-unit>
        <trans-unit id="2515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>In C#, C++, and Visual Basic you can also get nullable types using type operators.</source>
          <target state="translated">In c#, C++ und Visual Basic können Sie auch auf NULL festlegbaren Typen, die mithilfe von Operatoren abrufen.</target>       </trans-unit>
        <trans-unit id="2516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, the nullable <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> type is returned by <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> in C#, by <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> in C++, and by <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> in Visual Basic.</source>
          <target state="translated">Angenommen, die NULL-Werte zulässt <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> zurückgegebene Typ <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> in c# durch <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> in C++ und in <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> in Visual Basic.</target>       </trans-unit>
        <trans-unit id="2517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The following table shows the syntax you use with <ph id="ph1">`GetType`</ph> for various types.</source>
          <target state="translated">Die folgende Tabelle zeigt die Syntax, die Sie mit <ph id="ph1">`GetType`</ph> für verschiedene Typen.</target>       </trans-unit>
        <trans-unit id="2518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>To Get</source>
          <target state="translated">Zum Abrufen</target>       </trans-unit>
        <trans-unit id="2519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Use</source>
          <target state="translated">Mit</target>       </trans-unit>
        <trans-unit id="2520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph></source>
          <target state="translated">Ein NULL-Werte zulässt <ph id="ph1">&lt;xref:System.Int32&gt;</ph></target>       </trans-unit>
        <trans-unit id="2521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</target>       </trans-unit>
        <trans-unit id="2522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>An unmanaged pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Ein nicht verwalteter Zeiger auf <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>An unmanaged pointer to a pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Ein nicht verwalteter Zeiger auf einen Zeiger auf <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A managed pointer or reference to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Ein verwalteter Zeiger oder Verweis auf <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>.</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyType&amp;")`</ph></target>       </trans-unit>
        <trans-unit id="2526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Note that unlike pointers, references are limited to one level.</source>
          <target state="translated">Beachten Sie, dass Verweise im Gegensatz zu Zeigern auf eine Ebene beschränkt sind.</target>       </trans-unit>
        <trans-unit id="2527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A parent class and a nested class</source>
          <target state="translated">Eine übergeordnete Klasse und eine geschachtelte Klasse</target>       </trans-unit>
        <trans-unit id="2528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A one-dimensional array with a lower bound of 0</source>
          <target state="translated">Ein eindimensionales Array mit einer unteren Grenze von 0</target>       </trans-unit>
        <trans-unit id="2529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A one-dimensional array with an unknown lower bound</source>
          <target state="translated">Ein eindimensionales Array mit einer unbekannten Untergrenze</target>       </trans-unit>
        <trans-unit id="2530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>An n-dimensional array</source>
          <target state="translated">Ein n-dimensionalen array</target>       </trans-unit>
        <trans-unit id="2531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A comma (,) inside the brackets a total of n-1 times.</source>
          <target state="translated">Ein Komma (,) innerhalb der Klammern eine insgesamt n-1 Mal.</target>       </trans-unit>
        <trans-unit id="2532" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, <ph id="ph1">`System.Object[,,]`</ph> represents a three-dimensional <ph id="ph2">`Object`</ph> array.</source>
          <target state="translated">Beispielsweise <ph id="ph1">`System.Object[,,]`</ph> stellt eine dreidimensionale <ph id="ph2">`Object`</ph> Array.</target>       </trans-unit>
        <trans-unit id="2533" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A two-dimensional array's array</source>
          <target state="translated">Ein zweidimensionales Array von Arrays</target>       </trans-unit>
        <trans-unit id="2534" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A rectangular two-dimensional array with unknown lower bounds</source>
          <target state="translated">Kein rechteckiges zweidimensionales Array mit unbekannten Untergrenzen</target>       </trans-unit>
        <trans-unit id="2535" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A generic type with one type argument</source>
          <target state="translated">Ein generischer Typ mit einem Typargument</target>       </trans-unit>
        <trans-unit id="2536" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</target>       </trans-unit>
        <trans-unit id="2537" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A generic type with two type arguments</source>
          <target state="translated">Ein generischer Typ mit zwei Typargumenten</target>       </trans-unit>
        <trans-unit id="2538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</target>       </trans-unit>
        <trans-unit id="2539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A generic type with two assembly-qualified type arguments</source>
          <target state="translated">Ein generischer Typ mit zwei durch die Assembly qualifizierten Typargumenten</target>       </trans-unit>
        <trans-unit id="2540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")"</target>       </trans-unit>
        <trans-unit id="2541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>An assembly-qualified generic type with an assembly-qualified type argument</source>
          <target state="translated">Ein assemblyqualifizierten generischer Typ mit einem Assembly qualifizierten Typnamen-argument</target>       </trans-unit>
        <trans-unit id="2542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")"</target>       </trans-unit>
        <trans-unit id="2543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A generic type whose type argument is a generic type with two type arguments</source>
          <target state="translated">Ein generischer Typ, dessen Type-Argument ein generischer Typ mit zwei Typargumenten ist</target>       </trans-unit>
        <trans-unit id="2544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></target>       </trans-unit>
        <trans-unit id="2545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The following example retrieves the type of <ph id="ph1">`System.Int32`</ph> and uses that type object to display the <ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph> property of <ph id="ph3">`System.Int32`</ph>.</source>
          <target state="translated">Das folgende Beispiel ruft den Typ des <ph id="ph1">`System.Int32`</ph> und verwendet diese Typobjekt zum Anzeigen der <ph id="ph2">&lt;xref:System.Type.FullName%2A&gt;</ph> Eigenschaft <ph id="ph3">`System.Int32`</ph>.</target>       </trans-unit>
        <trans-unit id="2546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>If a type object refers to an assembly that does not exist, this example throws an exception.</source>
          <target state="translated">Wenn ein Objekt vom Typ auf eine Assembly, die nicht vorhanden ist verweist, wird in diesem Beispiel wird eine Ausnahme ausgelöst.</target>       </trans-unit>
        <trans-unit id="2547" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2548" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="2549" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und der Typ wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="2550" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2551" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid characters, such as an embedded tab.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen.</target>       </trans-unit>
        <trans-unit id="2552" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2553" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> ist eine leere Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2554" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2555" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> represents an array type with an invalid size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> stellt einen Arraytyp mit einer ungültigen Größe dar.</target>       </trans-unit>
        <trans-unit id="2556" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2557" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt ein Array von <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph> dar.</target>       </trans-unit>
        <trans-unit id="2558" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid syntax.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> enthält ungültige Syntax,</target>       </trans-unit>
        <trans-unit id="2559" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>For example, "MyType[,*,]".</source>
          <target state="translated">beispielsweise "MyType[,*,]".</target>       </trans-unit>
        <trans-unit id="2560" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2561" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt einen generischen Typ dar, der einen Zeigertyp, einen <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph>-Typ oder <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> als eines seiner Typargumente aufweist.</target>       </trans-unit>
        <trans-unit id="2562" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2563" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.</target>       </trans-unit>
        <trans-unit id="2564" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2565" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</target>       </trans-unit>
        <trans-unit id="2566" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the assembly or one of its dependencies was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="2567" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph>, instead.</source>
          <target state="translated">Fangen Sie in <bpt id="p1">[</bpt>.NET für Windows Store-Apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> oder der <bpt id="p2">[</bpt>portablen Klassenbibliothek<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept> stattdessen die Basisklassenausnahme <ph id="ph1">&lt;see cref="T:System.IO.IOException" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="2568" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</target>       </trans-unit>
        <trans-unit id="2569" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.</target>       </trans-unit>
        <trans-unit id="2570" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2571" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean)">
          <source>Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</source>
          <target state="translated">Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und die Assembly wurde mit einer höheren Version kompiliert.</target>       </trans-unit>
        <trans-unit id="2572" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly-qualified name of the type to get.</source>
          <target state="translated">Der durch die Assembly bezeichnete Name des abzurufenden Typs.</target>       </trans-unit>
        <trans-unit id="2573" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>.</source>
          <target state="translated">Siehe <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2574" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">Wenn sich der Typ in der aktuell ausgeführten Assembly oder in Mscorlib.dll befindet, ist eine Angabe des Typnamens einschließlich des qualifizierenden Namespace ausreichend.</target>       </trans-unit>
        <trans-unit id="2575" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.Specifying <ph id="ph4">&lt;see langword="false" /&gt;</ph> also suppresses some other exception conditions, but not all of them.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, um eine Ausnahme auszulösen, wenn der Typ nicht gefunden werden kann; <ph id="ph2">&lt;see langword="false" /&gt;</ph>, um <ph id="ph3">&lt;see langword="null" /&gt;</ph> zurückzugeben. Die Angabe von <ph id="ph4">&lt;see langword="false" /&gt;</ph> unterdrückt außerdem einige andere Ausnahmebedingungen, jedoch nicht alle.</target>       </trans-unit>
        <trans-unit id="2576" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">Informationen finden Sie im Abschnitt für Ausnahmen.</target>       </trans-unit>
        <trans-unit id="2577" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to perform a case-insensitive search for <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>, <ph id="ph2">&lt;see langword="false" /&gt;</ph> to perform a case-sensitive search for <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, um ohne Beachtung der Groß-/Kleinschreibung nach <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> zu suchen; <ph id="ph2">&lt;see langword="false" /&gt;</ph>, um mit Beachtung der Groß-/Kleinschreibung nach <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> zu suchen.</target>       </trans-unit>
        <trans-unit id="2578" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with the specified name, specifying whether to throw an exception if the type is not found and whether to perform a case-sensitive search.</source>
          <target state="translated">Ruft den <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> mit dem angegebenen Namen ab. Dabei wird angegeben, ob bei der Suche Groß- und Kleinschreibung berücksichtigt werden soll und ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird.</target>       </trans-unit>
        <trans-unit id="2579" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The type with the specified name.</source>
          <target state="translated">Der Typ mit dem angegebenen Namen.</target>       </trans-unit>
        <trans-unit id="2580" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the type is not found, the <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> parameter specifies whether <ph id="ph2">&lt;see langword="null" /&gt;</ph> is returned or an exception is thrown.</source>
          <target state="translated">Wenn der Typ nicht gefunden wird, gibt der <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>-Parameter an, ob <ph id="ph2">&lt;see langword="null" /&gt;</ph> zurückgegeben oder eine Ausnahme ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="2581" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In some cases, an exception is thrown regardless of the value of <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</source>
          <target state="translated">In einigen Fällen wird unabhängig vom Wert von <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> eine Ausnahme ausgelöst.</target>       </trans-unit>
        <trans-unit id="2582" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">Informationen finden Sie im Abschnitt für Ausnahmen.</target>       </trans-unit>
        <trans-unit id="2583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method to obtain a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object for a type in another assembly, if the you know its namespace-qualified name.</source>
          <target state="translated">Können Sie die <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> Methode zum Abrufen einer <ph id="ph2">&lt;xref:System.Type&gt;</ph> -Objekt für einen Typ in einer anderen Assembly, wenn Sie wissen, dass die Namespace-qualifizierten Namen.</target>       </trans-unit>
        <trans-unit id="2584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> causes loading of the assembly specified in <ph id="ph2">`typeName`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> führt zum Laden der Assembly im angegebenen <ph id="ph2">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="2585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>You can also load an assembly using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method, and then use the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> methods of the <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> class to get <ph id="ph5">&lt;xref:System.Type&gt;</ph> objects.</source>
          <target state="translated">Sie können auch laden eine Assembly mit der <ph id="ph1">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> -Methode, und verwenden Sie dann die <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> Methoden die <ph id="ph4">&lt;xref:System.Reflection.Assembly&gt;</ph> Klasse abgerufen <ph id="ph5">&lt;xref:System.Type&gt;</ph> Objekte.</target>       </trans-unit>
        <trans-unit id="2586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If a type is in an assembly known to your program at compile time, it is more efficient to use <ph id="ph1">`typeof`</ph> in C#, <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> in Visual Basic, or <ph id="ph3">`typeid`</ph> in C++.</source>
          <target state="translated">Wenn ein Typ in einer Assembly, die für Ihr Programm zur Kompilierzeit bekannt ist, ist es effizienter, verwenden <ph id="ph1">`typeof`</ph> in c# <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> in Visual Basic oder <ph id="ph3">`typeid`</ph> in C++.</target>       </trans-unit>
        <trans-unit id="2587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`GetType`</ph> only works on assemblies loaded from disk.</source>
          <target state="translated"><ph id="ph1">`GetType`</ph> funktioniert nur für Assemblys, die von der Festplatte geladen.</target>       </trans-unit>
        <trans-unit id="2588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If you call <ph id="ph1">`GetType`</ph> to look up a type defined in a dynamic assembly defined using the <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> services, you might get inconsistent behavior.</source>
          <target state="translated">Beim Aufrufen <ph id="ph1">`GetType`</ph> zum Nachschlagen eines Typs in eine dynamische Assembly mit definiert, definiert der <ph id="ph2">&lt;xref:System.Reflection.Emit&gt;</ph> Services, erhalten Sie möglicherweise inkonsistentes Verhalten.</target>       </trans-unit>
        <trans-unit id="2589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The behavior depends on whether the dynamic assembly is persistent, that is, created using the <ph id="ph1">`RunAndSave`</ph> or <ph id="ph2">`Save`</ph> access modes of the <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph> enumeration.</source>
          <target state="translated">Das Verhalten abhängig, ob die dynamische Assembly persistent, d. h., erstellt, mit der <ph id="ph1">`RunAndSave`</ph> oder <ph id="ph2">`Save`</ph> Zugriff auf die Modi für die <ph id="ph3">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType&gt;</ph> Enumeration.</target>       </trans-unit>
        <trans-unit id="2590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the dynamic assembly is persistent and has been written to disk before <ph id="ph1">`GetType`</ph> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</source>
          <target state="translated">Wenn die dynamische Assembly persistent ist und bevor Sie den Datenträger geschrieben wurden <ph id="ph1">`GetType`</ph> wird aufgerufen, das Ladeprogramm für die gespeicherte Assembly sucht, auf dem Datenträger, lädt die Assembly und ruft den Typ aus dieser Assembly ab.</target>       </trans-unit>
        <trans-unit id="2591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the assembly has not been saved to disk when <ph id="ph1">`GetType`</ph> is called, the method returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Wenn die Assembly nicht gespeichert wurde, wenn auf den Datenträger <ph id="ph1">`GetType`</ph> aufgerufen wird, wird der Methodenrückgabe <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`GetType`</ph> does not understand transient dynamic assemblies; therefore, calling <ph id="ph2">`GetType`</ph> to retrieve a type in a transient dynamic assembly returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated"><ph id="ph1">`GetType`</ph> flüchtige dynamische Assemblys versteht nicht; aus diesem Grund Aufrufen <ph id="ph2">`GetType`</ph> zum Abrufen eines Typs in eine flüchtige dynamische Assembly gibt <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To use <ph id="ph1">`GetType`</ph> on a dynamic module, subscribe to the <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph> event and call <ph id="ph3">`GetType`</ph> before saving.</source>
          <target state="translated">Mit <ph id="ph1">`GetType`</ph> für ein dynamisches Modul Abonnieren der <ph id="ph2">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType&gt;</ph> Ereignis, und rufen <ph id="ph3">`GetType`</ph> vor dem Speichern.</target>       </trans-unit>
        <trans-unit id="2594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Otherwise, you will get two copies of the assembly in memory.</source>
          <target state="translated">Andernfalls erhalten Sie zwei Kopien der Assembly im Arbeitsspeicher.</target>       </trans-unit>
        <trans-unit id="2595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`throwOnError`</ph> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</source>
          <target state="translated">Die <ph id="ph1">`throwOnError`</ph> Parameter gibt an, was geschieht, wenn der Typ nicht gefunden wird, und auch bestimmte andere Ausnahmebedingungen unterdrückt, wie im Abschnitt für Ausnahmen beschrieben.</target>       </trans-unit>
        <trans-unit id="2596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Some exceptions are thrown regardless of the value of <ph id="ph1">`throwOnError`</ph>.</source>
          <target state="translated">Einige Ausnahmen werden ausgelöst, unabhängig vom Wert der <ph id="ph1">`throwOnError`</ph>.</target>       </trans-unit>
        <trans-unit id="2597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, if the type is found but cannot be loaded, a <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> is thrown even if <ph id="ph2">`throwOnError`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Wenn der Typ wurde gefunden, aber kann nicht geladen werden kann, z. B. eine <ph id="ph1">&lt;xref:System.TypeLoadException&gt;</ph> wird ausgelöst, selbst wenn <ph id="ph2">`throwOnError`</ph> ist <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="2598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The following table shows what members of a base class are returned by the <ph id="ph1">`Get`</ph> methods when reflecting on a type.</source>
          <target state="translated">Die folgende Tabelle zeigt, welche Member einer Basisklasse von zurückgegeben werden die <ph id="ph1">`Get`</ph> Methoden, wenn für einen Typ reflektieren.</target>       </trans-unit>
        <trans-unit id="2599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Member Type</source>
          <target state="translated">Memberart</target>       </trans-unit>
        <trans-unit id="2600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Static</source>
          <target state="translated">Statisch</target>       </trans-unit>
        <trans-unit id="2601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Non-Static</source>
          <target state="translated">Nicht statische</target>       </trans-unit>
        <trans-unit id="2602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Constructor</source>
          <target state="translated">Konstruktor</target>       </trans-unit>
        <trans-unit id="2603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="2604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="2605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Field</source>
          <target state="translated">Feld</target>       </trans-unit>
        <trans-unit id="2606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="2607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="2608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A field is always hide-by-name-and-signature.</source>
          <target state="translated">Ein Feld ist immer nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="2609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Event</source>
          <target state="translated">event</target>       </trans-unit>
        <trans-unit id="2610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="2611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="2612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="2613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="2614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Method</source>
          <target state="translated">Methode</target>       </trans-unit>
        <trans-unit id="2615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="2616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Yes.</source>
          <target state="translated">Ja.</target>       </trans-unit>
        <trans-unit id="2617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</source>
          <target state="translated">Eine Methode (virtuelle und nicht virtuell) möglich nach Namen verdeckte oder nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="2618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Nested Type</source>
          <target state="translated">Geschachtelten Typs</target>       </trans-unit>
        <trans-unit id="2619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="2620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>No</source>
          <target state="translated">Nein</target>       </trans-unit>
        <trans-unit id="2621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Property</source>
          <target state="translated">Eigenschaft</target>       </trans-unit>
        <trans-unit id="2622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Not applicable</source>
          <target state="translated">Nicht zutreffend</target>       </trans-unit>
        <trans-unit id="2623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The common type system rule is that the inheritance is the same as that of the methods that implement the property.</source>
          <target state="translated">Das allgemeine Typsystem ist, dass die Vererbung ist identisch mit der Methoden, die die Eigenschaft zu implementieren.</target>       </trans-unit>
        <trans-unit id="2624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Reflection treats properties as hide-by-name-and-signature.</source>
          <target state="translated">Reflektion behandelt Eigenschaften als nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="2625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See note 2 below.</source>
          <target state="translated">Siehe Hinweis 2 weiter unten.</target>       </trans-unit>
        <trans-unit id="2626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</source>
          <target state="translated">Nach Name und Signatur ausblenden berücksichtigt, dass alle Teile der Signatur, die benutzerdefinierten Modifizierer, einschließlich Typen, Parametertypen Sentinels enthält und nicht verwalteten Aufrufkonventionen zurückgeben.</target>       </trans-unit>
        <trans-unit id="2627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>This is a binary comparison.</source>
          <target state="translated">Dies ist ein binärer Vergleich.</target>       </trans-unit>
        <trans-unit id="2628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For reflection, properties and events are hide-by-name-and-signature.</source>
          <target state="translated">Für die Reflektion sind die Eigenschaften und Ereignisse nach Name und Signatur ausblenden.</target>       </trans-unit>
        <trans-unit id="2629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</source>
          <target state="translated">Wenn Sie eine Eigenschaft mit einer Get und Set-Zugriffsmethode in der Basisklasse haben, aber hat nur einen Get-Accessor für die abgeleitete Klasse, die Eigenschaft der abgeleiteten Klasse ausgeblendet die Basisklasseneigenschaft und nicht den Setter für die Basisklasse zugreifen werden.</target>       </trans-unit>
        <trans-unit id="2630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Custom attributes are not part of the common type system.</source>
          <target state="translated">Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.</target>       </trans-unit>
        <trans-unit id="2631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</source>
          <target state="translated">Arrays oder COM-Typen werden nicht für durchsucht, es sei denn, sie bereits in der Tabelle der verfügbaren Klassen geladen wurden.</target>       </trans-unit>
        <trans-unit id="2632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`typeName`</ph> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</source>
          <target state="translated"><ph id="ph1">`typeName`</ph> Der Typname kann durch den Namespace oder ein Assembly qualifizierter Name, der eine Assembly namensspezifikation enthält qualifiziert werden.</target>       </trans-unit>
        <trans-unit id="2633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</source>
          <target state="translated">Siehe <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</source>
          <target state="translated">Wenn <ph id="ph1">`typeName`</ph> des Namespace, jedoch nicht den Assemblynamen eingeben, enthält diese Methode sucht nur die Assembly des aufrufenden Objekts und die Datei "mscorlib.dll", in dieser Reihenfolge.</target>       </trans-unit>
        <trans-unit id="2635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</source>
          <target state="translated">Wenn TypeName vollqualifizierten mit dem Assemblynamen teilweise oder vollständig ist, sucht diese Methode in der angegebenen Assembly.</target>       </trans-unit>
        <trans-unit id="2636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the assembly has a strong name, a complete assembly name is required.</source>
          <target state="translated">Wenn die Assembly einen starken Namen besitzt, ist ein vollständige Assemblyname erforderlich.</target>       </trans-unit>
        <trans-unit id="2637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property returns a fully qualified type name including nested types, the assembly name, and type arguments.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> Eigenschaft gibt einen vollqualifizierten Typnamen einschließlich geschachtelter Typen, Assemblyname und Typargumente.</target>       </trans-unit>
        <trans-unit id="2638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</source>
          <target state="translated">Alle Compiler, die die common Language Runtime unterstützen, den einfachen Namen einer geschachtelten Klasse geben, und Reflektion erstellt einen ergänzten Namen bei einer Abfrage in Übereinstimmung mit den folgenden Konventionen.</target>       </trans-unit>
        <trans-unit id="2639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</source>
          <target state="translated">In .NET Framework, Version 2.0 Prozessorarchitektur Assemblyidentität hinzugefügt und kann als Teil der Assembly-Zeichenfolgen angegeben werden.</target>       </trans-unit>
        <trans-unit id="2640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, "ProcessorArchitecture=msil".</source>
          <target state="translated">Z. B. "ProcessorArchitecture = Msil".</target>       </trans-unit>
        <trans-unit id="2641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>However, it is not included in the string returned by the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.</source>
          <target state="translated">Ist jedoch nicht in die zurückgegebene Zeichenfolge enthalten die <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> Eigenschaft, aus Gründen der Kompatibilität.</target>       </trans-unit>
        <trans-unit id="2642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>You can also load types by creating an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and passing it to an appropriate overload of the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.</source>
          <target state="translated">Sie können Typen auch laden, indem Sie erstellen eine <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> -Objekt und übergibt dieses an eine entsprechende Überladung der der <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>You can then use the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> method to load types from the assembly.</source>
          <target state="translated">Anschließend können Sie die <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> -Methode zum Laden von Typen aus der Assembly.</target>       </trans-unit>
        <trans-unit id="2644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>See also <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Siehe auch <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Delimiter</source>
          <target state="translated">Trennzeichen</target>       </trans-unit>
        <trans-unit id="2646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Meaning</source>
          <target state="translated">Bedeutung</target>       </trans-unit>
        <trans-unit id="2647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Backslash (<ph id="ph1">\\</ph>)</source>
          <target state="translated">Umgekehrter Schrägstrich (<ph id="ph1">\\</ph>)</target>       </trans-unit>
        <trans-unit id="2648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Escape character.</source>
          <target state="translated">Escape-Zeichen.</target>       </trans-unit>
        <trans-unit id="2649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Backtick (`)</source>
          <target state="translated">Umgekehrtes Apostroph (')</target>       </trans-unit>
        <trans-unit id="2650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</source>
          <target state="translated">Steht vor eine oder mehrere Ziffern, die die Anzahl von Typparametern, am Ende des Namens eines generischen Typs darstellt.</target>       </trans-unit>
        <trans-unit id="2651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Brackets ([])</source>
          <target state="translated">Klammern ([])</target>       </trans-unit>
        <trans-unit id="2652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</source>
          <target state="translated">Schließen Sie eine generische Liste der Typargumente, für einen konstruierten generischen Typ; Schließen Sie in einer Liste der Typargumente eine Assembly qualifizierten Typnamen an.</target>       </trans-unit>
        <trans-unit id="2653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Comma (,)</source>
          <target state="translated">Komma (,)</target>       </trans-unit>
        <trans-unit id="2654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Precedes the Assembly name.</source>
          <target state="translated">Ist der Name der Assembly vorangestellt.</target>       </trans-unit>
        <trans-unit id="2655" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Period (.)</source>
          <target state="translated">Punkt (.)</target>       </trans-unit>
        <trans-unit id="2656" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Denotes namespace identifiers.</source>
          <target state="translated">Gibt die Namespacebezeichner.</target>       </trans-unit>
        <trans-unit id="2657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Plus sign (+)</source>
          <target state="translated">Pluszeichen (+)</target>       </trans-unit>
        <trans-unit id="2658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Precedes a nested class.</source>
          <target state="translated">Ist eine geschachtelte Klasse vorangestellt.</target>       </trans-unit>
        <trans-unit id="2659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, the fully qualified name for a class might look like this:</source>
          <target state="translated">Beispielsweise kann der vollqualifizierte Name für eine Klasse wie folgt aussehen:</target>       </trans-unit>
        <trans-unit id="2660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (<ph id="ph1">\\</ph>) to prevent it from being interpreted as a nesting separator.</source>
          <target state="translated">Wenn der Namespace wurden TopNamespace.Sub, würde die Zeichenfolge auf das Pluszeichen (+) ein Escapezeichen vorangestellt haben (<ph id="ph1">\\</ph>) zu verhindern, dass er als schachteln Trennzeichen interpretiert wird.</target>       </trans-unit>
        <trans-unit id="2661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Reflection emits this string as follows:</source>
          <target state="translated">Reflektion wird diese Zeichenfolge wie folgt aus:</target>       </trans-unit>
        <trans-unit id="2662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A "++" becomes "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", and a "<ph id="ph4">\\</ph>" becomes "<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</source>
          <target state="translated">Ein "++" wird "<ph id="ph1">\\</ph><ph id="ph2">+</ph><ph id="ph3">\\</ph>+", und ein "<ph id="ph4">\\</ph>"wird"<ph id="ph5">\\</ph><ph id="ph6">\\</ph>".</target>       </trans-unit>
        <trans-unit id="2663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>This qualified name can be persisted and later used to load the <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Dieser qualifizierte Name kann beibehalten und später zum Laden der <ph id="ph1">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To search for and load a <ph id="ph1">&lt;xref:System.Type&gt;</ph>, use <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.</source>
          <target state="translated">Suchen und Laden einer <ph id="ph1">&lt;xref:System.Type&gt;</ph>, verwenden Sie <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> entweder mit dem Typ oder einen Namen geben nur mit der Assembly qualifizierten Typnamen.</target>       </trans-unit>
        <trans-unit id="2665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> mit dem Namen nur sieht für den <ph id="ph2">&lt;xref:System.Type&gt;</ph> in der Assembly des Aufrufers, und klicken Sie dann in der System-Assembly.</target>       </trans-unit>
        <trans-unit id="2666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id="ph2">&lt;xref:System.Type&gt;</ph> in any assembly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> mit der Assembly qualifizierten Typnamen für sieht die <ph id="ph2">&lt;xref:System.Type&gt;</ph> in jeder beliebigen Assembly.</target>       </trans-unit>
        <trans-unit id="2667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</source>
          <target state="translated">Geben Sie die Namen eventuell nachfolgende Zeichen, die zusätzliche über den Typ Informationen, z. B., ob der Typ ein Verweistyp, ein Zeigertyp oder ein Arraytyp ist.</target>       </trans-unit>
        <trans-unit id="2668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To retrieve the type name without these trailing characters, use <ph id="ph1">`t.GetElementType().ToString()`</ph>, where <ph id="ph2">`t`</ph> is the type.</source>
          <target state="translated">Verwenden Sie zum Abrufen der Typname ohne diese nachfolgenden Zeichen <ph id="ph1">`t.GetElementType().ToString()`</ph>, wobei <ph id="ph2">`t`</ph> ist der Typ.</target>       </trans-unit>
        <trans-unit id="2669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Spaces are relevant in all type name components except the assembly name.</source>
          <target state="translated">Leerzeichen sind in allen Komponenten von Typnamen mit Ausnahme der Assemblyname relevant.</target>       </trans-unit>
        <trans-unit id="2670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</source>
          <target state="translated">In der Assemblyname Leerzeichen vor dem Trennzeichen "," relevant sind, aber nach dem Trennzeichen "," Leerzeichen werden ignoriert.</target>       </trans-unit>
        <trans-unit id="2671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The name of a generic type ends with a backtick (<ph id="ph1">\`</ph>) followed by digits representing the number of generic type arguments.</source>
          <target state="translated">Der Name eines generischen Typs endet mit der ein umgekehrtes Apostroph (<ph id="ph1">\`</ph>) gefolgt von Ziffern, die die Anzahl der Argumente des generischen Typs darstellt.</target>       </trans-unit>
        <trans-unit id="2672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</source>
          <target state="translated">Dieser Name-mangling dient zum Zulassen von Compilern zur Unterstützung von generischer Typen mit dem gleichen Namen, aber mit einer unterschiedlichen Anzahl von Typparametern, im selben Gültigkeitsbereich auftritt.</target>       </trans-unit>
        <trans-unit id="2673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, reflection returns the mangled names <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>Tuple<ph id="ph3">`2`</ph> from the generic methods <ph id="ph4">`Tuple(Of T)`</ph> and <ph id="ph5">`Tuple(Of T0, T1)`</ph> in Visual Basic, or <ph id="ph6">`Tuple&lt;T&gt;`</ph> and Tuple<ph id="ph7">`\&lt;T0, T1&gt;`</ph> in Visual C#.</source>
          <target state="translated">Reflektion gibt z. B. die ergänzten Namen <ph id="ph1">`Tuple`</ph>1<ph id="ph2">` and `</ph>Tupel<ph id="ph3">`2`</ph> aus den generischen Methoden <ph id="ph4">`Tuple(Of T)`</ph> und <ph id="ph5">`Tuple(Of T0, T1)`</ph> in Visual Basic oder <ph id="ph6">`Tuple&lt;T&gt;`</ph> und Tupel<ph id="ph7">`\&lt;T0, T1&gt;`</ph> in Visual c#.</target>       </trans-unit>
        <trans-unit id="2674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</source>
          <target state="translated">Bei generischen Typen wird die Typargumentliste in Klammern gesetzt, und die Typargumente werden durch Kommas getrennt.</target>       </trans-unit>
        <trans-unit id="2675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, a generic <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> has two type parameters.</source>
          <target state="translated">Angenommen, eine generische <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> verfügt über zwei Typparameter.</target>       </trans-unit>
        <trans-unit id="2676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph> might be represented as follows:</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> von <ph id="ph2">`MyType`</ph> mit Schlüsseln des Typs <ph id="ph3">&lt;xref:System.String&gt;</ph> kann wie folgt dargestellt werden:</target>       </trans-unit>
        <trans-unit id="2677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</source>
          <target state="translated">Um eine Assembly qualifizierten Typnamen in einer Liste der Typargumente angeben, schließen Sie die Assembly qualifizierten Typnamen in Klammern ein.</target>       </trans-unit>
        <trans-unit id="2678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</source>
          <target state="translated">Andernfalls werden die Kommas, die trennen die Bestandteile der Assembly qualifizierte Name, als Trennzeichen für weitere Typargumente interpretiert.</target>       </trans-unit>
        <trans-unit id="2679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, a <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`MyType`</ph> from MyAssembly.dll, with keys of type <ph id="ph3">&lt;xref:System.String&gt;</ph>, might be specified as follows:</source>
          <target state="translated">Z. B. eine <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> von <ph id="ph2">`MyType`</ph> aus MyAssembly.dll mit Schlüsseln des Typs <ph id="ph3">&lt;xref:System.String&gt;</ph>, kann wie folgt angegeben werden:</target>       </trans-unit>
        <trans-unit id="2680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</source>
          <target state="translated">Eine Assembly qualifizierten Typnamen kann in Klammern eingeschlossen werden, nur, wenn es in einer Typparameterliste angezeigt wird.</target>       </trans-unit>
        <trans-unit id="2681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</source>
          <target state="translated">Die Regeln für das Suchen von Assemblys für qualifizierten und nicht qualifizierten Typen in Typparameterlisten sind identisch mit den Regeln für qualifizierte und nicht qualifizierte nicht generische Typen.</target>       </trans-unit>
        <trans-unit id="2682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Nullable types are a special case of generic types.</source>
          <target state="translated">Auf NULL festlegbare Typen sind ein besonderer Fall von generischen Typen.</target>       </trans-unit>
        <trans-unit id="2683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, a nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph> is represented by the string "System.Nullable`1[System.Int32]".</source>
          <target state="translated">Angenommen, ein NULL-Werte zulassen <ph id="ph1">&lt;xref:System.Int32&gt;</ph> wird durch die Zeichenfolge "System.Nullable'1[System.Int32]" dargestellt.</target>       </trans-unit>
        <trans-unit id="2684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>In C#, C++, and Visual Basic you can also get nullable types using type operators.</source>
          <target state="translated">In c#, C++ und Visual Basic können Sie auch auf NULL festlegbaren Typen, die mithilfe von Operatoren abrufen.</target>       </trans-unit>
        <trans-unit id="2685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, the nullable <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> type is returned by <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> in C#, by <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> in C++, and by <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> in Visual Basic.</source>
          <target state="translated">Angenommen, die NULL-Werte zulässt <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> zurückgegebene Typ <ph id="ph2">`typeof(Nullable&lt;bool&gt;)`</ph> in c# durch <ph id="ph3">`Nullable&lt;Boolean&gt;::typeid`</ph> in C++ und in <ph id="ph4">`GetType(Nullable(Of Boolean))`</ph> in Visual Basic.</target>       </trans-unit>
        <trans-unit id="2686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The following table shows the syntax you use with <ph id="ph1">`GetType`</ph> for various types.</source>
          <target state="translated">Die folgende Tabelle zeigt die Syntax, die Sie mit <ph id="ph1">`GetType`</ph> für verschiedene Typen.</target>       </trans-unit>
        <trans-unit id="2687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>To Get</source>
          <target state="translated">Zum Abrufen</target>       </trans-unit>
        <trans-unit id="2688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Use</source>
          <target state="translated">Mit</target>       </trans-unit>
        <trans-unit id="2689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A nullable <ph id="ph1">&lt;xref:System.Int32&gt;</ph></source>
          <target state="translated">Ein NULL-Werte zulässt <ph id="ph1">&lt;xref:System.Int32&gt;</ph></target>       </trans-unit>
        <trans-unit id="2690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("System.Nullable`</ph>1[System.Int32]")`</target>       </trans-unit>
        <trans-unit id="2691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An unmanaged pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Ein nicht verwalteter Zeiger auf <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An unmanaged pointer to a pointer to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Ein nicht verwalteter Zeiger auf einen Zeiger auf <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A managed pointer or reference to <ph id="ph1">`MyType`</ph></source>
          <target state="translated">Ein verwalteter Zeiger oder Verweis auf <ph id="ph1">`MyType`</ph></target>       </trans-unit>
        <trans-unit id="2694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyType&amp;")`</ph>.</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyType&amp;")`</ph></target>       </trans-unit>
        <trans-unit id="2695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Note that unlike pointers, references are limited to one level.</source>
          <target state="translated">Beachten Sie, dass Verweise im Gegensatz zu Zeigern auf eine Ebene beschränkt sind.</target>       </trans-unit>
        <trans-unit id="2696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A parent class and a nested class</source>
          <target state="translated">Eine übergeordnete Klasse und eine geschachtelte Klasse</target>       </trans-unit>
        <trans-unit id="2697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A one-dimensional array with a lower bound of 0</source>
          <target state="translated">Ein eindimensionales Array mit einer unteren Grenze von 0</target>       </trans-unit>
        <trans-unit id="2698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A one-dimensional array with an unknown lower bound</source>
          <target state="translated">Ein eindimensionales Array mit einer unbekannten Untergrenze</target>       </trans-unit>
        <trans-unit id="2699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An n-dimensional array</source>
          <target state="translated">Ein n-dimensionalen array</target>       </trans-unit>
        <trans-unit id="2700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A comma (,) inside the brackets a total of n-1 times.</source>
          <target state="translated">Ein Komma (,) innerhalb der Klammern eine insgesamt n-1 Mal.</target>       </trans-unit>
        <trans-unit id="2701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, <ph id="ph1">`System.Object[,,]`</ph> represents a three-dimensional <ph id="ph2">`Object`</ph> array.</source>
          <target state="translated">Beispielsweise <ph id="ph1">`System.Object[,,]`</ph> stellt eine dreidimensionale <ph id="ph2">`Object`</ph> Array.</target>       </trans-unit>
        <trans-unit id="2702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A two-dimensional array's array</source>
          <target state="translated">Ein zweidimensionales Array von Arrays</target>       </trans-unit>
        <trans-unit id="2703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A rectangular two-dimensional array with unknown lower bounds</source>
          <target state="translated">Kein rechteckiges zweidimensionales Array mit unbekannten Untergrenzen</target>       </trans-unit>
        <trans-unit id="2704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A generic type with one type argument</source>
          <target state="translated">Ein generischer Typ mit einem Typargument</target>       </trans-unit>
        <trans-unit id="2705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[MyType]")`</target>       </trans-unit>
        <trans-unit id="2706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A generic type with two type arguments</source>
          <target state="translated">Ein generischer Typ mit zwei Typargumenten</target>       </trans-unit>
        <trans-unit id="2707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[MyType,AnotherType]")`</target>       </trans-unit>
        <trans-unit id="2708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A generic type with two assembly-qualified type arguments</source>
          <target state="translated">Ein generischer Typ mit zwei durch die Assembly qualifizierten Typargumenten</target>       </trans-unit>
        <trans-unit id="2709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")"</target>       </trans-unit>
        <trans-unit id="2710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>An assembly-qualified generic type with an assembly-qualified type argument</source>
          <target state="translated">Ein assemblyqualifizierten generischer Typ mit einem Assembly qualifizierten Typnamen-argument</target>       </trans-unit>
        <trans-unit id="2711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly")"</target>       </trans-unit>
        <trans-unit id="2712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A generic type whose type argument is a generic type with two type arguments</source>
          <target state="translated">Ein generischer Typ, dessen Type-Argument ein generischer Typ mit zwei Typargumenten ist</target>       </trans-unit>
        <trans-unit id="2713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></source>
          <target state="translated"><ph id="ph1">`Type.GetType("MyGenericType`</ph>1[AnotherGenericType<ph id="ph2">`2[MyType,AnotherType]]")`</ph></target>       </trans-unit>
        <trans-unit id="2714" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2715" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="2716" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und der Typ wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="2717" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2718" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid characters, such as an embedded tab.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen.</target>       </trans-unit>
        <trans-unit id="2719" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2720" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> ist eine leere Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2721" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2722" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> represents an array type with an invalid size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> stellt einen Arraytyp mit einer ungültigen Größe dar.</target>       </trans-unit>
        <trans-unit id="2723" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2724" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt ein Array von <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph> dar.</target>       </trans-unit>
        <trans-unit id="2725" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid syntax.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> enthält ungültige Syntax,</target>       </trans-unit>
        <trans-unit id="2726" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, "MyType[,*,]".</source>
          <target state="translated">beispielsweise "MyType[,*,]".</target>       </trans-unit>
        <trans-unit id="2727" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2728" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt einen generischen Typ dar, der einen Zeigertyp, einen <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph>-Typ oder <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> als eines seiner Typargumente aufweist.</target>       </trans-unit>
        <trans-unit id="2729" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2730" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.</target>       </trans-unit>
        <trans-unit id="2731" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2732" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</target>       </trans-unit>
        <trans-unit id="2733" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the assembly or one of its dependencies was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="2734" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</target>       </trans-unit>
        <trans-unit id="2735" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.</target>       </trans-unit>
        <trans-unit id="2736" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2737" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)">
          <source>Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</source>
          <target state="translated">Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und die Assembly wurde mit einer höheren Version kompiliert.</target>       </trans-unit>
        <trans-unit id="2738" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The name of the type to get.</source>
          <target state="translated">Der Name des abzurufenden Typs.</target>       </trans-unit>
        <trans-unit id="2739" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided, the type name can be any string that <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> is capable of resolving.</source>
          <target state="translated">Wenn der Parameter <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> bereitgestellt wird, kann der Typname jede Zeichenfolge sein, die vom <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> aufgelöst werden kann.</target>       </trans-unit>
        <trans-unit id="2740" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided or if standard type resolution is used, <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> must be an assembly-qualified name (see <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">Wenn der Parameter <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> bereitgestellt oder die Standardtypauflösung verwendet wird, muss es sich bei <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> um einen durch die Assembly qualifizierten Namen (siehe <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>) handeln, es sei denn, der Typ befindet sich in der gerade ausgeführten Assembly oder in der Datei Mscorlib.dll. In diesem Fall genügt es, den von seinem Namespace qualifizierten Typnamen anzugeben.</target>       </trans-unit>
        <trans-unit id="2741" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>A method that locates and returns the assembly that is specified in <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Eine Methode, die die Assembly sucht und zurückgibt, die in <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> angegeben wird.</target>       </trans-unit>
        <trans-unit id="2742" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The assembly name is passed to <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> as an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> object.</source>
          <target state="translated">Der Assemblyname wird als ein <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>-Objekt an den <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> übergeben.</target>       </trans-unit>
        <trans-unit id="2743" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> does not contain the name of an assembly, <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> is not called.</source>
          <target state="translated">Wenn <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> keinen Namen einer Assembly enthält, wird der <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> nicht aufgerufen.</target>       </trans-unit>
        <trans-unit id="2744" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> is not supplied, standard assembly resolution is performed.</source>
          <target state="translated">Wenn der <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> nicht angegeben wird, wird die Standardassemblyauflösung ausgeführt.</target>       </trans-unit>
        <trans-unit id="2745" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</target>       </trans-unit>
        <trans-unit id="2746" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Doing so could result in elevation of privilege for malicious code.</source>
          <target state="translated">Andernfalls könnten Berechtigungen für bösartigen Code erweitert werden.</target>       </trans-unit>
        <trans-unit id="2747" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Use only methods that you provide or that you are familiar with.</source>
          <target state="translated">Verwenden Sie nur Methoden, die Sie bereitstellen oder mit denen Sie vertraut sind.</target>       </trans-unit>
        <trans-unit id="2748" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>A method that locates and returns the type that is specified by <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> from the assembly that is returned by <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> or by standard assembly resolution.</source>
          <target state="translated">Eine Methode, die den Typ sucht und zurückgibt, der von <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> von der Assembly angegeben wird, die vom <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> oder von der Standardassemblyauflösung zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="2749" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If no assembly is provided, the <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> method can provide one.</source>
          <target state="translated">Wenn keine Assembly bereitgestellt wird, kann die <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept>-Methode eine Assembly zur Verfügung stellen.</target>       </trans-unit>
        <trans-unit id="2750" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The method also takes a parameter that specifies whether to perform a case-insensitive search; <ph id="ph1">&lt;see langword="false" /&gt;</ph> is passed to that parameter.</source>
          <target state="translated">Die Methode nimmt auch einen Parameter an, der angibt, ob bei der Suche die Groß- und Kleinschreibung berücksichtigt werden soll; an diesen Parameter wird <ph id="ph1">&lt;see langword="false" /&gt;</ph> übergeben.</target>       </trans-unit>
        <trans-unit id="2751" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</target>       </trans-unit>
        <trans-unit id="2752" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Gets the type with the specified name, optionally providing custom methods to resolve the assembly and the type.</source>
          <target state="translated">Ruft den Typ mit dem angegebenen Namen ab und stellt optional benutzerdefinierte Methoden bereit, um die Assembly und den Typ aufzulösen.</target>       </trans-unit>
        <trans-unit id="2753" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The type with the specified name, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if the type is not found.</source>
          <target state="translated">Der Typ mit dem angegebenen Namen oder <ph id="ph1">&lt;see langword="null" /&gt;</ph>, wenn der Typ nicht gefunden wird.</target>       </trans-unit>
        <trans-unit id="2754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Usage scenarios for this method and details about the <ph id="ph1">`assemblyResolver`</ph> and <ph id="ph2">`typeResolver`</ph> parameters can be found in the <ph id="ph3">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload.</source>
          <target state="translated">Verwendungsszenarien für diese Methode und die Details zu den <ph id="ph1">`assemblyResolver`</ph> und <ph id="ph2">`typeResolver`</ph> Parameter finden Sie in der <ph id="ph3">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> methodenüberladung.</target>       </trans-unit>
        <trans-unit id="2755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>If <ph id="ph1">`typeName`</ph> cannot be found, the call to the <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29&gt;</ph> method returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`typeName`</ph> kann nicht gefunden werden, den Aufruf der <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29&gt;</ph> -Methode zurückkehrt <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>It does not throw an exception.</source>
          <target state="translated">Es wird keine Ausnahme auslöst.</target>       </trans-unit>
        <trans-unit id="2757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>To control whether an exception is thrown, call an overload of the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method that has a <ph id="ph2">`throwOnError`</ph> parameter.</source>
          <target state="translated">Um zu steuern, ob eine Ausnahme ausgelöst, rufen Sie eine Überladung der <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> Methode, die eine <ph id="ph2">`throwOnError`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="2758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>Calling this method overload is the same as calling the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload and specifying <ph id="ph2">`false`</ph> for the <ph id="ph3">`throwOnError`</ph> and <ph id="ph4">`ignoreCase`</ph> parameters.</source>
          <target state="translated">Aufrufen der Überladung dieser Methode wird der gleiche wie das Aufrufen der <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> methodenüberladung und Angeben von <ph id="ph2">`false`</ph> für die <ph id="ph3">`throwOnError`</ph> und <ph id="ph4">`ignoreCase`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="2759" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2760" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="2761" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>An error occurs when <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</source>
          <target state="translated">Ein Fehler tritt auf, wenn <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> in einen Typnamen und einen Assemblynamen analysiert wird (z. B. wenn der einfache Typname ein Sonderzeichen ohne Escapezeichen enthält).</target>       </trans-unit>
        <trans-unit id="2762" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2763" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt einen generischen Typ dar, der einen Zeigertyp, einen <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph>-Typ oder <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> als eines seiner Typargumente aufweist.</target>       </trans-unit>
        <trans-unit id="2764" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2765" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.</target>       </trans-unit>
        <trans-unit id="2766" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2767" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</target>       </trans-unit>
        <trans-unit id="2768" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt ein Array von <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph> dar.</target>       </trans-unit>
        <trans-unit id="2769" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</target>       </trans-unit>
        <trans-unit id="2770" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2771" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> contains an invalid assembly name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> enthält einen ungültigen Assemblynamen.</target>       </trans-unit>
        <trans-unit id="2772" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2773" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is a valid assembly name without a type name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> ist ein gültiger Assemblyname ohne Typnamen.</target>       </trans-unit>
        <trans-unit id="2774" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.</target>       </trans-unit>
        <trans-unit id="2775" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2776" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})">
          <source>The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated">Die Assembly wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</target>       </trans-unit>
        <trans-unit id="2777" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The name of the type to get.</source>
          <target state="translated">Der Name des abzurufenden Typs.</target>       </trans-unit>
        <trans-unit id="2778" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided, the type name can be any string that <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> is capable of resolving.</source>
          <target state="translated">Wenn der Parameter <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> bereitgestellt wird, kann der Typname jede Zeichenfolge sein, die vom <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> aufgelöst werden kann.</target>       </trans-unit>
        <trans-unit id="2779" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided or if standard type resolution is used, <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> must be an assembly-qualified name (see <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">Wenn der Parameter <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> bereitgestellt oder die Standardtypauflösung verwendet wird, muss es sich bei <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> um einen durch die Assembly qualifizierten Namen (siehe <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>) handeln, es sei denn, der Typ befindet sich in der gerade ausgeführten Assembly oder in der Datei Mscorlib.dll. In diesem Fall genügt es, den von seinem Namespace qualifizierten Typnamen anzugeben.</target>       </trans-unit>
        <trans-unit id="2780" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>A method that locates and returns the assembly that is specified in <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Eine Methode, die die Assembly sucht und zurückgibt, die in <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> angegeben wird.</target>       </trans-unit>
        <trans-unit id="2781" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The assembly name is passed to <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> as an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> object.</source>
          <target state="translated">Der Assemblyname wird als ein <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>-Objekt an den <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> übergeben.</target>       </trans-unit>
        <trans-unit id="2782" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> does not contain the name of an assembly, <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> is not called.</source>
          <target state="translated">Wenn <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> keinen Namen einer Assembly enthält, wird der <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> nicht aufgerufen.</target>       </trans-unit>
        <trans-unit id="2783" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> is not supplied, standard assembly resolution is performed.</source>
          <target state="translated">Wenn der <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> nicht angegeben wird, wird die Standardassemblyauflösung ausgeführt.</target>       </trans-unit>
        <trans-unit id="2784" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</target>       </trans-unit>
        <trans-unit id="2785" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Doing so could result in elevation of privilege for malicious code.</source>
          <target state="translated">Andernfalls könnten Berechtigungen für bösartigen Code erweitert werden.</target>       </trans-unit>
        <trans-unit id="2786" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Use only methods that you provide or that you are familiar with.</source>
          <target state="translated">Verwenden Sie nur Methoden, die Sie bereitstellen oder mit denen Sie vertraut sind.</target>       </trans-unit>
        <trans-unit id="2787" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>A method that locates and returns the type that is specified by <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> from the assembly that is returned by <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> or by standard assembly resolution.</source>
          <target state="translated">Eine Methode, die den Typ sucht und zurückgibt, der von <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> von der Assembly angegeben wird, die vom <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> oder von der Standardassemblyauflösung zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="2788" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If no assembly is provided, the method can provide one.</source>
          <target state="translated">Wenn keine Assembly bereitgestellt wird, kann die Methode eine Assembly zur Verfügung stellen.</target>       </trans-unit>
        <trans-unit id="2789" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The method also takes a parameter that specifies whether to perform a case-insensitive search; <ph id="ph1">&lt;see langword="false" /&gt;</ph> is passed to that parameter.</source>
          <target state="translated">Die Methode nimmt auch einen Parameter an, der angibt, ob bei der Suche die Groß- und Kleinschreibung berücksichtigt werden soll; an diesen Parameter wird <ph id="ph1">&lt;see langword="false" /&gt;</ph> übergeben.</target>       </trans-unit>
        <trans-unit id="2790" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</target>       </trans-unit>
        <trans-unit id="2791" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden werden kann, <ph id="ph2">&lt;see langword="false" /&gt;</ph>, damit <ph id="ph3">&lt;see langword="null" /&gt;</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="2792" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Specifying <ph id="ph1">&lt;see langword="false" /&gt;</ph> also suppresses some other exception conditions, but not all of them.</source>
          <target state="translated">Die Angabe von <ph id="ph1">&lt;see langword="false" /&gt;</ph> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle.</target>       </trans-unit>
        <trans-unit id="2793" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">Informationen finden Sie im Abschnitt für Ausnahmen.</target>       </trans-unit>
        <trans-unit id="2794" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Gets the type with the specified name, specifying whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</source>
          <target state="translated">Ruft den Typ mit dem angegebenen Namen ab. Dabei wird angegeben, ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird, und optional werden benutzerdefinierte Methoden bereitgestellt, um die Assembly und den Typ aufzulösen.</target>       </trans-unit>
        <trans-unit id="2795" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The type with the specified name.</source>
          <target state="translated">Der Typ mit dem angegebenen Namen.</target>       </trans-unit>
        <trans-unit id="2796" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>If the type is not found, the <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> parameter specifies whether <ph id="ph2">&lt;see langword="null" /&gt;</ph> is returned or an exception is thrown.</source>
          <target state="translated">Wenn der Typ nicht gefunden wird, gibt der <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>-Parameter an, ob <ph id="ph2">&lt;see langword="null" /&gt;</ph> zurückgegeben oder eine Ausnahme ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="2797" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>In some cases, an exception is thrown regardless of the value of <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</source>
          <target state="translated">In einigen Fällen wird unabhängig vom Wert von <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> eine Ausnahme ausgelöst.</target>       </trans-unit>
        <trans-unit id="2798" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">Informationen finden Sie im Abschnitt für Ausnahmen.</target>       </trans-unit>
        <trans-unit id="2799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Usage scenarios for this method and details about the <ph id="ph1">`assemblyResolver`</ph> and <ph id="ph2">`typeResolver`</ph> parameters can be found in the <ph id="ph3">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload.</source>
          <target state="translated">Verwendungsszenarien für diese Methode und die Details zu den <ph id="ph1">`assemblyResolver`</ph> und <ph id="ph2">`typeResolver`</ph> Parameter finden Sie in der <ph id="ph3">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> methodenüberladung.</target>       </trans-unit>
        <trans-unit id="2800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>Calling this method overload is the same as calling the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload and specifying <ph id="ph2">`false`</ph> for the <ph id="ph3">`ignoreCase`</ph> parameter.</source>
          <target state="translated">Aufrufen der Überladung dieser Methode wird der gleiche wie das Aufrufen der <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> methodenüberladung und Angeben von <ph id="ph2">`false`</ph> für die <ph id="ph3">`ignoreCase`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="2801" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2802" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="2803" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und der Typ wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="2804" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2805" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid characters, such as an embedded tab.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen.</target>       </trans-unit>
        <trans-unit id="2806" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2807" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> ist eine leere Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2808" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2809" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> represents an array type with an invalid size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> stellt einen Arraytyp mit einer ungültigen Größe dar.</target>       </trans-unit>
        <trans-unit id="2810" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2811" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt ein Array von <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph> dar.</target>       </trans-unit>
        <trans-unit id="2812" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>An error occurs when <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</source>
          <target state="translated">Ein Fehler tritt auf, wenn <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> in einen Typnamen und einen Assemblynamen analysiert wird (z. B. wenn der einfache Typname ein Sonderzeichen ohne Escapezeichen enthält).</target>       </trans-unit>
        <trans-unit id="2813" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2814" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid syntax (for example, "MyType[,*,]").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> enthält ungültige Syntax (z. B. "MyType[,*,]").</target>       </trans-unit>
        <trans-unit id="2815" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2816" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt einen generischen Typ dar, der einen Zeigertyp, einen <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph>-Typ oder <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> als eines seiner Typargumente aufweist.</target>       </trans-unit>
        <trans-unit id="2817" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2818" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.</target>       </trans-unit>
        <trans-unit id="2819" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2820" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</target>       </trans-unit>
        <trans-unit id="2821" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the assembly or one of its dependencies was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="2822" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2823" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> contains an invalid assembly name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> enthält einen ungültigen Assemblynamen.</target>       </trans-unit>
        <trans-unit id="2824" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2825" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is a valid assembly name without a type name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> ist ein gültiger Assemblyname ohne Typnamen.</target>       </trans-unit>
        <trans-unit id="2826" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, aber konnte nicht geladen werden.</target>       </trans-unit>
        <trans-unit id="2827" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.</target>       </trans-unit>
        <trans-unit id="2828" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2829" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)">
          <source>The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated">Die Assembly wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</target>       </trans-unit>
        <trans-unit id="2830" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The name of the type to get.</source>
          <target state="translated">Der Name des abzurufenden Typs.</target>       </trans-unit>
        <trans-unit id="2831" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided, the type name can be any string that <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> is capable of resolving.</source>
          <target state="translated">Wenn der Parameter <bpt id="p1">&lt;c&gt;</bpt>typeResolver<ept id="p1">&lt;/c&gt;</ept> bereitgestellt wird, kann der Typname jede Zeichenfolge sein, die vom <bpt id="p2">&lt;c&gt;</bpt>typeResolver<ept id="p2">&lt;/c&gt;</ept> aufgelöst werden kann.</target>       </trans-unit>
        <trans-unit id="2832" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> parameter is provided or if standard type resolution is used, <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> must be an assembly-qualified name (see <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</source>
          <target state="translated">Wenn der Parameter <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> bereitgestellt oder die Standardtypauflösung verwendet wird, muss es sich bei <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> um einen durch die Assembly qualifizierten Namen (siehe <ph id="ph1">&lt;see cref="P:System.Type.AssemblyQualifiedName" /&gt;</ph>) handeln, es sei denn, der Typ befindet sich in der gerade ausgeführten Assembly oder in der Datei Mscorlib.dll. In diesem Fall genügt es, den von seinem Namespace qualifizierten Typnamen anzugeben.</target>       </trans-unit>
        <trans-unit id="2833" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>A method that locates and returns the assembly that is specified in <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Eine Methode, die die Assembly sucht und zurückgibt, die in <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> angegeben wird.</target>       </trans-unit>
        <trans-unit id="2834" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The assembly name is passed to <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> as an <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph> object.</source>
          <target state="translated">Der Assemblyname wird als ein <ph id="ph1">&lt;see cref="T:System.Reflection.AssemblyName" /&gt;</ph>-Objekt an den <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> übergeben.</target>       </trans-unit>
        <trans-unit id="2835" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> does not contain the name of an assembly, <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> is not called.</source>
          <target state="translated">Wenn <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> keinen Namen einer Assembly enthält, wird der <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> nicht aufgerufen.</target>       </trans-unit>
        <trans-unit id="2836" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> is not supplied, standard assembly resolution is performed.</source>
          <target state="translated">Wenn der <bpt id="p1">&lt;c&gt;</bpt>assemblyResolver<ept id="p1">&lt;/c&gt;</ept> nicht angegeben wird, wird die Standardassemblyauflösung ausgeführt.</target>       </trans-unit>
        <trans-unit id="2837" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</target>       </trans-unit>
        <trans-unit id="2838" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Doing so could result in elevation of privilege for malicious code.</source>
          <target state="translated">Andernfalls könnten Berechtigungen für bösartigen Code erweitert werden.</target>       </trans-unit>
        <trans-unit id="2839" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Use only methods that you provide or that you are familiar with.</source>
          <target state="translated">Verwenden Sie nur Methoden, die Sie bereitstellen oder mit denen Sie vertraut sind.</target>       </trans-unit>
        <trans-unit id="2840" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>A method that locates and returns the type that is specified by <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> from the assembly that is returned by <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> or by standard assembly resolution.</source>
          <target state="translated">Eine Methode, die den Typ sucht und zurückgibt, der von <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> von der Assembly angegeben wird, die vom <bpt id="p2">&lt;c&gt;</bpt>assemblyResolver<ept id="p2">&lt;/c&gt;</ept> oder von der Standardassemblyauflösung zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="2841" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If no assembly is provided, the method can provide one.</source>
          <target state="translated">Wenn keine Assembly bereitgestellt wird, kann die Methode eine Assembly zur Verfügung stellen.</target>       </trans-unit>
        <trans-unit id="2842" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The method also takes a parameter that specifies whether to perform a case-insensitive search; the value of <bpt id="p1">&lt;c&gt;</bpt>ignoreCase<ept id="p1">&lt;/c&gt;</ept> is passed to that parameter.</source>
          <target state="translated">Die Methode nimmt auch einen Parameter an, der angibt, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll; der Wert von <bpt id="p1">&lt;c&gt;</bpt>ignoreCase<ept id="p1">&lt;/c&gt;</ept> wird an diesen Parameter übergeben.</target>       </trans-unit>
        <trans-unit id="2843" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Caution   Do not pass methods from unknown or untrusted callers.</source>
          <target state="translated">Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</target>       </trans-unit>
        <trans-unit id="2844" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw an exception if the type cannot be found; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to return <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden werden kann, <ph id="ph2">&lt;see langword="false" /&gt;</ph>, damit <ph id="ph3">&lt;see langword="null" /&gt;</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="2845" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Specifying <ph id="ph1">&lt;see langword="false" /&gt;</ph> also suppresses some other exception conditions, but not all of them.</source>
          <target state="translated">Die Angabe von <ph id="ph1">&lt;see langword="false" /&gt;</ph> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle.</target>       </trans-unit>
        <trans-unit id="2846" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">Informationen finden Sie im Abschnitt für Ausnahmen.</target>       </trans-unit>
        <trans-unit id="2847" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to perform a case-insensitive search for <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>, <ph id="ph2">&lt;see langword="false" /&gt;</ph> to perform a case-sensitive search for <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, um ohne Beachtung der Groß-/Kleinschreibung nach <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> zu suchen; <ph id="ph2">&lt;see langword="false" /&gt;</ph>, um mit Beachtung der Groß-/Kleinschreibung nach <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> zu suchen.</target>       </trans-unit>
        <trans-unit id="2848" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Gets the type with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</source>
          <target state="translated">Ruft den Typ mit dem angegebenen Namen ab. Dabei wird angegeben, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll und ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird, und optional werden benutzerdefinierte Methoden bereitgestellt, um die Assembly und den Typ aufzulösen.</target>       </trans-unit>
        <trans-unit id="2849" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The type with the specified name.</source>
          <target state="translated">Der Typ mit dem angegebenen Namen.</target>       </trans-unit>
        <trans-unit id="2850" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the type is not found, the <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> parameter specifies whether <ph id="ph2">&lt;see langword="null" /&gt;</ph> is returned or an exception is thrown.</source>
          <target state="translated">Wenn der Typ nicht gefunden wird, gibt der <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>-Parameter an, ob <ph id="ph2">&lt;see langword="null" /&gt;</ph> zurückgegeben oder eine Ausnahme ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="2851" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>In some cases, an exception is thrown regardless of the value of <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph>.</source>
          <target state="translated">In einigen Fällen wird unabhängig vom Wert von <ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> eine Ausnahme ausgelöst.</target>       </trans-unit>
        <trans-unit id="2852" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">Informationen finden Sie im Abschnitt für Ausnahmen.</target>       </trans-unit>
        <trans-unit id="2853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Use this method overload and its associated overloads (<ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29&gt;</ph>) to replace the default implementation of the <ph id="ph3">&lt;xref:System.Type.GetType%2A&gt;</ph> method with more flexible implementations.</source>
          <target state="translated">Verwenden Sie diese methodenüberladung und ihre zugeordneten Überladungen (<ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29&gt;</ph> und <ph id="ph2">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29&gt;</ph>) ersetzt die standardmäßige Implementierung des der <ph id="ph3">&lt;xref:System.Type.GetType%2A&gt;</ph> Methode mit flexibler Implementierungen.</target>       </trans-unit>
        <trans-unit id="2854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>By providing your own methods that resolve type names and the names of the assemblies that contain them, you can do the following:</source>
          <target state="translated">Durch Ihre eigenen Methoden, die aufgelöst werden Typnamen und die Namen der Assemblys, die sie enthalten, können Sie Folgendes tun:</target>       </trans-unit>
        <trans-unit id="2855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Control which version of an assembly a type is loaded from.</source>
          <target state="translated">Steuern Sie, welche Version einer Assembly, die ein Typ aus geladen wird.</target>       </trans-unit>
        <trans-unit id="2856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Provide another place to look for a type name that does not include an assembly name.</source>
          <target state="translated">Geben Sie einen anderen Speicherort für für einen Typnamen zu suchen, die keine Namen einer Assembly enthalten.</target>       </trans-unit>
        <trans-unit id="2857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Load assemblies using partial assembly names.</source>
          <target state="translated">Laden von Assemblys mit partiellen Assemblynamen.</target>       </trans-unit>
        <trans-unit id="2858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Return subclasses of <ph id="ph1">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> that are not created by the common language runtime (CLR).</source>
          <target state="translated">Zurückgeben von Unterklassen von <ph id="ph1">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> , die nicht von der common Language Runtime (CLR) erstellt werden.</target>       </trans-unit>
        <trans-unit id="2859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>For example, in version-tolerant serialization this method enables you to search for a "best fit" assembly by using a partial name.</source>
          <target state="translated">Beispielsweise kann in versionstolerante dieser Methode suchen Sie nach einer "best fit"-Assembly mithilfe eines unvollständigen Namens.</target>       </trans-unit>
        <trans-unit id="2860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Other overloads of the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method require an assembly-qualified type name, which includes the version number.</source>
          <target state="translated">Andere Überladungen der <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> Methode benötigt einen Assembly qualifizierten Typnamen, die die Versionsnummer enthält.</target>       </trans-unit>
        <trans-unit id="2861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Alternate implementations of the type system may need to return subclasses of <ph id="ph1">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> that are not created by the CLR; all types that are returned by other overloads of the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> method are runtime types.</source>
          <target state="translated">Alternative Implementierungen des Typsystems Unterklassen des zurückzugebenden müssen möglicherweise <ph id="ph1">&lt;xref:System.Type?displayProperty=nameWithType&gt;</ph> , die von der CLR nicht erstellt werden, alle Typen, die von anderen Überladungen der zurückgegeben werden die <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> Methode sind-Runtime-Typen.</target>       </trans-unit>
        <trans-unit id="2862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Usage Notes</source>
          <target state="translated">Hinweise zur Verwendung</target>       </trans-unit>
        <trans-unit id="2863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>This method overload and its associated overloads parse <ph id="ph1">`typeName`</ph> into the name of a type and the name of an assembly, and then resolve the names.</source>
          <target state="translated">Überladung dieser Methode und ihre zugeordneten Überladungen analysieren <ph id="ph1">`typeName`</ph> in den Namen eines Typs und den Namen einer Assembly, und klicken Sie dann den Namen aufzulösen.</target>       </trans-unit>
        <trans-unit id="2864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolution of the assembly name occurs before resolution of the type name, because a type name must be resolved in the context of an assembly.</source>
          <target state="translated">Auflösung des Assemblynamens tritt ein, bevor die Auflösung des Typnamens, da ein Typnamen im Kontext einer Assembly aufgelöst werden muss.</target>       </trans-unit>
        <trans-unit id="2865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If you are unfamiliar with the concept of assembly-qualified type names, see the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property.</source>
          <target state="translated">Wenn Sie mit dem Konzept der Assembly qualifizierten Typnamen nicht vertraut sind, finden Sie unter der <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="2866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> is not an assembly-qualified name, assembly resolution is skipped.</source>
          <target state="translated">Wenn <ph id="ph1">`typeName`</ph> ist kein Assembly qualifizierter Name, Assemblyauflösung wird übersprungen.</target>       </trans-unit>
        <trans-unit id="2867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Unqualified type names can be resolved in the context of Mscorlib.dll or the currently executing assembly, or you can optionally provide an assembly in the <ph id="ph1">`typeResolver`</ph> parameter.</source>
          <target state="translated">Nicht qualifizierte Typennamen können im Kontext von "mscorlib.dll" oder der aktuell ausgeführten Assembly aufgelöst werden, oder Sie können optional Bereitstellen einer Assembly in die <ph id="ph1">`typeResolver`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="2868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The effects of including or omitting the assembly name for different kinds of name resolution are displayed as a table in the <bpt id="p1">[</bpt>Mixed Name Resolution<ept id="p1">](#mixed_name_resolution)</ept> section.</source>
          <target state="translated">Die Auswirkungen der ein- oder den Assemblynamen auslassen, für verschiedene Arten von namensauflösung, wie eine Tabelle in angezeigt werden der <bpt id="p1">[</bpt>gemischten namensauflösung<ept id="p1">](#mixed_name_resolution)</ept> Abschnitt.</target>       </trans-unit>
        <trans-unit id="2869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>General usage notes:</source>
          <target state="translated">Allgemeine Verwendungshinweise:</target>       </trans-unit>
        <trans-unit id="2870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Do not pass methods to <ph id="ph1">`assemblyResolver`</ph> or <ph id="ph2">`typeResolver`</ph> if they come from unknown or untrusted callers.</source>
          <target state="translated">Übergeben Sie keine Methoden, um <ph id="ph1">`assemblyResolver`</ph> oder <ph id="ph2">`typeResolver`</ph> , wenn sie von unbekannten oder nicht vertrauenswürdigen Aufrufern stammen.</target>       </trans-unit>
        <trans-unit id="2871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Use only methods that you provide or that you are familiar with.</source>
          <target state="translated">Verwenden Sie nur Methoden, die Sie bereitstellen oder mit denen Sie vertraut sind.</target>       </trans-unit>
        <trans-unit id="2872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Using methods from unknown or untrusted callers could result in elevation of privilege for malicious code.</source>
          <target state="translated">Mithilfe der Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern kann zu einer Erhöhung von Berechtigungen für bösartigen Code führen.</target>       </trans-unit>
        <trans-unit id="2873" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If you omit the <ph id="ph1">`assemblyResolver`</ph> and/or <ph id="ph2">`typeResolver`</ph> parameters, the value of the <ph id="ph3">`throwOnError`</ph> parameter is passed to the methods that perform the default resolution.</source>
          <target state="translated">Wenn Sie weglassen der <ph id="ph1">`assemblyResolver`</ph> und/oder <ph id="ph2">`typeResolver`</ph> Parameter, der Wert der <ph id="ph3">`throwOnError`</ph> Parameter übergeben wird, um die Methoden, die Standardlösung ausführen.</target>       </trans-unit>
        <trans-unit id="2874" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`throwOnError`</ph> is <ph id="ph2">`true`</ph>, this method throws a <ph id="ph3">&lt;xref:System.TypeLoadException&gt;</ph> when <ph id="ph4">`typeResolver`</ph> returns <ph id="ph5">`null`</ph>, and a <ph id="ph6">&lt;xref:System.IO.FileNotFoundException&gt;</ph> when <ph id="ph7">`assemblyResolver`</ph> returns <ph id="ph8">`null`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`throwOnError`</ph> ist <ph id="ph2">`true`</ph>, löst diese Methode eine <ph id="ph3">&lt;xref:System.TypeLoadException&gt;</ph> beim <ph id="ph4">`typeResolver`</ph> gibt <ph id="ph5">`null`</ph>, und ein <ph id="ph6">&lt;xref:System.IO.FileNotFoundException&gt;</ph> Wenn <ph id="ph7">`assemblyResolver`</ph> gibt <ph id="ph8">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2875" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>This method does not catch exceptions thrown by <ph id="ph1">`assemblyResolver`</ph> and <ph id="ph2">`typeResolver`</ph>.</source>
          <target state="translated">Diese Methode keine Ausnahmen ausgelöst werden, indem <ph id="ph1">`assemblyResolver`</ph> und <ph id="ph2">`typeResolver`</ph>.</target>       </trans-unit>
        <trans-unit id="2876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>You are responsible for any exceptions that are thrown by the resolver methods.</source>
          <target state="translated">Sie sind verantwortlich für alle Ausnahmen, die von den Konfliktlöser Methoden ausgelöst werden.</target>       </trans-unit>
        <trans-unit id="2877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolving Assemblies</source>
          <target state="translated">Auflösen von Assemblys</target>       </trans-unit>
        <trans-unit id="2878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`assemblyResolver`</ph> method receives an <ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object, which is produced by parsing the string assembly name that is included in <ph id="ph3">`typeName`</ph>.</source>
          <target state="translated">Die <ph id="ph1">`assemblyResolver`</ph> Methode empfängt einen <ph id="ph2">&lt;xref:System.Reflection.AssemblyName&gt;</ph> -Objekt, das erzeugt wird, durch Analysieren der Zeichenfolge Assemblyname, der in enthalten ist <ph id="ph3">`typeName`</ph>.</target>       </trans-unit>
        <trans-unit id="2879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> does not contain an assembly name, <ph id="ph2">`assemblyResolver`</ph> is not called and <ph id="ph3">`null`</ph> is passed to <ph id="ph4">`typeResolver`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`typeName`</ph> enthält keinen Namen einer Assembly <ph id="ph2">`assemblyResolver`</ph> wird nicht aufgerufen und <ph id="ph3">`null`</ph> übergeben <ph id="ph4">`typeResolver`</ph>.</target>       </trans-unit>
        <trans-unit id="2880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> is not supplied, standard assembly probing is used to locate the assembly.</source>
          <target state="translated">Wenn <ph id="ph1">`assemblyResolver`</ph> ist nicht angegeben wird, Überprüfung wird verwendet, um die Assembly gesucht werden soll.</target>       </trans-unit>
        <trans-unit id="2881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> is provided, the <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> method does not do standard probing; in that case you must ensure that your <ph id="ph3">`assemblyResolver`</ph> can handle all the assemblies you pass to it.</source>
          <target state="translated">Wenn <ph id="ph1">`assemblyResolver`</ph> angegeben ist, die <ph id="ph2">&lt;xref:System.Type.GetType%2A&gt;</ph> Methode führt keine Standardsuche; in diesem Fall müssen Sie sicherstellen, dass Ihre <ph id="ph3">`assemblyResolver`</ph> können behandeln alle Assemblys, die Sie an diesen weitergegeben.</target>       </trans-unit>
        <trans-unit id="2882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`assemblyResolver`</ph> method should return <ph id="ph2">`null`</ph> if the assembly cannot be resolved.</source>
          <target state="translated">Die <ph id="ph1">`assemblyResolver`</ph> -Methode zurückgeben sollte <ph id="ph2">`null`</ph> Wenn die Assembly aufgelöst werden kann.</target>       </trans-unit>
        <trans-unit id="2883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> returns <ph id="ph2">`null`</ph>, <ph id="ph3">`typeResolver`</ph> is not called and no further processing occurs; additionally, if <ph id="ph4">`throwOnError`</ph> is <ph id="ph5">`true`</ph>, a <ph id="ph6">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
          <target state="translated">Wenn <ph id="ph1">`assemblyResolver`</ph> gibt <ph id="ph2">`null`</ph>, <ph id="ph3">`typeResolver`</ph> wird nicht aufgerufen, und keine weitere Verarbeitung erfolgt; darüber hinaus Wenn <ph id="ph4">`throwOnError`</ph> ist <ph id="ph5">`true`</ph>, eine <ph id="ph6">&lt;xref:System.IO.FileNotFoundException&gt;</ph> ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="2884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> that is passed to <ph id="ph2">`assemblyResolver`</ph> is a partial name, one or more of its parts are <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> übergebene <ph id="ph2">`assemblyResolver`</ph> ist eine partielle Name, eine oder mehrere Teile sind <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>For example, if it has no version, the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Version%2A&gt;</ph> property is <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Wenn sie keine Version verfügt beispielsweise die <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Version%2A&gt;</ph> Eigenschaft ist <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="2886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Version%2A&gt;</ph> property, the <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CultureInfo%2A&gt;</ph> property, and the <ph id="ph3">&lt;xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A&gt;</ph> method all return <ph id="ph4">`null`</ph>, then only the simple name of the assembly was supplied.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Reflection.AssemblyName.Version%2A&gt;</ph> -Eigenschaft, die <ph id="ph2">&lt;xref:System.Reflection.AssemblyName.CultureInfo%2A&gt;</ph> -Eigenschaft, und die <ph id="ph3">&lt;xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A&gt;</ph> alle-Methodenrückgabe <ph id="ph4">`null`</ph>, und klicken Sie dann nur der einfache Namen der Assembly angegeben wurde.</target>       </trans-unit>
        <trans-unit id="2887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`assemblyResolver`</ph> method can use or ignore all parts of the assembly name.</source>
          <target state="translated">Die <ph id="ph1">`assemblyResolver`</ph> Methode verwenden oder ignorieren Sie alle Teile des Assemblynamens.</target>       </trans-unit>
        <trans-unit id="2888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The effects of different assembly resolution options are displayed as a table in the <bpt id="p1">[</bpt>Mixed Name Resolution<ept id="p1">](#mixed_name_resolution)</ept> section, for simple and assembly-qualified type names.</source>
          <target state="translated">Die Auswirkungen der verschiedenen Auflösung Assemblyoptionen werden angezeigt, wie eine Tabelle in der <bpt id="p1">[</bpt>gemischten namensauflösung<ept id="p1">](#mixed_name_resolution)</ept> Abschnitt für einfache und Assembly qualifizierten Typnamen.</target>       </trans-unit>
        <trans-unit id="2889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolving Types</source>
          <target state="translated">Auflösen von Typen</target>       </trans-unit>
        <trans-unit id="2890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> does not specify an assembly name, <ph id="ph2">`typeResolver`</ph> is always called.</source>
          <target state="translated">Wenn <ph id="ph1">`typeName`</ph> gibt keinen Namen einer Assembly <ph id="ph2">`typeResolver`</ph> wird immer aufgerufen.</target>       </trans-unit>
        <trans-unit id="2891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> specifies an assembly name, <ph id="ph2">`typeResolver`</ph> is called only when the assembly name is successfully resolved.</source>
          <target state="translated">Wenn <ph id="ph1">`typeName`</ph> gibt den Namen einer Assembly <ph id="ph2">`typeResolver`</ph> wird nur aufgerufen, wenn der Name der Assembly erfolgreich aufgelöst wurde.</target>       </trans-unit>
        <trans-unit id="2892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> or standard assembly probing returns <ph id="ph2">`null`</ph>, <ph id="ph3">`typeResolver`</ph> is not called.</source>
          <target state="translated">Wenn <ph id="ph1">`assemblyResolver`</ph> oder Standardassembly gibt <ph id="ph2">`null`</ph>, <ph id="ph3">`typeResolver`</ph> wird nicht aufgerufen.</target>       </trans-unit>
        <trans-unit id="2893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`typeResolver`</ph> method receives three arguments:</source>
          <target state="translated">Die <ph id="ph1">`typeResolver`</ph> -Methode empfängt drei Argumente:</target>       </trans-unit>
        <trans-unit id="2894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The assembly to search or <ph id="ph1">`null`</ph> if <ph id="ph2">`typeName`</ph> does not contain an assembly name.</source>
          <target state="translated">Die Assembly zu suchen oder <ph id="ph1">`null`</ph> Wenn <ph id="ph2">`typeName`</ph> enthält keinen Namen einer Assembly.</target>       </trans-unit>
        <trans-unit id="2895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The simple name of the type.</source>
          <target state="translated">Der einfache Name des Typs.</target>       </trans-unit>
        <trans-unit id="2896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>In the case of a nested type, this is the outermost containing type.</source>
          <target state="translated">Im Falle eines geschachtelten Typs ist dies der äußersten enthaltenden Typ.</target>       </trans-unit>
        <trans-unit id="2897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>In the case of a generic type, this is the simple name of the generic type.</source>
          <target state="translated">Im Falle eines generischen Typs ist dies der einfache Name des generischen Typs.</target>       </trans-unit>
        <trans-unit id="2898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>A Boolean value that is <ph id="ph1">`true`</ph> if the case of type names is to be ignored.</source>
          <target state="translated">Ein boolescher Wert, der <ph id="ph1">`true`</ph> Wenn Typnamen die Groß-/Kleinschreibung ignoriert werden.</target>       </trans-unit>
        <trans-unit id="2899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The implementation determines the way these arguments are used.</source>
          <target state="translated">Die Implementierung bestimmt, wie diese Argumente verwendet werden.</target>       </trans-unit>
        <trans-unit id="2900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`typeResolver`</ph> method should return <ph id="ph2">`null`</ph> if it cannot resolve the type.</source>
          <target state="translated">Die <ph id="ph1">`typeResolver`</ph> -Methode zurückgeben sollte <ph id="ph2">`null`</ph> , wenn den Typ nicht auflösen kann.</target>       </trans-unit>
        <trans-unit id="2901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeResolver`</ph> returns <ph id="ph2">`null`</ph> and <ph id="ph3">`throwOnError`</ph> is <ph id="ph4">`true`</ph>, this overload of <ph id="ph5">&lt;xref:System.Type.GetType%2A&gt;</ph> throws a <ph id="ph6">&lt;xref:System.TypeLoadException&gt;</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`typeResolver`</ph> gibt <ph id="ph2">`null`</ph> und <ph id="ph3">`throwOnError`</ph> ist <ph id="ph4">`true`</ph>, diese Überladung der <ph id="ph5">&lt;xref:System.Type.GetType%2A&gt;</ph> löst eine <ph id="ph6">&lt;xref:System.TypeLoadException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The effects of different type resolution options are displayed as a table in the <bpt id="p1">[</bpt>Mixed Name Resolution<ept id="p1">](#mixed_name_resolution)</ept> section, for simple and assembly-qualified type names.</source>
          <target state="translated">Die Auswirkungen eines anderen Typs Optionen werden angezeigt, wie eine Tabelle in der <bpt id="p1">[</bpt>gemischten namensauflösung<ept id="p1">](#mixed_name_resolution)</ept> Abschnitt für einfache und Assembly qualifizierten Typnamen.</target>       </trans-unit>
        <trans-unit id="2903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolving Nested Types</source>
          <target state="translated">Auflösen von geschachtelten Typen</target>       </trans-unit>
        <trans-unit id="2904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`typeName`</ph> is a nested type, only the name of the outermost containing type is passed to <ph id="ph2">`typeResolver`</ph>.</source>
          <target state="translated">Wenn <ph id="ph1">`typeName`</ph> geschachtelter Typ, nur den Namen des äußersten übergeben wird, enthält Typ <ph id="ph2">`typeResolver`</ph>.</target>       </trans-unit>
        <trans-unit id="2905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>When <ph id="ph1">`typeResolver`</ph> returns this type, the <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph> method is called recursively until the innermost nested type has been resolved.</source>
          <target state="translated">Wenn <ph id="ph1">`typeResolver`</ph> diesen Typ zurückgibt, der <ph id="ph2">&lt;xref:System.Type.GetNestedType%2A&gt;</ph> Methode rekursiv aufgerufen, bis der innersten geschachtelten Typ aufgelöst wurde.</target>       </trans-unit>
        <trans-unit id="2906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolving Generic Types</source>
          <target state="translated">Auflösen von generischen Typen</target>       </trans-unit>
        <trans-unit id="2907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> is called recursively to resolve generic types: First to resolve the generic type itself, and then to resolve its type arguments.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> rekursiv aufgerufen, um generische Typen aufzulösen: zuerst an, um den generischen Typ selbst zu beheben und dann seine Typargumente aufgelöst.</target>       </trans-unit>
        <trans-unit id="2908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If a type argument is generic, <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> is called recursively to resolve its type arguments, and so on.</source>
          <target state="translated">Wenn ein Argument vom Typ generisch ist, wird <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> rekursiv aufgerufen, um zu seiner Typargumente beheben und so weiter.</target>       </trans-unit>
        <trans-unit id="2909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The combination of <ph id="ph1">`assemblyResolver`</ph> and <ph id="ph2">`typeResolver`</ph> that you provide must be capable of resolving all levels of this recursion.</source>
          <target state="translated">Die Kombination von <ph id="ph1">`assemblyResolver`</ph> und <ph id="ph2">`typeResolver`</ph> der Auflösung dieses alle Stufen in der Lage sein, dass Sie zur Verfügung stellen.</target>       </trans-unit>
        <trans-unit id="2910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>For example, suppose you supply an <ph id="ph1">`assemblyResolver`</ph> that controls the loading of <ph id="ph2">`MyAssembly`</ph>.</source>
          <target state="translated">Nehmen wir beispielsweise an, Sie geben eine <ph id="ph1">`assemblyResolver`</ph> , steuert das Laden von <ph id="ph2">`MyAssembly`</ph>.</target>       </trans-unit>
        <trans-unit id="2911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Suppose you want to resolve the generic type <ph id="ph1">`Dictionary&lt;string, MyType&gt;`</ph> (<ph id="ph2">`Dictionary(Of String, MyType)`</ph> in Visual Basic).</source>
          <target state="translated">Angenommen, Sie möchten den generischen Typ aufgelöst <ph id="ph1">`Dictionary&lt;string, MyType&gt;`</ph> (<ph id="ph2">`Dictionary(Of String, MyType)`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="2912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>You might pass the following generic type name:</source>
          <target state="translated">Sie können die folgenden Name des generischen Typs übergeben:</target>       </trans-unit>
        <trans-unit id="2913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Notice that <ph id="ph1">`MyType`</ph> is the only assembly-qualified type argument.</source>
          <target state="translated">Beachten Sie, dass <ph id="ph1">`MyType`</ph> ist das Argument nur Assembly qualifizierten Typnamen.</target>       </trans-unit>
        <trans-unit id="2914" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The names of the <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> and <ph id="ph2">&lt;xref:System.String&gt;</ph> classes are not assembly-qualified.</source>
          <target state="translated">Die Namen der <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> und <ph id="ph2">&lt;xref:System.String&gt;</ph> Klassen sind nicht für die Assembly qualifizierten.</target>       </trans-unit>
        <trans-unit id="2915" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Your <ph id="ph1">`typeResolver`</ph> must be able handle either an assembly or <ph id="ph2">`null`</ph>, because it will receive <ph id="ph3">`null`</ph> for <ph id="ph4">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> and <ph id="ph5">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated">Ihre <ph id="ph1">`typeResolver`</ph> muss Handle kann entweder eine Assembly oder <ph id="ph2">`null`</ph>, da er erhält <ph id="ph3">`null`</ph> für <ph id="ph4">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> und <ph id="ph5">&lt;xref:System.String&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2916" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>It can handle that case by calling an overload of the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method that takes a string, because both of the unqualified type names are in Mscorlib.dll:</source>
          <target state="translated">Sie können diesen Fall behandeln, durch Aufruf einer Überladung von der <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> -Methode, die eine Zeichenfolge akzeptiert, da beide den nicht qualifizierten Typnamen in "mscorlib.dll" sind:</target>       </trans-unit>
        <trans-unit id="2917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`assemblyResolver`</ph> method is not called for the dictionary type and the string type, because those type names are not assembly-qualified.</source>
          <target state="translated">Die <ph id="ph1">`assemblyResolver`</ph> Methode wird für den Wörterbuchtyp und den String-Datentyp nicht aufgerufen, da diese Namen nicht Assembly qualifiziert sind.</target>       </trans-unit>
        <trans-unit id="2918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Now suppose that instead of <ph id="ph1">`System.String`</ph>, the first generic argument type is <ph id="ph2">`YourType`</ph>, from <ph id="ph3">`YourAssembly`</ph>:</source>
          <target state="translated">Nehmen wir jetzt an, die anstelle von <ph id="ph1">`System.String`</ph>, ist der erste generische Argumenttyp <ph id="ph2">`YourType`</ph>, aus <ph id="ph3">`YourAssembly`</ph>:</target>       </trans-unit>
        <trans-unit id="2919" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Because this assembly is neither Mscorlib.dll nor the currently executing assembly, you cannot resolve <ph id="ph1">`YourType`</ph> without an assembly-qualified name.</source>
          <target state="translated">Da diese Assembly weder "mscorlib.dll" als auch der aktuell ausgeführten Assembly ist, können Sie nicht auflösen <ph id="ph1">`YourType`</ph> ohne ein Assembly qualifizierter Name.</target>       </trans-unit>
        <trans-unit id="2920" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Because your <ph id="ph1">`assemblyResolve`</ph> will be called recursively, it must be able to handle this case.</source>
          <target state="translated">Da Ihre <ph id="ph1">`assemblyResolve`</ph> werden rekursiv aufgerufen wird, muss er in diesem Fall können.</target>       </trans-unit>
        <trans-unit id="2921" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Instead of returning <ph id="ph1">`null`</ph> for assemblies other than <ph id="ph2">`MyAssembly`</ph>, it now performs an assembly load using the supplied <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object.</source>
          <target state="translated">Anstatt <ph id="ph1">`null`</ph> für andere Assemblys als <ph id="ph2">`MyAssembly`</ph>, führt es jetzt Laden einer Assembly, die mit dem angegebenen <ph id="ph3">&lt;xref:System.Reflection.AssemblyName&gt;</ph> Objekt.</target>       </trans-unit>
        <trans-unit id="2922" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Back to <bpt id="p1">[</bpt>Usage Notes<ept id="p1">](#usage_notes)</ept>.</source>
          <target state="translated">Zurück zur <bpt id="p1">[</bpt>Verwendungshinweise<ept id="p1">](#usage_notes)</ept>.</target>       </trans-unit>
        <trans-unit id="2923" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Resolving Type Names with Special Characters</source>
          <target state="translated">Auflösen von Typnamen mit Sonderzeichen</target>       </trans-unit>
        <trans-unit id="2924" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Certain characters have special meanings in assembly-qualified names.</source>
          <target state="translated">Bestimmte Zeichen eine besondere Bedeutung in assemblyqualifizierten Namen an.</target>       </trans-unit>
        <trans-unit id="2925" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If a simple type name contains these characters, the characters cause parsing errors when the simple name is part of an assembly-qualified name.</source>
          <target state="translated">Wenn ein einfache Typname diese Zeichen enthält, verursachen die Zeichen Analysefehler aus, wenn der einfache Namen einer Assembly qualifizierte Name gehört.</target>       </trans-unit>
        <trans-unit id="2926" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>To avoid the parsing errors, you must escape the special characters with a backslash before you can pass the assembly-qualified name to the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method.</source>
          <target state="translated">Um die Analysefehler zu vermeiden, müssen Sie die Sonderzeichen nicht mit einem umgekehrten Schrägstrich sein, bevor Sie die Assembly qualifizierte Name zu übergeben, können die <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>For example, if a type is named <ph id="ph1">`Strange]Type`</ph>, the escape character must be added ahead of the square bracket as follows: <ph id="ph2">`Strange\]Type`</ph>.</source>
          <target state="translated">Wenn ein Typ mit dem Namen wird z. B. <ph id="ph1">`Strange]Type`</ph>, das Escape-Zeichen muss wie folgt vor die eckige Klammer hinzugefügt werden: <ph id="ph2">`Strange\]Type`</ph>.</target>       </trans-unit>
        <trans-unit id="2928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Names with such special characters cannot be created in Visual Basic or C#, but can be created by using Microsoft intermediate language (MSIL) or by emitting dynamic assemblies.</source>
          <target state="translated">Namen mit solchen Sonderzeichen können nicht in Visual Basic oder c# erstellt werden, aber Sie können mithilfe von Microsoft intermediate Language (MSIL) oder durch Ausgeben von dynamischen Assemblys erstellt werden.</target>       </trans-unit>
        <trans-unit id="2929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The following table shows the special characters for type names.</source>
          <target state="translated">Die folgende Tabelle zeigt die Sonderzeichen für Typnamen.</target>       </trans-unit>
        <trans-unit id="2930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Character</source>
          <target state="translated">Zeichen</target>       </trans-unit>
        <trans-unit id="2931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Meaning</source>
          <target state="translated">Bedeutung</target>       </trans-unit>
        <trans-unit id="2932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`,`</ph> (comma)</source>
          <target state="translated"><ph id="ph1">`,`</ph> (Komma)</target>       </trans-unit>
        <trans-unit id="2933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Delimiter for assembly-qualified names.</source>
          <target state="translated">Trennzeichen für die Assembly qualifizierten Namen.</target>       </trans-unit>
        <trans-unit id="2934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`[]`</ph> (square brackets)</source>
          <target state="translated"><ph id="ph1">`[]`</ph> (eckige Klammern)</target>       </trans-unit>
        <trans-unit id="2935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>As a suffix pair, indicates an array type; as a delimiter pair, encloses generic argument lists and assembly-qualified names.</source>
          <target state="translated">Als Suffix paarweise angegeben gibt Sie einen Arraytyp an. als Trennzeichen paarweise angegeben umfasst generische Argumentlisten und qualifizierte Assemblynamen.</target>       </trans-unit>
        <trans-unit id="2936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`&amp;`</ph> (ampersand)</source>
          <target state="translated"><ph id="ph1">`&amp;`</ph> (kaufmännisches und-Zeichen)</target>       </trans-unit>
        <trans-unit id="2937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>As a suffix, indicates that a type is a reference type.</source>
          <target state="translated">Gibt an, dass ein Typ ein Verweistyp ist, als Suffix.</target>       </trans-unit>
        <trans-unit id="2938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`*`</ph> (asterisk)</source>
          <target state="translated"><ph id="ph1">`*`</ph> (Sternchen)</target>       </trans-unit>
        <trans-unit id="2939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>As a suffix, indicates that a type is a pointer type.</source>
          <target state="translated">Gibt an, dass ein Typ ein Zeigertyp ist, als Suffix.</target>       </trans-unit>
        <trans-unit id="2940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`+`</ph> (plus)</source>
          <target state="translated"><ph id="ph1">`+`</ph> (plus)</target>       </trans-unit>
        <trans-unit id="2941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Delimiter for nested types.</source>
          <target state="translated">Trennzeichen für geschachtelte Typen.</target>       </trans-unit>
        <trans-unit id="2942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`\`</ph> (backslash)</source>
          <target state="translated"><ph id="ph1">`\`</ph> (umgekehrter Schrägstrich)</target>       </trans-unit>
        <trans-unit id="2943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Escape character.</source>
          <target state="translated">Escape-Zeichen.</target>       </trans-unit>
        <trans-unit id="2944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Properties such as <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> return correctly escaped strings.</source>
          <target state="translated">Eigenschaften, z. B. <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> Return Zeichenfolgen korrekt in Escapezeichen eingeschlossen.</target>       </trans-unit>
        <trans-unit id="2945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>You must pass correctly escaped strings to the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method.</source>
          <target state="translated">Müssen Sie ordnungsgemäß mit Escapezeichen versehene Zeichenfolgen zum Übergeben der <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>In turn, the <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> method passes correctly escaped names to <ph id="ph2">`typeResolver`</ph> and to the default type resolution methods.</source>
          <target state="translated">Wiederum die <ph id="ph1">&lt;xref:System.Type.GetType%2A&gt;</ph> Methode übergibt ordnungsgemäß mit Escapezeichen versehene Objektnamen <ph id="ph2">`typeResolver`</ph> und Auflösung die Standardmethoden-Typ.</target>       </trans-unit>
        <trans-unit id="2947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If you need to compare a name to an unescaped name in <ph id="ph1">`typeResolver`</ph>, you must remove the escape characters.</source>
          <target state="translated">Wenn Sie einen Namen, den Namen einer ohne Escapezeichen in Vergleichen <ph id="ph1">`typeResolver`</ph>, müssen Sie die Escape-Zeichen entfernen.</target>       </trans-unit>
        <trans-unit id="2948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Back to <bpt id="p1">[</bpt>Usage Notes<ept id="p1">](#usage_notes)</ept>.</source>
          <target state="translated">Zurück zur <bpt id="p1">[</bpt>Verwendungshinweise<ept id="p1">](#usage_notes)</ept>.</target>       </trans-unit>
        <trans-unit id="2949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Mixed Name Resolution</source>
          <target state="translated">Gemischte namensauflösung</target>       </trans-unit>
        <trans-unit id="2950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The following table summarizes the interactions between <ph id="ph1">`assemblyResolver`</ph>, <ph id="ph2">`typeResolver`</ph>, and default name resolution, for all combinations of type name and assembly name in <ph id="ph3">`typeName`</ph>:</source>
          <target state="translated">Die folgende Tabelle enthält die Interaktionen zwischen <ph id="ph1">`assemblyResolver`</ph>, <ph id="ph2">`typeResolver`</ph>, und die standardmäßige namensauflösung für alle Kombinationen von Typ und Assemblynamen im <ph id="ph3">`typeName`</ph>:</target>       </trans-unit>
        <trans-unit id="2951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Contents of type name</source>
          <target state="translated">Inhalt des Typnamens</target>       </trans-unit>
        <trans-unit id="2952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Assembly resolver method</source>
          <target state="translated">Assembly-Resolver-Methode</target>       </trans-unit>
        <trans-unit id="2953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Type resolver method</source>
          <target state="translated">Typ-Resolver-Methode</target>       </trans-unit>
        <trans-unit id="2954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Result</source>
          <target state="translated">Ergebnis</target>       </trans-unit>
        <trans-unit id="2955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type, assembly</source>
          <target state="translated">Typ-assembly</target>       </trans-unit>
        <trans-unit id="2956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null</source>
          <target state="translated">NULL</target>       </trans-unit>
        <trans-unit id="2957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null</source>
          <target state="translated">NULL</target>       </trans-unit>
        <trans-unit id="2958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Equivalent to calling the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">Entspricht dem Aufrufen der <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> -methodenüberladung.</target>       </trans-unit>
        <trans-unit id="2959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type, assembly</source>
          <target state="translated">Typ-assembly</target>       </trans-unit>
        <trans-unit id="2960" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>provided</source>
          <target state="translated">bereitgestellt</target>       </trans-unit>
        <trans-unit id="2961" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null</source>
          <target state="translated">NULL</target>       </trans-unit>
        <trans-unit id="2962" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`assemblyResolver`</ph> returns the assembly or returns <ph id="ph2">`null`</ph> if it cannot resolve the assembly.</source>
          <target state="translated"><ph id="ph1">`assemblyResolver`</ph> Gibt die Assembly zurück oder <ph id="ph2">`null`</ph> Falls die Assembly aufgelöst werden kann.</target>       </trans-unit>
        <trans-unit id="2963" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the assembly is resolved, the <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> method overload is used to load the type from the assembly; otherwise, there is no attempt to resolve the type.</source>
          <target state="translated">Wenn die Assembly aufgelöst wird, wird die <ph id="ph1">&lt;xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> methodenüberladung wird verwendet, um den Typ aus der Assembly zu laden; andernfalls ist es versucht nicht, die den Typ aufzulösen.</target>       </trans-unit>
        <trans-unit id="2964" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type, assembly</source>
          <target state="translated">Typ-assembly</target>       </trans-unit>
        <trans-unit id="2965" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null</source>
          <target state="translated">NULL</target>       </trans-unit>
        <trans-unit id="2966" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>provided</source>
          <target state="translated">bereitgestellt</target>       </trans-unit>
        <trans-unit id="2967" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Equivalent to converting the assembly name to an <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and calling the <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType&gt;</ph> method overload to get the assembly.</source>
          <target state="translated">Konvertiert den Namen der Ausgabeassembly ein <ph id="ph1">&lt;xref:System.Reflection.AssemblyName&gt;</ph> Objekt und der Aufruf der <ph id="ph2">&lt;xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType&gt;</ph> -methodenüberladung, um die Assembly zu erhalten.</target>       </trans-unit>
        <trans-unit id="2968" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the assembly is resolved, it is passed to <ph id="ph1">`typeResolver`</ph>; otherwise, <ph id="ph2">`typeResolver`</ph> is not called and there is no further attempt to resolve the type.</source>
          <target state="translated">Wenn die Assembly aufgelöst wird, erfolgt eine Übergabe an <ph id="ph1">`typeResolver`</ph>ist, andernfalls <ph id="ph2">`typeResolver`</ph> wird nicht aufgerufen, und es gibt keinen weiteren Versuch, den Typ aufzulösen.</target>       </trans-unit>
        <trans-unit id="2969" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type, assembly</source>
          <target state="translated">Typ-assembly</target>       </trans-unit>
        <trans-unit id="2970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>provided</source>
          <target state="translated">bereitgestellt</target>       </trans-unit>
        <trans-unit id="2971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>provided</source>
          <target state="translated">bereitgestellt</target>       </trans-unit>
        <trans-unit id="2972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`assemblyResolver`</ph> returns the assembly or returns <ph id="ph2">`null`</ph> if it cannot resolve the assembly.</source>
          <target state="translated"><ph id="ph1">`assemblyResolver`</ph> Gibt die Assembly zurück oder <ph id="ph2">`null`</ph> Falls die Assembly aufgelöst werden kann.</target>       </trans-unit>
        <trans-unit id="2973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If the assembly is resolved, it is passed to <ph id="ph1">`typeResolver`</ph>; otherwise, <ph id="ph2">`typeResolver`</ph> is not called and there is no further attempt to resolve the type.</source>
          <target state="translated">Wenn die Assembly aufgelöst wird, erfolgt eine Übergabe an <ph id="ph1">`typeResolver`</ph>ist, andernfalls <ph id="ph2">`typeResolver`</ph> wird nicht aufgerufen, und es gibt keinen weiteren Versuch, den Typ aufzulösen.</target>       </trans-unit>
        <trans-unit id="2974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type</source>
          <target state="translated">Typ</target>       </trans-unit>
        <trans-unit id="2975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null, provided</source>
          <target state="translated">NULL, bereitgestellt wird,</target>       </trans-unit>
        <trans-unit id="2976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null</source>
          <target state="translated">NULL</target>       </trans-unit>
        <trans-unit id="2977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Equivalent to calling the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">Entspricht dem Aufrufen der <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType&gt;</ph> -methodenüberladung.</target>       </trans-unit>
        <trans-unit id="2978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Because the assembly name is not provided, only Mscorlib.dll and the currently executing assembly are searched.</source>
          <target state="translated">Da der Assemblyname nicht angegeben wird, werden nur "mscorlib.dll" und der aktuell ausgeführten Assembly durchsucht.</target>       </trans-unit>
        <trans-unit id="2979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> is provided, it is ignored.</source>
          <target state="translated">Wenn <ph id="ph1">`assemblyResolver`</ph> angegeben wird, diese ignoriert wird.</target>       </trans-unit>
        <trans-unit id="2980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>type</source>
          <target state="translated">Typ</target>       </trans-unit>
        <trans-unit id="2981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null, provided</source>
          <target state="translated">NULL, bereitgestellt wird,</target>       </trans-unit>
        <trans-unit id="2982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>provided</source>
          <target state="translated">bereitgestellt</target>       </trans-unit>
        <trans-unit id="2983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`typeResolver`</ph> is called, and <ph id="ph2">`null`</ph> is passed for the assembly.</source>
          <target state="translated"><ph id="ph1">`typeResolver`</ph> wird aufgerufen, und <ph id="ph2">`null`</ph> für die Assembly übergeben wird.</target>       </trans-unit>
        <trans-unit id="2984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">`typeResolver`</ph> can provide a type from any assembly, including assemblies it loads for the purpose.</source>
          <target state="translated"><ph id="ph1">`typeResolver`</ph> Geben Sie einen Typ können aus beliebigen Assemblys, einschließlich der Assemblys, die sie für diesen Zweck lädt.</target>       </trans-unit>
        <trans-unit id="2985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>If <ph id="ph1">`assemblyResolver`</ph> is provided, it is ignored.</source>
          <target state="translated">Wenn <ph id="ph1">`assemblyResolver`</ph> angegeben wird, diese ignoriert wird.</target>       </trans-unit>
        <trans-unit id="2986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>assembly</source>
          <target state="translated">Assembly</target>       </trans-unit>
        <trans-unit id="2987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null, provided</source>
          <target state="translated">NULL, bereitgestellt wird,</target>       </trans-unit>
        <trans-unit id="2988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>null, provided</source>
          <target state="translated">NULL, bereitgestellt wird,</target>       </trans-unit>
        <trans-unit id="2989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>A <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown, because the assembly name is parsed as if it were an assembly-qualified type name.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.IO.FileLoadException&gt;</ph> ausgelöst wird, da der Assemblyname analysiert wird, als handele es sich um eine Assembly qualifizierten Typnamen an.</target>       </trans-unit>
        <trans-unit id="2990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>This results in an invalid assembly name.</source>
          <target state="translated">Dies führt zu einem ungültigen Assemblynamen.</target>       </trans-unit>
        <trans-unit id="2991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>Back to: <bpt id="p1">[</bpt>Usage Notes<ept id="p1">](#usage_notes)</ept>, <bpt id="p2">[</bpt>Resolving Assemblies<ept id="p2">](#resolving_assemblies)</ept>, <bpt id="p3">[</bpt>Resolving Types<ept id="p3">](#resolving_types)</ept>.</source>
          <target state="translated">Zurück zur: <bpt id="p1">[</bpt>Verwendungshinweise<ept id="p1">](#usage_notes)</ept>, <bpt id="p2">[</bpt>Auflösen von Assemblys<ept id="p2">](#resolving_assemblies)</ept>, <bpt id="p3">[</bpt>Auflösen von Typen<ept id="p3">](#resolving_types)</ept>.</target>       </trans-unit>
        <trans-unit id="2992" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2993" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="2994" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und der Typ wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="2995" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2996" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid characters, such as an embedded tab.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen.</target>       </trans-unit>
        <trans-unit id="2997" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2998" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> ist eine leere Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="2999" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3000" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> represents an array type with an invalid size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> stellt einen Arraytyp mit einer ungültigen Größe dar.</target>       </trans-unit>
        <trans-unit id="3001" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3002" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt ein Array von <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph> dar.</target>       </trans-unit>
        <trans-unit id="3003" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>An error occurs when <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</source>
          <target state="translated">Ein Fehler tritt auf, wenn <ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> in einen Typnamen und einen Assemblynamen analysiert wird (z. B. wenn der einfache Typname ein Sonderzeichen ohne Escapezeichen enthält).</target>       </trans-unit>
        <trans-unit id="3004" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3005" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid syntax (for example, "MyType[,*,]").</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> enthält ungültige Syntax (z. B. "MyType[,*,]").</target>       </trans-unit>
        <trans-unit id="3006" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3007" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt einen generischen Typ dar, der einen Zeigertyp, einen <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph>-Typ oder <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> als eines seiner Typargumente aufweist.</target>       </trans-unit>
        <trans-unit id="3008" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3009" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.</target>       </trans-unit>
        <trans-unit id="3010" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3011" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</target>       </trans-unit>
        <trans-unit id="3012" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the assembly or one of its dependencies was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwOnError" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="3013" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</target>       </trans-unit>
        <trans-unit id="3014" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3015" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> contains an invalid assembly name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> enthält einen ungültigen Assemblynamen.</target>       </trans-unit>
        <trans-unit id="3016" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3017" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is a valid assembly name without a type name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> ist ein gültiger Assemblyname ohne Typnamen.</target>       </trans-unit>
        <trans-unit id="3018" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.</target>       </trans-unit>
        <trans-unit id="3019" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3020" translate="yes" xml:space="preserve" uid="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)">
          <source>The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated">Die Assembly wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</target>       </trans-unit>
        <trans-unit id="3021" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>An array of objects whose types to determine.</source>
          <target state="translated">Ein Array von Objekten, deren Typen bestimmt werden sollen.</target>       </trans-unit>
        <trans-unit id="3022" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>Gets the types of the objects in the specified array.</source>
          <target state="translated">Ruft die Typen der Objekte im angegebenen Array ab.</target>       </trans-unit>
        <trans-unit id="3023" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects representing the types of the corresponding elements in <ph id="ph2">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekten, die die Typen der entsprechenden Elemente in <ph id="ph2">&lt;paramref name="args" /&gt;</ph> darstellen.</target>       </trans-unit>
        <trans-unit id="3024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>The following code example demonstrates how to use the <ph id="ph1">&lt;xref:System.Type.GetTypeArray%2A&gt;</ph> method to list the types of the elements of an array.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie die <ph id="ph1">&lt;xref:System.Type.GetTypeArray%2A&gt;</ph> Methode, um die Typen der Elemente eines Arrays aufführen.</target>       </trans-unit>
        <trans-unit id="3025" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source><ph id="ph1">&lt;paramref name="args" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="args" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3026" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3027" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>One or more of the elements in <ph id="ph1">&lt;paramref name="args" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Mindestens eines der Elemente in <ph id="ph1">&lt;paramref name="args" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3028" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeArray(System.Object[])">
          <source>The class initializers are invoked and at least one throws an exception.</source>
          <target state="translated">Die Klasseninitialisierer werden aufgerufen, und mindestens einer löst eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="3029" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>The type whose underlying type code to get.</source>
          <target state="translated">Der Typ, dessen zugrunde liegender Typcode abgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="3030" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>Gets the underlying type code of the specified <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft den zugrunde liegenden Typcode des angegebenen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="3031" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>The code of the underlying type, or <ph id="ph1">&lt;see cref="F:System.TypeCode.Empty" /&gt;</ph> if <ph id="ph2">&lt;paramref name="type" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der Code des zugrunde liegenden Typs oder <ph id="ph1">&lt;see cref="F:System.TypeCode.Empty" /&gt;</ph>, wenn <ph id="ph2">&lt;paramref name="type" /&gt;</ph> <ph id="ph3">&lt;see langword="null" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="3032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>When you inherit from <ph id="ph1">&lt;xref:System.Type&gt;</ph>, you can change the behavior of this method by overriding the <ph id="ph2">&lt;xref:System.Type.GetTypeCodeImpl%2A&gt;</ph> method.</source>
          <target state="translated">Beim Erben von <ph id="ph1">&lt;xref:System.Type&gt;</ph>, Sie können das Verhalten dieser Methode ändern, durch Überschreiben der <ph id="ph2">&lt;xref:System.Type.GetTypeCodeImpl%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>The following code example demonstrates how the <ph id="ph1">&lt;xref:System.TypeCode&gt;</ph> enumeration can be used.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie die <ph id="ph1">&lt;xref:System.TypeCode&gt;</ph> Enumeration verwendet werden kann.</target>       </trans-unit>
        <trans-unit id="3034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeCode(System.Type)">
          <source>In a decision block inside the <ph id="ph1">`WriteObjectInfo`</ph> method, the <ph id="ph2">&lt;xref:System.TypeCode&gt;</ph> of an <ph id="ph3">&lt;xref:System.Object&gt;</ph> parameter is examined, and an appropriate message is written to the console.</source>
          <target state="translated">In einem Entscheidungsblock innerhalb der <ph id="ph1">`WriteObjectInfo`</ph> -Methode, die <ph id="ph2">&lt;xref:System.TypeCode&gt;</ph> des ein <ph id="ph3">&lt;xref:System.Object&gt;</ph> Parameter wird untersucht und eine entsprechende Meldung in die Konsole geschrieben wird.</target>       </trans-unit>
        <trans-unit id="3035" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeCodeImpl">
          <source>Returns the underlying type code of this <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> instance.</source>
          <target state="translated">Gibt den zugrunde liegenden Typcode dieser <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Instanz zurück.</target>       </trans-unit>
        <trans-unit id="3036" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeCodeImpl">
          <source>The type code of the underlying type.</source>
          <target state="translated">Der Typcode des zugrunde liegenden Typs.</target>       </trans-unit>
        <trans-unit id="3037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeCodeImpl">
          <source>This method provides the implementation for the <ph id="ph1">`static`</ph> (in C#) or <ph id="ph2">`Shared`</ph> (in Visual Basic) <ph id="ph3">&lt;xref:System.Type.GetTypeCode%28System.Type%29&gt;</ph> method.</source>
          <target state="translated">Diese Methode stellt die Implementierung für die <ph id="ph1">`static`</ph> (in c#) oder <ph id="ph2">`Shared`</ph> (in Visual Basic) <ph id="ph3">&lt;xref:System.Type.GetTypeCode%28System.Type%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeCodeImpl">
          <source>When you inherit from <ph id="ph1">&lt;xref:System.Type&gt;</ph>, you can override this method to provide your own implementation of <ph id="ph2">&lt;xref:System.Type.GetTypeCode%2A&gt;</ph>.</source>
          <target state="translated">Beim Erben von <ph id="ph1">&lt;xref:System.Type&gt;</ph>, Sie können diese Methode, um eine eigene Implementierung bereitstellen überschreiben <ph id="ph2">&lt;xref:System.Type.GetTypeCode%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3039" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the type associated with the specified class identifier (CLSID).</source>
          <target state="translated">Ruft den Typ ab, dem die angegebene Klassen-ID (CLSID) zugeordnet ist.</target>       </trans-unit>
        <trans-unit id="3040" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>The CLSID of the type to get.</source>
          <target state="translated">Die CLSID des abzurufenden Typs.</target>       </trans-unit>
        <trans-unit id="3041" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Gets the type associated with the specified class identifier (CLSID).</source>
          <target state="translated">Ruft den Typ ab, dem die angegebene Klassen-ID (CLSID) zugeordnet ist.</target>       </trans-unit>
        <trans-unit id="3042" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> regardless of whether the CLSID is valid.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> unabhängig von der Gültigkeit der CLSID.</target>       </trans-unit>
        <trans-unit id="3043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> Methode unterstützt spät gebundener Zugriff auf nicht verwalteten COM-Objekte aus .NET Framework-apps, wenn Sie wissen, dass der Klassenbezeichner (CLSID) der COM-Objekt.</target>       </trans-unit>
        <trans-unit id="3044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</source>
          <target state="translated">Die Klassen-ID für COM-Klassen wird in den Schlüssel HKEY_CLASSES_ROOT\CLSID der Registrierung definiert.</target>       </trans-unit>
        <trans-unit id="3045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.</source>
          <target state="translated">Sie können den Wert der Abrufen der <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> Eigenschaft, um zu bestimmen, ob der von dieser Methode zurückgegebene Typ ein COM-Objekt ist.</target>       </trans-unit>
        <trans-unit id="3046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</source>
          <target state="translated">Sie erreichen die <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> Methode für spät gebundener Zugriff für COM-Objekte, deren programmatischen Bezeichner (ProgID), die Sie kennen.</target>       </trans-unit>
        <trans-unit id="3047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Instantiating an unmanaged COM object from its CLSID is a two-step process:</source>
          <target state="translated">Instanziieren ein nicht verwaltetes COM-Objekt aus seiner CLSID ist ein zweistufiger Prozess:</target>       </trans-unit>
        <trans-unit id="3048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the<ph id="ph2">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.</source>
          <target state="translated">Abrufen einer <ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekt, das darstellt der<ph id="ph2">`__ComObject`</ph> , entspricht die CLSID durch Aufrufen der <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Call the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> method to instantiate the COM object.</source>
          <target state="translated">Rufen Sie die <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> Methode, um das COM-Objekt zu instanziieren.</target>       </trans-unit>
        <trans-unit id="3050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>See the example for an illustration.</source>
          <target state="translated">Siehe das Beispiel veranschaulicht.</target>       </trans-unit>
        <trans-unit id="3051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%28System.Guid%29&gt;</ph> overload ignores any exception that may occur when instantiating a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object based on the <ph id="ph3">`clsid`</ph> argument.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%28System.Guid%29&gt;</ph> Überladung ignoriert alle Ausnahmen, die auftreten können, bei der Instanziierung einer <ph id="ph2">&lt;xref:System.Type&gt;</ph> -Objekt auf Grundlage der <ph id="ph3">`clsid`</ph> Argument.</target>       </trans-unit>
        <trans-unit id="3052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Note that no exception is thrown if <ph id="ph1">`clsid`</ph> is not found in the registry.</source>
          <target state="translated">Beachten Sie, die keine Ausnahme ausgelöst wird, wenn <ph id="ph1">`clsid`</ph> befindet sich nicht in der Registrierung.</target>       </trans-unit>
        <trans-unit id="3053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>The following example uses the CLSID of the Microsoft Word <bpt id="p1">[</bpt>Application object<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> to retrieve a COM type that represents the Microsoft Word application.</source>
          <target state="translated">Im folgenden Beispiel wird die CLSID der Microsoft Word <bpt id="p1">[</bpt>Anwendungsobjekt<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> ein COM-Typs abgerufen, die die Microsoft Word-Anwendung darstellt.</target>       </trans-unit>
        <trans-unit id="3054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>It then instantiates the type by calling the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> method, and closes it by calling the <bpt id="p1">[</bpt>Application.Quit<ept id="p1">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> method.</source>
          <target state="translated">Dann instanziiert den Typ durch Aufrufen der <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> -Methode und schließt ihn durch Aufrufen der <bpt id="p1">[</bpt>Application.Quit<ept id="p1">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> Methode.</target>       </trans-unit>
        <trans-unit id="3055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>This method is intended for use when working with COM objects, not with .NET Framework objects.</source>
          <target state="translated">Diese Methode dient zur Verwendung bei der Arbeit mit COM-Objekte nicht mit .NET Framework-Objekten.</target>       </trans-unit>
        <trans-unit id="3056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>All managed objects, including those that are visible to COM (that is, their <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> attribute is <ph id="ph2">&lt;see langword="true" /&gt;</ph>) have a GUID that is returned by the <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> property.</source>
          <target state="translated">Alle verwalteten Objekte, einschließlich derer, die für COM sichtbar sind (d. h. deren <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> -Attribut ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>) haben eine GUID, die von zurückgegeben wird die <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="3057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Although the method returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that corresponds to the GUID for .NET Framework objects, you can't use that <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object to create a type instance by calling the  <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method, as the following example shows.</source>
          <target state="translated">Obwohl die Methode gibt ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> -Objekten Objekt, das die GUID für .NET Framework entspricht, kann nicht verwendet <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> Objekt so erstellen eine Instanz eines Datentyps durch Aufrufen der <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> Methode, wie im folgenden Beispiel gezeigt.</target>       </trans-unit>
        <trans-unit id="3058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid)">
          <source>Instead, the <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object that is passed to the <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method must represent an unmanaged COM object.</source>
          <target state="translated">Stattdessen die <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> sollte nur verwendet werden, um die GUID der nicht verwaltete COM-Objekte und die resultierende abrufen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> -Objekt, das an die <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> Methode muss ein nicht verwaltetes COM-Objekt darstellen.</target>       </trans-unit>
        <trans-unit id="3059" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>The CLSID of the type to get.</source>
          <target state="translated">Die CLSID des abzurufenden Typs.</target>       </trans-unit>
        <trans-unit id="3060" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw any exception that occurs.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, um mögliche Ausnahmen auszulösen.</target>       </trans-unit>
        <trans-unit id="3061" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3062" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to ignore any exception that occurs.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>, um Ausnahmen zu ignorieren.</target>       </trans-unit>
        <trans-unit id="3063" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.</source>
          <target state="translated">Ruft den Typ ab, dem die angegebene Klassen-ID (CLSID) zugeordnet ist. Dabei wird angegeben, ob bei Auftreten eines Fehlers beim Laden des Typs eine Ausnahme ausgelöst werden soll.</target>       </trans-unit>
        <trans-unit id="3064" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> regardless of whether the CLSID is valid.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> unabhängig von der Gültigkeit der CLSID.</target>       </trans-unit>
        <trans-unit id="3065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> Methode unterstützt spät gebundener Zugriff auf nicht verwalteten COM-Objekte aus .NET Framework-apps, wenn Sie wissen, dass der Klassenbezeichner (CLSID) der COM-Objekt.</target>       </trans-unit>
        <trans-unit id="3066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</source>
          <target state="translated">Die Klassen-ID für COM-Klassen wird in den Schlüssel HKEY_CLASSES_ROOT\CLSID der Registrierung definiert.</target>       </trans-unit>
        <trans-unit id="3067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.</source>
          <target state="translated">Sie können den Wert der Abrufen der <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> Eigenschaft, um zu bestimmen, ob der von dieser Methode zurückgegebene Typ ein COM-Objekt ist.</target>       </trans-unit>
        <trans-unit id="3068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</source>
          <target state="translated">Sie erreichen die <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> Methode für spät gebundener Zugriff für COM-Objekte, deren programmatischen Bezeichner (ProgID), die Sie kennen.</target>       </trans-unit>
        <trans-unit id="3069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Instantiating an unmanaged COM object from its CLSID is a two-step process:</source>
          <target state="translated">Instanziieren ein nicht verwaltetes COM-Objekt aus seiner CLSID ist ein zweistufiger Prozess:</target>       </trans-unit>
        <trans-unit id="3070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the <ph id="ph2">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.</source>
          <target state="translated">Abrufen einer <ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekt, das darstellt der <ph id="ph2">`__ComObject`</ph> , entspricht die CLSID durch Aufrufen der <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Call the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> method to instantiate the COM object.</source>
          <target state="translated">Rufen Sie die <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> Methode, um das COM-Objekt zu instanziieren.</target>       </trans-unit>
        <trans-unit id="3072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>See the example for an illustration.</source>
          <target state="translated">Siehe das Beispiel veranschaulicht.</target>       </trans-unit>
        <trans-unit id="3073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Exceptions such as <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> will be thrown when specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnError`</ph>, but it will not fail for unregistered CLSIDs.</source>
          <target state="translated">Ausnahmen wie <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> wird ausgelöst, wenn die Angabe <ph id="ph2">`true`</ph> für <ph id="ph3">`throwOnError`</ph>, aber nicht registrierte CLSIDs führen nicht zu einem Fehler.</target>       </trans-unit>
        <trans-unit id="3074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>The following example uses the CLSID of the Microsoft Word <bpt id="p1">[</bpt>Application object<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> to retrieve a COM type that represents the Microsoft Word application.</source>
          <target state="translated">Im folgenden Beispiel wird die CLSID der Microsoft Word <bpt id="p1">[</bpt>Anwendungsobjekt<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> ein COM-Typs abgerufen, die die Microsoft Word-Anwendung darstellt.</target>       </trans-unit>
        <trans-unit id="3075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>It then instantiates the type by calling the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> method, and closes it by calling the <bpt id="p1">[</bpt>Application.Quit<ept id="p1">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> method.</source>
          <target state="translated">Dann instanziiert den Typ durch Aufrufen der <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> -Methode und schließt ihn durch Aufrufen der <bpt id="p1">[</bpt>Application.Quit<ept id="p1">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> Methode.</target>       </trans-unit>
        <trans-unit id="3076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>An exception is thrown if an error occurs while loading the type.</source>
          <target state="translated">Eine Ausnahme wird ausgelöst, wenn beim Laden des Typs ein Fehler auftritt.</target>       </trans-unit>
        <trans-unit id="3077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>This method is intended for use when working with COM objects, not with .NET Framework objects.</source>
          <target state="translated">Diese Methode dient zur Verwendung bei der Arbeit mit COM-Objekte nicht mit .NET Framework-Objekten.</target>       </trans-unit>
        <trans-unit id="3078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>All managed objects, including those that are visible to COM (that is, their <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> attribute is <ph id="ph2">&lt;see langword="true" /&gt;</ph>) have a GUID that is returned by the <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> property.</source>
          <target state="translated">Alle verwalteten Objekte, einschließlich derer, die für COM sichtbar sind (d. h. deren <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> -Attribut ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>) haben eine GUID, die von zurückgegeben wird die <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="3079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Although the method returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that corresponds to the GUID for .NET Framework objects, you can't use that <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object to create a type instance by calling the  <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method, as the following example shows.</source>
          <target state="translated">Obwohl die Methode gibt ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> -Objekten Objekt, das die GUID für .NET Framework entspricht, kann nicht verwendet <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> Objekt so erstellen eine Instanz eines Datentyps durch Aufrufen der <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> Methode, wie im folgenden Beispiel gezeigt.</target>       </trans-unit>
        <trans-unit id="3080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)">
          <source>Instead, the <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object that is passed to the <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method must represent an unmanaged COM object.</source>
          <target state="translated">Stattdessen die <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> sollte nur verwendet werden, um die GUID der nicht verwaltete COM-Objekte und die resultierende abrufen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> -Objekt, das an die <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> Methode muss ein nicht verwaltetes COM-Objekt darstellen.</target>       </trans-unit>
        <trans-unit id="3081" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>The CLSID of the type to get.</source>
          <target state="translated">Die CLSID des abzurufenden Typs.</target>       </trans-unit>
        <trans-unit id="3082" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>The server from which to load the type.</source>
          <target state="translated">Der Server, von dem der Typ geladen werden soll.</target>       </trans-unit>
        <trans-unit id="3083" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>If the server name is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, this method automatically reverts to the local machine.</source>
          <target state="translated">Wenn der Servername <ph id="ph1">&lt;see langword="null" /&gt;</ph> ist, wird diese Methode automatisch auf den lokalen Computer zurückgesetzt.</target>       </trans-unit>
        <trans-unit id="3084" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Gets the type associated with the specified class identifier (CLSID) from the specified server.</source>
          <target state="translated">Ruft den Typ, dem die angegebene Klassen-ID (CLSID) zugeordnet ist, vom angegebenen Server ab.</target>       </trans-unit>
        <trans-unit id="3085" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> regardless of whether the CLSID is valid.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> unabhängig von der Gültigkeit der CLSID.</target>       </trans-unit>
        <trans-unit id="3086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> Methode unterstützt spät gebundener Zugriff auf nicht verwalteten COM-Objekte aus .NET Framework-apps, wenn Sie wissen, dass der Klassenbezeichner (CLSID) der COM-Objekt.</target>       </trans-unit>
        <trans-unit id="3087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</source>
          <target state="translated">Die Klassen-ID für COM-Klassen wird in den Schlüssel HKEY_CLASSES_ROOT\CLSID der Registrierung definiert.</target>       </trans-unit>
        <trans-unit id="3088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.</source>
          <target state="translated">Sie können den Wert der Abrufen der <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> Eigenschaft, um zu bestimmen, ob der von dieser Methode zurückgegebene Typ ein COM-Objekt ist.</target>       </trans-unit>
        <trans-unit id="3089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</source>
          <target state="translated">Sie erreichen die <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> Methode für spät gebundener Zugriff für COM-Objekte, deren programmatischen Bezeichner (ProgID), die Sie kennen.</target>       </trans-unit>
        <trans-unit id="3090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Instantiating an unmanaged COM object from its CLSID is a two-step process:</source>
          <target state="translated">Instanziieren ein nicht verwaltetes COM-Objekt aus seiner CLSID ist ein zweistufiger Prozess:</target>       </trans-unit>
        <trans-unit id="3091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the <ph id="ph2">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.</source>
          <target state="translated">Abrufen einer <ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekt, das darstellt der <ph id="ph2">`__ComObject`</ph> , entspricht die CLSID durch Aufrufen der <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Call the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> method to instantiate the COM object.</source>
          <target state="translated">Rufen Sie die <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> Methode, um das COM-Objekt zu instanziieren.</target>       </trans-unit>
        <trans-unit id="3093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>The following example uses the CLSID of the Microsoft Word <bpt id="p1">[</bpt>Application object<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com. It then instantiates the type by calling the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> method, and closes it by calling the <bpt id="p2">[</bpt>Application.Quit<ept id="p2">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> method.</source>
          <target state="translated">Im folgenden Beispiel wird die CLSID der Microsoft Word <bpt id="p1">[</bpt>Anwendungsobjekt<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> ein COM-Typs abgerufen, die die Microsoft Word-Anwendung von einem pullserver namens computer17.central.contoso.com darstellt. Dann instanziiert den Typ durch Aufrufen der <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> -Methode und schließt ihn durch Aufrufen der <bpt id="p2">[</bpt>Application.Quit<ept id="p2">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> Methode.</target>       </trans-unit>
        <trans-unit id="3094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>This method is intended for use when working with COM objects, not with .NET Framework objects.</source>
          <target state="translated">Diese Methode dient zur Verwendung bei der Arbeit mit COM-Objekte nicht mit .NET Framework-Objekten.</target>       </trans-unit>
        <trans-unit id="3095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>All managed objects, including those that are visible to COM (that is, their <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> attribute is <ph id="ph2">&lt;see langword="true" /&gt;</ph>) have a GUID that is returned by the <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> property.</source>
          <target state="translated">Alle verwalteten Objekte, einschließlich derer, die für COM sichtbar sind (d. h. deren <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> -Attribut ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>) haben eine GUID, die von zurückgegeben wird die <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="3096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Although the method returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that corresponds to the GUID for .NET Framework objects, you can't use that <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object to create a type instance by calling the  <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method, as the following example shows.</source>
          <target state="translated">Obwohl die Methode gibt ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> -Objekten Objekt, das die GUID für .NET Framework entspricht, kann nicht verwendet <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> Objekt so erstellen eine Instanz eines Datentyps durch Aufrufen der <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> Methode, wie im folgenden Beispiel gezeigt.</target>       </trans-unit>
        <trans-unit id="3097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)">
          <source>Instead, the <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object that is passed to the <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method must represent an unmanaged COM object.</source>
          <target state="translated">Stattdessen die <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> sollte nur verwendet werden, um die GUID der nicht verwaltete COM-Objekte und die resultierende abrufen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> -Objekt, das an die <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> Methode muss ein nicht verwaltetes COM-Objekt darstellen.</target>       </trans-unit>
        <trans-unit id="3098" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>The CLSID of the type to get.</source>
          <target state="translated">Die CLSID des abzurufenden Typs.</target>       </trans-unit>
        <trans-unit id="3099" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>The server from which to load the type.</source>
          <target state="translated">Der Server, von dem der Typ geladen werden soll.</target>       </trans-unit>
        <trans-unit id="3100" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>If the server name is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, this method automatically reverts to the local machine.</source>
          <target state="translated">Wenn der Servername <ph id="ph1">&lt;see langword="null" /&gt;</ph> ist, wird diese Methode automatisch auf den lokalen Computer zurückgesetzt.</target>       </trans-unit>
        <trans-unit id="3101" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw any exception that occurs.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, um mögliche Ausnahmen auszulösen.</target>       </trans-unit>
        <trans-unit id="3102" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3103" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to ignore any exception that occurs.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>, um Ausnahmen zu ignorieren.</target>       </trans-unit>
        <trans-unit id="3104" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</source>
          <target state="translated">Ruft den Typ, dem die angegebene Klassen-ID (CLSID) zugeordnet ist, vom angegebenen Server ab. Dabei wird angegeben, ob bei Auftreten eines Fehlers beim Laden des Typs eine Ausnahme ausgelöst werden soll.</target>       </trans-unit>
        <trans-unit id="3105" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> regardless of whether the CLSID is valid.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="System.__ComObject" /&gt;</ph> unabhängig von der Gültigkeit der CLSID.</target>       </trans-unit>
        <trans-unit id="3106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>The <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> Methode unterstützt spät gebundener Zugriff auf nicht verwalteten COM-Objekte aus .NET Framework-apps, wenn Sie wissen, dass der Klassenbezeichner (CLSID) der COM-Objekt.</target>       </trans-unit>
        <trans-unit id="3107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</source>
          <target state="translated">Die Klassen-ID für COM-Klassen wird in den Schlüssel HKEY_CLASSES_ROOT\CLSID der Registrierung definiert.</target>       </trans-unit>
        <trans-unit id="3108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>You can retrieve the value of the <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.</source>
          <target state="translated">Sie können den Wert der Abrufen der <ph id="ph1">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> Eigenschaft, um zu bestimmen, ob der von dieser Methode zurückgegebene Typ ein COM-Objekt ist.</target>       </trans-unit>
        <trans-unit id="3109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</source>
          <target state="translated">Sie erreichen die <ph id="ph1">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> Methode für spät gebundener Zugriff für COM-Objekte, deren programmatischen Bezeichner (ProgID), die Sie kennen.</target>       </trans-unit>
        <trans-unit id="3110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Instantiating an unmanaged COM object from its CLSID is a two-step process:</source>
          <target state="translated">Instanziieren ein nicht verwaltetes COM-Objekt aus seiner CLSID ist ein zweistufiger Prozess:</target>       </trans-unit>
        <trans-unit id="3111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Get a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object that represents the <ph id="ph2">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.</source>
          <target state="translated">Abrufen einer <ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekt, das darstellt der <ph id="ph2">`__ComObject`</ph> , entspricht die CLSID durch Aufrufen der <ph id="ph3">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Call the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> method to instantiate the COM object.</source>
          <target state="translated">Rufen Sie die <ph id="ph1">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType&gt;</ph> Methode, um das COM-Objekt zu instanziieren.</target>       </trans-unit>
        <trans-unit id="3113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Exceptions such as <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> will be thrown when specifying <ph id="ph2">`true`</ph> for <ph id="ph3">`throwOnError`</ph>, but it will not fail for unregistered CLSIDs.</source>
          <target state="translated">Ausnahmen wie <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> wird ausgelöst, wenn die Angabe <ph id="ph2">`true`</ph> für <ph id="ph3">`throwOnError`</ph>, aber nicht registrierte CLSIDs führen nicht zu einem Fehler.</target>       </trans-unit>
        <trans-unit id="3114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>The following example uses the CLSID of the Microsoft Word <bpt id="p1">[</bpt>Application object<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com. It then instantiates the type by calling the <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> method, and closes it by calling the <bpt id="p2">[</bpt>Application.Quit<ept id="p2">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> method.</source>
          <target state="translated">Im folgenden Beispiel wird die CLSID der Microsoft Word <bpt id="p1">[</bpt>Anwendungsobjekt<ept id="p1">](http://msdn.microsoft.com/library/office/ff838565.aspx)</ept> ein COM-Typs abgerufen, die die Microsoft Word-Anwendung von einem pullserver namens computer17.central.contoso.com darstellt. Dann instanziiert den Typ durch Aufrufen der <ph id="ph1">&lt;xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType&gt;</ph> -Methode und schließt ihn durch Aufrufen der <bpt id="p2">[</bpt>Application.Quit<ept id="p2">](http://msdn.microsoft.com/library/office/ff844895.aspx)</ept> Methode.</target>       </trans-unit>
        <trans-unit id="3115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>An exception is thrown if an error occurs while loading the type.</source>
          <target state="translated">Eine Ausnahme wird ausgelöst, wenn beim Laden des Typs ein Fehler auftritt.</target>       </trans-unit>
        <trans-unit id="3116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>This method is intended for use when working with COM objects, not with .NET Framework objects.</source>
          <target state="translated">Diese Methode dient zur Verwendung bei der Arbeit mit COM-Objekte nicht mit .NET Framework-Objekten.</target>       </trans-unit>
        <trans-unit id="3117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>All managed objects, including those that are visible to COM (that is, their <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> attribute is <ph id="ph2">&lt;see langword="true" /&gt;</ph>) have a GUID that is returned by the <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> property.</source>
          <target state="translated">Alle verwalteten Objekte, einschließlich derer, die für COM sichtbar sind (d. h. deren <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /&gt;</ph> -Attribut ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>) haben eine GUID, die von zurückgegeben wird die <ph id="ph3">&lt;see cref="P:System.Type.GUID" /&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="3118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Although the <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> method returns a <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object that corresponds to the GUID for a particular managed object, you can't use that <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> object to create a type instance by calling the  <ph id="ph4">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method, as the following example shows.</source>
          <target state="translated">Obwohl die <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> Methode gibt ein <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> Objekt, das die GUID für ein bestimmtes verwaltetes Objekt entspricht, kann nicht verwendet <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> Objekt so erstellen eine Instanz eines Datentyps durch Aufrufen der <ph id="ph4">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> Methode, wie im folgenden Beispiel zeigt.</target>       </trans-unit>
        <trans-unit id="3119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)">
          <source>Instead, the <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object that is passed to the <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> method must represent an unmanaged COM object.</source>
          <target state="translated">Stattdessen die <ph id="ph1">&lt;see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /&gt;</ph> sollte nur verwendet werden, um die GUID der nicht verwaltete COM-Objekte und die resultierende abrufen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> -Objekt, das an die <ph id="ph3">&lt;see cref="M:System.Activator.CreateInstance(System.Type)" /&gt;</ph> Methode muss ein nicht verwaltetes COM-Objekt darstellen.</target>       </trans-unit>
        <trans-unit id="3120" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>The object that refers to the type.</source>
          <target state="translated">Das Objekt, das auf den Typ verweist.</target>       </trans-unit>
        <trans-unit id="3121" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>Gets the type referenced by the specified type handle.</source>
          <target state="translated">Ruft den Typ ab, auf den das angegebene Typhandle verweist.</target>       </trans-unit>
        <trans-unit id="3122" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>The type referenced by the specified <ph id="ph1">&lt;see cref="T:System.RuntimeTypeHandle" /&gt;</ph>, or <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the <ph id="ph3">&lt;see cref="P:System.RuntimeTypeHandle.Value" /&gt;</ph> property of <ph id="ph4">&lt;paramref name="handle" /&gt;</ph> is <ph id="ph5">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der Typ, auf den das angegebene <ph id="ph1">&lt;see cref="T:System.RuntimeTypeHandle" /&gt;</ph> verweist, oder <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn die <ph id="ph3">&lt;see cref="P:System.RuntimeTypeHandle.Value" /&gt;</ph>-Eigenschaft von <ph id="ph4">&lt;paramref name="handle" /&gt;</ph> den Wert <ph id="ph5">&lt;see langword="null" /&gt;</ph> hat.</target>       </trans-unit>
        <trans-unit id="3123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>The handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">Die Handles gelten nur in der Anwendungsdomäne, in der sie erworben wurden.</target>       </trans-unit>
        <trans-unit id="3124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Type.GetTypeFromHandle%2A&gt;</ph> method to get a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object from a <ph id="ph3">&lt;xref:System.RuntimeTypeHandle&gt;</ph> provided by the <ph id="ph4">&lt;xref:System.Type.GetTypeHandle%2A&gt;</ph> method.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.Type.GetTypeFromHandle%2A&gt;</ph> Methode zum Abrufen einer <ph id="ph2">&lt;xref:System.Type&gt;</ph> -Objekt aus einer <ph id="ph3">&lt;xref:System.RuntimeTypeHandle&gt;</ph> gebotenen die <ph id="ph4">&lt;xref:System.Type.GetTypeHandle%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3125" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="3126" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Gets the type associated with the specified program identifier (ProgID).</source>
          <target state="translated">Ruft den Typ ab, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist.</target>       </trans-unit>
        <trans-unit id="3127" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>The ProgID of the type to get.</source>
          <target state="translated">Die ProgID des abzurufenden Typs.</target>       </trans-unit>
        <trans-unit id="3128" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft den Typ ab, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist. Wenn beim Laden des <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> ein Fehler auftritt, wird NULL zurückgegeben.</target>       </trans-unit>
        <trans-unit id="3129" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>The type associated with the specified ProgID, if <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is a valid entry in the registry and a type is associated with it; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der Typ, dem die angegebene ProgID zugeordnet ist, wenn <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> ein gültiger Eintrag in der Registrierung ist und diesem ein Typ zugeordnet ist, andernfalls <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>This method is provided for COM support.</source>
          <target state="translated">Diese Methode wird bereitgestellt, für COM-Unterstützung.</target>       </trans-unit>
        <trans-unit id="3131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>ProgIDs are not used in the Microsoft .NET Framework because they have been superseded by the concept of namespace.</source>
          <target state="translated">Versionsabhängige Programm-IDs werden nicht in Microsoft .NET Framework verwendet, da sie durch das Konzept der Namespace ersetzt wurden.</target>       </trans-unit>
        <trans-unit id="3132" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="3134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="3135" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>The ProgID of the type to get.</source>
          <target state="translated">Die ProgID des abzurufenden Typs.</target>       </trans-unit>
        <trans-unit id="3136" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw any exception that occurs.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, um mögliche Ausnahmen auszulösen.</target>       </trans-unit>
        <trans-unit id="3137" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3138" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to ignore any exception that occurs.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>, um Ausnahmen zu ignorieren.</target>       </trans-unit>
        <trans-unit id="3139" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.</source>
          <target state="translated">Ruft den Typ ab, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist. Dabei wird angegeben, ob bei Auftreten eines Fehlers beim Laden des Typs eine Ausnahme ausgelöst werden soll.</target>       </trans-unit>
        <trans-unit id="3140" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>The type associated with the specified program identifier (ProgID), if <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is a valid entry in the registry and a type is associated with it; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, wenn <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> ein gültiger Eintrag in der Registrierung ist und diesem ein Typ zugeordnet ist, andernfalls <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>This method is provided for COM support.</source>
          <target state="translated">Diese Methode wird bereitgestellt, für COM-Unterstützung.</target>       </trans-unit>
        <trans-unit id="3142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</source>
          <target state="translated">Programm-IDs werden nicht in Microsoft .NET Framework verwendet, da sie durch das Konzept der Namespace ersetzt wurden.</target>       </trans-unit>
        <trans-unit id="3143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>The following example retrieves a type by passing a ProgID, specifying whether to throw an exception if the ProgID is invalid.</source>
          <target state="translated">Im folgende Beispiel ruft einen Typ ab, durch Übergeben einer ProgID, der angibt, ob eine Ausnahme auslöst, wenn die ProgID ungültig ist.</target>       </trans-unit>
        <trans-unit id="3144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>The example then displays the ClassID related to the ProgID, along with any applicable exception message.</source>
          <target state="translated">Das Beispiel zeigt dann die ClassID im Zusammenhang mit der ProgID sowie alle anwendbaren Ausnahmemeldung.</target>       </trans-unit>
        <trans-unit id="3145" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3146" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>The specified ProgID is not registered.</source>
          <target state="translated">Die angegebene ProgID ist nicht registriert.</target>       </trans-unit>
        <trans-unit id="3147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="3148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="3149" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>The progID of the type to get.</source>
          <target state="translated">Die ProgID des abzurufenden Typs.</target>       </trans-unit>
        <trans-unit id="3150" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>The server from which to load the type.</source>
          <target state="translated">Der Server, von dem der Typ geladen werden soll.</target>       </trans-unit>
        <trans-unit id="3151" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>If the server name is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, this method automatically reverts to the local machine.</source>
          <target state="translated">Wenn der Servername <ph id="ph1">&lt;see langword="null" /&gt;</ph> ist, wird diese Methode automatisch auf den lokalen Computer zurückgesetzt.</target>       </trans-unit>
        <trans-unit id="3152" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.</source>
          <target state="translated">Ruft den Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, vom angegebenen Server ab. Wenn bei Laden des Typs ein Fehler auftritt, wird NULL zurückgegeben.</target>       </trans-unit>
        <trans-unit id="3153" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>The type associated with the specified program identifier (progID), if <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is a valid entry in the registry and a type is associated with it; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, wenn <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> ein gültiger Eintrag in der Registrierung ist und diesem ein Typ zugeordnet ist, andernfalls <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>This method is provided for COM support.</source>
          <target state="translated">Diese Methode wird bereitgestellt, für COM-Unterstützung.</target>       </trans-unit>
        <trans-unit id="3155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</source>
          <target state="translated">Programm-IDs werden nicht in Microsoft .NET Framework verwendet, da sie durch das Konzept der Namespace ersetzt wurden.</target>       </trans-unit>
        <trans-unit id="3156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>The following example retrieves a type by passing a ProgID and server name.</source>
          <target state="translated">Im folgende Beispiel ruft einen Typ ab, durch die Übergabe einer ProgID "und" Server-Namens.</target>       </trans-unit>
        <trans-unit id="3157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>The example then displays the ClassID related to the ProgID, or throws an exception if the ProgID or the server name is invalid.</source>
          <target state="translated">Im Beispiel für die ClassID angezeigt, die ProgID oder löst eine Ausnahme aus, wenn die ProgID oder den Namen des Servers ungültig ist.</target>       </trans-unit>
        <trans-unit id="3158" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source><ph id="ph1">&lt;paramref name="prodID" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="prodID" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="3160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="3161" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The progID of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to get.</source>
          <target state="translated">Die ProgID des abzurufenden <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3162" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The server from which to load the type.</source>
          <target state="translated">Der Server, von dem der Typ geladen werden soll.</target>       </trans-unit>
        <trans-unit id="3163" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>If the server name is <ph id="ph1">&lt;see langword="null" /&gt;</ph>, this method automatically reverts to the local machine.</source>
          <target state="translated">Wenn der Servername <ph id="ph1">&lt;see langword="null" /&gt;</ph> ist, wird diese Methode automatisch auf den lokalen Computer zurückgesetzt.</target>       </trans-unit>
        <trans-unit id="3164" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw any exception that occurs.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, um mögliche Ausnahmen auszulösen.</target>       </trans-unit>
        <trans-unit id="3165" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3166" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> to ignore any exception that occurs.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>, um Ausnahmen zu ignorieren.</target>       </trans-unit>
        <trans-unit id="3167" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</source>
          <target state="translated">Ruft den Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, vom angegebenen Server ab. Dabei wird angegeben, ob bei Auftreten eines Fehlers beim Laden des Typs eine Ausnahme ausgelöst werden soll.</target>       </trans-unit>
        <trans-unit id="3168" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The type associated with the specified program identifier (progID), if <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is a valid entry in the registry and a type is associated with it; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, wenn <ph id="ph1">&lt;paramref name="progID" /&gt;</ph> ein gültiger Eintrag in der Registrierung ist und diesem ein Typ zugeordnet ist, andernfalls <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>This method is provided for COM support.</source>
          <target state="translated">Diese Methode wird bereitgestellt, für COM-Unterstützung.</target>       </trans-unit>
        <trans-unit id="3170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</source>
          <target state="translated">Programm-IDs werden nicht in Microsoft .NET Framework verwendet, da sie durch das Konzept der Namespace ersetzt wurden.</target>       </trans-unit>
        <trans-unit id="3171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The following example retrieves a type by passing a ProgID and server name.</source>
          <target state="translated">Im folgende Beispiel ruft einen Typ ab, durch die Übergabe einer ProgID "und" Server-Namens.</target>       </trans-unit>
        <trans-unit id="3172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The example then displays the ClassID related to the ProgID, specifying whether to throw an exception if the ProgID or the server name is invalid.</source>
          <target state="translated">Das Beispiel zeigt dann die ClassID im Zusammenhang mit der ProgID angeben, ob eine Ausnahme auslöst, wenn die ProgID oder den Namen des Servers ungültig ist.</target>       </trans-unit>
        <trans-unit id="3173" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="progID" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3174" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>The specified progID is not registered.</source>
          <target state="translated">Die angegebene progID ist nicht registriert.</target>       </trans-unit>
        <trans-unit id="3175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>Requires full trust for the immediate caller.</source>
          <target state="translated">erfordert volle Vertrauenswürdigkeit für den unmittelbaren Aufrufer.</target>       </trans-unit>
        <trans-unit id="3176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)">
          <source>This member cannot be used by partially trusted or transparent code.</source>
          <target state="translated">Dieser Member kann nicht von teilweise vertrauenswürdigem oder transparentem Code verwendet werden.</target>       </trans-unit>
        <trans-unit id="3177" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source>The object for which to get the type handle.</source>
          <target state="translated">Das Objekt, für das das Typhandle abgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="3178" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source>Gets the handle for the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of a specified object.</source>
          <target state="translated">Ruft das Handle für den <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Wert eines angegebenen Objekts ab.</target>       </trans-unit>
        <trans-unit id="3179" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source>The handle for the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the specified <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>.</source>
          <target state="translated">Das Handle für den <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> des angegebenen <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source>The handles are valid only in the application domain in which they were obtained.</source>
          <target state="translated">Die Handles gelten nur in der Anwendungsdomäne, in der sie erworben wurden.</target>       </trans-unit>
        <trans-unit id="3181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source>The following example defines the class <ph id="ph1">`MyClass1`</ph>, gets an instance of it, and retrieves the runtime handle of the object.</source>
          <target state="translated">Das folgende Beispiel definiert die Klasse <ph id="ph1">`MyClass1`</ph>, ruft eine Instanz des Zertifikats ab und ruft die Common Language Runtime Handle des Objekts ab.</target>       </trans-unit>
        <trans-unit id="3182" translate="yes" xml:space="preserve" uid="M:System.Type.GetTypeHandle(System.Object)">
          <source><ph id="ph1">&lt;paramref name="o" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="o" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3183" translate="yes" xml:space="preserve" uid="P:System.Type.GUID">
          <source>Gets the GUID associated with the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft die dem <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> zugeordnete GUID ab.</target>       </trans-unit>
        <trans-unit id="3184" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GUID">
          <source>The GUID associated with the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Die dem <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> zugeordnete GUID.</target>       </trans-unit>
        <trans-unit id="3185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GUID">
          <source>A GUID is associated with a type using the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GuidAttribute&gt;</ph> attribute.</source>
          <target state="translated">Eine GUID bezieht sich auf einen Typ mit dem <ph id="ph1">&lt;xref:System.Runtime.InteropServices.GuidAttribute&gt;</ph> Attribut.</target>       </trans-unit>
        <trans-unit id="3186" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.GUID">
          <source>The following example creates the class <ph id="ph1">`MyClass1`</ph> with a public method, creates a <ph id="ph2">`Type`</ph> object corresponding to <ph id="ph3">`MyClass1`</ph>, and gets the <ph id="ph4">&lt;xref:System.Guid&gt;</ph> structure using the <ph id="ph5">`GUID`</ph> property of the <ph id="ph6">`Type`</ph> class.</source>
          <target state="translated">Im folgenden Beispiel wird die Klasse <ph id="ph1">`MyClass1`</ph> mit einer öffentlichen Methode erstellt eine <ph id="ph2">`Type`</ph> , Objekt entspricht <ph id="ph3">`MyClass1`</ph>, und ruft die <ph id="ph4">&lt;xref:System.Guid&gt;</ph> -Struktur unter Verwendung der <ph id="ph5">`GUID`</ph> Eigenschaft von der <ph id="ph6">`Type`</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="3187" translate="yes" xml:space="preserve" uid="P:System.Type.HasElementType">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> encompasses or refers to another type; that is, whether the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array, a pointer, or is passed by reference.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der aktuelle <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> einen anderen Typ umfasst oder auf einen anderen Typ verweist, d. h. ob der aktuelle <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> ein Array oder ein Zeiger ist oder als Verweis übergeben wird.</target>       </trans-unit>
        <trans-unit id="3188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.HasElementType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array, a pointer, or is passed by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> ein Array oder ein Zeiger ist oder als Verweis übergeben wird, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.HasElementType">
          <source>For example, Type.GetType("Int32[]").HasElementType returns <ph id="ph1">`true`</ph>, but Type.GetType("Int32").HasElementType returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Beispielsweise Type.GetType("Int32[]"). HasElementType gibt <ph id="ph1">`true`</ph>, wohingegen Type.GetType("Int32"). HasElementType gibt <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.HasElementType">
          <source>HasElementType also returns <ph id="ph1">`true`</ph> for "Int32*" and "Int32&amp;".</source>
          <target state="translated">HasElementType gibt auch <ph id="ph1">`true`</ph> für "Int32 *" und "Int32 &amp;".</target>       </trans-unit>
        <trans-unit id="3191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.HasElementType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen generischen Typ oder Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Eigenschaft gibt immer <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.HasElementType">
          <source>The following example returns <ph id="ph1">`true`</ph> or <ph id="ph2">`false`</ph> depending on whether or not the object is an array, a reference type, or a pointer.</source>
          <target state="translated">Das folgende Beispiel gibt <ph id="ph1">`true`</ph> oder <ph id="ph2">`false`</ph> abhängig davon, ob das Objekt ein Array, ein Verweistyp oder ein Zeiger ist.</target>       </trans-unit>
        <trans-unit id="3193" translate="yes" xml:space="preserve" uid="M:System.Type.HasElementTypeImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.HasElementType" /&gt;</ph> property and determines whether the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> encompasses or refers to another type; that is, whether the current <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> is an array, a pointer, or is passed by reference.</source>
          <target state="translated">Implementiert beim Überschreiben in einer abgeleiteten Klasse die <ph id="ph1">&lt;see cref="P:System.Type.HasElementType" /&gt;</ph>-Eigenschaft und bestimmt, ob der aktuelle <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> einen anderen Typ umfasst oder auf einen solchen verweist, d. h. ob der aktuelle <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> ein Array oder Zeiger ist oder als Verweis übergeben wird.</target>       </trans-unit>
        <trans-unit id="3194" translate="yes" xml:space="preserve" uid="M:System.Type.HasElementTypeImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array, a pointer, or is passed by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> ein Array oder ein Zeiger ist oder als Verweis übergeben wird, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.HasElementTypeImpl">
          <source>For example, Type.GetType("Int32[]").HasElementTypeImpl returns <ph id="ph1">`true`</ph>, but Type.GetType("Int32").HasElementTypeImpl returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Beispielsweise Type.GetType("Int32[]"). HasElementTypeImpl gibt <ph id="ph1">`true`</ph>, wohingegen Type.GetType("Int32"). HasElementTypeImpl gibt <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.HasElementTypeImpl">
          <source>HasElementTypeImpl also returns <ph id="ph1">`true`</ph> for "Int32*" and "Int32&amp;".</source>
          <target state="translated">HasElementTypeImpl gibt auch <ph id="ph1">`true`</ph> für "Int32 *" und "Int32 &amp;".</target>       </trans-unit>
        <trans-unit id="3197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.HasElementTypeImpl">
          <source>The following example defines the class <ph id="ph1">`MyTypeDelegator`</ph>, which overrides the <ph id="ph2">`HasElementTypeImpl`</ph> method.</source>
          <target state="translated">Das folgende Beispiel definiert die Klasse <ph id="ph1">`MyTypeDelegator`</ph>, welche Außerkraftsetzungen der <ph id="ph2">`HasElementTypeImpl`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.HasElementTypeImpl">
          <source>The main class checks for the <ph id="ph1">`HasElementType`</ph> property and displays the element type.</source>
          <target state="translated">Die Hauptklasse überprüft die <ph id="ph1">`HasElementType`</ph> Eigenschaft und zeigt den Elementtyp an.</target>       </trans-unit>
        <trans-unit id="3199" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Invokes a specific member of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft einen bestimmten Member vom aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> auf.</target>       </trans-unit>
        <trans-unit id="3200" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The string containing the name of the constructor, method, property, or field member to invoke.</source>
          <target state="translated">Die Zeichenfolge, die den Namen des Konstruktors, der Methode, der Eigenschaft oder des Feldmembers enthält, der bzw. die aufgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="3201" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3202" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>An empty string ("") to invoke the default member.</source>
          <target state="translated">Eine leere Zeichenfolge ("") zum Aufrufen des Standardmembers.</target>       </trans-unit>
        <trans-unit id="3203" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3204" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>For <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> members, a string representing the DispID, for example "[DispID=3]".</source>
          <target state="translated">Für <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph>-Member eine Zeichenfolge, die die DispID darstellt, z. B. "[DispID=3]".</target>       </trans-unit>
        <trans-unit id="3205" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="3206" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The access can be one of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> such as <ph id="ph2">&lt;see langword="Public" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, <ph id="ph4">&lt;see langword="Private" /&gt;</ph>, <ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetField" /&gt;</ph>, and so on.</source>
          <target state="translated">Der Zugriff kann aus einem der <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> wie <ph id="ph2">&lt;see langword="Public" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, <ph id="ph4">&lt;see langword="Private" /&gt;</ph>, <ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetField" /&gt;</ph> usw. bestehen.</target>       </trans-unit>
        <trans-unit id="3207" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The type of lookup need not be specified.</source>
          <target state="translated">Die Art der Suche muss nicht angegeben werden.</target>       </trans-unit>
        <trans-unit id="3208" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>If the type of lookup is omitted, <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph> are used.</source>
          <target state="translated">Wenn die Art der Suche nicht angegeben ist, werden <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph> verwendet.</target>       </trans-unit>
        <trans-unit id="3209" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</target>       </trans-unit>
        <trans-unit id="3210" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3211" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Ein Nullverweis (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), wenn <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph> verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="3212" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Note that explicitly defining a <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> object may be required for successfully invoking method overloads with variable arguments.</source>
          <target state="translated">Beachten Sie, dass möglicherweise ein <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>-Objekt explizit definiert werden muss, um erfolgreich Methodenüberladungen mit Variablenargumenten aufrufen zu können.</target>       </trans-unit>
        <trans-unit id="3213" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The object on which to invoke the specified member.</source>
          <target state="translated">Das Objekt, für das der angegebene Member aufgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="3214" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>An array containing the arguments to pass to the member to invoke.</source>
          <target state="translated">Ein Array mit den Argumenten, die dem aufzurufenden Member übergeben werden sollen.</target>       </trans-unit>
        <trans-unit id="3215" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Invokes the specified member, using the specified binding constraints and matching the specified argument list.</source>
          <target state="translated">Ruft den angegebenen Member auf, der den angegebenen Bindungseinschränkungen und der angegebenen Argumentliste entspricht.</target>       </trans-unit>
        <trans-unit id="3216" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>An object representing the return value of the invoked member.</source>
          <target state="translated">Ein Objekt, das den Rückgabewert des aufgerufenen Members darstellt.</target>       </trans-unit>
        <trans-unit id="3217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>You cannot use <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> to invoke a generic method.</source>
          <target state="translated">Sie können keine <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> um eine generische Methode aufrufen.</target>       </trans-unit>
        <trans-unit id="3218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Filterkennzeichnungen genutzt werden, welche Member in die Suche einbezogen werden:</target>       </trans-unit>
        <trans-unit id="3219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Public`</ph> auf öffentliche Member in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="3220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private and protected members) in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.NonPublic`</ph> auf nicht öffentliche Member (d. h. private und geschützte Member) in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="3221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include static members up the hierarchy.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> statische Mitglieder der Hierarchie aufwärts eingeschlossen werden sollen.</target>       </trans-unit>
        <trans-unit id="3222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</target>       </trans-unit>
        <trans-unit id="3223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> um die Groß-/Kleinschreibung ignorieren <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="3224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> Suche nur die deklarierten Member der <ph id="ph2">&lt;xref:System.Type&gt;</ph>, nicht die Elemente, die nur geerbt wurden.</target>       </trans-unit>
        <trans-unit id="3225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> invocation flags can be used to denote what action to take with the member:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Aufrufflags genutzt werden, welche Aktion für das Element ausführen soll:</target>       </trans-unit>
        <trans-unit id="3226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`CreateInstance`</ph> to invoke a constructor.</source>
          <target state="translated"><ph id="ph1">`CreateInstance`</ph> Um einen Konstruktor aufzurufen.</target>       </trans-unit>
        <trans-unit id="3227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`name`</ph> is ignored.</source>
          <target state="translated"><ph id="ph1">`name`</ph> wird ignoriert.</target>       </trans-unit>
        <trans-unit id="3228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with other invocation flags.</source>
          <target state="translated">Mit anderen Aufrufflags ist ungültig.</target>       </trans-unit>
        <trans-unit id="3229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`InvokeMethod`</ph> to invoke a method, but not a constructor or a type initializer.</source>
          <target state="translated"><ph id="ph1">`InvokeMethod`</ph> Aufrufen einer Methode, jedoch nicht auf einen Konstruktor oder Typinitialisierer</target>       </trans-unit>
        <trans-unit id="3230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with <ph id="ph1">`SetField`</ph> or <ph id="ph2">`SetProperty`</ph>.</source>
          <target state="translated">Ungültig mit <ph id="ph1">`SetField`</ph> oder <ph id="ph2">`SetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>If <ph id="ph1">`InvokeMethod`</ph> is specified by itself, <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, and <ph id="ph4">`BindingFlags.Static`</ph> are automatically included.</source>
          <target state="translated">Wenn <ph id="ph1">`InvokeMethod`</ph> angegeben wird, <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, und <ph id="ph4">`BindingFlags.Static`</ph> werden automatisch mit eingeschlossen.</target>       </trans-unit>
        <trans-unit id="3232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`GetField`</ph> to get the value of a field.</source>
          <target state="translated"><ph id="ph1">`GetField`</ph> den Wert eines Felds abgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="3233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with <ph id="ph1">`SetField`</ph>.</source>
          <target state="translated">Ungültig mit <ph id="ph1">`SetField`</ph>.</target>       </trans-unit>
        <trans-unit id="3234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`SetField`</ph> to set the value of a field.</source>
          <target state="translated"><ph id="ph1">`SetField`</ph> den Wert eines Felds festgelegt.</target>       </trans-unit>
        <trans-unit id="3235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with <ph id="ph1">`GetField`</ph>.</source>
          <target state="translated">Ungültig mit <ph id="ph1">`GetField`</ph>.</target>       </trans-unit>
        <trans-unit id="3236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`GetProperty`</ph> to get a property.</source>
          <target state="translated"><ph id="ph1">`GetProperty`</ph> zum Abrufen einer Eigenschaft.</target>       </trans-unit>
        <trans-unit id="3237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with <ph id="ph1">`SetProperty`</ph>.</source>
          <target state="translated">Ungültig mit <ph id="ph1">`SetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">`SetProperty`</ph> to set a property.</source>
          <target state="translated"><ph id="ph1">`SetProperty`</ph> Festlegen von Eigenschaften.</target>       </trans-unit>
        <trans-unit id="3239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Not valid with <ph id="ph1">`GetProperty`</ph>.</source>
          <target state="translated">Ungültig mit <ph id="ph1">`GetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>A method will be invoked if both of the following conditions are true:</source>
          <target state="translated">Eine Methode wird aufgerufen, wenn beide der folgenden Bedingungen zutreffen:</target>       </trans-unit>
        <trans-unit id="3242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The number of parameters in the method declaration equals the number of arguments in the <ph id="ph1">`args`</ph> array (unless default arguments are defined on the member and <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> is specified).</source>
          <target state="translated">Die Anzahl von Parametern in der Deklaration der Methode entspricht der Anzahl der Argumente in der <ph id="ph1">`args`</ph> Array (, wenn Standardargumente für das Element definiert sind und <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> angegeben ist).</target>       </trans-unit>
        <trans-unit id="3243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The type of each argument can be converted by the binder to the type of the parameter.</source>
          <target state="translated">Der Typ jedes Arguments kann vom Binder in den Typ des Parameters konvertiert werden.</target>       </trans-unit>
        <trans-unit id="3244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The binder will find all of the matching methods.</source>
          <target state="translated">Der Binder findet alle übereinstimmenden Methoden.</target>       </trans-unit>
        <trans-unit id="3245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>These methods are found based upon the type of binding requested (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> values <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>, and so on).</source>
          <target state="translated">Diese Methoden werden basierend auf den Typ der Bindung, die angeforderte gefunden (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Werte <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>usw.).</target>       </trans-unit>
        <trans-unit id="3246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
          <target state="translated">Der Satz von Methoden wird durch den Namen, Anzahl von Argumenten und einen Satz von Suchabfragen in der Binder definierten gefiltert.</target>       </trans-unit>
        <trans-unit id="3247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>After the method is selected, it is invoked.</source>
          <target state="translated">Wenn die Methode ausgewählt wurde, wird er aufgerufen.</target>       </trans-unit>
        <trans-unit id="3248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Accessibility is checked at that point.</source>
          <target state="translated">Eingabehilfen ist an diesem Punkt aktiviert.</target>       </trans-unit>
        <trans-unit id="3249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
          <target state="translated">Die Suche kann gesteuert werden durchsucht, welchen Satz von Methoden basierend auf der Eingabehilfen-Attribut, das der Methode zugeordnet.</target>       </trans-unit>
        <trans-unit id="3250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> class is responsible for selecting the method to be invoked.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> Methode von der <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> -Klasse ist verantwortlich für die Auswahl der Methode, die aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="3251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The default binder selects the most specific match.</source>
          <target state="translated">Der Standardbinder wählt die spezifischste Übereinstimmung.</target>       </trans-unit>
        <trans-unit id="3252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <ph id="ph1">&lt;xref:System.Reflection&gt;</ph> whenever the code is fully trusted.</source>
          <target state="translated">Zugriffseinschränkungen werden für vollständig vertrauenswürdige Code ignoriert. d. h. private Konstruktoren, Methoden, Felder und Eigenschaften können zugegriffen und aufgerufene <ph id="ph1">&lt;xref:System.Reflection&gt;</ph> immer der Code vollständig vertrauenswürdig ist.</target>       </trans-unit>
        <trans-unit id="3253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>You can use <ph id="ph1">`Type.InvokeMember`</ph> to set a field to a particular value by specifying <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Sie können <ph id="ph1">`Type.InvokeMember`</ph> auf ein Feld auf einen bestimmten Wert festgelegt wird, durch Angabe <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>For example, if you want to set a public instance field named F on class C, and F is a <ph id="ph1">`String`</ph>, you can use code such as:</source>
          <target state="translated">Beispielsweise, wenn Sie eine öffentliche Instanzenfeld F auf Klasse C und F festlegen möchten ist eine <ph id="ph1">`String`</ph>, können Sie Code wie z. B.:</target>       </trans-unit>
        <trans-unit id="3255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>If F is a <ph id="ph1">`String[]`</ph>, you can use code such as:</source>
          <target state="translated">Wenn F# ist eine <ph id="ph1">`String[]`</ph>, können Sie Code wie z. B.:</target>       </trans-unit>
        <trans-unit id="3256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>which will initialize the field F to this new array.</source>
          <target state="translated">die wird das Feld F für dieses neue Array zu initialisieren.</target>       </trans-unit>
        <trans-unit id="3257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>You can also use <ph id="ph1">`Type.InvokeMember`</ph> to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</source>
          <target state="translated">Sie können auch <ph id="ph1">`Type.InvokeMember`</ph> an eine Position in einem Array festlegen, indem der Index des Werts, und klicken Sie dann den nächsten Wert mit Code wie dem folgenden:</target>       </trans-unit>
        <trans-unit id="3258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>This will change string "z" in the array that F holds to string "b".</source>
          <target state="translated">Dadurch wird die Zeichenfolge "Z" in das Array geändert, die in der Zeichenfolge "b" F enthält.</target>       </trans-unit>
        <trans-unit id="3259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>When you invoke an <ph id="ph1">`IDispatch`</ph> member, you can specify the DispID instead of the member name, using the string format "[DispID=##]".</source>
          <target state="translated">Beim Aufruf einer <ph id="ph1">`IDispatch`</ph> Member auf, Sie können die DispID anstelle des Namens des Elements, das Zeichenfolgenformat mithilfe angeben "[DispID = ##]".</target>       </trans-unit>
        <trans-unit id="3260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</source>
          <target state="translated">Beispielsweise, wenn die DispID MyComMethod 3 ist, können Sie angeben die Zeichenfolge "[DispID = 3]" statt "MyComMethod".</target>       </trans-unit>
        <trans-unit id="3261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Invoking a member by DispID is faster than looking up the member by name.</source>
          <target state="translated">Der Aufruf eines Members durch DispID ist schneller als das Element anhand des Namens nachschlagen.</target>       </trans-unit>
        <trans-unit id="3262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</source>
          <target state="translated">In komplexen Aggregation Szenarien ist die DispID in einigen Fällen die einzige Möglichkeit zum Aufrufen des gewünschten Mitglieds an.</target>       </trans-unit>
        <trans-unit id="3263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Methode kann verwendet werden, auf nicht öffentliche Member zuzugreifen, wenn der Aufrufer erteilt wurde <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> kennzeichnen und erteilen Sie der Berechtigungssatz für die nicht öffentlichen Member an des Aufrufers beschränkt ist Set- oder eine Teilmenge davon.</target>       </trans-unit>
        <trans-unit id="3264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsüberlegungen für die Reflektion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="3265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein. </target>       </trans-unit>
        <trans-unit id="3266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The following example uses <ph id="ph1">`InvokeMember`</ph> to access members of a type.</source>
          <target state="translated">Im folgenden Beispiel wird <ph id="ph1">`InvokeMember`</ph> den Zugriff auf Member eines Typs.</target>       </trans-unit>
        <trans-unit id="3267" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> and <ph id="ph3">&lt;paramref name="name" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> enthält keine <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3268" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> attribute.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> ist kein gültiges <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>-Attribut.</target>       </trans-unit>
        <trans-unit id="3269" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3270" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain one of the following binding flags: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> enthält keines der folgenden Bindungsflags: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> oder <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3271" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3272" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> enthält <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> in Kombination mit <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> oder <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3273" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3274" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetField" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> enthält sowohl <ph id="ph2">&lt;see langword="GetField" /&gt;</ph> als auch <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3275" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3276" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> enthält sowohl <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> als auch <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3277" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3278" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> or <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> enthält <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> in Kombination mit <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> oder <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3279" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3280" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="SetField" /&gt;</ph> and <ph id="ph3">&lt;paramref name="args" /&gt;</ph> has more than one element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> enthält <ph id="ph2">&lt;see langword="SetField" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="args" /&gt;</ph> enthält mehr als ein Element.</target>       </trans-unit>
        <trans-unit id="3281" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3282" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>This method is called on a COM object and one of the following binding flags was not passed in: <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>, <ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>, <ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>, <ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph>, or <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>.</source>
          <target state="translated">Diese Methode wird für ein COM-Objekt aufgerufen, und eines der folgenden Bindungsflags wurde nicht übergeben: <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>, <ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>, <ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>, <ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph> oder <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3283" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3284" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>One of the named parameter arrays contains a string that is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Eines der benannten Parameterarrays enthält eine Zeichenfolge, die <ph id="ph1">&lt;see langword="null" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="3285" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The specified member is a class initializer.</source>
          <target state="translated">Der angegebene Member ist ein Klasseninitialisierer.</target>       </trans-unit>
        <trans-unit id="3286" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The field or property cannot be found.</source>
          <target state="translated">Das Feld oder die Eigenschaft wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="3287" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>No method can be found that matches the arguments in <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated">Es wurde keine Methode gefunden, die den Argumenten in <ph id="ph1">&lt;paramref name="args" /&gt;</ph> entspricht.</target>       </trans-unit>
        <trans-unit id="3288" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3289" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type that contains open type parameters, that is, <ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Das aktuelle <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt stellt einen Typ dar, der offene Typparameter enthält. Das bedeutet, dass <ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> den Wert <ph id="ph3">&lt;see langword="true" /&gt;</ph> zurückgibt.</target>       </trans-unit>
        <trans-unit id="3290" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The specified member cannot be invoked on <ph id="ph1">&lt;paramref name="target" /&gt;</ph>.</source>
          <target state="translated">Der angegebene Member kann nicht für <ph id="ph1">&lt;paramref name="target" /&gt;</ph> aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="3291" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>More than one method matches the binding criteria.</source>
          <target state="translated">Mehrere Methoden entsprechen den Bindungskriterien.</target>       </trans-unit>
        <trans-unit id="3292" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The .NET Compact Framework does not currently support this method.</source>
          <target state="translated">Diese Methode wird von .NET Compact Framework derzeit nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="3293" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>The method represented by <ph id="ph1">&lt;paramref name="name" /&gt;</ph> has one or more unspecified generic type parameters.</source>
          <target state="translated">Die durch <ph id="ph1">&lt;paramref name="name" /&gt;</ph> dargestellte Methode enthält mindestens einen nicht angegebenen generischen Typparameter.</target>       </trans-unit>
        <trans-unit id="3294" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>That is, the method's <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Das bedeutet, dass die <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph>-Eigenschaft der Methode <ph id="ph2">&lt;see langword="true" /&gt;</ph> zurückgibt.</target>       </trans-unit>
        <trans-unit id="3295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>for accessing non-public members regardless of their grant set.</source>
          <target state="translated">Legen Sie für den Zugriff auf nicht öffentliche Member unabhängig von deren Berechtigungssatz.</target>       </trans-unit>
        <trans-unit id="3296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>to call unmanaged code.</source>
          <target state="translated">zum Aufrufen von nicht verwalteten Code.</target>       </trans-unit>
        <trans-unit id="3298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3299" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The string containing the name of the constructor, method, property, or field member to invoke.</source>
          <target state="translated">Die Zeichenfolge, die den Namen des Konstruktors, der Methode, der Eigenschaft oder des Feldmembers enthält, der bzw. die aufgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="3300" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3301" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>An empty string ("") to invoke the default member.</source>
          <target state="translated">Eine leere Zeichenfolge ("") zum Aufrufen des Standardmembers.</target>       </trans-unit>
        <trans-unit id="3302" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3303" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>For <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> members, a string representing the DispID, for example "[DispID=3]".</source>
          <target state="translated">Für <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph>-Member eine Zeichenfolge, die die DispID darstellt, z. B. "[DispID=3]".</target>       </trans-unit>
        <trans-unit id="3304" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="3305" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The access can be one of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> such as <ph id="ph2">&lt;see langword="Public" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, <ph id="ph4">&lt;see langword="Private" /&gt;</ph>, <ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetField" /&gt;</ph>, and so on.</source>
          <target state="translated">Der Zugriff kann aus einem der <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> wie <ph id="ph2">&lt;see langword="Public" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, <ph id="ph4">&lt;see langword="Private" /&gt;</ph>, <ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetField" /&gt;</ph> usw. bestehen.</target>       </trans-unit>
        <trans-unit id="3306" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The type of lookup need not be specified.</source>
          <target state="translated">Die Art der Suche muss nicht angegeben werden.</target>       </trans-unit>
        <trans-unit id="3307" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>If the type of lookup is omitted, <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph> are used.</source>
          <target state="translated">Wenn die Art der Suche nicht angegeben ist, werden <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph> verwendet.</target>       </trans-unit>
        <trans-unit id="3308" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</target>       </trans-unit>
        <trans-unit id="3309" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3310" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), to use the <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Ein Nullverweis (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), wenn <ph id="ph2">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph> verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="3311" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Note that explicitly defining a <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> object may be required for successfully invoking method overloads with variable arguments.</source>
          <target state="translated">Beachten Sie, dass möglicherweise ein <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>-Objekt explizit definiert werden muss, um erfolgreich Methodenüberladungen mit Variablenargumenten aufrufen zu können.</target>       </trans-unit>
        <trans-unit id="3312" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The object on which to invoke the specified member.</source>
          <target state="translated">Das Objekt, für das der angegebene Member aufgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="3313" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>An array containing the arguments to pass to the member to invoke.</source>
          <target state="translated">Ein Array mit den Argumenten, die dem aufzurufenden Member übergeben werden sollen.</target>       </trans-unit>
        <trans-unit id="3314" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> to a <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph>.</source>
          <target state="translated">Das Objekt, das das zu verwendende Globalisierungsgebietsschema darstellt, das für gebietsspezifische Konvertierungen wie die Konvertierung einer numerischen <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> in einen <ph id="ph2">&lt;see cref="T:System.Double" /&gt;</ph> erforderlich sein kann.</target>       </trans-unit>
        <trans-unit id="3315" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3316" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic) to use the current thread's <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>.</source>
          <target state="translated">Ein Nullverweis (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), wenn die <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> des aktuellen Threads verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="3317" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</source>
          <target state="translated">Ruft den angegebenen Member auf, der den angegebenen Bindungseinschränkungen sowie der angegebenen Argumentliste und Kultur entspricht.</target>       </trans-unit>
        <trans-unit id="3318" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>An object representing the return value of the invoked member.</source>
          <target state="translated">Ein Objekt, das den Rückgabewert des aufgerufenen Members darstellt.</target>       </trans-unit>
        <trans-unit id="3319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> (the <ph id="ph2">`culture`</ph> parameter), you can use the abstract <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph4">`culture`</ph>.</source>
          <target state="translated">Obwohl der Standardbinder nicht verarbeitet <ph id="ph1">&lt;xref:System.Globalization.CultureInfo&gt;</ph> (die <ph id="ph2">`culture`</ph> Parameter), können Sie die abstrakte <ph id="ph3">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden <ph id="ph4">`culture`</ph>.</target>       </trans-unit>
        <trans-unit id="3320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>You cannot use <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> to invoke a generic method.</source>
          <target state="translated">Sie können keine <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> um eine generische Methode aufrufen.</target>       </trans-unit>
        <trans-unit id="3321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Filterkennzeichnungen genutzt werden, welche Member in die Suche einbezogen werden:</target>       </trans-unit>
        <trans-unit id="3322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Public`</ph> auf öffentliche Member in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="3323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.NonPublic`</ph> auf nicht öffentliche Member (d. h. private, interne und geschützte Member) in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="3324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include static members up the hierarchy.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> statische Mitglieder der Hierarchie aufwärts eingeschlossen werden sollen.</target>       </trans-unit>
        <trans-unit id="3325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</target>       </trans-unit>
        <trans-unit id="3326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> um die Groß-/Kleinschreibung ignorieren <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="3327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> Suche nur die deklarierten Member der <ph id="ph2">&lt;xref:System.Type&gt;</ph>, nicht die Elemente, die nur geerbt wurden.</target>       </trans-unit>
        <trans-unit id="3328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> invocation flags can be used to denote what action to take with the member:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Aufrufflags genutzt werden, welche Aktion für das Element ausführen soll:</target>       </trans-unit>
        <trans-unit id="3329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`CreateInstance`</ph> to invoke a constructor.</source>
          <target state="translated"><ph id="ph1">`CreateInstance`</ph> Um einen Konstruktor aufzurufen.</target>       </trans-unit>
        <trans-unit id="3330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`name`</ph> is ignored.</source>
          <target state="translated"><ph id="ph1">`name`</ph> wird ignoriert.</target>       </trans-unit>
        <trans-unit id="3331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with other invocation flags.</source>
          <target state="translated">Mit anderen Aufrufflags ist ungültig.</target>       </trans-unit>
        <trans-unit id="3332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`InvokeMethod`</ph> to invoke a method, but not a constructor or a type initializer.</source>
          <target state="translated"><ph id="ph1">`InvokeMethod`</ph> Aufrufen einer Methode, jedoch nicht auf einen Konstruktor oder Typinitialisierer</target>       </trans-unit>
        <trans-unit id="3333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with <ph id="ph1">`SetField`</ph> or <ph id="ph2">`SetProperty`</ph>.</source>
          <target state="translated">Ungültig mit <ph id="ph1">`SetField`</ph> oder <ph id="ph2">`SetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>If <ph id="ph1">`InvokeMethod`</ph> is specified by itself, <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, and <ph id="ph4">`BindingFlags.Static`</ph> are automatically included.</source>
          <target state="translated">Wenn <ph id="ph1">`InvokeMethod`</ph> angegeben wird, <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, und <ph id="ph4">`BindingFlags.Static`</ph> werden automatisch mit eingeschlossen.</target>       </trans-unit>
        <trans-unit id="3335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`GetField`</ph> to get the value of a field.</source>
          <target state="translated"><ph id="ph1">`GetField`</ph> den Wert eines Felds abgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="3336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with <ph id="ph1">`SetField`</ph>.</source>
          <target state="translated">Ungültig mit <ph id="ph1">`SetField`</ph>.</target>       </trans-unit>
        <trans-unit id="3337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`SetField`</ph> to set the value of a field.</source>
          <target state="translated"><ph id="ph1">`SetField`</ph> den Wert eines Felds festgelegt.</target>       </trans-unit>
        <trans-unit id="3338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with <ph id="ph1">`GetField`</ph>.</source>
          <target state="translated">Ungültig mit <ph id="ph1">`GetField`</ph>.</target>       </trans-unit>
        <trans-unit id="3339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`GetProperty`</ph> to get a property.</source>
          <target state="translated"><ph id="ph1">`GetProperty`</ph> zum Abrufen einer Eigenschaft.</target>       </trans-unit>
        <trans-unit id="3340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with <ph id="ph1">`SetProperty`</ph>.</source>
          <target state="translated">Ungültig mit <ph id="ph1">`SetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">`SetProperty`</ph> to set a property.</source>
          <target state="translated"><ph id="ph1">`SetProperty`</ph> Festlegen von Eigenschaften.</target>       </trans-unit>
        <trans-unit id="3342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Not valid with <ph id="ph1">`GetProperty`</ph>.</source>
          <target state="translated">Ungültig mit <ph id="ph1">`GetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>A method will be invoked if both of the following conditions are true:</source>
          <target state="translated">Eine Methode wird aufgerufen, wenn beide der folgenden Bedingungen zutreffen:</target>       </trans-unit>
        <trans-unit id="3345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The number of parameters in the method declaration equals the number of arguments in the <ph id="ph1">`args`</ph> array (unless default arguments are defined on the member and <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> is specified).</source>
          <target state="translated">Die Anzahl von Parametern in der Deklaration der Methode entspricht der Anzahl der Argumente in der <ph id="ph1">`args`</ph> Array (, wenn Standardargumente für das Element definiert sind und <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> angegeben ist).</target>       </trans-unit>
        <trans-unit id="3346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The type of each argument can be converted by the binder to the type of the parameter.</source>
          <target state="translated">Der Typ jedes Arguments kann vom Binder in den Typ des Parameters konvertiert werden.</target>       </trans-unit>
        <trans-unit id="3347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The binder will find all of the matching methods.</source>
          <target state="translated">Der Binder findet alle übereinstimmenden Methoden.</target>       </trans-unit>
        <trans-unit id="3348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>These methods are found based upon the type of binding requested (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> values <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>, and so on).</source>
          <target state="translated">Diese Methoden werden basierend auf den Typ der Bindung, die angeforderte gefunden (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Werte <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>usw.).</target>       </trans-unit>
        <trans-unit id="3349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
          <target state="translated">Der Satz von Methoden wird durch den Namen, Anzahl von Argumenten und einen Satz von Suchabfragen in der Binder definierten gefiltert.</target>       </trans-unit>
        <trans-unit id="3350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>After the method is selected, it is invoked.</source>
          <target state="translated">Wenn die Methode ausgewählt wurde, wird er aufgerufen.</target>       </trans-unit>
        <trans-unit id="3351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Accessibility is checked at that point.</source>
          <target state="translated">Eingabehilfen ist an diesem Punkt aktiviert.</target>       </trans-unit>
        <trans-unit id="3352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
          <target state="translated">Die Suche kann gesteuert werden durchsucht, welchen Satz von Methoden basierend auf der Eingabehilfen-Attribut, das der Methode zugeordnet.</target>       </trans-unit>
        <trans-unit id="3353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> class is responsible for selecting the method to be invoked.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> Methode von der <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> -Klasse ist verantwortlich für die Auswahl der Methode, die aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="3354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The default binder selects the most specific match.</source>
          <target state="translated">Der Standardbinder wählt die spezifischste Übereinstimmung.</target>       </trans-unit>
        <trans-unit id="3355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.</source>
          <target state="translated">Zugriffseinschränkungen werden für vollständig vertrauenswürdige Code ignoriert. d. h. können private Konstruktoren, Methoden, Felder und Eigenschaften werden zugegriffen und durch Reflektion aufgerufen werden, wenn der Code vollständig vertrauenswürdig ist.</target>       </trans-unit>
        <trans-unit id="3356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>You can use <ph id="ph1">`Type.InvokeMember`</ph> to set a field to a particular value by specifying <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Sie können <ph id="ph1">`Type.InvokeMember`</ph> auf ein Feld auf einen bestimmten Wert festgelegt wird, durch Angabe <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, if you want to set a public instance field named F on class C, and F is a <ph id="ph1">`String`</ph> you can use code such as:</source>
          <target state="translated">Beispielsweise, wenn Sie eine öffentliche Instanzenfeld F auf Klasse C und F festlegen möchten ist eine <ph id="ph1">`String`</ph> Sie Code verwenden, z. B.:</target>       </trans-unit>
        <trans-unit id="3358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>If F is a <ph id="ph1">`String[]`</ph>, you can use code such as:</source>
          <target state="translated">Wenn F# ist eine <ph id="ph1">`String[]`</ph>, können Sie Code wie z. B.:</target>       </trans-unit>
        <trans-unit id="3359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>which will initialize the field F to this new array.</source>
          <target state="translated">die wird das Feld F für dieses neue Array zu initialisieren.</target>       </trans-unit>
        <trans-unit id="3360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>You can also use <ph id="ph1">`Type.InvokeMember`</ph> to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</source>
          <target state="translated">Sie können auch <ph id="ph1">`Type.InvokeMember`</ph> an eine Position in einem Array festlegen, indem der Index des Werts, und klicken Sie dann den nächsten Wert mit Code wie dem folgenden:</target>       </trans-unit>
        <trans-unit id="3361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>This will change string "z" in the array that F holds to string "b".</source>
          <target state="translated">Dadurch wird die Zeichenfolge "Z" in das Array geändert, die in der Zeichenfolge "b" F enthält.</target>       </trans-unit>
        <trans-unit id="3362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>When you invoke an <ph id="ph1">`IDispatch`</ph> member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</source>
          <target state="translated">Beim Aufruf einer <ph id="ph1">`IDispatch`</ph> Member können Sie angeben, die DispID anstelle der Elementname, verwenden das Format der Zeichenfolge "[DispID = ##]".</target>       </trans-unit>
        <trans-unit id="3363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</source>
          <target state="translated">Beispielsweise, wenn die DispID MyComMethod 3 ist, können Sie angeben die Zeichenfolge "[DispID = 3]" statt "MyComMethod".</target>       </trans-unit>
        <trans-unit id="3364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Invoking a member by DispID is faster than looking up the member by name.</source>
          <target state="translated">Der Aufruf eines Members durch DispID ist schneller als das Element anhand des Namens nachschlagen.</target>       </trans-unit>
        <trans-unit id="3365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</source>
          <target state="translated">In komplexen Aggregation Szenarien ist die DispID in einigen Fällen die einzige Möglichkeit zum Aufrufen des gewünschten Mitglieds an.</target>       </trans-unit>
        <trans-unit id="3366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Methode kann verwendet werden, auf nicht öffentliche Member zuzugreifen, wenn der Aufrufer erteilt wurde <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> kennzeichnen und erteilen Sie der Berechtigungssatz für die nicht öffentlichen Member an des Aufrufers beschränkt ist Set- oder eine Teilmenge davon.</target>       </trans-unit>
        <trans-unit id="3367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsüberlegungen für die Reflektion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="3368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein. </target>       </trans-unit>
        <trans-unit id="3369" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> and <ph id="ph3">&lt;paramref name="name" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> enthält keine <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3370" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> attribute.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> ist kein gültiges <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>-Attribut.</target>       </trans-unit>
        <trans-unit id="3371" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3372" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain one of the following binding flags: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> enthält keines der folgenden Bindungsflags: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> oder <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3373" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3374" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> enthält <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> in Kombination mit <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> oder <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3375" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3376" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetField" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> enthält sowohl <ph id="ph2">&lt;see langword="GetField" /&gt;</ph> als auch <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3377" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3378" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> enthält sowohl <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> als auch <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3379" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3380" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> or <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> enthält <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> in Kombination mit <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> oder <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3381" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3382" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="SetField" /&gt;</ph> and <ph id="ph3">&lt;paramref name="args" /&gt;</ph> has more than one element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> enthält <ph id="ph2">&lt;see langword="SetField" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="args" /&gt;</ph> enthält mehr als ein Element.</target>       </trans-unit>
        <trans-unit id="3383" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3384" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>This method is called on a COM object and one of the following binding flags was not passed in: <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>, <ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>, <ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>, <ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph>, or <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>.</source>
          <target state="translated">Diese Methode wird für ein COM-Objekt aufgerufen, und eines der folgenden Bindungsflags wurde nicht übergeben: <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>, <ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>, <ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>, <ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph> oder <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3385" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3386" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>One of the named parameter arrays contains a string that is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Eines der benannten Parameterarrays enthält eine Zeichenfolge, die <ph id="ph1">&lt;see langword="null" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="3387" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The specified member is a class initializer.</source>
          <target state="translated">Der angegebene Member ist ein Klasseninitialisierer.</target>       </trans-unit>
        <trans-unit id="3388" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The field or property cannot be found.</source>
          <target state="translated">Das Feld oder die Eigenschaft wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="3389" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>No method can be found that matches the arguments in <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated">Es wurde keine Methode gefunden, die den Argumenten in <ph id="ph1">&lt;paramref name="args" /&gt;</ph> entspricht.</target>       </trans-unit>
        <trans-unit id="3390" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3391" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type that contains open type parameters, that is, <ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Das aktuelle <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt stellt einen Typ dar, der offene Typparameter enthält. Das bedeutet, dass <ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> den Wert <ph id="ph3">&lt;see langword="true" /&gt;</ph> zurückgibt.</target>       </trans-unit>
        <trans-unit id="3392" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The specified member cannot be invoked on <ph id="ph1">&lt;paramref name="target" /&gt;</ph>.</source>
          <target state="translated">Der angegebene Member kann nicht für <ph id="ph1">&lt;paramref name="target" /&gt;</ph> aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="3393" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>More than one method matches the binding criteria.</source>
          <target state="translated">Mehrere Methoden entsprechen den Bindungskriterien.</target>       </trans-unit>
        <trans-unit id="3394" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>The method represented by <ph id="ph1">&lt;paramref name="name" /&gt;</ph> has one or more unspecified generic type parameters.</source>
          <target state="translated">Die durch <ph id="ph1">&lt;paramref name="name" /&gt;</ph> dargestellte Methode enthält mindestens einen nicht angegebenen generischen Typparameter.</target>       </trans-unit>
        <trans-unit id="3395" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>That is, the method's <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Das bedeutet, dass die <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph>-Eigenschaft der Methode <ph id="ph2">&lt;see langword="true" /&gt;</ph> zurückgibt.</target>       </trans-unit>
        <trans-unit id="3396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>for accessing non-public members regardless of their grant set.</source>
          <target state="translated">Legen Sie für den Zugriff auf nicht öffentliche Member unabhängig von deren Berechtigungssatz.</target>       </trans-unit>
        <trans-unit id="3397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>to call unmanaged code.</source>
          <target state="translated">zum Aufrufen von nicht verwalteten Code.</target>       </trans-unit>
        <trans-unit id="3399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3400" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The string containing the name of the constructor, method, property, or field member to invoke.</source>
          <target state="translated">Die Zeichenfolge, die den Namen des Konstruktors, der Methode, der Eigenschaft oder des Feldmembers enthält, der bzw. die aufgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="3401" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3402" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An empty string ("") to invoke the default member.</source>
          <target state="translated">Eine leere Zeichenfolge ("") zum Aufrufen des Standardmembers.</target>       </trans-unit>
        <trans-unit id="3403" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3404" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph> members, a string representing the DispID, for example "[DispID=3]".</source>
          <target state="translated">Für <ph id="ph1">&lt;see langword="IDispatch" /&gt;</ph>-Member eine Zeichenfolge, die die DispID darstellt, z. B. "[DispID=3]".</target>       </trans-unit>
        <trans-unit id="3405" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A bitmask comprised of one or more <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> that specify how the search is conducted.</source>
          <target state="translated">Eine Bitmaske aus einem oder mehreren <ph id="ph1">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>, die angeben, wie die Suche durchgeführt wird.</target>       </trans-unit>
        <trans-unit id="3406" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The access can be one of the <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> such as <ph id="ph2">&lt;see langword="Public" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, <ph id="ph4">&lt;see langword="Private" /&gt;</ph>, <ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetField" /&gt;</ph>, and so on.</source>
          <target state="translated">Der Zugriff kann aus einem der <ph id="ph1">&lt;see langword="BindingFlags" /&gt;</ph> wie <ph id="ph2">&lt;see langword="Public" /&gt;</ph>, <ph id="ph3">&lt;see langword="NonPublic" /&gt;</ph>, <ph id="ph4">&lt;see langword="Private" /&gt;</ph>, <ph id="ph5">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetField" /&gt;</ph> usw. bestehen.</target>       </trans-unit>
        <trans-unit id="3407" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The type of lookup need not be specified.</source>
          <target state="translated">Die Art der Suche muss nicht angegeben werden.</target>       </trans-unit>
        <trans-unit id="3408" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If the type of lookup is omitted, <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph> are used.</source>
          <target state="translated">Wenn die Art der Suche nicht angegeben ist, werden <ph id="ph1">&lt;see langword="BindingFlags.Public" /&gt;</ph><ph id="ph2"> | </ph><ph id="ph3">&lt;see langword="BindingFlags.Instance" /&gt;</ph><ph id="ph4"> | </ph><ph id="ph5">&lt;see langword="BindingFlags.Static" /&gt;</ph> verwendet.</target>       </trans-unit>
        <trans-unit id="3409" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</source>
          <target state="translated">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.</target>       </trans-unit>
        <trans-unit id="3410" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3411" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A null reference (Nothing in Visual Basic), to use the <ph id="ph1">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph>.</source>
          <target state="translated">Ein Nullverweis (Nothing in Visual Basic), wenn <ph id="ph1">&lt;see cref="P:System.Type.DefaultBinder" /&gt;</ph> verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="3412" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Note that explicitly defining a <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph> object may be required for successfully invoking method overloads with variable arguments.</source>
          <target state="translated">Beachten Sie, dass möglicherweise ein <ph id="ph1">&lt;see cref="T:System.Reflection.Binder" /&gt;</ph>-Objekt explizit definiert werden muss, um erfolgreich Methodenüberladungen mit Variablenargumenten aufrufen zu können.</target>       </trans-unit>
        <trans-unit id="3413" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The object on which to invoke the specified member.</source>
          <target state="translated">Das Objekt, für das der angegebene Member aufgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="3414" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array containing the arguments to pass to the member to invoke.</source>
          <target state="translated">Ein Array mit den Argumenten, die dem aufzurufenden Member übergeben werden sollen.</target>       </trans-unit>
        <trans-unit id="3415" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array of <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> array.</source>
          <target state="translated">Ein Array von <ph id="ph1">&lt;see cref="T:System.Reflection.ParameterModifier" /&gt;</ph>-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept>-Array zugeordnet sind.</target>       </trans-unit>
        <trans-unit id="3416" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A parameter's associated attributes are stored in the member's signature.</source>
          <target state="translated">Die einem Parameter zugeordneten Attribute werden in der Signatur des Members gespeichert.</target>       </trans-unit>
        <trans-unit id="3417" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The default binder processes this parameter only when calling a COM component.</source>
          <target state="translated">Der Standardbinder verarbeitet diesen Parameter nur, wenn eine COM-Komponente aufgerufen wird.</target>       </trans-unit>
        <trans-unit id="3418" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>-Objekt, das das zu verwendende Globalisierungsgebietsschema darstellt, das für gebietsspezifische Konvertierungen wie die Konvertierung einer numerischen Zeichenfolge in einen Double erforderlich sein kann.</target>       </trans-unit>
        <trans-unit id="3419" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3420" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A null reference (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic) to use the current thread's <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph>.</source>
          <target state="translated">Ein Nullverweis (<ph id="ph1">&lt;see langword="Nothing" /&gt;</ph> in Visual Basic), wenn die <ph id="ph2">&lt;see cref="T:System.Globalization.CultureInfo" /&gt;</ph> des aktuellen Threads verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="3421" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An array containing the names of the parameters to which the values in the <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept> array are passed.</source>
          <target state="translated">Ein Array mit den Namen der Parameter, an die die Werte des <bpt id="p1">&lt;c&gt;</bpt>args<ept id="p1">&lt;/c&gt;</ept>-Arrays übergeben werden.</target>       </trans-unit>
        <trans-unit id="3422" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.</source>
          <target state="translated">Ruft nach Überschreiben in einer abgeleiteten Klasse den angegebenen Member auf, der den angegebenen Bindungseinschränkungen sowie der angegebenen Argumentliste, den Modifizierern und der Kultur entspricht.</target>       </trans-unit>
        <trans-unit id="3423" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>An object representing the return value of the invoked member.</source>
          <target state="translated">Ein Objekt, das den Rückgabewert des aufgerufenen Members darstellt.</target>       </trans-unit>
        <trans-unit id="3424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`InvokeMember`</ph> calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member.</source>
          <target state="translated"><ph id="ph1">`InvokeMember`</ph> Mitglied Konstruktor oder eine Methodenmember aufruft, ruft ab oder legt ein Eigenschaftenelement, ruft ab oder legt einen Feldmember Daten oder abgerufen oder festgelegt ein Element von einen Arraymember angeben.</target>       </trans-unit>
        <trans-unit id="3425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>You cannot use <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> to invoke a generic method.</source>
          <target state="translated">Sie können keine <ph id="ph1">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> um eine generische Methode aufrufen.</target>       </trans-unit>
        <trans-unit id="3426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>When you invoke an <ph id="ph1">`IDispatch`</ph> member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</source>
          <target state="translated">Beim Aufruf einer <ph id="ph1">`IDispatch`</ph> Member können Sie angeben, die DispID anstelle der Elementname, verwenden das Format der Zeichenfolge "[DispID = ##]".</target>       </trans-unit>
        <trans-unit id="3427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</source>
          <target state="translated">Beispielsweise, wenn die DispID MyComMethod 3 ist, können Sie angeben die Zeichenfolge "[DispID = 3]" statt "MyComMethod".</target>       </trans-unit>
        <trans-unit id="3428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Invoking a member by DispID is faster than looking up the member by name.</source>
          <target state="translated">Der Aufruf eines Members durch DispID ist schneller als das Element anhand des Namens nachschlagen.</target>       </trans-unit>
        <trans-unit id="3429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</source>
          <target state="translated">In komplexen Aggregation Szenarien ist die DispID in einigen Fällen die einzige Möglichkeit zum Aufrufen des gewünschten Mitglieds an.</target>       </trans-unit>
        <trans-unit id="3430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Although the default binder does not process <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> or <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> (the <ph id="ph3">`modifiers`</ph> and <ph id="ph4">`culture`</ph> parameters), you can use the abstract <ph id="ph5">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> class to write a custom binder that does process <ph id="ph6">`modifiers`</ph> and <ph id="ph7">`culture`</ph>.</source>
          <target state="translated">Obwohl der Standardbinder nicht verarbeitet <ph id="ph1">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> oder <ph id="ph2">&lt;xref:System.Globalization.CultureInfo&gt;</ph> (die <ph id="ph3">`modifiers`</ph> und <ph id="ph4">`culture`</ph> Parameter), können Sie die abstrakte <ph id="ph5">&lt;xref:System.Reflection.Binder?displayProperty=nameWithType&gt;</ph> Klasse, um einen benutzerdefinierten Binder zu schreiben, die verarbeitet werden <ph id="ph6">`modifiers`</ph> und <ph id="ph7">`culture`</ph>.</target>       </trans-unit>
        <trans-unit id="3431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.</source>
          <target state="translated"><ph id="ph1">`ParameterModifier`</ph> wird nur verwendet werden, wenn der Aufruf über COM-Interop und nur als Verweis übergebenen Parameter behandelt.</target>       </trans-unit>
        <trans-unit id="3432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Each parameter in the <ph id="ph1">`namedParameters`</ph> array gets the value in the corresponding element in the <ph id="ph2">`args`</ph> array.</source>
          <target state="translated">Jeder Parameter im <ph id="ph1">`namedParameters`</ph>-Array ruft den Wert aus dem entsprechenden Element im <ph id="ph2">`args`</ph>-Array ab.</target>       </trans-unit>
        <trans-unit id="3433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If the length of <ph id="ph1">`args`</ph> is greater than the length of <ph id="ph2">`namedParameters`</ph>, the remaining argument values are passed in order.</source>
          <target state="translated">Wenn die Länge von <ph id="ph1">`args`</ph> größer als die Länge von <ph id="ph2">`namedParameters`</ph> ist, werden die restlichen Argumentwerte in der bestehenden Reihenfolge übergeben.</target>       </trans-unit>
        <trans-unit id="3434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The <ph id="ph1">`namedParameters`</ph> array can be used to change the order of arguments in an input array.</source>
          <target state="translated">Die <ph id="ph1">`namedParameters`</ph> Array kann verwendet werden, um die Reihenfolge der Argumente in der ein Eingabearray zu ändern.</target>       </trans-unit>
        <trans-unit id="3435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For example, given the method <ph id="ph1">`M(string a, int b)`</ph> (<ph id="ph2">`M(ByVal a As String, ByVal b As Integer)`</ph> in Visual Basic) and the input array <ph id="ph3">`{ 42, "x" }`</ph>, the input array can be passed unchanged to <ph id="ph4">`args`</ph> if the array <ph id="ph5">`{ "b", "a" }`</ph> is supplied for <ph id="ph6">`namedParameters`</ph>.</source>
          <target state="translated">Angenommen, die Methode <ph id="ph1">`M(string a, int b)`</ph> (<ph id="ph2">`M(ByVal a As String, ByVal b As Integer)`</ph> in Visual Basic) und das Eingabearray <ph id="ph3">`{ 42, "x" }`</ph>, das Eingabearray unverändert an den übergeben werden kann <ph id="ph4">`args`</ph> Wenn das Array <ph id="ph5">`{ "b", "a" }`</ph> angegeben wird, für die <ph id="ph6">`namedParameters`</ph>.</target>       </trans-unit>
        <trans-unit id="3436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Filterkennzeichnungen genutzt werden, welche Member in die Suche einbezogen werden:</target>       </trans-unit>
        <trans-unit id="3437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Specify <ph id="ph1">`BindingFlags.Public`</ph> to include public members in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.Public`</ph> auf öffentliche Member in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="3438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Specify <ph id="ph1">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.NonPublic`</ph> auf nicht öffentliche Member (d. h. private, interne und geschützte Member) in die Suche einbeziehen.</target>       </trans-unit>
        <trans-unit id="3439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Specify <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> to include static members up the hierarchy.</source>
          <target state="translated">Geben Sie <ph id="ph1">`BindingFlags.FlattenHierarchy`</ph> statische Mitglieder der Hierarchie aufwärts eingeschlossen werden sollen.</target>       </trans-unit>
        <trans-unit id="3440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Modifiziererflags können verwendet werden, um die ändern, wie die Suche funktioniert:</target>       </trans-unit>
        <trans-unit id="3441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id="ph2">`name`</ph>.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.IgnoreCase`</ph> um die Groß-/Kleinschreibung ignorieren <ph id="ph2">`name`</ph>.</target>       </trans-unit>
        <trans-unit id="3442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id="ph2">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.</source>
          <target state="translated"><ph id="ph1">`BindingFlags.DeclaredOnly`</ph> Suche nur die deklarierten Member der <ph id="ph2">&lt;xref:System.Type&gt;</ph>, nicht die Elemente, die nur geerbt wurden.</target>       </trans-unit>
        <trans-unit id="3443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The following <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> invocation flags can be used to denote what action to take with the member:</source>
          <target state="translated">Die folgenden <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Aufrufflags genutzt werden, welche Aktion für das Element ausführen soll:</target>       </trans-unit>
        <trans-unit id="3444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`CreateInstance`</ph> to invoke a constructor.</source>
          <target state="translated"><ph id="ph1">`CreateInstance`</ph> Um einen Konstruktor aufzurufen.</target>       </trans-unit>
        <trans-unit id="3445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`name`</ph> is ignored.</source>
          <target state="translated"><ph id="ph1">`name`</ph> wird ignoriert.</target>       </trans-unit>
        <trans-unit id="3446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with other invocation flags.</source>
          <target state="translated">Mit anderen Aufrufflags ist ungültig.</target>       </trans-unit>
        <trans-unit id="3447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`InvokeMethod`</ph> to invoke a method, but not a constructor or a type initializer.</source>
          <target state="translated"><ph id="ph1">`InvokeMethod`</ph> Aufrufen einer Methode, jedoch nicht auf einen Konstruktor oder Typinitialisierer</target>       </trans-unit>
        <trans-unit id="3448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with <ph id="ph1">`SetField`</ph> or <ph id="ph2">`SetProperty`</ph>.</source>
          <target state="translated">Ungültig mit <ph id="ph1">`SetField`</ph> oder <ph id="ph2">`SetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If <ph id="ph1">`InvokeMethod`</ph> is specified by itself, <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, and <ph id="ph4">`BindingFlags.Static`</ph> are automatically included.</source>
          <target state="translated">Wenn <ph id="ph1">`InvokeMethod`</ph> angegeben wird, <ph id="ph2">`BindingFlags.Public`</ph>, <ph id="ph3">`BindingFlags.Instance`</ph>, und <ph id="ph4">`BindingFlags.Static`</ph> werden automatisch mit eingeschlossen.</target>       </trans-unit>
        <trans-unit id="3450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`GetField`</ph> to get the value of a field.</source>
          <target state="translated"><ph id="ph1">`GetField`</ph> den Wert eines Felds abgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="3451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with <ph id="ph1">`SetField`</ph>.</source>
          <target state="translated">Ungültig mit <ph id="ph1">`SetField`</ph>.</target>       </trans-unit>
        <trans-unit id="3452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`SetField`</ph> to set the value of a field.</source>
          <target state="translated"><ph id="ph1">`SetField`</ph> den Wert eines Felds festgelegt.</target>       </trans-unit>
        <trans-unit id="3453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with <ph id="ph1">`GetField`</ph>.</source>
          <target state="translated">Ungültig mit <ph id="ph1">`GetField`</ph>.</target>       </trans-unit>
        <trans-unit id="3454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`GetProperty`</ph> to get a property.</source>
          <target state="translated"><ph id="ph1">`GetProperty`</ph> zum Abrufen einer Eigenschaft.</target>       </trans-unit>
        <trans-unit id="3455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with <ph id="ph1">`SetProperty`</ph>.</source>
          <target state="translated">Ungültig mit <ph id="ph1">`SetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`SetProperty`</ph> to set a property.</source>
          <target state="translated"><ph id="ph1">`SetProperty`</ph> Festlegen von Eigenschaften.</target>       </trans-unit>
        <trans-unit id="3457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Not valid with <ph id="ph1">`GetProperty`</ph>.</source>
          <target state="translated">Ungültig mit <ph id="ph1">`GetProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="3458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>See <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph> for more information.</source>
          <target state="translated">Weitere Informationen finden Sie unter <ph id="ph1">&lt;xref:System.Reflection.BindingFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>A method will be invoked if both of the following conditions are true:</source>
          <target state="translated">Eine Methode wird aufgerufen, wenn beide der folgenden Bedingungen zutreffen:</target>       </trans-unit>
        <trans-unit id="3460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The number of parameters in the method declaration equals the number of arguments in the <ph id="ph1">`args`</ph> array (unless default arguments are defined on the member and <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> is specified).</source>
          <target state="translated">Die Anzahl von Parametern in der Deklaration der Methode entspricht der Anzahl der Argumente in der <ph id="ph1">`args`</ph> Array (, wenn Standardargumente für das Element definiert sind und <ph id="ph2">`BindingFlags.OptionalParamBinding`</ph> angegeben ist).</target>       </trans-unit>
        <trans-unit id="3461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The type of each argument can be converted by the binder to the type of the parameter.</source>
          <target state="translated">Der Typ jedes Arguments kann vom Binder in den Typ des Parameters konvertiert werden.</target>       </trans-unit>
        <trans-unit id="3462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The binder will find all of the matching methods.</source>
          <target state="translated">Der Binder findet alle übereinstimmenden Methoden.</target>       </trans-unit>
        <trans-unit id="3463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>These methods are found based upon the type of binding requested (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> values <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>, and so on).</source>
          <target state="translated">Diese Methoden werden basierend auf den Typ der Bindung, die angeforderte gefunden (<ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> Werte <ph id="ph2">`InvokeMethod`</ph>, <ph id="ph3">`GetProperty`</ph>usw.).</target>       </trans-unit>
        <trans-unit id="3464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</source>
          <target state="translated">Der Satz von Methoden wird durch den Namen, Anzahl von Argumenten und einen Satz von Suchabfragen in der Binder definierten gefiltert.</target>       </trans-unit>
        <trans-unit id="3465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>After the method is selected, it is invoked.</source>
          <target state="translated">Wenn die Methode ausgewählt wurde, wird er aufgerufen.</target>       </trans-unit>
        <trans-unit id="3466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Accessibility is checked at that point.</source>
          <target state="translated">Eingabehilfen ist an diesem Punkt aktiviert.</target>       </trans-unit>
        <trans-unit id="3467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</source>
          <target state="translated">Die Suche kann gesteuert werden durchsucht, welchen Satz von Methoden basierend auf der Eingabehilfen-Attribut, das der Methode zugeordnet.</target>       </trans-unit>
        <trans-unit id="3468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> method of the <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> class is responsible for selecting the method to be invoked.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType&gt;</ph> Methode von der <ph id="ph2">&lt;xref:System.Reflection.Binder&gt;</ph> -Klasse ist verantwortlich für die Auswahl der Methode, die aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="3469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The default binder selects the most specific match.</source>
          <target state="translated">Der Standardbinder wählt die spezifischste Übereinstimmung.</target>       </trans-unit>
        <trans-unit id="3470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">`InvokeMember`</ph> can be used to invoke methods with parameters that have default values.</source>
          <target state="translated"><ph id="ph1">`InvokeMember`</ph> kann verwendet werden, zum Aufrufen von Methoden mit Parametern, die über Standardwerte verfügen.</target>       </trans-unit>
        <trans-unit id="3471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>To bind to these methods, Reflection requires <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType&gt;</ph> to be specified.</source>
          <target state="translated">Um diese Methoden zu binden, muss für die Reflektion <ph id="ph1">&lt;xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType&gt;</ph> angegeben werden.</target>       </trans-unit>
        <trans-unit id="3472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For a parameter that has a default value, you can either supply a different value, or supply <ph id="ph1">&lt;xref:System.Reflection.Missing.Value?displayProperty=nameWithType&gt;</ph> to use the default value.</source>
          <target state="translated">Für einen Parameter, die über einen Standardwert verfügt, können Sie entweder einen anderen Wert angeben oder angeben <ph id="ph1">&lt;xref:System.Reflection.Missing.Value?displayProperty=nameWithType&gt;</ph> auf den Standardwert verwenden.</target>       </trans-unit>
        <trans-unit id="3473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For example, consider a method such as MyMethod(int x, float y = 2.0).</source>
          <target state="translated">Betrachten Sie beispielsweise eine Methode wie MyMethod (Int, x, "float" y = 2.0).</target>       </trans-unit>
        <trans-unit id="3474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and <ph id="ph1">`Missing.Value`</ph> for the second argument.</source>
          <target state="translated">Klicken Sie zum Aufrufen dieser Methode mit nur das erste Argument als MyMethod(4), übergeben Sie eine der oben genannten Bindungsflags und zwei Argumente, d. h. 4 für das erste Argument übergeben und <ph id="ph1">`Missing.Value`</ph> für das zweite Argument.</target>       </trans-unit>
        <trans-unit id="3475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Unless you use <ph id="ph1">`Missing.Value`</ph>, you may not omit optional parameters with the <ph id="ph2">`Invoke`</ph> method.</source>
          <target state="translated">Es sei denn, Sie verwenden <ph id="ph1">`Missing.Value`</ph>, kann nicht ausgelassen werden optionale Parameter mit der <ph id="ph2">`Invoke`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If you must do so, use <ph id="ph1">`InvokeMember`</ph> instead.</source>
          <target state="translated">Wenn Sie dies tun müssen, verwenden <ph id="ph1">`InvokeMember`</ph> stattdessen.</target>       </trans-unit>
        <trans-unit id="3477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <ph id="ph1">&lt;xref:System.Reflection&gt;</ph> whenever the code is fully trusted.</source>
          <target state="translated">Zugriffseinschränkungen werden für vollständig vertrauenswürdige Code ignoriert. d. h. private Konstruktoren, Methoden, Felder und Eigenschaften können zugegriffen und aufgerufene <ph id="ph1">&lt;xref:System.Reflection&gt;</ph> immer der Code vollständig vertrauenswürdig ist.</target>       </trans-unit>
        <trans-unit id="3478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>You can use <ph id="ph1">`Type.InvokeMember`</ph> to set a field to a particular value by specifying <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Sie können <ph id="ph1">`Type.InvokeMember`</ph> auf ein Feld auf einen bestimmten Wert festgelegt wird, durch Angabe <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>For example, if you want to set a public instance field named F on class C, and F is a <ph id="ph1">`String`</ph>, you can use code such as:</source>
          <target state="translated">Beispielsweise, wenn Sie eine öffentliche Instanzenfeld F auf Klasse C und F festlegen möchten ist eine <ph id="ph1">`String`</ph>, können Sie Code wie z. B.:</target>       </trans-unit>
        <trans-unit id="3480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>If F is a <ph id="ph1">`String[]`</ph>, you can use code such as:</source>
          <target state="translated">Wenn F# ist eine <ph id="ph1">`String[]`</ph>, können Sie Code wie z. B.:</target>       </trans-unit>
        <trans-unit id="3481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>which will initialize the field F to this new array.</source>
          <target state="translated">die wird das Feld F für dieses neue Array zu initialisieren.</target>       </trans-unit>
        <trans-unit id="3482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>You can also use <ph id="ph1">`Type.InvokeMember`</ph> to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</source>
          <target state="translated">Sie können auch <ph id="ph1">`Type.InvokeMember`</ph> an eine Position in einem Array festlegen, indem der Index des Werts, und klicken Sie dann den nächsten Wert mit Code wie dem folgenden:</target>       </trans-unit>
        <trans-unit id="3483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This will change string "z" in the array that F holds to string "b".</source>
          <target state="translated">Dadurch wird die Zeichenfolge "Z" in das Array geändert, die in der Zeichenfolge "b" F enthält.</target>       </trans-unit>
        <trans-unit id="3484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, diese Methode kann verwendet werden, auf nicht öffentliche Member zuzugreifen, wenn der Aufrufer erteilt wurde <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType&gt;</ph> kennzeichnen und erteilen Sie der Berechtigungssatz für die nicht öffentlichen Member an des Aufrufers beschränkt ist Set- oder eine Teilmenge davon.</target>       </trans-unit>
        <trans-unit id="3485" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
          <target state="translated">(Siehe <bpt id="p1">[</bpt>Sicherheitsüberlegungen für die Reflektion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="3486" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
          <target state="translated">Zur Verwendung dieser Funktionen sollte die Anwendung für <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> oder höher ausgelegt sein. </target>       </trans-unit>
        <trans-unit id="3487" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> and <ph id="ph3">&lt;paramref name="name" /&gt;</ph> is <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> enthält keine <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="name" /&gt;</ph> ist <ph id="ph4">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3488" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="args" /&gt;</ph> and <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> do not have the same length.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="args" /&gt;</ph> und <ph id="ph2">&lt;paramref name="modifiers" /&gt;</ph> weisen nicht die gleiche Länge auf.</target>       </trans-unit>
        <trans-unit id="3489" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3490" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> is not a valid <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph> attribute.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> ist kein gültiges <ph id="ph2">&lt;see cref="T:System.Reflection.BindingFlags" /&gt;</ph>-Attribut.</target>       </trans-unit>
        <trans-unit id="3491" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3492" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> does not contain one of the following binding flags: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> enthält keines der folgenden Bindungsflags: <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph3">&lt;see langword="CreateInstance" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> oder <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3493" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3494" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph>, or <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> enthält <ph id="ph2">&lt;see langword="CreateInstance" /&gt;</ph> in Kombination mit <ph id="ph3">&lt;see langword="InvokeMethod" /&gt;</ph>, <ph id="ph4">&lt;see langword="GetField" /&gt;</ph>, <ph id="ph5">&lt;see langword="SetField" /&gt;</ph>, <ph id="ph6">&lt;see langword="GetProperty" /&gt;</ph> oder <ph id="ph7">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3495" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3496" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetField" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> enthält sowohl <ph id="ph2">&lt;see langword="GetField" /&gt;</ph> als auch <ph id="ph3">&lt;see langword="SetField" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3497" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3498" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains both <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> and <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> enthält sowohl <ph id="ph2">&lt;see langword="GetProperty" /&gt;</ph> als auch <ph id="ph3">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3499" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3500" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> combined with <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> or <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> enthält <ph id="ph2">&lt;see langword="InvokeMethod" /&gt;</ph> in Kombination mit <ph id="ph3">&lt;see langword="SetField" /&gt;</ph> oder <ph id="ph4">&lt;see langword="SetProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3501" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3502" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> contains <ph id="ph2">&lt;see langword="SetField" /&gt;</ph> and <ph id="ph3">&lt;paramref name="args" /&gt;</ph> has more than one element.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="invokeAttr" /&gt;</ph> enthält <ph id="ph2">&lt;see langword="SetField" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="args" /&gt;</ph> enthält mehr als ein Element.</target>       </trans-unit>
        <trans-unit id="3503" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3504" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The named parameter array is larger than the argument array.</source>
          <target state="translated">Das benannte Parameterarray ist größer als das Argumentarray.</target>       </trans-unit>
        <trans-unit id="3505" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3506" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>This method is called on a COM object and one of the following binding flags was not passed in: <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>, <ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>, <ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>, <ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph>, or <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>.</source>
          <target state="translated">Diese Methode wird für ein COM-Objekt aufgerufen, und eines der folgenden Bindungsflags wurde nicht übergeben: <ph id="ph1">&lt;see langword="BindingFlags.InvokeMethod" /&gt;</ph>, <ph id="ph2">&lt;see langword="BindingFlags.GetProperty" /&gt;</ph>, <ph id="ph3">&lt;see langword="BindingFlags.SetProperty" /&gt;</ph>, <ph id="ph4">&lt;see langword="BindingFlags.PutDispProperty" /&gt;</ph> oder <ph id="ph5">&lt;see langword="BindingFlags.PutRefDispProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3507" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3508" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>One of the named parameter arrays contains a string that is <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Eines der benannten Parameterarrays enthält eine Zeichenfolge, die <ph id="ph1">&lt;see langword="null" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="3509" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The specified member is a class initializer.</source>
          <target state="translated">Der angegebene Member ist ein Klasseninitialisierer.</target>       </trans-unit>
        <trans-unit id="3510" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The field or property cannot be found.</source>
          <target state="translated">Das Feld oder die Eigenschaft wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="3511" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>No method can be found that matches the arguments in <ph id="ph1">&lt;paramref name="args" /&gt;</ph>.</source>
          <target state="translated">Es wurde keine Methode gefunden, die den Argumenten in <ph id="ph1">&lt;paramref name="args" /&gt;</ph> entspricht.</target>       </trans-unit>
        <trans-unit id="3512" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3513" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>No member can be found that has the argument names supplied in <ph id="ph1">&lt;paramref name="namedParameters" /&gt;</ph>.</source>
          <target state="translated">Es wurde kein Member gefunden, dessen Argumentnamen in <ph id="ph1">&lt;paramref name="namedParameters" /&gt;</ph> angegeben sind.</target>       </trans-unit>
        <trans-unit id="3514" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3515" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type that contains open type parameters, that is, <ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Das aktuelle <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt stellt einen Typ dar, der offene Typparameter enthält. Das bedeutet, dass <ph id="ph2">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> den Wert <ph id="ph3">&lt;see langword="true" /&gt;</ph> zurückgibt.</target>       </trans-unit>
        <trans-unit id="3516" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The specified member cannot be invoked on <ph id="ph1">&lt;paramref name="target" /&gt;</ph>.</source>
          <target state="translated">Der angegebene Member kann nicht für <ph id="ph1">&lt;paramref name="target" /&gt;</ph> aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="3517" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>More than one method matches the binding criteria.</source>
          <target state="translated">Mehrere Methoden entsprechen den Bindungskriterien.</target>       </trans-unit>
        <trans-unit id="3518" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>The method represented by <ph id="ph1">&lt;paramref name="name" /&gt;</ph> has one or more unspecified generic type parameters.</source>
          <target state="translated">Die durch <ph id="ph1">&lt;paramref name="name" /&gt;</ph> dargestellte Methode enthält mindestens einen nicht angegebenen generischen Typparameter.</target>       </trans-unit>
        <trans-unit id="3519" translate="yes" xml:space="preserve" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>That is, the method's <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph> property returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Das bedeutet, dass die <ph id="ph1">&lt;see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /&gt;</ph>-Eigenschaft der Methode <ph id="ph2">&lt;see langword="true" /&gt;</ph> zurückgibt.</target>       </trans-unit>
        <trans-unit id="3520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>for accessing non-public members regardless of their grant set.</source>
          <target state="translated">Legen Sie für den Zugriff auf nicht öffentliche Member unabhängig von deren Berechtigungssatz.</target>       </trans-unit>
        <trans-unit id="3521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>to call unmanaged code.</source>
          <target state="translated">zum Aufrufen von nicht verwalteten Code.</target>       </trans-unit>
        <trans-unit id="3523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="3524" translate="yes" xml:space="preserve" uid="P:System.Type.IsAbstract">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is abstract and must be overridden.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> abstrakt ist und überschrieben werden muss.</target>       </trans-unit>
        <trans-unit id="3525" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is abstract; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> abstrakt ist, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3526" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsAbstract%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> in the following cases:</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.IsAbstract%2A&gt;</ph> -Eigenschaft gibt <ph id="ph2">`true`</ph> in den folgenden Fällen:</target>       </trans-unit>
        <trans-unit id="3527" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>The current type is abstract; that is, it cannot be instantiated, but can only serve as the base class for derived classes.</source>
          <target state="translated">Der aktuelle Typ ist abstrakt. d. h. kann nicht instanziiert werden, aber kann nur als Basisklasse für abgeleitete Klassen dienen.</target>       </trans-unit>
        <trans-unit id="3528" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>In C#, abstract classes are marked with the <bpt id="p1">[</bpt>abstract<ept id="p1">](~/docs/csharp/language-reference/keywords/abstract.md)</ept> keyword; in Visual Basic, they are marked with the <bpt id="p2">[</bpt>MustInherit<ept id="p2">](~/docs/visual-basic/language-reference/modifiers/mustinherit.md)</ept> keyword.</source>
          <target state="translated">Abstrakte Klassen werden in c# mit markiert die <bpt id="p1">[</bpt>abstrakte<ept id="p1">](~/docs/csharp/language-reference/keywords/abstract.md)</ept> Schlüsselwort in Visual Basic markiert sind mit den <bpt id="p2">[</bpt>MustInherit<ept id="p2">](~/docs/visual-basic/language-reference/modifiers/mustinherit.md)</ept> Schlüsselwort.</target>       </trans-unit>
        <trans-unit id="3529" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>The current type is an interface.</source>
          <target state="translated">Der aktuelle Typ ist eine Schnittstelle.</target>       </trans-unit>
        <trans-unit id="3530" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3531" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>The following example creates an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects that represent the following types:contains type returns <ph id="ph2">`true`</ph> if the specified object is <ph id="ph3">`abstract`</ph>; otherwise, it returns <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Das folgende Beispiel erstellt ein Array von <ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekte, die die folgenden Typen darstellen: Typ gibt enthält <ph id="ph2">`true`</ph> , wenn das angegebene Objekt <ph id="ph3">`abstract`</ph>ist, andernfalls gibt <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3532" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">`AbstractClass`</ph>, an abstract class (a class marked as <ph id="ph2">`abstract`</ph> in C# and <ph id="ph3">`MustInherit`</ph> in Visual Basic).</source>
          <target state="translated"><ph id="ph1">`AbstractClass`</ph>, eine abstrakte Klasse (eine Klasse als markiert <ph id="ph2">`abstract`</ph> in C# geschrieben und <ph id="ph3">`MustInherit`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="3533" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">`DerivedClass`</ph>, a class that inherits from <ph id="ph2">`AbstractClass`</ph>.</source>
          <target state="translated"><ph id="ph1">`DerivedClass`</ph>, eine Klasse, die von erben <ph id="ph2">`AbstractClass`</ph>.</target>       </trans-unit>
        <trans-unit id="3534" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">`SingleClass`</ph>, a non-inheritable class.</source>
          <target state="translated"><ph id="ph1">`SingleClass`</ph>, einer nicht vererbbaren Klasse.</target>       </trans-unit>
        <trans-unit id="3535" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>It is defined as <ph id="ph1">`sealed`</ph> in C# and <ph id="ph2">`NotInheritable`</ph> in Visual Basic.</source>
          <target state="translated">Es ist definiert als <ph id="ph1">`sealed`</ph> in C# geschrieben und <ph id="ph2">`NotInheritable`</ph> in Visual Basic.</target>       </trans-unit>
        <trans-unit id="3536" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">`ITypeInfo`</ph>, an interface.</source>
          <target state="translated"><ph id="ph1">`ITypeInfo`</ph>, eine Schnittstelle.</target>       </trans-unit>
        <trans-unit id="3537" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source><ph id="ph1">`ImplementingClass`</ph>, a class that implements the <ph id="ph2">`ITypeInfo`</ph> interface.</source>
          <target state="translated"><ph id="ph1">`ImplementingClass`</ph>, eine Klasse, implementiert die <ph id="ph2">`ITypeInfo`</ph> Schnittstelle.</target>       </trans-unit>
        <trans-unit id="3538" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAbstract">
          <source>The method returns <ph id="ph1">`true`</ph> only for <ph id="ph2">`AbstractClass`</ph>, the abstract class, and <ph id="ph3">`ITypeInfo`</ph>, the interface.</source>
          <target state="translated">Gibt die Methode <ph id="ph1">`true`</ph> nur für <ph id="ph2">`AbstractClass`</ph>, die abstrakte Klasse und <ph id="ph3">`ITypeInfo`</ph>, die Schnittstelle.</target>       </trans-unit>
        <trans-unit id="3539" translate="yes" xml:space="preserve" uid="P:System.Type.IsAnsiClass">
          <source>Gets a value indicating whether the string format attribute <ph id="ph1">&lt;see langword="AnsiClass" /&gt;</ph> is selected for the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob für <ph id="ph1">&lt;see langword="AnsiClass" /&gt;</ph> das Zeichenfolgenformatattribut <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> ausgewählt ist.</target>       </trans-unit>
        <trans-unit id="3540" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the string format attribute <ph id="ph2">&lt;see langword="AnsiClass" /&gt;</ph> is selected for the <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn für <ph id="ph2">&lt;see langword="AnsiClass" /&gt;</ph> das Zeichenfolgenformatattribut <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> ausgewählt ist, andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3541" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> selects the string format attributes.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> wählt die Zeichenfolgenformatattribute.</target>       </trans-unit>
        <trans-unit id="3542" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>The string format attributes enhance interoperability by defining how strings should be interpreted.</source>
          <target state="translated">Die Zeichenfolge Formatattribute zur Verbesserung der Interoperabilität von definieren, wie Zeichenfolgen interpretiert werden sollen.</target>       </trans-unit>
        <trans-unit id="3543" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, this property pertains to the generic type definition from which the type was constructed.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein generischer Typ, der diese Eigenschaft bezieht sich auf die generische Typdefinition, aus der der Typ konstruiert wurde.</target>       </trans-unit>
        <trans-unit id="3544" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Z. B. wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), der Wert dieser Eigenschaft richtet sich nach <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3545" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3546" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAnsiClass">
          <source>The following example gets the field information and checks for the <ph id="ph1">`AnsiClass`</ph> attribute.</source>
          <target state="translated">Im folgenden Beispiel ruft die Feldinformationen ab und überprüft, ob die <ph id="ph1">`AnsiClass`</ph> Attribut.</target>       </trans-unit>
        <trans-unit id="3547" translate="yes" xml:space="preserve" uid="P:System.Type.IsArray">
          <source>Gets a value that indicates whether the type is an array.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der Typ ein Array ist.</target>       </trans-unit>
        <trans-unit id="3548" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is an array; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der aktuelle Typ ein Array ist, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3549" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsArray%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for the <ph id="ph3">&lt;xref:System.Array&gt;</ph> class.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.IsArray%2A&gt;</ph> -Eigenschaft gibt <ph id="ph2">`false`</ph> für die <ph id="ph3">&lt;xref:System.Array&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="3550" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>It also returns <ph id="ph1">`false`</ph> if the current instance is a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents a collection type or an interface designed to work with collections, such as <ph id="ph3">&lt;xref:System.Collections.IEnumerable&gt;</ph> or <ph id="ph4">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.</source>
          <target state="translated">Sie gibt überdies <ph id="ph1">`false`</ph> , wenn die aktuelle Instanz ist eine <ph id="ph2">&lt;xref:System.Type&gt;</ph> Objekt, das einen Auflistungstyp oder eine Schnittstelle, die Auflistungen, wie z. B. ausgelegt darstellt <ph id="ph3">&lt;xref:System.Collections.IEnumerable&gt;</ph> oder <ph id="ph4">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3551" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>To check for an array, use code such as:</source>
          <target state="translated">Verwenden Sie z. B. Code, um ein Array zu prüfen:</target>       </trans-unit>
        <trans-unit id="3552" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>If the current type represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph1">`false`</ph>.</source>
          <target state="translated">Wenn der aktuelle Typ ein generischer Typ oder ein Typparameter in der Definition einer generischen Typ- oder Methodendefinition darstellt, gibt diese Eigenschaft immer <ph id="ph1">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3553" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>This property is read-only.</source>
          <target state="translated">Diese Eigenschaft ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="3554" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsArray">
          <source>The following example demonstrates using the <ph id="ph1">&lt;xref:System.Type.IsArray%2A&gt;</ph> property.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung der <ph id="ph1">&lt;xref:System.Type.IsArray%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="3555" translate="yes" xml:space="preserve" uid="M:System.Type.IsArrayImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.IsArray" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array.</source>
          <target state="translated">Implementiert beim Überschreiben in einer abgeleiteten Klasse die <ph id="ph1">&lt;see cref="P:System.Type.IsArray" /&gt;</ph>-Eigenschaft und bestimmt, ob <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> ein Array ist.</target>       </trans-unit>
        <trans-unit id="3556" translate="yes" xml:space="preserve" uid="M:System.Type.IsArrayImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an array; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> ein Array ist, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsArrayImpl">
          <source>An instance of the <ph id="ph1">&lt;xref:System.Array&gt;</ph> class must return <ph id="ph2">`false`</ph> because it is an object, not an array.</source>
          <target state="translated">Eine Instanz von der <ph id="ph1">&lt;xref:System.Array&gt;</ph> Klasse zurückgeben muss <ph id="ph2">`false`</ph> , da es sich um ein Objekt, das kein Array ist.</target>       </trans-unit>
        <trans-unit id="3558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsArrayImpl">
          <source>The following example overrides the <ph id="ph1">`IsArrayImpl`</ph> method in the <ph id="ph2">`MyTypeDelegator`</ph> class, checks if a variable is an array, and displays the result.</source>
          <target state="translated">Im folgende Beispiel überschreibt die <ph id="ph1">`IsArrayImpl`</ph> Methode in der <ph id="ph2">`MyTypeDelegator`</ph> -Klasse überprüft, ob eine Variable ein Array ist, und das Ergebnis wird angezeigt.</target>       </trans-unit>
        <trans-unit id="3559" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>The type to compare with the current type.</source>
          <target state="translated">Der Typ, der mit dem aktuellen Typ verglichen werden soll.</target>       </trans-unit>
        <trans-unit id="3560" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>Determines whether an instance of a specified type can be assigned to an instance of the current type.</source>
          <target state="translated">Bestimmt, ob eine Instanz des angegebenen Typs der Instanz des aktuellen Typs zugewiesen werden kann</target>       </trans-unit>
        <trans-unit id="3561" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if any of the following conditions is true:</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn eine der folgenden Bedingungen erfüllt ist:</target>       </trans-unit>
        <trans-unit id="3562" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> and the current instance represent the same type.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> und die aktuelle Instanz haben denselben Typ.</target>       </trans-unit>
        <trans-unit id="3563" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is derived either directly or indirectly from the current instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> ist entweder direkt oder indirekt von der aktuellen Instanz abgeleitet.</target>       </trans-unit>
        <trans-unit id="3564" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is derived directly from the current instance if it inherits from the current instance; <ph id="ph2">&lt;paramref name="c" /&gt;</ph> is derived indirectly from the current instance if it inherits from a succession of one or more classes that inherit from the current instance.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> wird direkt von der aktuellen Instanz abgeleitet, wenn es von der aktuellen Instanz erbt; <ph id="ph2">&lt;paramref name="c" /&gt;</ph> wird indirekt von der aktuellen Instanz abgeleitet, wenn es von einer Folge von einer oder mehr Klassen erbt, die von der aktuellen Instanz erben.</target>       </trans-unit>
        <trans-unit id="3565" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>The current instance is an interface that <ph id="ph1">&lt;paramref name="c" /&gt;</ph> implements.</source>
          <target state="translated">Die aktuelle Instanz ist eine Schnittstelle, die von <ph id="ph1">&lt;paramref name="c" /&gt;</ph> implementiert wird.</target>       </trans-unit>
        <trans-unit id="3566" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is a generic type parameter, and the current instance represents one of the constraints of <ph id="ph2">&lt;paramref name="c" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> ist ein generischer Typparameter, und die aktuelle Instanz stellt eine der Einschränkungen von <ph id="ph2">&lt;paramref name="c" /&gt;</ph> dar.</target>       </trans-unit>
        <trans-unit id="3567" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>In the following example, the current instance is a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> class.</source>
          <target state="translated">Im folgenden Beispiel handelt es sich bei der aktuellen Instanz um ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt, das die Klasse <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> darstellt.</target>       </trans-unit>
        <trans-unit id="3568" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><bpt id="p1">&lt;c&gt;</bpt>GenericWithConstraint<ept id="p1">&lt;/c&gt;</ept> is a generic type whose generic type parameter must be of type    <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph>.</source>
          <target state="translated">Bei <bpt id="p1">&lt;c&gt;</bpt>GenericWithConstraint<ept id="p1">&lt;/c&gt;</ept> handel es sich um einen generische Typ, dessen generischer Typparameter vom Typ <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> sein muss.</target>       </trans-unit>
        <trans-unit id="3569" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>Passing its generic type parameter to the <ph id="ph1">&lt;see cref="M:System.Type.IsAssignableFrom(System.Type)" /&gt;</ph> indicates that  an instance of the generic type parameter can be assigned to an <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph> object.</source>
          <target state="translated">Wenn der generische Typparameter an <ph id="ph1">&lt;see cref="M:System.Type.IsAssignableFrom(System.Type)" /&gt;</ph> übergeben wird,zeigt dies, dass eine Instanz des generischen Typparameters einem <ph id="ph2">&lt;see cref="T:System.IO.Stream" /&gt;</ph>-Objekt zugewiesen werden kann.</target>       </trans-unit>
        <trans-unit id="3570" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> represents a value type, and the current instance represents <bpt id="p1">&lt;c&gt;</bpt>Nullable<ph id="ph2">&amp;lt;</ph>c<ph id="ph3">&amp;gt;</ph><ept id="p1">&lt;/c&gt;</ept> (<bpt id="p2">&lt;c&gt;</bpt>Nullable(Of c)<ept id="p2">&lt;/c&gt;</ept> in Visual Basic).</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> stellt einen Werttyp dar, und die aktuelle Instanz stellt <bpt id="p1">&lt;c&gt;</bpt>Nullable<ph id="ph2">&amp;lt;</ph>c<ph id="ph3">&amp;gt;</ph><ept id="p1">&lt;/c&gt;</ept> (<bpt id="p2">&lt;c&gt;</bpt>Nullable(Of c)<ept id="p2">&lt;/c&gt;</ept> in Visual Basic) dar.</target>       </trans-unit>
        <trans-unit id="3571" translate="yes" xml:space="preserve" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if none of these conditions are true, or if <ph id="ph2">&lt;paramref name="c" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>, wenn keine dieser Bedingungen erfüllt sind oder wenn <ph id="ph2">&lt;paramref name="c" /&gt;</ph> <ph id="ph3">&lt;see langword="null" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="3572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph> method can be used to determine whether an instance of <ph id="ph2">`c`</ph> can be assigned to an instance of the current type, The method is most useful when you are handling objects whose types are not known at design time and allows for conditional assignment, as the following example shows.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph> Methode kann verwendet werden, um zu bestimmen, ob eine Instanz von <ph id="ph2">`c`</ph> zugewiesen werden kann mit einer Instanz des aktuellen Typs, die Methode eignet sich am besten, wenn Sie Objekte verarbeiten, deren Typen zur Entwurfszeit nicht bekannt sind, und ermöglicht die bedingte Zuweisung, wie im folgenden Beispiel veranschaulicht.</target>       </trans-unit>
        <trans-unit id="3573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>This method thus ensures that a line of code like the following will execute at runtime without throwing an <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> exception or a similar exception:</source>
          <target state="translated">Diese Methode somit wird sichergestellt, dass eine Codezeile wie Folgendes zur Laufzeit, ohne Auslösen ausgeführt wird einer <ph id="ph1">&lt;xref:System.InvalidCastException&gt;</ph> Ausnahme oder eine ähnliche Ausnahme:</target>       </trans-unit>
        <trans-unit id="3574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.</target>       </trans-unit>
        <trans-unit id="3575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>A generic type definition is not assignable from a closed constructed type.</source>
          <target state="translated">Eine generische Typdefinition ist nicht von einem geschlossenen konstruierten Typ zugewiesen werden.</target>       </trans-unit>
        <trans-unit id="3576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>That is, you cannot assign the closed constructed type <ph id="ph1">`MyGenericList&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericList(Of Integer)`</ph> in Visual Basic) to a variable of type <ph id="ph3">`MyGenericList&lt;T&gt;`</ph>.</source>
          <target state="translated">D. h. Sie geschlossenen konstruierten Typs zuweisen können nicht <ph id="ph1">`MyGenericList&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericList(Of Integer)`</ph> in Visual Basic) einer Variablen vom Typ <ph id="ph3">`MyGenericList&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>If the <ph id="ph1">`c`</ph> parameter is of type <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>, the result is based on the type that is to be built.</source>
          <target state="translated">Wenn die <ph id="ph1">`c`</ph> Parameter ist vom Typ <ph id="ph2">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>, das Ergebnis wird auf Grundlage des Typs, die erstellt werden soll.</target>       </trans-unit>
        <trans-unit id="3578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>The following code example demonstrates this using a built type named <ph id="ph1">`B`</ph>.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, dies mithilfe eines integrierten Typs mit dem Namen <ph id="ph1">`B`</ph>.</target>       </trans-unit>
        <trans-unit id="3579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsAssignableFrom(System.Type)">
          <source>The following example demonstrates the <ph id="ph1">`IsAssignableFrom`</ph> method using defined classes, integer arrays, and generics.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">`IsAssignableFrom`</ph> -Methode definiert Klassen, Arrays Ganzzahlen und Generika.</target>       </trans-unit>
        <trans-unit id="3580" translate="yes" xml:space="preserve" uid="P:System.Type.IsAutoClass">
          <source>Gets a value indicating whether the string format attribute <ph id="ph1">&lt;see langword="AutoClass" /&gt;</ph> is selected for the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob für <ph id="ph1">&lt;see langword="AutoClass" /&gt;</ph> das Zeichenfolgenformatattribut <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> ausgewählt ist.</target>       </trans-unit>
        <trans-unit id="3581" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the string format attribute <ph id="ph2">&lt;see langword="AutoClass" /&gt;</ph> is selected for the <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn für <ph id="ph2">&lt;see langword="AutoClass" /&gt;</ph> das Zeichenfolgenformatattribut <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> ausgewählt ist, andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3582" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> selects the string format attributes.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> wählt die Zeichenfolgenformatattribute.</target>       </trans-unit>
        <trans-unit id="3583" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source>The string format attributes enhance interoperability by defining how strings should be interpreted.</source>
          <target state="translated">Die Zeichenfolge Formatattribute zur Verbesserung der Interoperabilität von definieren, wie Zeichenfolgen interpretiert werden sollen.</target>       </trans-unit>
        <trans-unit id="3584" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde.</target>       </trans-unit>
        <trans-unit id="3585" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Z. B. wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), der Wert dieser Eigenschaft richtet sich nach <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3586" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3587" translate="yes" xml:space="preserve" uid="P:System.Type.IsAutoLayout">
          <source>Gets a value indicating whether the fields of the current type are laid out automatically by the common language runtime.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob die Felder des aktuellen Typs automatisch von der Common Language Runtime angelegt werden.</target>       </trans-unit>
        <trans-unit id="3588" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> property of the current type includes <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.AutoLayout" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph>-Eigenschaft des aktuellen Typs <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.AutoLayout" /&gt;</ph> umfasst; andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3589" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>This property is provided as a convenience.</source>
          <target state="translated">Diese Eigenschaft wird als Annehmlichkeit bereitgestellt.</target>       </trans-unit>
        <trans-unit id="3590" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>Alternatively, you can use the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph> enumeration value to select the type layout attributes, and then test whether <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph> is set.</source>
          <target state="translated">Alternativ können Sie die <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph> Enumerationswert, wählen Sie die Attribute des Typs Layout und diesen dann testen, ob <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph> festgelegt ist.</target>       </trans-unit>
        <trans-unit id="3591" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>,<ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> enumeration values indicate the way the fields of the type are laid out in memory.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>,<ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>, und <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> Enumerationswerte anzugeben, wie die Felder des Typs werden im Arbeitsspeicher angeordnet.</target>       </trans-unit>
        <trans-unit id="3592" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>For dynamic types, you can specify <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph> when you create the type.</source>
          <target state="translated">Für dynamische Typen festlegbaren <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph> beim Erstellen des Typs.</target>       </trans-unit>
        <trans-unit id="3593" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>In code, apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute with the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType&gt;</ph> enumeration value to the type, to let the runtime determine the appropriate way to lay out the class.</source>
          <target state="translated">Im Code, gelten die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> -Attribut mit der <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType&gt;</ph> Enumerationswert in den Typ, damit die Laufzeit die geeignete Möglichkeit zum Klassenlayout bestimmen können.</target>       </trans-unit>
        <trans-unit id="3594" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>You cannot use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method to determine whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> has been applied to a type.</source>
          <target state="translated">Können Sie keine der <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> Methode, um zu bestimmen, ob die <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> auf einen Typ angewendet wurde.</target>       </trans-unit>
        <trans-unit id="3595" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde.</target>       </trans-unit>
        <trans-unit id="3596" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;.`</ph></source>
          <target state="translated">Z. B. wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), der Wert dieser Eigenschaft wird bestimmt durch <ph id="ph4">`MyGenericType&lt;T&gt;.`</ph></target>       </trans-unit>
        <trans-unit id="3597" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3598" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsAutoLayout">
          <source>The following example creates an instance of the type and displays the <ph id="ph1">&lt;xref:System.Type.IsAutoLayout%2A&gt;</ph> property.</source>
          <target state="translated">Das folgende Beispiel erstellt eine Instanz des Typs und zeigt die <ph id="ph1">&lt;xref:System.Type.IsAutoLayout%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="3599" translate="yes" xml:space="preserve" uid="P:System.Type.IsByRef">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is passed by reference.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> als Verweis übergeben wird.</target>       </trans-unit>
        <trans-unit id="3600" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsByRef">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is passed by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> als Verweis übergeben wird, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3601" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsByRef">
          <source>To get to the actual type, dereference the type that was passed by reference, and then call <ph id="ph1">&lt;xref:System.Type.GetElementType%2A&gt;</ph> on that type.</source>
          <target state="translated">Um den tatsächlichen Typ zu erhalten, dereferenzieren den Typ, der als Verweis übergeben wurde, und rufen Sie anschließend <ph id="ph1">&lt;xref:System.Type.GetElementType%2A&gt;</ph> für diesen Typ.</target>       </trans-unit>
        <trans-unit id="3602" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsByRef">
          <source>The following example demonstrates a use of the <ph id="ph1">`IsByRef`</ph> property to check whether a specified type is passed by reference.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung von der <ph id="ph1">`IsByRef`</ph> Eigenschaft zu überprüfen, ob ein angegebenen Typs als Verweis übergeben wird.</target>       </trans-unit>
        <trans-unit id="3603" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsByRef">
          <source>The example defines the class <ph id="ph1">`MyTypeDelegator`</ph>, which overrides the <ph id="ph2">`HasElementTypeImpl`</ph> method.</source>
          <target state="translated">Im Beispiel wird die Klasse definiert <ph id="ph1">`MyTypeDelegator`</ph>, welche Außerkraftsetzungen der <ph id="ph2">`HasElementTypeImpl`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3604" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsByRef">
          <source>The main class checks for the <ph id="ph1">`HasElementType`</ph> property and displays the element type.</source>
          <target state="translated">Die Hauptklasse überprüft die <ph id="ph1">`HasElementType`</ph> Eigenschaft und zeigt den Elementtyp an.</target>       </trans-unit>
        <trans-unit id="3605" translate="yes" xml:space="preserve" uid="M:System.Type.IsByRefImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is passed by reference.</source>
          <target state="translated">Implementiert beim Überschreiben in einer abgeleiteten Klasse die <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph>-Eigenschaft und bestimmt, ob <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> als Verweis übergeben wird.</target>       </trans-unit>
        <trans-unit id="3606" translate="yes" xml:space="preserve" uid="M:System.Type.IsByRefImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is passed by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> als Verweis übergeben wird, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3607" translate="yes" xml:space="preserve" uid="P:System.Type.IsClass">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is a class or a delegate; that is, not a value type or interface.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> eine Klasse oder ein Delegat ist, d. h. weder ein Werttyp noch eine Schnittstelle.</target>       </trans-unit>
        <trans-unit id="3608" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a class; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> eine Klasse ist, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3609" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>This property returns <ph id="ph1">`true`</ph> for classes as well as delegates.</source>
          <target state="translated">Diese Eigenschaft gibt <ph id="ph1">`true`</ph> für Klassen als auch für Delegaten.</target>       </trans-unit>
        <trans-unit id="3610" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>It returns <ph id="ph1">`false`</ph> for value types (for structures and enumerations) even if they are boxed.</source>
          <target state="translated">Es gibt <ph id="ph1">`false`</ph> für Werttypen (für Strukturen und Enumerationen) auch wenn sie verschachtelt sind.</target>       </trans-unit>
        <trans-unit id="3611" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`true`</ph>.If the current <ph id="ph3">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns <ph id="ph4">`true`</ph> if the generic type definition is a class definition; that is, it does not define an interface or a value type.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer <ph id="ph2">`true`</ph>. Wenn die aktuelle <ph id="ph3">&lt;xref:System.Type&gt;</ph> einen konstruierten generischen Typ darstellt, gibt diese Eigenschaft <ph id="ph4">`true`</ph> ist die generische Typdefinition einer Klassendefinition; d. h. kein definiert eine Schnittstelle oder ein Werttyp.</target>       </trans-unit>
        <trans-unit id="3612" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>This property returns <ph id="ph1">`true`</ph> for <ph id="ph2">`Type`</ph> instances that represent the <ph id="ph3">&lt;xref:System.Enum&gt;</ph> and <ph id="ph4">&lt;xref:System.ValueType&gt;</ph> classes.</source>
          <target state="translated">Diese Eigenschaft gibt <ph id="ph1">`true`</ph> für <ph id="ph2">`Type`</ph> Instanzen, die darstellen, die <ph id="ph3">&lt;xref:System.Enum&gt;</ph> und <ph id="ph4">&lt;xref:System.ValueType&gt;</ph> Klassen.</target>       </trans-unit>
        <trans-unit id="3613" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>These two classes are the base types for enumerations and value types, respectively, but they are not enumerations or value types themselves.</source>
          <target state="translated">Diese beiden Klassen sind die Basisklasse für Enumerationen und Werttypen, allerdings sind nicht Enumerationen oder Werttypen selbst.</target>       </trans-unit>
        <trans-unit id="3614" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Type.IsValueType%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.IsEnum%2A&gt;</ph> properties.</source>
          <target state="translated">Weitere Informationen finden Sie unter der <ph id="ph1">&lt;xref:System.Type.IsValueType%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Type.IsEnum%2A&gt;</ph> Eigenschaften.</target>       </trans-unit>
        <trans-unit id="3615" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType&gt;</ph> enumeration value  distinguishes a type declaration as class or interface.However, both classes and value types are marked with the <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType&gt;</ph> attribute.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType&gt;</ph> Enumerationswert kennzeichnet eine Typdeklaration als Klasse oder Schnittstelle. Klassen und Werttypen sind jedoch mit markierten der <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType&gt;</ph> Attribut.</target>       </trans-unit>
        <trans-unit id="3616" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>If you retrieve the value of a type's Attributes property and use the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType&gt;</ph> value to determine whether a type is a class instead of a value type, you must also call the <ph id="ph2">&lt;xref:System.Type.IsValueType%2A&gt;</ph> property.</source>
          <target state="translated">Wenn Sie den Wert der Eigenschaft Attributes aus und Verwenden des Typs Abrufen der <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType&gt;</ph> um zu bestimmen, ob ein Typ eine Klasse anstelle eines Werttyps ist, müssen Sie auch Aufrufen der <ph id="ph2">&lt;xref:System.Type.IsValueType%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="3617" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>The example for the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeration contains additional information as well as anexample.</source>
          <target state="translated">Im Beispiel für die <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> Enumeration enthält zusätzliche Informationen sowie beispielsweise.</target>       </trans-unit>
        <trans-unit id="3618" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>This property is read-only.</source>
          <target state="translated">Diese Eigenschaft ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="3619" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsClass">
          <source>The following example creates an instance of a type and indicates whether the type is a class.</source>
          <target state="translated">Das folgende Beispiel erstellt eine Instanz eines Typs und gibt an, ob der Typ eine Klasse ist.</target>       </trans-unit>
        <trans-unit id="3620" translate="yes" xml:space="preserve" uid="P:System.Type.IsCOMObject">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is a COM object.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> ein COM-Objekt ist.</target>       </trans-unit>
        <trans-unit id="3621" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a COM object; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> ein COM-Objekt ist, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3622" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>This method returns <ph id="ph1">`false`</ph> for COM interfaces because they are not objects.</source>
          <target state="translated">Diese Methode gibt <ph id="ph1">`false`</ph> für COM-Schnittstellen, da diese keine Objekte sind.</target>       </trans-unit>
        <trans-unit id="3623" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>COM interfaces can be implemented by Microsoft .NET Framework objects.</source>
          <target state="translated">COM-Schnittstellen können von Microsoft .NET Framework-Objekte implementiert werden.</target>       </trans-unit>
        <trans-unit id="3624" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>You can also load a COM class and get a <ph id="ph1">`Type`</ph> object for that COM class by using the <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> tool.</source>
          <target state="translated">Sie können auch eine COM‑Klasse laden und Abrufen eine <ph id="ph1">`Type`</ph> Objekt für diese COM-Klasse, indem die <bpt id="p1">[</bpt>Tlbimp.exe (Type Library Importer-Tool)<ept id="p1">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> Tool.</target>       </trans-unit>
        <trans-unit id="3625" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde.</target>       </trans-unit>
        <trans-unit id="3626" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int`</ph>&gt; (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Z. B. wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt <ph id="ph2">`MyGenericType&lt;int`</ph>&gt; (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), der Wert dieser Eigenschaft richtet sich nach <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3627" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsCOMObject">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3628" translate="yes" xml:space="preserve" uid="M:System.Type.IsCOMObjectImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.IsCOMObject" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a COM object.</source>
          <target state="translated">Implementiert beim Überschreiben in einer abgeleiteten Klasse die <ph id="ph1">&lt;see cref="P:System.Type.IsCOMObject" /&gt;</ph>-Eigenschaft und bestimmt, ob <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> ein COM-Objekt ist.</target>       </trans-unit>
        <trans-unit id="3629" translate="yes" xml:space="preserve" uid="M:System.Type.IsCOMObjectImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a COM object; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> ein COM-Objekt ist, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsCOMObjectImpl">
          <source>This method returns <ph id="ph1">`false`</ph> for COM interfaces because they are not objects.</source>
          <target state="translated">Diese Methode gibt <ph id="ph1">`false`</ph> für COM-Schnittstellen, da diese keine Objekte sind.</target>       </trans-unit>
        <trans-unit id="3631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsCOMObjectImpl">
          <source>COM interfaces can be implemented by Microsoft .NET Framework objects.</source>
          <target state="translated">COM-Schnittstellen können von Microsoft .NET Framework-Objekte implementiert werden.</target>       </trans-unit>
        <trans-unit id="3632" translate="yes" xml:space="preserve" uid="P:System.Type.IsConstructedGenericType">
          <source>Gets a value that indicates whether this object represents a constructed generic type.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob dieses Objekt einen konstruierten generischen Typ darstellt.</target>       </trans-unit>
        <trans-unit id="3633" translate="yes" xml:space="preserve" uid="P:System.Type.IsConstructedGenericType">
          <source>You can create instances of a constructed generic type.</source>
          <target state="translated">Sie können Instanzen eines konstruierten generischen Typs erstellen.</target>       </trans-unit>
        <trans-unit id="3634" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsConstructedGenericType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this object represents a constructed generic type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn dieses Objekt einen konstruierten generischen Typ darstellt, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3635" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsConstructedGenericType">
          <source>A constructed generic type has had explicit types supplied for all of its generic type parameters.</source>
          <target state="translated">Ein konstruierter generischer Typ wies explizite Typen, die für alle generischen Typparameter angegeben.</target>       </trans-unit>
        <trans-unit id="3636" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsConstructedGenericType">
          <source>It is also referred to as a closed generic type.</source>
          <target state="translated">Es wird auch als ein geschlossener generischer Typ bezeichnet.</target>       </trans-unit>
        <trans-unit id="3637" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsConstructedGenericType">
          <source>When this property is <ph id="ph1">`true`</ph>, you can create instances of the current type; when it is <ph id="ph2">`false`</ph>, you can't.</source>
          <target state="translated">Wenn diese Eigenschaft den Wert <ph id="ph1">`true`</ph>, können Sie Instanzen des aktuellen Typs erstellen, wenn es sich um <ph id="ph2">`false`</ph>, nicht möglich.</target>       </trans-unit>
        <trans-unit id="3638" translate="yes" xml:space="preserve" uid="P:System.Type.IsContextful">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> can be hosted in a context.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> in einen Kontext aufgenommen werden kann.</target>       </trans-unit>
        <trans-unit id="3639" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> can be hosted in a context; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> in einen Kontext aufgenommen werden kann, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3640" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source>A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization.</source>
          <target state="translated">Ein Kontext fängt Aufrufe von Klassenmembern ab und erzwingt Richtlinien, die auf die Klasse, z. B. Synchronisierung angewendet werden.</target>       </trans-unit>
        <trans-unit id="3641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source>For more detailed information on remoting contexts, see <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.Context&gt;</ph>.</source>
          <target state="translated">Ausführlichere Informationen über Remotekontext finden Sie unter <ph id="ph1">&lt;xref:System.Runtime.Remoting.Contexts.Context&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source>The following example demonstrates the <ph id="ph1">`IsContextful`</ph>, <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph> properties of the <ph id="ph4">&lt;xref:System.Type&gt;</ph> class.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">`IsContextful`</ph>, <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>, und <ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph> Eigenschaften der <ph id="ph4">&lt;xref:System.Type&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="3644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsContextful">
          <source>It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</source>
          <target state="translated">Er überprüft, ob der angegebene Typ in den Kontext aufgenommen werden kann, ob er als Verweis gemarshallt werden kann und ob der Typ ein primitiver Datentyp ist.</target>       </trans-unit>
        <trans-unit id="3645" translate="yes" xml:space="preserve" uid="M:System.Type.IsContextfulImpl">
          <source>Implements the <ph id="ph1">&lt;see cref="P:System.Type.IsContextful" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> can be hosted in a context.</source>
          <target state="translated">Implementiert die <ph id="ph1">&lt;see cref="P:System.Type.IsContextful" /&gt;</ph>-Eigenschaft und bestimmt, ob <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> in einen Kontext aufgenommen werden kann.</target>       </trans-unit>
        <trans-unit id="3646" translate="yes" xml:space="preserve" uid="M:System.Type.IsContextfulImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> can be hosted in a context; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> in einen Kontext aufgenommen werden kann, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsContextfulImpl">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.</target>       </trans-unit>
        <trans-unit id="3648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsContextfulImpl">
          <source>A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.</source>
          <target state="translated">Ein Kontext fängt Aufrufe von Klassenmembern ab und erzwingt Richtlinien, die auf die Klasse, z. B. Synchronisierung angewendet werden.</target>       </trans-unit>
        <trans-unit id="3649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsContextfulImpl">
          <source>The following example demonstrates a use of the <ph id="ph1">`IsContextfulImpl`</ph> method.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung von der <ph id="ph1">`IsContextfulImpl`</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3650" translate="yes" xml:space="preserve" uid="P:System.Type.IsEnum">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents an enumeration.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der aktuelle <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> eine Enumeration darstellt.</target>       </trans-unit>
        <trans-unit id="3651" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> represents an enumeration; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der aktuelle <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> eine Enumeration darstellt, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3652" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>This property returns <ph id="ph1">`true`</ph> for an enumeration, but not for the <ph id="ph2">&lt;xref:System.Enum&gt;</ph> type itself.</source>
          <target state="translated">Diese Eigenschaft gibt <ph id="ph1">`true`</ph> für eine Enumeration, aber nicht für die <ph id="ph2">&lt;xref:System.Enum&gt;</ph> -Typ selbst.</target>       </trans-unit>
        <trans-unit id="3653" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde.</target>       </trans-unit>
        <trans-unit id="3654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Z. B. wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), der Wert dieser Eigenschaft richtet sich nach <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3655" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3656" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>This property is read-only.</source>
          <target state="translated">Diese Eigenschaft ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="3657" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsEnum">
          <source>The following example demonstrates how to use the <ph id="ph1">`IsEnum`</ph> property.</source>
          <target state="translated">Im folgenden Beispiel wird veranschaulicht, wie die <ph id="ph1">`IsEnum`</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="3658" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source>The value to be tested.</source>
          <target state="translated">Der zu überprüfende Wert.</target>       </trans-unit>
        <trans-unit id="3659" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source>Returns a value that indicates whether the specified value exists in the current enumeration type.</source>
          <target state="translated">Gibt einen Wert zurück, der angibt, ob der angegebene Wert im aktuellen Enumerationstyp vorhanden ist.</target>       </trans-unit>
        <trans-unit id="3660" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified value is a member of the current enumeration type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der angegebene Wert ein Member des aktuellen Enumerationstyps ist, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3661" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source>The current type is not an enumeration.</source>
          <target state="translated">Der aktuelle Typ ist keine Enumeration.</target>       </trans-unit>
        <trans-unit id="3662" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3663" translate="yes" xml:space="preserve" uid="M:System.Type.IsEnumDefined(System.Object)">
          <source><ph id="ph1">&lt;paramref name="value" /&gt;</ph> is of a type that cannot be the underlying type of an enumeration.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="value" /&gt;</ph> ist von einem Typ, der nicht der zugrunde liegende Typ einer Enumeration sein kann.</target>       </trans-unit>
        <trans-unit id="3664" translate="yes" xml:space="preserve" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>The COM type that is tested for equivalence with the current type.</source>
          <target state="translated">Der COM-Typ, der auf Äquivalenz mit dem aktuellen Typ überprüft wird.</target>       </trans-unit>
        <trans-unit id="3665" translate="yes" xml:space="preserve" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>Determines whether two COM types have the same identity and are eligible for type equivalence.</source>
          <target state="translated">Bestimmt, ob zwei COM-Typen die gleiche Identität haben und äquivalente Typen aufweisen können.</target>       </trans-unit>
        <trans-unit id="3666" translate="yes" xml:space="preserve" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the COM types are equivalent; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die COM-Typen äquivalent sind, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3667" translate="yes" xml:space="preserve" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>This method also returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context.</source>
          <target state="translated">Diese Methode gibt auch <ph id="ph1">&lt;see langword="false" /&gt;</ph> zurück, wenn ein Typ in einer Assembly enthalten ist, die zum Ausführen geladen wird, und der andere in einer Assembly enthalten ist, die in den reflektionsbezogenen Kontext geladen wird.</target>       </trans-unit>
        <trans-unit id="3668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>Beginning with the <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the common language runtime supports the embedding of type information for COM types directly into managed assemblies, instead of requiring the managed assemblies to obtain type information for COM types from interop assemblies.</source>
          <target state="translated">Beginnend mit der <ph id="ph1">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, die common Language Runtime unterstützt das Einbetten von Typinformationen für COM-Typen direkt in verwaltete Assemblys, anstatt die verwalteten Assemblys zum Abrufen der Typinformationen für COM-Typen von Interop Assemblys.</target>       </trans-unit>
        <trans-unit id="3669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>Because the embedded type information includes only the types and members that are actually used by a managed assembly, two managed assemblies might have very different views of the same COM type.</source>
          <target state="translated">Da die eingebettete Typinformation nur die Typen und Member enthält, die tatsächlich von einer verwalteten Assembly verwendet werden, können zwei verwaltete Assemblys möglicherweise sehr unterschiedliche Ansichten desselben COM-Typs haben.</target>       </trans-unit>
        <trans-unit id="3670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>Each managed assembly has a different <ph id="ph1">&lt;xref:System.Type&gt;</ph> object to represent its view of the COM type.</source>
          <target state="translated">Jede verwaltete Assembly besitzt ein anderes <ph id="ph1">&lt;xref:System.Type&gt;</ph>-Objekt, das eine Ansicht des COM-Typs darstellt.</target>       </trans-unit>
        <trans-unit id="3671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>The common language runtime supports type equivalence between these different views for interfaces, structures, enumerations, and delegates.</source>
          <target state="translated">Die Common Language Runtime unterstützt Typäquivalenz zwischen diesen unterschiedlichen Ansichten für Schnittstellen, Strukturen, Enumerationen und Delegaten.</target>       </trans-unit>
        <trans-unit id="3672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>Type equivalence means that a COM object that is passed from one managed assembly to another can be cast to the appropriate managed type in the receiving assembly.</source>
          <target state="translated">Typäquivalenz bedeutet, dass ein COM-Objekt, das von einer verwalteten Assembly an eine andere übergeben wird, für den entsprechenden verwalteten Typ in der empfangenden Assembly bereitgestellt werden kann.</target>       </trans-unit>
        <trans-unit id="3673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsEquivalentTo%2A&gt;</ph> method enables an assembly to determine that a COM object obtained from another assembly has the same COM identity as one of the first assembly's own embedded interop types, and thus can be cast to that type.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.IsEquivalentTo%2A&gt;</ph> -Methode können Sie eine Assembly, um zu ermitteln, ein COM-Objekt, das von einer anderen Assembly abgerufen, die gleiche COM-Identität als eines der ersten eigenen eingebettete Interop-Assemblytyp hat und daher auf diesen Typ umgewandelt werden kann.</target>       </trans-unit>
        <trans-unit id="3674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsEquivalentTo(System.Type)">
          <source>For more information, see <bpt id="p1">[</bpt>Type Equivalence and Embedded Interop Types<ept id="p1">](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Typäquivalenz und eingebettete Interop-Typen<ept id="p1">](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3675" translate="yes" xml:space="preserve" uid="P:System.Type.IsExplicitLayout">
          <source>Gets a value indicating whether the fields of the current type are laid out at explicitly specified offsets.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob die Felder des aktuellen Typs an den explizit angegebenen Offsets angelegt werden.</target>       </trans-unit>
        <trans-unit id="3676" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> property of the current type includes <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph>-Eigenschaft des aktuellen Typs <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" /&gt;</ph> umfasst; andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3677" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>This property is provided as a convenience.</source>
          <target state="translated">Diese Eigenschaft wird als Annehmlichkeit bereitgestellt.</target>       </trans-unit>
        <trans-unit id="3678" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>Alternatively, you can use the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph> enumeration value to select the type layout attributes, and then test whether <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph> is set.</source>
          <target state="translated">Alternativ können Sie die <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph> Enumerationswert, wählen Sie die Attribute des Typs Layout und diesen dann testen, ob <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph> festgelegt ist.</target>       </trans-unit>
        <trans-unit id="3679" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> enumeration values indicate the way the fields of the type are laid out in memory.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>, und <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> Enumerationswerte anzugeben, wie die Felder des Typs werden im Arbeitsspeicher angeordnet.</target>       </trans-unit>
        <trans-unit id="3680" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>For dynamic types, you can specify <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph> when you create the type.</source>
          <target state="translated">Für dynamische Typen festlegbaren <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph> beim Erstellen des Typs.</target>       </trans-unit>
        <trans-unit id="3681" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>In code, apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute with the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> enumeration value to the type, to specify that the offsets at which the fields start are specified explicitly.</source>
          <target state="translated">Im Code, gelten die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> -Attribut mit der <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType&gt;</ph> Enumerationswert in den Typ, um anzugeben, dass die Offsets, an dem die Felder starten, explizit angegeben werden.</target>       </trans-unit>
        <trans-unit id="3682" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>You cannot use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method to determine whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> has been applied to a type.</source>
          <target state="translated">Können Sie keine der <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> Methode, um zu bestimmen, ob die <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> auf einen Typ angewendet wurde.</target>       </trans-unit>
        <trans-unit id="3683" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde.</target>       </trans-unit>
        <trans-unit id="3684" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Z. B. wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), der Wert dieser Eigenschaft richtet sich nach <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3685" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3686" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>The following example creates an instance of a type and displays the value of its <ph id="ph1">&lt;xref:System.Type.IsExplicitLayout%2A&gt;</ph> property.</source>
          <target state="translated">Das folgende Beispiel erstellt eine Instanz eines Typs und zeigt den Wert des seine <ph id="ph1">&lt;xref:System.Type.IsExplicitLayout%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="3687" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsExplicitLayout">
          <source>It uses the <ph id="ph1">`MySystemTime`</ph> class, which is also in the code example for <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>.</source>
          <target state="translated">Er verwendet die <ph id="ph1">`MySystemTime`</ph> Klasse, die auch im Codebeispiel für <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3688" translate="yes" xml:space="preserve" uid="P:System.Type.IsGenericParameter">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a type parameter in the definition of a generic type or method.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der aktuelle <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> einen Typparameter einer generischen Typ- oder Methodendefinition darstellt.</target>       </trans-unit>
        <trans-unit id="3689" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type parameter of a generic type definition or generic method definition; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn das <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt einen Typparameter einer generischen Typ- oder Methodendefinition darstellt, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3690" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source><ph id="ph1">&lt;xref:System.Type&gt;</ph> objects that represent generic type parameters can be obtained by calling the <ph id="ph2">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> method of a <ph id="ph3">&lt;xref:System.Type&gt;</ph> object that represents a generic type definition, or the <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A&gt;</ph> method of a <ph id="ph5">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a generic method definition.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekte, die generischen Typparameter darstellen, abgerufen werden können, durch den Aufruf der <ph id="ph2">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> Methode eine <ph id="ph3">&lt;xref:System.Type&gt;</ph> -Objekt, das eine generische Typdefinition darstellt, oder die <ph id="ph4">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A&gt;</ph> Methode eine <ph id="ph5">&lt;xref:System.Reflection.MethodInfo&gt;</ph> -Objekt, das eine generische Methode darstellt Definition.</target>       </trans-unit>
        <trans-unit id="3691" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>For a generic type or method definition, the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> for every element of the resulting array.</source>
          <target state="translated">Für eine generische Typ- bzw. Methodendefinition die <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> -Eigenschaft gibt <ph id="ph2">`true`</ph> für jedes Element des sich ergebenden Array.</target>       </trans-unit>
        <trans-unit id="3692" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>For a closed constructed type or method, the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for every element of the array returned by the <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> method.</source>
          <target state="translated">Für einen geschlossenen konstruierten Typ oder Methode die <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> -Eigenschaft gibt <ph id="ph2">`false`</ph> für jedes Element des Arrays zurückgegebenes die <ph id="ph3">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3693" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>For an open constructed type or method, some elements of the array might be specific types and others might be type parameters.</source>
          <target state="translated">Für einen offenen konstruierten Typ oder eine Methode einige Elemente des Arrays möglicherweise bestimmte Typen und andere möglicherweise Typparameter.</target>       </trans-unit>
        <trans-unit id="3694" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> returns <ph id="ph2">`false`</ph> for the types and <ph id="ph3">`true`</ph> for the type parameters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> Gibt <ph id="ph2">`false`</ph> für die Typen und <ph id="ph3">`true`</ph> für den Typparameter.</target>       </trans-unit>
        <trans-unit id="3695" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>The code example for the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property demonstrates a generic class with a mixture of types and type parameters.</source>
          <target state="translated">Das Codebeispiel für die <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> Eigenschaft wird mit einer Mischung von Typen und die Typparameter eine generische Klasse veranschaulicht.</target>       </trans-unit>
        <trans-unit id="3696" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3697" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericParameter">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to test for generic type parameters in a generic type.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> Eigenschaft so testen Sie die generischen Typparameter in einem generischen Typ.</target>       </trans-unit>
        <trans-unit id="3698" translate="yes" xml:space="preserve" uid="P:System.Type.IsGenericType">
          <source>Gets a value indicating whether the current type is a generic type.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der aktuelle Typ ein generischer Typ ist.</target>       </trans-unit>
        <trans-unit id="3699" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is a generic type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> Wenn der aktuelle Typ ein generischer Typ ist; andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3700" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property to determine whether a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object represents a generic type.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> -Eigenschaft können Sie bestimmen, ob ein <ph id="ph2">&lt;xref:System.Type&gt;</ph> -Objekt einen generischen Typ darstellt.</target>       </trans-unit>
        <trans-unit id="3701" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property to determine whether a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object represents an open constructed type or a closed constructed type.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> -Eigenschaft können Sie bestimmen, ob ein <ph id="ph2">&lt;xref:System.Type&gt;</ph> -Objekt ein offener konstruierten Typ oder einen geschlossenen konstruierten Typ darstellt.</target>       </trans-unit>
        <trans-unit id="3702" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> if the immediate type is not generic.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> -Eigenschaft gibt <ph id="ph2">`false`</ph> Wenn nicht die unmittelbare Typ generisch ist.</target>       </trans-unit>
        <trans-unit id="3703" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For example, an array whose elements are of type <ph id="ph1">`A&lt;int&gt;`</ph> (<ph id="ph2">`A(Of Integer)`</ph> in Visual Basic) is not itself a generic type.</source>
          <target state="translated">Angenommen, ein Array, dessen Elemente vom Typ sind <ph id="ph1">`A&lt;int&gt;`</ph> (<ph id="ph2">`A(Of Integer)`</ph> in Visual Basic) ist nicht selbst ein generischer Typ.</target>       </trans-unit>
        <trans-unit id="3704" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The following table summarizes the invariant conditions for common terms used in generic reflection.</source>
          <target state="translated">In der folgenden Tabelle werden die Invarianten Bedingungen für allgemeine Begriffe in generischen Reflektion verwendet zusammengefasst.</target>       </trans-unit>
        <trans-unit id="3705" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Term</source>
          <target state="translated">Begriff</target>       </trans-unit>
        <trans-unit id="3706" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Invariant</source>
          <target state="translated">Invariante</target>       </trans-unit>
        <trans-unit id="3707" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>generic type definition</source>
          <target state="translated">generische Typdefinition</target>       </trans-unit>
        <trans-unit id="3708" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph>-Eigenschaft ist <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3709" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Defines a generic type.</source>
          <target state="translated">Definiert einen generischen Typ an.</target>       </trans-unit>
        <trans-unit id="3710" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>A constructed type is created by calling the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents a generic type definition and specifying an array of type arguments.</source>
          <target state="translated">Ein konstruierter Typ wird erstellt, durch Aufrufen der <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> Methode auf eine <ph id="ph2">&lt;xref:System.Type&gt;</ph> -Objekt, das eine generische Typdefinition darstellt, und ein Array der Argumente des Typs angeben.</target>       </trans-unit>
        <trans-unit id="3711" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> can be called only on generic type definitions.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> kann nur für generische Typdefinitionen aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="3712" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Any generic type definition is a generic type (the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property is <ph id="ph2">`true`</ph>), but the converse is not true.</source>
          <target state="translated">Generische Typdefinition ist ein generischer Typ (die <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> Eigenschaft <ph id="ph2">`true`</ph>), das Gegenteil aber nicht "true".</target>       </trans-unit>
        <trans-unit id="3713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>generic type</source>
          <target state="translated">generischer Typ</target>       </trans-unit>
        <trans-unit id="3714" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>-Eigenschaft ist <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3715" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Can be a generic type definition, an open constructed type, or a closed constructed type.</source>
          <target state="translated">Hierbei kann es sich um eine generische Typdefinition, ein offener konstruierten Typ oder einen geschlossenen konstruierten Typ sein.</target>       </trans-unit>
        <trans-unit id="3716" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Note that an array type whose element type is generic is not itself a generic type.</source>
          <target state="translated">Beachten Sie, dass ein, dessen Elementtyp Arraytyp ist generisch ist nicht selbst ein generischer Typ.</target>       </trans-unit>
        <trans-unit id="3717" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The same is true of a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing a pointer to a generic type.</source>
          <target state="translated">Dasselbe gilt für eine <ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekt, das einen Zeiger auf einen generischen Typ darstellt.</target>       </trans-unit>
        <trans-unit id="3718" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>open constructed type</source>
          <target state="translated">Öffnen Sie konstruierten Typ</target>       </trans-unit>
        <trans-unit id="3719" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>-Eigenschaft ist <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3720" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Examples are a generic type that has unassigned type parameters, a type that is nested in a generic type definition or in an open constructed type, or a generic type that has a type argument for which the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Beispiele sind ein generischer Typ, der nicht zugewiesene Typparameter verfügt, ein Typ, der in der Definition eines generischen Typs oder in einen offenen konstruierten Typ geschachtelt ist oder einen generischen Typ an, die ein Type-Argument für die die <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> Eigenschaft ist <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3721" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>It is not possible to create an instance of an open constructed type.</source>
          <target state="translated">Es ist nicht möglich, eine Instanz einer offenen konstruierten Typ erstellen.</target>       </trans-unit>
        <trans-unit id="3722" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Note that not all open constructed types are generic.</source>
          <target state="translated">Beachten Sie, dass nicht alle offene konstruierte Typen generisch sind.</target>       </trans-unit>
        <trans-unit id="3723" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For example, an array whose element type is a generic type definition is not generic, and a pointer to an open constructed type is not generic.</source>
          <target state="translated">Angenommen, ein Array, dessen Elementtyp eine generische Typdefinition ist, ist nicht generisch, und ein Zeiger auf einen offenen konstruierten Typ ist nicht generisch.</target>       </trans-unit>
        <trans-unit id="3724" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>closed constructed type</source>
          <target state="translated">geschlossenen konstruierten Typs</target>       </trans-unit>
        <trans-unit id="3725" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>-Eigenschaft ist <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3726" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>When examined recursively, the type has no unassigned generic parameters.</source>
          <target state="translated">Wenn hat untersuchten rekursiv, den Typ nicht zugewiesene generische Parameter.</target>       </trans-unit>
        <trans-unit id="3727" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>generic type parameter</source>
          <target state="translated">generischer Typparameter</target>       </trans-unit>
        <trans-unit id="3728" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>-Eigenschaft ist <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3729" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph>-Eigenschaft ist <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3730" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>In a generic type definition, a placeholder for a type that will be assigned later.</source>
          <target state="translated">In einer generischen Typdefinition ein Platzhalter für einen Typ, der später zugewiesen wird.</target>       </trans-unit>
        <trans-unit id="3731" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>generic type argument</source>
          <target state="translated">generisches Typargument</target>       </trans-unit>
        <trans-unit id="3732" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Can be any type, including a generic type parameter.</source>
          <target state="translated">Kann beliebigen Typs, einschließlich einen generischen Typparameter ab.</target>       </trans-unit>
        <trans-unit id="3733" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Type arguments are specified as an array of <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects passed to the <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method when creating a constructed generic type.</source>
          <target state="translated">Typargumente werden als Array von angegeben <ph id="ph1">&lt;xref:System.Type&gt;</ph> -Objekte übergeben, um die <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> Methode, wenn Sie einen konstruierten generischen Typ erstellen.</target>       </trans-unit>
        <trans-unit id="3734" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>If instances of the resulting type are to be created, the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property must be <ph id="ph2">`false`</ph> for all the type arguments.</source>
          <target state="translated">Wenn Instanzen des resultierenden Typs erstellt werden, sind die <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> Eigenschaft muss <ph id="ph2">`false`</ph> für alle Typargumente.</target>       </trans-unit>
        <trans-unit id="3735" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The following code example and table illustrate some of these terms and invariants.</source>
          <target state="translated">Im folgenden Codebeispiel und Tabelle veranschaulichen einige dieser Begriffe und Invarianten.</target>       </trans-unit>
        <trans-unit id="3736" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The <ph id="ph1">`Derived`</ph> class is of particular interest because its base type is a constructed type that has a mixture of types and type parameters in its type argument list.</source>
          <target state="translated">Die <ph id="ph1">`Derived`</ph> -Klasse ist von besonderem Interesse, da Basistyp einen konstruierten Typ ist, eine Mischung von Typen und die Typparameter in der Liste der Typargumente hat.</target>       </trans-unit>
        <trans-unit id="3737" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The following table shows examples that use and build on the classes <ph id="ph1">`Base`</ph>, <ph id="ph2">`Derived`</ph>, and <ph id="ph3">`G`</ph>.</source>
          <target state="translated">Die folgende Tabelle zeigt Beispiele, die in den Klassen zu erstellen und verwenden <ph id="ph1">`Base`</ph>, <ph id="ph2">`Derived`</ph>, und <ph id="ph3">`G`</ph>.</target>       </trans-unit>
        <trans-unit id="3738" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>When the C++ and C# code is the same, only one entry is shown.</source>
          <target state="translated">Wenn die C++- und C#-Code identisch ist, wird nur ein Eintrag angezeigt.</target>       </trans-unit>
        <trans-unit id="3739" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Example</source>
          <target state="translated">Beispiel</target>       </trans-unit>
        <trans-unit id="3740" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Invariants</source>
          <target state="translated">Invarianten</target>       </trans-unit>
        <trans-unit id="3741" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For this type:</source>
          <target state="translated">Für diesen Typ:</target>       </trans-unit>
        <trans-unit id="3742" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> ist <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3743" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> ist <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3744" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> ist <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3745" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For this type:</source>
          <target state="translated">Für diesen Typ:</target>       </trans-unit>
        <trans-unit id="3746" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> ist <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3747" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> ist <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3748" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> ist <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3749" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For the type of variable <ph id="ph1">`d`</ph>:</source>
          <target state="translated">Für den Typ der Variable <ph id="ph1">`d`</ph>:</target>       </trans-unit>
        <trans-unit id="3750" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`false`</ph> because <ph id="ph3">`d`</ph> is an array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> ist <ph id="ph2">`false`</ph> da <ph id="ph3">`d`</ph> ist ein Array.</target>       </trans-unit>
        <trans-unit id="3751" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> ist <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3752" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> ist <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3753" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">`T`</ph>, <ph id="ph2">`U`</ph>, and <ph id="ph3">`V`</ph> (everywhere they appear)</source>
          <target state="translated"><ph id="ph1">`T`</ph>, <ph id="ph2">`U`</ph>, und <ph id="ph3">`V`</ph> (bei allen Vorkommen)</target>       </trans-unit>
        <trans-unit id="3754" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> ist <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3755" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`false`</ph> because there is no way to constrain a type parameter to generic types.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> ist <ph id="ph2">`false`</ph> , da es keine Möglichkeit gibt, die einen Typparameter auf generische Typen zu beschränken.</target>       </trans-unit>
        <trans-unit id="3756" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> ist <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3757" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph> because <ph id="ph3">`T`</ph>, <ph id="ph4">`U`</ph>, and <ph id="ph5">`V`</ph> are themselves generic type parameters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> ist <ph id="ph2">`true`</ph> da <ph id="ph3">`T`</ph>, <ph id="ph4">`U`</ph>, und <ph id="ph5">`V`</ph> selbst generische Typparameter sind.</target>       </trans-unit>
        <trans-unit id="3758" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>This does not imply anything about type arguments that are assigned to them later.</source>
          <target state="translated">Dies bedeutet nichts über Typargumente nicht, die ihnen später zugewiesen werden.</target>       </trans-unit>
        <trans-unit id="3759" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The type of field <ph id="ph1">`F`</ph></source>
          <target state="translated">Der Typ des Felds <ph id="ph1">`F`</ph></target>       </trans-unit>
        <trans-unit id="3760" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> ist <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3761" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`false`</ph> because a type has been assigned to the type parameter of <ph id="ph3">`G`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> ist <ph id="ph2">`false`</ph> , da der Typparameter, der ein Typ zugewiesen wurde <ph id="ph3">`G`</ph>.</target>       </trans-unit>
        <trans-unit id="3762" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>Note that this is equivalent to having called the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method.</source>
          <target state="translated">Beachten Sie, dass dies dem Aufruf der <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3763" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph> because the type of field <ph id="ph3">`F`</ph> has a type argument that is an open constructed type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> ist <ph id="ph2">`true`</ph> da der Typ des Felds <ph id="ph3">`F`</ph> ist ein Typargument, das ein offener konstruierten Typ ist.</target>       </trans-unit>
        <trans-unit id="3764" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The constructed type is open because its type argument (that is, <ph id="ph1">`Base`</ph>) is a generic type definition.</source>
          <target state="translated">Der konstruierte Typ geöffnet ist. da Typargument (d. h. <ph id="ph1">`Base`</ph>) ist eine generische Typdefinition.</target>       </trans-unit>
        <trans-unit id="3765" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>This illustrates the recursive nature of the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property.</source>
          <target state="translated">Dies veranschaulicht die rekursive Charakter der <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="3766" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The nested class <ph id="ph1">`Nested`</ph></source>
          <target state="translated">Die geschachtelte Klasse <ph id="ph1">`Nested`</ph></target>       </trans-unit>
        <trans-unit id="3767" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id="ph2">`true`</ph>, even though the <ph id="ph3">`Nested`</ph> class has no generic type parameters of its own, because it is nested in a generic type.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> ist <ph id="ph2">`true`</ph>, obwohl die <ph id="ph3">`Nested`</ph> -Klasse verfügt über keine generischen Typparameter von allein, weil sie in einem generischen Typ geschachtelt ist.</target>       </trans-unit>
        <trans-unit id="3768" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> ist <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3769" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>That is, you can call the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method and supply the type parameter of the enclosing type, <ph id="ph2">`Derived`</ph>.</source>
          <target state="translated">Sie können also Aufrufen der <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> -Methode, und übergeben Sie den Typparameter von einschließenden Typs <ph id="ph2">`Derived`</ph>.</target>       </trans-unit>
        <trans-unit id="3770" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id="ph2">`true`</ph> because the enclosing type, <ph id="ph3">`Derived`</ph>, has generic type parameters.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> ist <ph id="ph2">`true`</ph> , da der einschließende Typ, <ph id="ph3">`Derived`</ph>, verfügt der generische Typparameter.</target>       </trans-unit>
        <trans-unit id="3771" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>This illustrates the recursive nature of the <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property.</source>
          <target state="translated">Dies veranschaulicht die rekursive Charakter der <ph id="ph1">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="3772" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>The following code example displays the value of the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> properties for the types described in the Remarks section.</source>
          <target state="translated">Das folgende Codebeispiel zeigt den Wert, der die <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph>, und <ph id="ph4">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> Eigenschaften für die Typen, die im Abschnitt "Hinweise" beschrieben.</target>       </trans-unit>
        <trans-unit id="3773" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericType">
          <source>For explanations of the property values, see the accompanying table in Remarks.</source>
          <target state="translated">Erläuterungen der Eigenschaftswerte finden Sie unter "Hinweise" der zugehörigen Tabelle.</target>       </trans-unit>
        <trans-unit id="3774" translate="yes" xml:space="preserve" uid="P:System.Type.IsGenericTypeDefinition">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> represents a generic type definition, from which other generic types can be constructed.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der aktuelle <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> eine generische Typdefinition darstellt, aus der andere generische Typen konstruiert werden können.</target>       </trans-unit>
        <trans-unit id="3775" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object represents a generic type definition; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn das <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt eine generische Typdefinition darstellt, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3776" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>A generic type definition is a template from which other types can be constructed.</source>
          <target state="translated">Eine generische Typdefinition ist eine Vorlage aus der anderen Typen konstruiert werden können.</target>       </trans-unit>
        <trans-unit id="3777" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>For example, from the generic type definition <ph id="ph1">`G&lt;T&gt;`</ph> (expressed in C# syntax; <ph id="ph2">`G(Of T)`</ph> in Visual Basic or <ph id="ph3">`generic &lt;typename T&gt; ref class G`</ph> in C++) you can construct and instantiate the type <ph id="ph4">`G&lt;int&gt;`</ph> (<ph id="ph5">`G(Of Integer)`</ph> in Visual Basic), by calling the <ph id="ph6">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with a generic argument list containing the <ph id="ph7">&lt;xref:System.Int32&gt;</ph> type.</source>
          <target state="translated">Z. B. von der generischen Typdefinition <ph id="ph1">`G&lt;T&gt;`</ph> (ausgedrückt in C#-Syntax; <ph id="ph2">`G(Of T)`</ph> in Visual Basic oder <ph id="ph3">`generic &lt;typename T&gt; ref class G`</ph> in C++) können Sie erstellen und instanziieren Sie den Typ <ph id="ph4">`G&lt;int&gt;`</ph> (<ph id="ph5">`G(Of Integer)`</ph> in Visual Basic), durch Aufrufen der <ph id="ph6">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> Methode mit einer Liste mit generisches Argument der <ph id="ph7">&lt;xref:System.Int32&gt;</ph> Typ.</target>       </trans-unit>
        <trans-unit id="3778" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>Given a <ph id="ph1">&lt;xref:System.Type&gt;</ph> object representing this constructed type, the <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method gets the generic type definition back again.</source>
          <target state="translated">Erhält eine <ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekt, das dies darstellt konstruierter Typ, der <ph id="ph2">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> Methode ruft die generische Typdefinition zurück, erneut aus.</target>       </trans-unit>
        <trans-unit id="3779" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property to determine whether you can create new types from the current type.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> Eigenschaft, um zu bestimmen, ob Sie aus dem aktuellen Typ neue Typen erstellen können.</target>       </trans-unit>
        <trans-unit id="3780" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>If the <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>, you can call the <ph id="ph3">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method to create new generic types.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> -Eigenschaft gibt <ph id="ph2">`true`</ph>, Sie erreichen die <ph id="ph3">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> Methode, um neue generische Typen zu erstellen.</target>       </trans-unit>
        <trans-unit id="3781" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3782" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>The following example displays information about a type, including whether or not it is a generic type definition.</source>
          <target state="translated">Das folgende Beispiel zeigt Informationen zu einem Typ, einschließlich, und zwar unabhängig davon, ob es sich um eine generische Typdefinition ist.</target>       </trans-unit>
        <trans-unit id="3783" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsGenericTypeDefinition">
          <source>Information is displayed for a constructed type, for its generic type definition, and for an ordinary type.</source>
          <target state="translated">Informationen werden für einen konstruierten Typ, dessen Definition eines generischen Typs und einem normalen Typ angezeigt.</target>       </trans-unit>
        <trans-unit id="3784" translate="yes" xml:space="preserve" uid="P:System.Type.IsImport">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> has a <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ComImportAttribute" /&gt;</ph> attribute applied, indicating that it was imported from a COM type library.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> ein <ph id="ph2">&lt;see cref="T:System.Runtime.InteropServices.ComImportAttribute" /&gt;</ph>-Attribut hat, was bedeutet, dass er aus einer COM-Typbibliothek importiert wurde.</target>       </trans-unit>
        <trans-unit id="3785" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsImport">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> has a <ph id="ph3">&lt;see cref="T:System.Runtime.InteropServices.ComImportAttribute" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> ein <ph id="ph3">&lt;see cref="T:System.Runtime.InteropServices.ComImportAttribute" /&gt;</ph> hat, andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3786" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsImport">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde.</target>       </trans-unit>
        <trans-unit id="3787" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsImport">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;.`</ph></source>
          <target state="translated">Z. B. wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), der Wert dieser Eigenschaft wird bestimmt durch <ph id="ph4">`MyGenericType&lt;T&gt;.`</ph></target>       </trans-unit>
        <trans-unit id="3788" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsImport">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3789" translate="yes" xml:space="preserve" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>The object to compare with the current type.</source>
          <target state="translated">Das mit dem aktuellen Typ zu vergleichende Objekt.</target>       </trans-unit>
        <trans-unit id="3790" translate="yes" xml:space="preserve" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>Determines whether the specified object is an instance of the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Bestimmt, ob das angegebene Objekt eine Instanz des aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="3791" translate="yes" xml:space="preserve" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see langword="Type" /&gt;</ph> is in the inheritance hierarchy of the object represented by <ph id="ph3">&lt;paramref name="o" /&gt;</ph>, or if the current <ph id="ph4">&lt;see langword="Type" /&gt;</ph> is an interface that <ph id="ph5">&lt;paramref name="o" /&gt;</ph> implements.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der aktuelle <ph id="ph2">&lt;see langword="Type" /&gt;</ph> in der Vererbungshierarchie des von <ph id="ph3">&lt;paramref name="o" /&gt;</ph> dargestellten Objekts vorhanden ist oder wenn der aktuelle <ph id="ph4">&lt;see langword="Type" /&gt;</ph> eine Schnittstelle ist, die von <ph id="ph5">&lt;paramref name="o" /&gt;</ph> implementiert wird.</target>       </trans-unit>
        <trans-unit id="3792" translate="yes" xml:space="preserve" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if neither of these conditions is the case, if <ph id="ph2">&lt;paramref name="o" /&gt;</ph> is <ph id="ph3">&lt;see langword="null" /&gt;</ph>, or if the current <ph id="ph4">&lt;see langword="Type" /&gt;</ph> is an open generic type (that is, <ph id="ph5">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> returns <ph id="ph6">&lt;see langword="true" /&gt;</ph>).</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>, wenn keine dieser Bedingungen zutrifft, wenn <ph id="ph2">&lt;paramref name="o" /&gt;</ph> den Wert <ph id="ph3">&lt;see langword="null" /&gt;</ph> hat oder wenn der aktuelle <ph id="ph4">&lt;see langword="Type" /&gt;</ph> ein offener generischer Typ ist (d. h. <ph id="ph5">&lt;see cref="P:System.Type.ContainsGenericParameters" /&gt;</ph> gibt <ph id="ph6">&lt;see langword="true" /&gt;</ph> zurück).</target>       </trans-unit>
        <trans-unit id="3793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.</target>       </trans-unit>
        <trans-unit id="3794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>A constructed type is not an instance of its generic type definition.</source>
          <target state="translated">Ein konstruierter Typ ist keine Instanz der generischen Typdefinition.</target>       </trans-unit>
        <trans-unit id="3795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>That is, <ph id="ph1">`MyGenericList&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericList(Of Integer)`</ph> in Visual Basic) is not an instance of <ph id="ph3">`MyGenericList&lt;T&gt;`</ph> (<ph id="ph4">`MyGenericList(Of T)`</ph> in Visual Basic).</source>
          <target state="translated">D. h. <ph id="ph1">`MyGenericList&lt;int&gt;`</ph> (<ph id="ph2">`MyGenericList(Of Integer)`</ph> in Visual Basic) ist keine Instanz des <ph id="ph3">`MyGenericList&lt;T&gt;`</ph> (<ph id="ph4">`MyGenericList(Of T)`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="3796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsInstanceOfType(System.Object)">
          <source>The following example demonstrates the use of the <ph id="ph1">`IsInstanceOfType`</ph> method.</source>
          <target state="translated">Im folgenden Beispiel wird die Verwendung der <ph id="ph1">`IsInstanceOfType`</ph>-Methode gezeigt.</target>       </trans-unit>
        <trans-unit id="3797" translate="yes" xml:space="preserve" uid="P:System.Type.IsInterface">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is an interface; that is, not a class or a value type.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> eine Schnittstelle ist, d. h. weder eine Klasse noch ein Werttyp.</target>       </trans-unit>
        <trans-unit id="3798" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsInterface">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is an interface; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> eine Schnittstelle ist, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3799" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsInterface">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask&gt;</ph> distinguishes a type declaration as class, interface or value type.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask&gt;</ph> eine Typdeklaration als Klasse, Schnittstelle oder ein Wert unterscheidet.</target>       </trans-unit>
        <trans-unit id="3800" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsInterface">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3801" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsInterface">
          <source>This property is read-only.</source>
          <target state="translated">Diese Eigenschaft ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="3802" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsInterface">
          <source>The following example creates an interface, checks for the interface type, and indicates whether a class has the <ph id="ph1">`IsInterface`</ph> property set.</source>
          <target state="translated">Das folgende Beispiel erstellt eine Schnittstelle, für den Schnittstellentyp überprüft und gibt an, ob eine Klasse verfügt über die <ph id="ph1">`IsInterface`</ph> Eigenschaftensatz.</target>       </trans-unit>
        <trans-unit id="3803" translate="yes" xml:space="preserve" uid="P:System.Type.IsLayoutSequential">
          <source>Gets a value indicating whether the fields of the current type are laid out sequentially, in the order that they were defined or emitted to the metadata.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob die Felder des aktuellen Typs sequenziell angelegt werden, in der Reihenfolge, in der sie definiert oder an die Metadaten ausgegeben wurden.</target>       </trans-unit>
        <trans-unit id="3804" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph> property of the current type includes <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die <ph id="ph2">&lt;see cref="P:System.Type.Attributes" /&gt;</ph>-Eigenschaft des aktuellen Typs <ph id="ph3">&lt;see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /&gt;</ph> umfasst; andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3805" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>This property is provided as a convenience.</source>
          <target state="translated">Diese Eigenschaft wird als Annehmlichkeit bereitgestellt.</target>       </trans-unit>
        <trans-unit id="3806" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>Alternatively, you can use the <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph> enumeration value to select the type layout attributes, and then test whether <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> is set.</source>
          <target state="translated">Alternativ können Sie die <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType&gt;</ph> Enumerationswert, wählen Sie die Attribute des Typs Layout und diesen dann testen, ob <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> festgelegt ist.</target>       </trans-unit>
        <trans-unit id="3807" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> enumeration values indicate the way the fields of the type are laid out in memory.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType&gt;</ph>, und <ph id="ph3">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> Enumerationswerte anzugeben, wie die Felder des Typs werden im Arbeitsspeicher angeordnet.</target>       </trans-unit>
        <trans-unit id="3808" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>For dynamic types, you can specify <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> when you create the type.</source>
          <target state="translated">Für dynamische Typen festlegbaren <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType&gt;</ph> beim Erstellen des Typs.</target>       </trans-unit>
        <trans-unit id="3809" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>In code, apply the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute with the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> enumeration value to the type, to specify that layout is sequential.</source>
          <target state="translated">Im Code, gelten die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> -Attribut mit der <ph id="ph2">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> Enumerationswert in den Typ, um anzugeben, das Layout ist sequenziell.</target>       </trans-unit>
        <trans-unit id="3810" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>You cannot use the <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method to determine whether the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> has been applied to a type.</source>
          <target state="translated">Können Sie keine der <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> Methode, um zu bestimmen, ob die <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> auf einen Typ angewendet wurde.</target>       </trans-unit>
        <trans-unit id="3811" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>For more information, see section 9.1.2 of the specification for the Common Language Infrastructure (CLI) documentation, "Partition II: Metadata Definition and Semantics".</source>
          <target state="translated">Weitere Informationen finden Sie im Abschnitt 9.1.2 der Spezifikation für die Common Language Infrastructure (CLI)-Dokumentation "Partition II: Metadata Definition and Semantics".</target>       </trans-unit>
        <trans-unit id="3812" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>The documentation is available online; see <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.</source>
          <target state="translated">Die Dokumentation ist online verfügbar. Sie finden sie unter <bpt id="p1">[</bpt>ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> auf MSDN und <bpt id="p2">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))<ept id="p2">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> auf der Ecma International-Website.</target>       </trans-unit>
        <trans-unit id="3813" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde.</target>       </trans-unit>
        <trans-unit id="3814" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Z. B. wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), der Wert dieser Eigenschaft richtet sich nach <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3815" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3816" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsLayoutSequential">
          <source>The following example creates an instance of a class for which the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> enumeration value in the <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> class has been set, checks for the <ph id="ph3">&lt;xref:System.Type.IsLayoutSequential%2A&gt;</ph> property, and displays the result.</source>
          <target state="translated">Das folgende Beispiel erstellt eine Instanz einer Klasse für die die <ph id="ph1">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType&gt;</ph> Enumerationswert in der <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> -Klasse festgelegt wurde, überprüft, ob die <ph id="ph3">&lt;xref:System.Type.IsLayoutSequential%2A&gt;</ph> -Eigenschaft, und das Ergebnis wird angezeigt.</target>       </trans-unit>
        <trans-unit id="3817" translate="yes" xml:space="preserve" uid="P:System.Type.IsMarshalByRef">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is marshaled by reference.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> als Verweis gemarshallt wird.</target>       </trans-unit>
        <trans-unit id="3818" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsMarshalByRef">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is marshaled by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> als Verweis gemarshallt wird, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3819" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsMarshalByRef">
          <source>The following example demonstrates the <ph id="ph1">`IsContextful`</ph>, <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph> properties of the <ph id="ph4">&lt;xref:System.Type&gt;</ph> class.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">`IsContextful`</ph>, <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>, und <ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph> Eigenschaften der <ph id="ph4">&lt;xref:System.Type&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="3820" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsMarshalByRef">
          <source>It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</source>
          <target state="translated">Er überprüft, ob der angegebene Typ in den Kontext aufgenommen werden kann, ob er als Verweis gemarshallt werden kann und ob der Typ ein primitiver Datentyp ist.</target>       </trans-unit>
        <trans-unit id="3821" translate="yes" xml:space="preserve" uid="M:System.Type.IsMarshalByRefImpl">
          <source>Implements the <ph id="ph1">&lt;see cref="P:System.Type.IsMarshalByRef" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is marshaled by reference.</source>
          <target state="translated">Implementiert die <ph id="ph1">&lt;see cref="P:System.Type.IsMarshalByRef" /&gt;</ph>-Eigenschaft und bestimmt, ob der <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> als Verweis gemarshallt wird.</target>       </trans-unit>
        <trans-unit id="3822" translate="yes" xml:space="preserve" uid="M:System.Type.IsMarshalByRefImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is marshaled by reference; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> als Verweis gemarshallt wird, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsMarshalByRefImpl">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.</target>       </trans-unit>
        <trans-unit id="3824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsMarshalByRefImpl">
          <source>The following example determines whether the given type is marshaled by reference and displays the result.</source>
          <target state="translated">Im folgenden Beispiel wird bestimmt, ob der angegebene Typ Verweis gemarshallt wird, und das Ergebnis wird angezeigt.</target>       </trans-unit>
        <trans-unit id="3825" translate="yes" xml:space="preserve" uid="P:System.Type.IsNested">
          <source>Gets a value indicating whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object represents a type whose definition is nested inside the definition of another type.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob das aktuelle <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt einen Typ darstellt, dessen Definition in der Definition eines anderen Typs geschachtelt ist.</target>       </trans-unit>
        <trans-unit id="3826" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested inside another type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> in einem anderen Typ geschachtelt ist, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3827" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsNested%2A&gt;</ph> property returns <ph id="ph2">`true`</ph> for all nested types, regardless of visibility.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.IsNested%2A&gt;</ph> -Eigenschaft gibt <ph id="ph2">`true`</ph> für alle geschachtelten Typen unabhängig von der Sichtbarkeit.</target>       </trans-unit>
        <trans-unit id="3828" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source>To test for nesting and visibility at the same time, use the related properties <ph id="ph1">&lt;xref:System.Type.IsNestedAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsNestedFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Type.IsNestedFamANDAssem%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Type.IsNestedFamORAssem%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Type.IsNestedPrivate%2A&gt;</ph>, or <ph id="ph6">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph>.</source>
          <target state="translated">Um zur gleichen Zeit Schachtelung und Sichtbarkeit zu testen, verwenden Sie die verwandten Eigenschaften <ph id="ph1">&lt;xref:System.Type.IsNestedAssembly%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsNestedFamily%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Type.IsNestedFamANDAssem%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Type.IsNestedFamORAssem%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Type.IsNestedPrivate%2A&gt;</ph>, oder <ph id="ph6">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3829" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask&gt;</ph> enumeration member selects the visibility attributes for a type.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask&gt;</ph> Enumerationsmember wählt die Sichtbarkeitsattribute für einen Typ aus.</target>       </trans-unit>
        <trans-unit id="3830" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Fehlertypen Sichtbarkeit verfügen.</target>       </trans-unit>
        <trans-unit id="3831" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNested">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">Dann wird der Wert einer Reihe von Sichtbarkeit bezogene abgerufen <ph id="ph1">&lt;xref:System.Type&gt;</ph> Eigenschaften für den übergeordneten Typ und den geschachtelten Typen.</target>       </trans-unit>
        <trans-unit id="3832" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedAssembly">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only within its own assembly.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> geschachtelt und nur innerhalb der eigenen Assembly sichtbar ist.</target>       </trans-unit>
        <trans-unit id="3833" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedAssembly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only within its own assembly; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> geschachtelt und nur innerhalb der eigenen Assembly sichtbar ist, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3834" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedAssembly">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3835" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedAssembly">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> Wählt die Sichtbarkeitsattribute an.</target>       </trans-unit>
        <trans-unit id="3836" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedAssembly">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Fehlertypen Sichtbarkeit verfügen.</target>       </trans-unit>
        <trans-unit id="3837" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedAssembly">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">Dann wird der Wert einer Reihe von Sichtbarkeit bezogene abgerufen <ph id="ph1">&lt;xref:System.Type&gt;</ph> Eigenschaften für den übergeordneten Typ und den geschachtelten Typen.</target>       </trans-unit>
        <trans-unit id="3838" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedFamANDAssem">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only to classes that belong to both its own family and its own assembly.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> geschachtelt und ausschließlich für Klassen sichtbar ist, die sowohl zur eigenen Familie als auch zur eigenen Assembly gehören.</target>       </trans-unit>
        <trans-unit id="3839" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only to classes that belong to both its own family and its own assembly; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> geschachtelt und ausschließlich für Klassen sichtbar ist, die sowohl zur eigenen Familie als auch zur eigenen Assembly gehören, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3840" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3841" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> Wählt die Sichtbarkeitsattribute an.</target>       </trans-unit>
        <trans-unit id="3842" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source>The C# and Visual Basic languages do not include semantics that allow you to define a nested type that is visible only to protected types in its own assembly.</source>
          <target state="translated">Die Sprachen c# und Visual Basic enthalten keine Semantik, mit denen Sie einen geschachtelten Typ definieren, der nur für geschützte Typen in der eigenen Assembly sichtbar ist.</target>       </trans-unit>
        <trans-unit id="3843" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source><ph id="ph1">`protected internal`</ph> visibility in C# and <ph id="ph2">`Protected Friend`</ph> visibility in Visual Basic define a nested type that is visible both to protected types and to types in the same assembly.</source>
          <target state="translated"><ph id="ph1">`protected internal`</ph> Sichtbarkeit in C# geschrieben und <ph id="ph2">`Protected Friend`</ph> Sichtbarkeit in Visual Basic definieren einen geschachtelten Typ, der sowohl für geschützte Typen und Typen in der gleichen Assembly sichtbar ist.</target>       </trans-unit>
        <trans-unit id="3844" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source>A <ph id="ph1">&lt;xref:System.Type&gt;</ph> object's family is defined as all objects of the same <ph id="ph2">&lt;xref:System.Type&gt;</ph> and of its subtypes.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Type&gt;</ph> objektspezifischen Familie wird definiert, wie alle Objekte des gleichen <ph id="ph2">&lt;xref:System.Type&gt;</ph> und seiner Untertypen.</target>       </trans-unit>
        <trans-unit id="3845" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Fehlertypen Sichtbarkeit verfügen.</target>       </trans-unit>
        <trans-unit id="3846" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamANDAssem">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">Dann wird der Wert einer Reihe von Sichtbarkeit bezogene abgerufen <ph id="ph1">&lt;xref:System.Type&gt;</ph> Eigenschaften für den übergeordneten Typ und den geschachtelten Typen.</target>       </trans-unit>
        <trans-unit id="3847" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedFamily">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only within its own family.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> geschachtelt und nur innerhalb der eigenen Familie sichtbar ist.</target>       </trans-unit>
        <trans-unit id="3848" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only within its own family; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> geschachtelt und nur innerhalb der eigenen Familie sichtbar ist, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3849" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3850" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> Wählt die Sichtbarkeitsattribute an.</target>       </trans-unit>
        <trans-unit id="3851" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source>A <ph id="ph1">&lt;xref:System.Type&gt;</ph> object's family is defined as all objects of the exact same <ph id="ph2">&lt;xref:System.Type&gt;</ph> and of its subtypes.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Type&gt;</ph> objektspezifischen Familie wird definiert, wie alle Objekte der genauen gleichen <ph id="ph2">&lt;xref:System.Type&gt;</ph> und seiner Untertypen.</target>       </trans-unit>
        <trans-unit id="3852" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Fehlertypen Sichtbarkeit verfügen.</target>       </trans-unit>
        <trans-unit id="3853" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamily">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">Dann wird der Wert einer Reihe von Sichtbarkeit bezogene abgerufen <ph id="ph1">&lt;xref:System.Type&gt;</ph> Eigenschaften für den übergeordneten Typ und den geschachtelten Typen.</target>       </trans-unit>
        <trans-unit id="3854" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedFamORAssem">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only to classes that belong to either its own family or to its own assembly.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> geschachtelt und ausschließlich für Klassen sichtbar ist, die zur eigenen Familie oder zur eigenen Assembly gehören.</target>       </trans-unit>
        <trans-unit id="3855" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested and visible only to classes that belong to its own family or to its own assembly; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> geschachtelt und ausschließlich für Klassen sichtbar ist, die zur eigenen Familie oder zur eigenen Assembly gehören, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3856" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source>If the visibility of a type is <ph id="ph1">`protected internal`</ph> in C# or <ph id="ph2">`Protected Friend`</ph> in Visual Basic, the <ph id="ph3">&lt;xref:System.Type.IsNestedFamORAssem%2A&gt;</ph> property returns <ph id="ph4">`true`</ph>.</source>
          <target state="translated">Wenn die Sichtbarkeit eines Typs ist <ph id="ph1">`protected internal`</ph> in c# oder <ph id="ph2">`Protected Friend`</ph> in Visual Basic die <ph id="ph3">&lt;xref:System.Type.IsNestedFamORAssem%2A&gt;</ph> -Eigenschaft gibt <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3857" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3858" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> Wählt die Sichtbarkeitsattribute an.</target>       </trans-unit>
        <trans-unit id="3859" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source>A <ph id="ph1">&lt;xref:System.Type&gt;</ph> object's family is defined as all objects of the exact same <ph id="ph2">&lt;xref:System.Type&gt;</ph> and of its subtypes.</source>
          <target state="translated">Ein <ph id="ph1">&lt;xref:System.Type&gt;</ph> objektspezifischen Familie wird definiert, wie alle Objekte der genauen gleichen <ph id="ph2">&lt;xref:System.Type&gt;</ph> und seiner Untertypen.</target>       </trans-unit>
        <trans-unit id="3860" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Fehlertypen Sichtbarkeit verfügen.</target>       </trans-unit>
        <trans-unit id="3861" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedFamORAssem">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">Dann wird der Wert einer Reihe von Sichtbarkeit bezogene abgerufen <ph id="ph1">&lt;xref:System.Type&gt;</ph> Eigenschaften für den übergeordneten Typ und den geschachtelten Typen.</target>       </trans-unit>
        <trans-unit id="3862" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedPrivate">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is nested and declared private.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> geschachtelt und als privat deklariert ist.</target>       </trans-unit>
        <trans-unit id="3863" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPrivate">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is nested and declared private; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> geschachtelt und als privat deklariert ist, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3864" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPrivate">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3865" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPrivate">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> Wählt die Sichtbarkeitsattribute an.</target>       </trans-unit>
        <trans-unit id="3866" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPrivate">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Fehlertypen Sichtbarkeit verfügen.</target>       </trans-unit>
        <trans-unit id="3867" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPrivate">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">Dann wird der Wert einer Reihe von Sichtbarkeit bezogene abgerufen <ph id="ph1">&lt;xref:System.Type&gt;</ph> Eigenschaften für den übergeordneten Typ und den geschachtelten Typen.</target>       </trans-unit>
        <trans-unit id="3868" translate="yes" xml:space="preserve" uid="P:System.Type.IsNestedPublic">
          <source>Gets a value indicating whether a class is nested and declared public.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob eine Klasse geschachtelt und als öffentlich deklariert ist.</target>       </trans-unit>
        <trans-unit id="3869" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPublic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the class is nested and declared public; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die Klasse geschachtelt und als öffentlich deklariert ist, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3870" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPublic">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3871" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPublic">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> Wählt die Sichtbarkeitsattribute an.</target>       </trans-unit>
        <trans-unit id="3872" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPublic">
          <source>The following example creates an outer class with a number of nested classes that have various types of visibility.</source>
          <target state="translated">Das folgende Beispiel erstellt eine äußere Klasse mit einer Reihe von geschachtelten Klassen, die verschiedene Fehlertypen Sichtbarkeit verfügen.</target>       </trans-unit>
        <trans-unit id="3873" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNestedPublic">
          <source>It then retrieves the value of a number of visibility-related <ph id="ph1">&lt;xref:System.Type&gt;</ph> properties for the parent type and each of its nested types.</source>
          <target state="translated">Dann wird der Wert einer Reihe von Sichtbarkeit bezogene abgerufen <ph id="ph1">&lt;xref:System.Type&gt;</ph> Eigenschaften für den übergeordneten Typ und den geschachtelten Typen.</target>       </trans-unit>
        <trans-unit id="3874" translate="yes" xml:space="preserve" uid="P:System.Type.IsNotPublic">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is not declared public.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> nicht als öffentlich deklariert ist.</target>       </trans-unit>
        <trans-unit id="3875" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is not declared public and is not a nested type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> nicht als öffentlich deklariert und kein geschachtelter Typ ist, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3876" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>Do not use this property with nested types; use the <ph id="ph1">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> property instead.</source>
          <target state="translated">Verwenden Sie diese Eigenschaft nicht mit geschachtelten Typen. Verwenden Sie die <ph id="ph1">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> Eigenschaft stattdessen.</target>       </trans-unit>
        <trans-unit id="3877" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3878" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>This example usesthe <ph id="ph1">`IsNotPublic`</ph> property to get the visibility of the type.</source>
          <target state="translated">Dieses Beispiel verwenden bewirkt, dassdie <ph id="ph1">`IsNotPublic`</ph> Eigenschaft, um die Sichtbarkeit des Typs abzurufen.</target>       </trans-unit>
        <trans-unit id="3879" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>The following code example demonstrates why you cannot use <ph id="ph1">`IsPublic`</ph> and <ph id="ph2">`IsNotPublic`</ph> for nested classes.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, warum Sie nicht verwenden können <ph id="ph1">`IsPublic`</ph> und <ph id="ph2">`IsNotPublic`</ph> für geschachtelte Klassen.</target>       </trans-unit>
        <trans-unit id="3880" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>For nested classes, ignore the results of <ph id="ph1">`IsPublic`</ph> and <ph id="ph2">`IsNotPublic`</ph> and pay attention only to the results of <ph id="ph3">`IsNestedPublic`</ph> and <ph id="ph4">`IsNestedPrivate`</ph>.</source>
          <target state="translated">Für geschachtelte Klassen, ignorieren Sie die Ergebnisse der <ph id="ph1">`IsPublic`</ph> und <ph id="ph2">`IsNotPublic`</ph> und achten Sie darauf, nur für die Ergebnisse der <ph id="ph3">`IsNestedPublic`</ph> und <ph id="ph4">`IsNestedPrivate`</ph>.</target>       </trans-unit>
        <trans-unit id="3881" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>The reflection output for this code fragment would be as follows:</source>
          <target state="translated">Die Ausgabe der Reflektion für dieses Codefragment würde wie folgt lauten:</target>       </trans-unit>
        <trans-unit id="3882" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>Class</source>
          <target state="translated">Klasse</target>       </trans-unit>
        <trans-unit id="3883" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>IsNotPublic</source>
          <target state="translated">IsNotPublic</target>       </trans-unit>
        <trans-unit id="3884" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>IsPublic</source>
          <target state="translated">IsPublic</target>       </trans-unit>
        <trans-unit id="3885" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>IsNestedPublic</source>
          <target state="translated">IsNestedPublic</target>       </trans-unit>
        <trans-unit id="3886" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>IsNestedPrivate</source>
          <target state="translated">IsNestedPrivate</target>       </trans-unit>
        <trans-unit id="3887" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>A</source>
          <target state="translated">A</target>       </trans-unit>
        <trans-unit id="3888" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3889" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>TRUE</source>
          <target state="translated">true</target>       </trans-unit>
        <trans-unit id="3890" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3891" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3892" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>B</source>
          <target state="translated">B</target>       </trans-unit>
        <trans-unit id="3893" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3894" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3895" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>TRUE</source>
          <target state="translated">true</target>       </trans-unit>
        <trans-unit id="3896" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3897" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>C</source>
          <target state="translated">A</target>       </trans-unit>
        <trans-unit id="3898" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3899" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3900" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>FALSE</source>
          <target state="translated">false</target>       </trans-unit>
        <trans-unit id="3901" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsNotPublic">
          <source>TRUE</source>
          <target state="translated">true</target>       </trans-unit>
        <trans-unit id="3902" translate="yes" xml:space="preserve" uid="P:System.Type.IsPointer">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is a pointer.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> ein Zeiger ist.</target>       </trans-unit>
        <trans-unit id="3903" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPointer">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a pointer; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> ein Zeiger ist, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3904" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPointer">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen generischen Typ oder Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Eigenschaft gibt immer <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3905" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPointer">
          <source>This property is read-only.</source>
          <target state="translated">Diese Eigenschaft ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="3906" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPointer">
          <source>The following example shows a use of the <ph id="ph1">`IsPointer`</ph> property.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die Verwendung von der <ph id="ph1">`IsPointer`</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="3907" translate="yes" xml:space="preserve" uid="M:System.Type.IsPointerImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.IsPointer" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a pointer.</source>
          <target state="translated">Implementiert beim Überschreiben in einer abgeleiteten Klasse die <ph id="ph1">&lt;see cref="P:System.Type.IsPointer" /&gt;</ph>-Eigenschaft und bestimmt, ob <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> ein Zeiger ist.</target>       </trans-unit>
        <trans-unit id="3908" translate="yes" xml:space="preserve" uid="M:System.Type.IsPointerImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a pointer; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> ein Zeiger ist, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3909" translate="yes" xml:space="preserve" uid="P:System.Type.IsPrimitive">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is one of the primitive types.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> zu den primitiven Typen gehört.</target>       </trans-unit>
        <trans-unit id="3910" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPrimitive">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is one of the primitive types; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> zu den primitiven Typen gehört, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3911" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPrimitive">
          <source>The primitive types are <ph id="ph1">&lt;xref:System.Boolean&gt;</ph>, <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.SByte&gt;</ph>, <ph id="ph4">&lt;xref:System.Int16&gt;</ph>, <ph id="ph5">&lt;xref:System.UInt16&gt;</ph>, <ph id="ph6">&lt;xref:System.Int32&gt;</ph>, <ph id="ph7">&lt;xref:System.UInt32&gt;</ph>, <ph id="ph8">&lt;xref:System.Int64&gt;</ph>, <ph id="ph9">&lt;xref:System.UInt64&gt;</ph>, <ph id="ph10">&lt;xref:System.IntPtr&gt;</ph>, <ph id="ph11">&lt;xref:System.UIntPtr&gt;</ph>, <ph id="ph12">&lt;xref:System.Char&gt;</ph>, <ph id="ph13">&lt;xref:System.Double&gt;</ph>, and <ph id="ph14">&lt;xref:System.Single&gt;</ph>.</source>
          <target state="translated">Primitive Typen sind <ph id="ph1">&lt;xref:System.Boolean&gt;</ph>, <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.SByte&gt;</ph>, <ph id="ph4">&lt;xref:System.Int16&gt;</ph>, <ph id="ph5">&lt;xref:System.UInt16&gt;</ph>, <ph id="ph6">&lt;xref:System.Int32&gt;</ph>, <ph id="ph7">&lt;xref:System.UInt32&gt;</ph>, <ph id="ph8">&lt;xref:System.Int64&gt;</ph>, <ph id="ph9">&lt;xref:System.UInt64&gt;</ph>, <ph id="ph10">&lt;xref:System.IntPtr&gt;</ph>, <ph id="ph11">&lt;xref:System.UIntPtr&gt;</ph>, <ph id="ph12">&lt;xref:System.Char&gt;</ph>, <ph id="ph13">&lt;xref:System.Double&gt;</ph>, und <ph id="ph14">&lt;xref:System.Single&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3912" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPrimitive">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen generischen Typ oder Typparameter in der Definition einer generischen Typ- oder Methodendefinition, diese Eigenschaft gibt immer <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3913" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPrimitive">
          <source>The following example demonstrates the <ph id="ph1">`IsContextful`</ph>, <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph> properties of the <ph id="ph4">&lt;xref:System.Type&gt;</ph> class.</source>
          <target state="translated">Das folgende Beispiel veranschaulicht die <ph id="ph1">`IsContextful`</ph>, <ph id="ph2">&lt;xref:System.Type.IsMarshalByRef%2A&gt;</ph>, und <ph id="ph3">&lt;xref:System.Type.IsPrimitive%2A&gt;</ph> Eigenschaften der <ph id="ph4">&lt;xref:System.Type&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="3914" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPrimitive">
          <source>It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</source>
          <target state="translated">Er überprüft, ob der angegebene Typ in den Kontext aufgenommen werden kann, ob er als Verweis gemarshallt werden kann und ob der Typ ein primitiver Datentyp ist.</target>       </trans-unit>
        <trans-unit id="3915" translate="yes" xml:space="preserve" uid="M:System.Type.IsPrimitiveImpl">
          <source>When overridden in a derived class, implements the <ph id="ph1">&lt;see cref="P:System.Type.IsPrimitive" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is one of the primitive types.</source>
          <target state="translated">Implementiert beim Überschreiben in einer abgeleiteten Klasse die <ph id="ph1">&lt;see cref="P:System.Type.IsPrimitive" /&gt;</ph>-Eigenschaft und bestimmt, ob <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> zu den primitiven Typen gehört.</target>       </trans-unit>
        <trans-unit id="3916" translate="yes" xml:space="preserve" uid="M:System.Type.IsPrimitiveImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is one of the primitive types; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> zu den primitiven Typen gehört, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3917" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsPrimitiveImpl">
          <source>The primitive types are <ph id="ph1">&lt;xref:System.Boolean&gt;</ph>, <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.SByte&gt;</ph>, <ph id="ph4">&lt;xref:System.Int16&gt;</ph>, <ph id="ph5">&lt;xref:System.UInt16&gt;</ph>, <ph id="ph6">&lt;xref:System.Int32&gt;</ph>, <ph id="ph7">&lt;xref:System.UInt32&gt;</ph>, <ph id="ph8">&lt;xref:System.Int64&gt;</ph>, <ph id="ph9">&lt;xref:System.UInt64&gt;</ph>, <ph id="ph10">&lt;xref:System.Char&gt;</ph>, <ph id="ph11">&lt;xref:System.Double&gt;</ph>, and <ph id="ph12">&lt;xref:System.Single&gt;</ph>.</source>
          <target state="translated">Primitive Typen sind <ph id="ph1">&lt;xref:System.Boolean&gt;</ph>, <ph id="ph2">&lt;xref:System.Byte&gt;</ph>, <ph id="ph3">&lt;xref:System.SByte&gt;</ph>, <ph id="ph4">&lt;xref:System.Int16&gt;</ph>, <ph id="ph5">&lt;xref:System.UInt16&gt;</ph>, <ph id="ph6">&lt;xref:System.Int32&gt;</ph>, <ph id="ph7">&lt;xref:System.UInt32&gt;</ph>, <ph id="ph8">&lt;xref:System.Int64&gt;</ph>, <ph id="ph9">&lt;xref:System.UInt64&gt;</ph>, <ph id="ph10">&lt;xref:System.Char&gt;</ph>, <ph id="ph11">&lt;xref:System.Double&gt;</ph>, und <ph id="ph12">&lt;xref:System.Single&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3918" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsPrimitiveImpl">
          <source>The following example determines whether the given type is a primitive type and displays the result.</source>
          <target state="translated">Im folgenden Beispiel wird bestimmt, ob der angegebene Typ ein primitiver Typ ist, und das Ergebnis wird angezeigt.</target>       </trans-unit>
        <trans-unit id="3919" translate="yes" xml:space="preserve" uid="P:System.Type.IsPublic">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is declared public.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> als öffentlich deklariert ist.</target>       </trans-unit>
        <trans-unit id="3920" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is declared public and is not a nested type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> als öffentlich deklariert und kein geschachtelter Typ ist, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3921" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source>Do not use with nested types; use <ph id="ph1">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> instead.</source>
          <target state="translated">Verwenden Sie keine geschachtelten Typen. Verwenden Sie <ph id="ph1">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> stattdessen.</target>       </trans-unit>
        <trans-unit id="3922" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3923" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> selects the visibility attributes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType&gt;</ph> Wählt die Sichtbarkeitsattribute an.</target>       </trans-unit>
        <trans-unit id="3924" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source>The following example creates an instance of <ph id="ph1">`MyTestClass`</ph>, checks for the <ph id="ph2">`IsPublic`</ph> property, and displays the result.</source>
          <target state="translated">Das folgende Beispiel erstellt eine Instanz des <ph id="ph1">`MyTestClass`</ph>, überprüft, ob die <ph id="ph2">`IsPublic`</ph> -Eigenschaft, und das Ergebnis wird angezeigt.</target>       </trans-unit>
        <trans-unit id="3925" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsPublic">
          <source>For nested classes, ignore the results of <ph id="ph1">`IsPublic`</ph> and <ph id="ph2">`IsNotPublic`</ph> and pay attention only to the results of <ph id="ph3">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Type.IsNestedPrivate%2A&gt;</ph>.</source>
          <target state="translated">Für geschachtelte Klassen, ignorieren Sie die Ergebnisse der <ph id="ph1">`IsPublic`</ph> und <ph id="ph2">`IsNotPublic`</ph> und achten Sie darauf, nur für die Ergebnisse der <ph id="ph3">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> und <ph id="ph4">&lt;xref:System.Type.IsNestedPrivate%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3926" translate="yes" xml:space="preserve" uid="P:System.Type.IsSealed">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is declared sealed.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> als versiegelt deklariert ist.</target>       </trans-unit>
        <trans-unit id="3927" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSealed">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is declared sealed; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> als versiegelt deklariert ist, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3928" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSealed">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter eines generischen Typs darstellt, auf diese Eigenschaft gibt immer <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="3929" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSealed">
          <source>The following example creates an instance of a <ph id="ph1">`sealed`</ph> class, checks for the <ph id="ph2">`IsSealed`</ph> property, and displays the result.</source>
          <target state="translated">Das folgende Beispiel erstellt eine Instanz von einem <ph id="ph1">`sealed`</ph> Klasse, sucht der <ph id="ph2">`IsSealed`</ph> -Eigenschaft, und das Ergebnis wird angezeigt.</target>       </trans-unit>
        <trans-unit id="3930" translate="yes" xml:space="preserve" uid="P:System.Type.IsSecurityCritical">
          <source>Gets a value that indicates whether the current type is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitsrelevant ist und daher wichtige Vorgänge ausführen darf.</target>       </trans-unit>
        <trans-unit id="3931" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is security-critical or security-safe-critical at the current trust level; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is transparent.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitsrelevant ist, <ph id="ph2">&lt;see langword="false" /&gt;</ph>, wenn er sicherheitstransparent ist.</target>       </trans-unit>
        <trans-unit id="3932" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, und <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> Eigenschaften melden die Transparenzebene eines Typs mit der aktuellen Vertrauensebene, wie von der common Language Runtime (CLR) bestimmt.</target>       </trans-unit>
        <trans-unit id="3933" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">In der folgenden Tabelle werden die Kombinationen dieser Eigenschaften gezeigt:</target>       </trans-unit>
        <trans-unit id="3934" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>Security level</source>
          <target state="translated">Sicherheitsstufe</target>       </trans-unit>
        <trans-unit id="3935" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="3936" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="3937" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="3938" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>Critical</source>
          <target state="translated">Kritisch</target>       </trans-unit>
        <trans-unit id="3939" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>Safe critical</source>
          <target state="translated">Safe ist kritisch</target>       </trans-unit>
        <trans-unit id="3940" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>Transparent</source>
          <target state="translated">Transparent</target>       </trans-unit>
        <trans-unit id="3941" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.</target>       </trans-unit>
        <trans-unit id="3942" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">Für teilweise vertrauenswürdige Assemblys ist der Wert dieser Eigenschaft hängt von der aktuellen Vertrauensebene der Assembly.</target>       </trans-unit>
        <trans-unit id="3943" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Wenn die Assembly in einer teilweise vertrauenswürdigen Anwendungsdomäne (z. B. in einer Sandkastenanwendungsdomäne) geladen wird, ignoriert die Common Language Runtime die sicherheitsanmerkungen der Assembly.</target>       </trans-unit>
        <trans-unit id="3944" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">Die Assembly und alle zugehörigen Typen werden als transparent behandelt.</target>       </trans-unit>
        <trans-unit id="3945" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">Die Common Language Runtime zahlt Beachtung der sicherheitsanmerkungen einer teilweise vertrauenswürdigen Assembly nur, wenn diese Assembly in eine voll vertrauenswürdige Anwendungsdomäne (z. B. in der Standardanwendungsdomäne einer Desktopanwendung) geladen wird.</target>       </trans-unit>
        <trans-unit id="3946" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">Dagegen ist eine vertrauenswürdige Assembly (d. h. eine Assembly mit starkem Namen, die im globalen Assemblycache installiert ist) immer mit voller Vertrauenswürdigkeit unabhängig von der Vertrauensebene der Anwendungsdomäne geladen, damit der aktuellen Vertrauensebene immer voll vertrauenswürdig ist.</target>       </trans-unit>
        <trans-unit id="3947" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">Sie können die aktuellen Vertrauensebenen von Assemblys und Anwendungsdomänen bestimmen, indem Sie mit der <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> Eigenschaften.</target>       </trans-unit>
        <trans-unit id="3948" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">Weitere Informationen über Reflektion und Transparenz finden Sie unter <bpt id="p1">[</bpt>Sicherheitsüberlegungen für die Reflektion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3949" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Informationen zur Transparenz finden Sie unter <bpt id="p1">[</bpt>Sicherheitsänderungen<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3950" translate="yes" xml:space="preserve" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Gets a value that indicates whether the current type is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitsrelevant ist, d. h. ob er wichtige Vorgänge ausführen darf und ob von transparentem Code auf ihn zugegriffen werden kann.</target>       </trans-unit>
        <trans-unit id="3951" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current type is security-safe-critical at the current trust level; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if it is security-critical or transparent.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitsrelevant ist, <ph id="ph2">&lt;see langword="false" /&gt;</ph> wenn er sicherheitstransparent oder sicherheitsrelevant ist.</target>       </trans-unit>
        <trans-unit id="3952" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, und <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> Eigenschaften melden die Transparenzebene eines Typs mit der aktuellen Vertrauensebene, wie von der common Language Runtime (CLR) bestimmt.</target>       </trans-unit>
        <trans-unit id="3953" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>The combinations of these properties are shown in the following table:</source>
          <target state="translated">In der folgenden Tabelle werden die Kombinationen dieser Eigenschaften gezeigt:</target>       </trans-unit>
        <trans-unit id="3954" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Security level</source>
          <target state="translated">Sicherheitsstufe</target>       </trans-unit>
        <trans-unit id="3955" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>IsSecurityCritical</source>
          <target state="translated">IsSecurityCritical</target>       </trans-unit>
        <trans-unit id="3956" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>IsSecuritySafeCritical</source>
          <target state="translated">IsSecuritySafeCritical</target>       </trans-unit>
        <trans-unit id="3957" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>IsSecurityTransparent</source>
          <target state="translated">IsSecurityTransparent</target>       </trans-unit>
        <trans-unit id="3958" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Critical</source>
          <target state="translated">Kritisch</target>       </trans-unit>
        <trans-unit id="3959" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Safe critical</source>
          <target state="translated">Safe ist kritisch</target>       </trans-unit>
        <trans-unit id="3960" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Transparent</source>
          <target state="translated">Transparent</target>       </trans-unit>
        <trans-unit id="3961" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.</target>       </trans-unit>
        <trans-unit id="3962" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">Für teilweise vertrauenswürdige Assemblys ist der Wert dieser Eigenschaft hängt von der aktuellen Vertrauensebene der Assembly.</target>       </trans-unit>
        <trans-unit id="3963" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Wenn die Assembly in einer teilweise vertrauenswürdigen Anwendungsdomäne (z. B. in einer Sandkastenanwendungsdomäne) geladen wird, ignoriert die Common Language Runtime die sicherheitsanmerkungen der Assembly.</target>       </trans-unit>
        <trans-unit id="3964" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">Die Assembly und alle zugehörigen Typen werden als transparent behandelt.</target>       </trans-unit>
        <trans-unit id="3965" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">Die Common Language Runtime zahlt Beachtung der sicherheitsanmerkungen einer teilweise vertrauenswürdigen Assembly nur, wenn diese Assembly in eine voll vertrauenswürdige Anwendungsdomäne (z. B. in der Standardanwendungsdomäne einer Desktopanwendung) geladen wird.</target>       </trans-unit>
        <trans-unit id="3966" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">Dagegen ist eine vertrauenswürdige Assembly (d. h. eine Assembly mit starkem Namen, die im globalen Assemblycache installiert ist) immer mit voller Vertrauenswürdigkeit unabhängig von der Vertrauensebene der Anwendungsdomäne geladen, damit der aktuellen Vertrauensebene immer voll vertrauenswürdig ist.</target>       </trans-unit>
        <trans-unit id="3967" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">Sie können die aktuellen Vertrauensebenen von Assemblys und Anwendungsdomänen bestimmen, indem Sie mit der <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> Eigenschaften.</target>       </trans-unit>
        <trans-unit id="3968" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">Weitere Informationen über Reflektion und Transparenz finden Sie unter <bpt id="p1">[</bpt>Sicherheitsüberlegungen für die Reflektion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3969" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecuritySafeCritical">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Informationen zur Transparenz finden Sie unter <bpt id="p1">[</bpt>Sicherheitsänderungen<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3970" translate="yes" xml:space="preserve" uid="P:System.Type.IsSecurityTransparent">
          <source>Gets a value that indicates whether the current type is transparent at the current trust level, and therefore cannot perform critical operations.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitstransparent ist und daher keine wichtigen Vorgänge ausführen kann.</target>       </trans-unit>
        <trans-unit id="3971" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the type is security-transparent at the current trust level; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der Typ auf der aktuellen Vertrauensebene sicherheitstransparent ist, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3972" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>If this property returns <ph id="ph1">`true`</ph>, the <ph id="ph2">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph> properties return <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Wenn diese Eigenschaft gibt <ph id="ph1">`true`</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph> und <ph id="ph3">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph> Eigenschaften zurückgeben <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3973" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, und <ph id="ph3">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> Eigenschaften melden die Transparenzebene eines Typs mit der aktuellen Vertrauensebene, wie von der common Language Runtime (CLR) bestimmt.</target>       </trans-unit>
        <trans-unit id="3974" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
          <target state="translated">Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.</target>       </trans-unit>
        <trans-unit id="3975" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
          <target state="translated">Für teilweise vertrauenswürdige Assemblys ist der Wert dieser Eigenschaft hängt von der aktuellen Vertrauensebene der Assembly.</target>       </trans-unit>
        <trans-unit id="3976" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</source>
          <target state="translated">Wenn die Assembly in einer teilweise vertrauenswürdigen Anwendungsdomäne (z. B. in einer Sandkastenanwendungsdomäne) geladen wird, ignoriert die Common Language Runtime die sicherheitsanmerkungen der Assembly.</target>       </trans-unit>
        <trans-unit id="3977" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>The assembly and all its types are treated as transparent.</source>
          <target state="translated">Die Assembly und alle zugehörigen Typen werden als transparent behandelt.</target>       </trans-unit>
        <trans-unit id="3978" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
          <target state="translated">Die Common Language Runtime zahlt Beachtung der sicherheitsanmerkungen einer teilweise vertrauenswürdigen Assembly nur, wenn diese Assembly in eine voll vertrauenswürdige Anwendungsdomäne (z. B. in der Standardanwendungsdomäne einer Desktopanwendung) geladen wird.</target>       </trans-unit>
        <trans-unit id="3979" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
          <target state="translated">Dagegen ist eine vertrauenswürdige Assembly (d. h. eine Assembly mit starkem Namen, die im globalen Assemblycache installiert ist) immer mit voller Vertrauenswürdigkeit unabhängig von der Vertrauensebene der Anwendungsdomäne geladen, damit der aktuellen Vertrauensebene immer voll vertrauenswürdig ist.</target>       </trans-unit>
        <trans-unit id="3980" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> properties.</source>
          <target state="translated">Sie können die aktuellen Vertrauensebenen von Assemblys und Anwendungsdomänen bestimmen, indem Sie mit der <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType&gt;</ph> Eigenschaften.</target>       </trans-unit>
        <trans-unit id="3981" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
          <target state="translated">Weitere Informationen über Reflektion und Transparenz finden Sie unter <bpt id="p1">[</bpt>Sicherheitsüberlegungen für die Reflektion<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3982" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSecurityTransparent">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
          <target state="translated">Informationen zur Transparenz finden Sie unter <bpt id="p1">[</bpt>Sicherheitsänderungen<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3983" translate="yes" xml:space="preserve" uid="P:System.Type.IsSerializable">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is serializable.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> serialisierbar ist.</target>       </trans-unit>
        <trans-unit id="3984" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is serializable; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> serialisierbar ist, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3985" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>Types that are defined in the .NET Standard are not marked with <ph id="ph1">&lt;xref:System.SerializableAttribute&gt;</ph>.</source>
          <target state="translated">In .NET Standard definierte Typen sind nicht mit markierten <ph id="ph1">&lt;xref:System.SerializableAttribute&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3986" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>Instead, each .NET implementation determines whether a type is serializable.</source>
          <target state="translated">Jede Implementierung .NET bestimmt stattdessen, ob ein Typ serialisierbar ist.</target>       </trans-unit>
        <trans-unit id="3987" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>At run time, you can use the <ph id="ph1">&lt;xref:System.Type.IsSerializable%2A&gt;</ph> property to determine whether that implementation supports serialization of an instance of the type.</source>
          <target state="translated">Zur Laufzeit können Sie die <ph id="ph1">&lt;xref:System.Type.IsSerializable%2A&gt;</ph> Eigenschaft, um zu bestimmen, ob diese Implementierung die Serialisierung einer Instanz des Typs unterstützt.</target>       </trans-unit>
        <trans-unit id="3988" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>For more information and an example, see <bpt id="p1">[</bpt>How to determine if a .NET Standard object is serializable<ept id="p1">](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md)</ept>.</source>
          <target state="translated">Weitere Informationen und ein Beispiel finden Sie unter <bpt id="p1">[</bpt>Vorgehensweise zu bestimmen, ob ein .NET Standard Objekt serialisierbar ist<ept id="p1">](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3989" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde.</target>       </trans-unit>
        <trans-unit id="3990" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Z. B. wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), der Wert dieser Eigenschaft richtet sich nach <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3991" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3992" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSerializable">
          <source>The following example creates an instance of <ph id="ph1">`MyTestClass`</ph> class, sets the [Serializable] attribute, and checks the <ph id="ph2">`IsSerializable`</ph> property for <ph id="ph3">`true`</ph> or <ph id="ph4">`false`</ph>.</source>
          <target state="translated">Das folgende Beispiel erstellt eine Instanz des <ph id="ph1">`MyTestClass`</ph> -Klasse, das [Serializable]-Attribut festgelegt, und überprüft die <ph id="ph2">`IsSerializable`</ph> -Eigenschaft für <ph id="ph3">`true`</ph> oder <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3993" translate="yes" xml:space="preserve" uid="P:System.Type.IsSpecialName">
          <source>Gets a value indicating whether the type has a name that requires special handling.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der Typ einen Namen besitzt, der eine Sonderbehandlung erfordert.</target>       </trans-unit>
        <trans-unit id="3994" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSpecialName">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the type has a name that requires special handling; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der Typ einen Namen besitzt, der eine Sonderbehandlung erfordert, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3995" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSpecialName">
          <source>Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.</source>
          <target state="translated">Namen, die beginnen mit einem Unterstrich (_), Eigenschaftenaccessoren und Operatoren überladen von Methoden enthalten sind Beispiele für Typen, die von einigen Compilern möglicherweise eine besondere Behandlung erfordern.</target>       </trans-unit>
        <trans-unit id="3996" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSpecialName">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde.</target>       </trans-unit>
        <trans-unit id="3997" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSpecialName">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Z. B. wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), der Wert dieser Eigenschaft richtet sich nach <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="3998" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsSpecialName">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="3999" translate="yes" xml:space="preserve" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>The type to compare with the current type.</source>
          <target state="translated">Der Typ, der mit dem aktuellen Typ verglichen werden soll.</target>       </trans-unit>
        <trans-unit id="4000" translate="yes" xml:space="preserve" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Determines whether the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> derives from the specified <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Bestimmt, ob der aktuelle <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> vom angegebenen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> abgeleitet ist.</target>       </trans-unit>
        <trans-unit id="4001" translate="yes" xml:space="preserve" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see langword="Type" /&gt;</ph> derives from <ph id="ph3">&lt;paramref name="c" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der aktuelle <ph id="ph2">&lt;see langword="Type" /&gt;</ph> von <ph id="ph3">&lt;paramref name="c" /&gt;</ph> abgeleitet ist, andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4002" translate="yes" xml:space="preserve" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>This method also returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if <ph id="ph2">&lt;paramref name="c" /&gt;</ph> and the current <ph id="ph3">&lt;see langword="Type" /&gt;</ph> are equal.</source>
          <target state="translated">Diese Methode gibt auch dann <ph id="ph1">&lt;see langword="false" /&gt;</ph> zurück, wenn <ph id="ph2">&lt;paramref name="c" /&gt;</ph> und der aktuelle <ph id="ph3">&lt;see langword="Type" /&gt;</ph> gleich sind.</target>       </trans-unit>
        <trans-unit id="4003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>You can call the <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> method to determine any of the following:</source>
          <target state="translated">Sie erreichen die <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> Methode, um Folgendes festzulegen:</target>       </trans-unit>
        <trans-unit id="4004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Whether one class derives from another.</source>
          <target state="translated">Gibt an, ob eine Klasse von einem anderen abgeleitet ist.</target>       </trans-unit>
        <trans-unit id="4005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Whether a type derives from <ph id="ph1">&lt;xref:System.ValueType&gt;</ph>.</source>
          <target state="translated">Ob ein Typ abgeleitet <ph id="ph1">&lt;xref:System.ValueType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>However, the <ph id="ph1">&lt;xref:System.Type.IsValueType%2A&gt;</ph> is a more efficient way to determine whether a type is a value type.</source>
          <target state="translated">Allerdings die <ph id="ph1">&lt;xref:System.Type.IsValueType%2A&gt;</ph> effizienter lässt sich bestimmen, ob ein Typ ein Werttyp ist.</target>       </trans-unit>
        <trans-unit id="4007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Whether a type derives from <ph id="ph1">&lt;xref:System.Enum&gt;</ph>.</source>
          <target state="translated">Ob ein Typ abgeleitet <ph id="ph1">&lt;xref:System.Enum&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>However, the <ph id="ph1">&lt;xref:System.Type.IsEnum%2A&gt;</ph> method is a more efficient way to determine whether a type is an enumeration.</source>
          <target state="translated">Allerdings die <ph id="ph1">&lt;xref:System.Type.IsEnum%2A&gt;</ph> Methode ist eine effizientere Methode zum bestimmen, ob ein Typ eine Enumeration ist.</target>       </trans-unit>
        <trans-unit id="4009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Whether a type is a delegate, that is, whether it derives from either <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> or <ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph>.</source>
          <target state="translated">Gibt an, ob ein Typ ein Delegat ist, ob er entweder abgeleitet <ph id="ph1">&lt;xref:System.Delegate&gt;</ph> oder <ph id="ph2">&lt;xref:System.MulticastDelegate&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> Methode kann nicht verwendet werden, um zu bestimmen, ob eine Schnittstelle von einer anderen Schnittstelle abgeleitet wird, oder gibt an, ob eine Klasse eine Schnittstelle implementiert.</target>       </trans-unit>
        <trans-unit id="4011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph> method for that purpose, as the following example shows.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph> Methode für diesen Zweck, wie im folgenden Beispiel gezeigt.</target>       </trans-unit>
        <trans-unit id="4012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, it derives from its class constraint or from <ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph> if it has no class constraint.</source>
          <target state="translated">Wenn das aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> jedoch einen Typparameter darstellt, in der Definition einer generischen Typ- oder Methodendefinition, abgeleitet aus seiner Class-Einschränkung oder <ph id="ph2">&lt;xref:System.Object?displayProperty=nameWithType&gt;</ph> hat keine klasseneinschränkung.</target>       </trans-unit>
        <trans-unit id="4013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>Except when used with interfaces, <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> is the converse of <ph id="ph2">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph>.</source>
          <target state="translated">Außer in Verbindung mit Schnittstellen, <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> ist das Gegenteil von <ph id="ph2">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>That is, if <ph id="ph1">`t1.IsSubclassOf(t2)`</ph> is <ph id="ph2">`true`</ph>, then <ph id="ph3">`t2.IsAssignableFrom(t1)`</ph> is also <ph id="ph4">`true`</ph>.</source>
          <target state="translated">D. h. wenn <ph id="ph1">`t1.IsSubclassOf(t2)`</ph> ist <ph id="ph2">`true`</ph>, klicken Sie dann <ph id="ph3">`t2.IsAssignableFrom(t1)`</ph> ist auch <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="4015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>This method can be overridden by a derived class.</source>
          <target state="translated">Diese Methode kann durch eine abgeleitete Klasse überschrieben werden.</target>       </trans-unit>
        <trans-unit id="4016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>The following example creates a class named <ph id="ph1">`Class1`</ph> and a derived class named <ph id="ph2">`DerivedC1`</ph>.</source>
          <target state="translated">Das folgende Beispiel erstellt eine Klasse namens <ph id="ph1">`Class1`</ph> und eine abgeleitete Klasse mit dem Namen <ph id="ph2">`DerivedC1`</ph>.</target>       </trans-unit>
        <trans-unit id="4017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source>It calls the <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> method to show that <ph id="ph2">`DerivedC1`</ph> is a subclass of <ph id="ph3">`Class1`</ph>.</source>
          <target state="translated">Ruft die <ph id="ph1">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> Methode, um anzugeben, dass <ph id="ph2">`DerivedC1`</ph> ist eine Unterklasse von <ph id="ph3">`Class1`</ph>.</target>       </trans-unit>
        <trans-unit id="4018" translate="yes" xml:space="preserve" uid="M:System.Type.IsSubclassOf(System.Type)">
          <source><ph id="ph1">&lt;paramref name="c" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="c" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4019" translate="yes" xml:space="preserve" uid="P:System.Type.IsUnicodeClass">
          <source>Gets a value indicating whether the string format attribute <ph id="ph1">&lt;see langword="UnicodeClass" /&gt;</ph> is selected for the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob für <ph id="ph1">&lt;see langword="UnicodeClass" /&gt;</ph> das Zeichenfolgenformatattribut <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> ausgewählt ist.</target>       </trans-unit>
        <trans-unit id="4020" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the string format attribute <ph id="ph2">&lt;see langword="UnicodeClass" /&gt;</ph> is selected for the <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn für <ph id="ph2">&lt;see langword="UnicodeClass" /&gt;</ph> das Zeichenfolgenformatattribut <ph id="ph3">&lt;see cref="T:System.Type" /&gt;</ph> ausgewählt ist, andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4021" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> is used to select the string format attributes.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> wird verwendet, um die Zeichenfolge Formatattribute auszuwählen.</target>       </trans-unit>
        <trans-unit id="4022" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source>The string format attributes enhance interoperability by defining how strings should be interpreted.</source>
          <target state="translated">Die Zeichenfolge Formatattribute zur Verbesserung der Interoperabilität von definieren, wie Zeichenfolgen interpretiert werden sollen.</target>       </trans-unit>
        <trans-unit id="4023" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde.</target>       </trans-unit>
        <trans-unit id="4024" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Z. B. wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), der Wert dieser Eigenschaft richtet sich nach <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="4025" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsUnicodeClass">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="4026" translate="yes" xml:space="preserve" uid="P:System.Type.IsValueType">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is a value type.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> ein Werttyp ist.</target>       </trans-unit>
        <trans-unit id="4027" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a value type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> ein Werttyp ist, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4028" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>Value types are types that are represented as sequences of bits; value types are not classes or interfaces.</source>
          <target state="translated">Werttypen sind Typen, die als Sequenzen von Bits dargestellt werden. Werttypen sind nicht Klassen oder Schnittstellen.</target>       </trans-unit>
        <trans-unit id="4029" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>Value types are referred to as "structs" in some programming languages.</source>
          <target state="translated">Werttypen werden in einigen Programmiersprachen als "Strukturen" bezeichnet.</target>       </trans-unit>
        <trans-unit id="4030" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>Enums are a special case of value types.</source>
          <target state="translated">Enumerationen sind ein besonderer Fall von Werttypen.</target>       </trans-unit>
        <trans-unit id="4031" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>This property returns <ph id="ph1">`false`</ph> for the <ph id="ph2">&lt;xref:System.ValueType&gt;</ph> class, because <ph id="ph3">&lt;xref:System.ValueType&gt;</ph> is not a value type itself.</source>
          <target state="translated">Diese Eigenschaft gibt <ph id="ph1">`false`</ph> für die <ph id="ph2">&lt;xref:System.ValueType&gt;</ph> Klasse, da <ph id="ph3">&lt;xref:System.ValueType&gt;</ph> ist kein Werttyp selbst.</target>       </trans-unit>
        <trans-unit id="4032" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>It is the base class for all value types, and therefore any value type can be assigned to it.</source>
          <target state="translated">Es ist die Basisklasse für alle Werttypen und aus diesem Grund zu einem beliebigen Werttyp zugewiesen werden kann.</target>       </trans-unit>
        <trans-unit id="4033" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>This would not be possible if <ph id="ph1">&lt;xref:System.ValueType&gt;</ph> itself was a value type.</source>
          <target state="translated">Dies ist nicht möglich, wenn <ph id="ph1">&lt;xref:System.ValueType&gt;</ph> selbst wurde ein Werttyp.</target>       </trans-unit>
        <trans-unit id="4034" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>Value types are boxed when they are assigned to a field of type <ph id="ph1">&lt;xref:System.ValueType&gt;</ph>.</source>
          <target state="translated">Werttypen sind geschachtelt, wenn sie ein Feld des Typs zugewiesen werden <ph id="ph1">&lt;xref:System.ValueType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4035" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>This property returns <ph id="ph1">`true`</ph> for enumerations, but not for the <ph id="ph2">&lt;xref:System.Enum&gt;</ph> type itself.</source>
          <target state="translated">Diese Eigenschaft gibt <ph id="ph1">`true`</ph> für Enumerationen, jedoch nicht für die <ph id="ph2">&lt;xref:System.Enum&gt;</ph> -Typ selbst.</target>       </trans-unit>
        <trans-unit id="4036" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>For an example that demonstrates this behavior, see <ph id="ph1">&lt;xref:System.Type.IsEnum%2A&gt;</ph>.</source>
          <target state="translated">Ein Beispiel für dieses Verhalten finden Sie unter <ph id="ph1">&lt;xref:System.Type.IsEnum%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4037" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>This property is read-only.</source>
          <target state="translated">Diese Eigenschaft ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="4038" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsValueType">
          <source>The following example creates a variable of type <ph id="ph1">`MyEnum`</ph>, checks for the <ph id="ph2">`IsValueType`</ph> property, and displays the result.</source>
          <target state="translated">Das folgende Beispiel erstellt eine Variable vom Typ <ph id="ph1">`MyEnum`</ph>, überprüft, ob die <ph id="ph2">`IsValueType`</ph> -Eigenschaft, und das Ergebnis wird angezeigt.</target>       </trans-unit>
        <trans-unit id="4039" translate="yes" xml:space="preserve" uid="M:System.Type.IsValueTypeImpl">
          <source>Implements the <ph id="ph1">&lt;see cref="P:System.Type.IsValueType" /&gt;</ph> property and determines whether the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a value type; that is, not a class or an interface.</source>
          <target state="translated">Implementiert die <ph id="ph1">&lt;see cref="P:System.Type.IsValueType" /&gt;</ph>-Eigenschaft und bestimmt, ob <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> ein Werttyp ist, also weder eine Klasse noch eine Schnittstelle.</target>       </trans-unit>
        <trans-unit id="4040" translate="yes" xml:space="preserve" uid="M:System.Type.IsValueTypeImpl">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a value type; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> ein Werttyp ist, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsValueTypeImpl">
          <source>This method is provided to enable the implementation of alternate type systems.</source>
          <target state="translated">Diese Methode wird bereitgestellt, um die Implementierung von alternativen Typsysteme zu aktivieren.</target>       </trans-unit>
        <trans-unit id="4042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.IsValueTypeImpl">
          <source>It is not generally used in application code.</source>
          <target state="translated">Es wird im Allgemeinen nicht im Anwendungscode verwendet.</target>       </trans-unit>
        <trans-unit id="4043" translate="yes" xml:space="preserve" uid="P:System.Type.IsVisible">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> can be accessed by code outside the assembly.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob auf den <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> aus Code von außerhalb der Assembly zugegriffen werden kann.</target>       </trans-unit>
        <trans-unit id="4044" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsVisible">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> is a public type or a public nested type such that all the enclosing types are public; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der aktuelle <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> ein öffentlicher Typ oder ein öffentlicher geschachtelter Typ ist, sodass alle einschließenden Typen öffentlich sind, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4045" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsVisible">
          <source>Use this property to determine whether a type is part of the public interface of a component assembly.</source>
          <target state="translated">Verwenden Sie diese Eigenschaft, um zu bestimmen, ob ein Teil der öffentlichen Schnittstelle einer Komponente-Assembly ist.</target>       </trans-unit>
        <trans-unit id="4046" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.IsVisible">
          <source>The following code example tests two classes, only one of which is visible outside the assembly.</source>
          <target state="translated">Im folgenden Codebeispiel wird testet zwei Klassen, von denen nur, die eine außerhalb der Assembly sichtbar ist.</target>       </trans-unit>
        <trans-unit id="4047" translate="yes" xml:space="preserve" uid="T:System.Type">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents an array of the current type.</source>
          <target state="translated">Gibt ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt zurück, das ein Array des aktuellen Typs darstellt.</target>       </trans-unit>
        <trans-unit id="4048" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing a one-dimensional array of the current type, with a lower bound of zero.</source>
          <target state="translated">Gibt ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt zurück, das ein eindimensionales Array vom aktuellen Typ mit einer unteren Grenze von 0 (null) darstellt.</target>       </trans-unit>
        <trans-unit id="4049" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing a one-dimensional array of the current type, with a lower bound of zero.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt, das ein eindimensionales Array vom aktuellen Typ mit einer unteren Grenze von 0 (null) darstellt.</target>       </trans-unit>
        <trans-unit id="4050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> method provides a way to generate array types whose element types are computed at run time.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> Methode bietet eine Möglichkeit zum Arraytypen generieren, deren Elementtypen zur Laufzeit berechnet werden.</target>       </trans-unit>
        <trans-unit id="4051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</source>
          <target state="translated"><bpt id="p1">**</bpt>Hinweis<ept id="p1">**</ept> die common Language Runtime unterscheidet zwischen Vektoren (d. h. eindimensionale Arrays, die immer nullbasiert sind) und mehrdimensionale Arrays.</target>       </trans-unit>
        <trans-unit id="4052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source>A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</source>
          <target state="translated">Ein Vektor, der immer nur eine Dimension hat, ist nicht identisch mit einem mehrdimensionalen Array, das ausgeführt wird, nur eine Dimension aufweisen.</target>       </trans-unit>
        <trans-unit id="4053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source>This method overload can only be used to create vector types, and it is the only way to create a vector type.</source>
          <target state="translated">Überladung dieser Methode kann nur verwendet werden, um vektortypen zu erstellen, und es ist die einzige Möglichkeit, einen Vector-Typ zu erstellen.</target>       </trans-unit>
        <trans-unit id="4054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.MakeArrayType%28System.Int32%29&gt;</ph> method overload to create multidimensional array types.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Type.MakeArrayType%28System.Int32%29&gt;</ph> -methodenüberladung, um mehrdimensionale von Arraytypen zu erstellen.</target>       </trans-unit>
        <trans-unit id="4055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType">
          <source>The following code example creates array, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> in Visual Basic), and pointer types for the <ph id="ph3">`Test`</ph> class.</source>
          <target state="translated">Im folgenden Codebeispiel wird erstellt, Array, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> in Visual Basic), und Zeigertypen für die <ph id="ph3">`Test`</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="4056" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="4057" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>Derived classes must provide an implementation.</source>
          <target state="translated">Abgeleitete Klassen müssen eine Implementation angeben.</target>       </trans-unit>
        <trans-unit id="4058" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>The current type is <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated">Der aktuelle Typ ist <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4059" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="4060" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>The current type is a <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> type.</source>
          <target state="translated">Der aktuelle Typ ist ein <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph>-Typ.</target>       </trans-unit>
        <trans-unit id="4061" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Das heißt, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> gibt <ph id="ph2">&lt;see langword="true" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="4062" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The number of dimensions for the array.</source>
          <target state="translated">Die Anzahl von Dimensionen für das Array.</target>       </trans-unit>
        <trans-unit id="4063" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>This number must be less than or equal to 32.</source>
          <target state="translated">Diese Zahl muss kleiner oder gleich 32 sein.</target>       </trans-unit>
        <trans-unit id="4064" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing an array of the current type, with the specified number of dimensions.</source>
          <target state="translated">Gibt ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt zurück, das ein Array vom aktuellen Typ mit der angegebenen Anzahl von Dimensionen darstellt.</target>       </trans-unit>
        <trans-unit id="4065" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>An object representing an array of the current type, with the specified number of dimensions.</source>
          <target state="translated">Ein Objekt, das ein Array vom aktuellen Typ mit der angegebenen Anzahl von Dimensionen darstellt.</target>       </trans-unit>
        <trans-unit id="4066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> method provides a way to generate array types whose element types are computed at run time.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> Methode bietet eine Möglichkeit zum Arraytypen generieren, deren Elementtypen zur Laufzeit berechnet werden.</target>       </trans-unit>
        <trans-unit id="4067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</source>
          <target state="translated">Die common Language Runtime unterscheidet zwischen Vektoren (d. h. eindimensionale Arrays, die immer nullbasiert sind) und mehrdimensionale Arrays.</target>       </trans-unit>
        <trans-unit id="4068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</source>
          <target state="translated">Ein Vektor, der immer nur eine Dimension hat, ist nicht identisch mit einem mehrdimensionalen Array, das ausgeführt wird, nur eine Dimension aufweisen.</target>       </trans-unit>
        <trans-unit id="4069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>You cannot use this method overload to create a vector type; if <ph id="ph1">`rank`</ph> is 1, this method overload returns a multidimensional array type that happens to have one dimension.</source>
          <target state="translated">Überladung dieser Methode können Sie um einen Vector-Typ zu erstellen. Wenn <ph id="ph1">`rank`</ph> beträgt 1, Überladung dieser Methode gibt einen mehrdimensionales Array-Typ, der an eine Dimension über zurück.</target>       </trans-unit>
        <trans-unit id="4070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.MakeArrayType&gt;</ph> method overload to create vector types.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Type.MakeArrayType&gt;</ph> -methodenüberladung vektortypen zu erstellen.</target>       </trans-unit>
        <trans-unit id="4071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The following code example creates array, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> in Visual Basic), and pointer types for the <ph id="ph3">`Test`</ph> class.</source>
          <target state="translated">Im folgenden Codebeispiel wird erstellt, Array, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> in Visual Basic), und Zeigertypen für die <ph id="ph3">`Test`</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="4072" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> is invalid.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> ist ungültig.</target>       </trans-unit>
        <trans-unit id="4073" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>For example, 0 or negative.</source>
          <target state="translated">Beispielsweise 0 oder ein negativer Wert.</target>       </trans-unit>
        <trans-unit id="4074" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="4075" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The current type is <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated">Der aktuelle Typ ist <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4076" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="4077" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>The current type is a <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> type.</source>
          <target state="translated">Der aktuelle Typ ist ein <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph>-Typ.</target>       </trans-unit>
        <trans-unit id="4078" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Das heißt, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> gibt <ph id="ph2">&lt;see langword="true" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="4079" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="4080" translate="yes" xml:space="preserve" uid="M:System.Type.MakeArrayType(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> is greater than 32.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="rank" /&gt;</ph> ist größer als 32.</target>       </trans-unit>
        <trans-unit id="4081" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the current type when passed as a <ph id="ph2">&lt;see langword="ref" /&gt;</ph> parameter (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> parameter in Visual Basic).</source>
          <target state="translated">Gibt ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt zurück, das beim Übergeben als <ph id="ph2">&lt;see langword="ref" /&gt;</ph>-Parameter (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph>-Parameter in Visual Basic) den aktuellen Typ darstellt.</target>       </trans-unit>
        <trans-unit id="4082" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents the current type when passed as a <ph id="ph2">&lt;see langword="ref" /&gt;</ph> parameter (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph> parameter in Visual Basic).</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt, das beim Übergeben als <ph id="ph2">&lt;see langword="ref" /&gt;</ph>-Parameter (<ph id="ph3">&lt;see langword="ByRef" /&gt;</ph>-Parameter in Visual Basic) den aktuellen Typ darstellt.</target>       </trans-unit>
        <trans-unit id="4083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeByRefType">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph> method provides a way to generate <ph id="ph2">`ref`</ph> types (<ph id="ph3">`ByRef`</ph> in Visual Basic) for parameter lists.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph> Methode bietet eine Möglichkeit zum Generieren von <ph id="ph2">`ref`</ph> Typen (<ph id="ph3">`ByRef`</ph> in Visual Basic) für Parameter aufgeführt sind.</target>       </trans-unit>
        <trans-unit id="4084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeByRefType">
          <source>Using the syntax of Microsoft intermediate language (MSIL), if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, this method returns a <ph id="ph3">&lt;xref:System.Type&gt;</ph> object representing <ph id="ph4">`Int32&amp;`</ph>.</source>
          <target state="translated">Verwenden die Syntax der Microsoft intermediate Language (MSIL), wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> -Objekt stellt <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, gibt diese Methode eine <ph id="ph3">&lt;xref:System.Type&gt;</ph> Objekt darstellt <ph id="ph4">`Int32&amp;`</ph>.</target>       </trans-unit>
        <trans-unit id="4085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeByRefType">
          <source>The following code example creates array, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> in Visual Basic), and pointer types for the <ph id="ph3">`Test`</ph> class.</source>
          <target state="translated">Im folgenden Codebeispiel wird erstellt, Array, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> in Visual Basic), und Zeigertypen für die <ph id="ph3">`Test`</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="4086" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="4087" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>The current type is <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated">Der aktuelle Typ ist <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4088" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="4089" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>The current type is a <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> type.</source>
          <target state="translated">Der aktuelle Typ ist ein <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph>-Typ.</target>       </trans-unit>
        <trans-unit id="4090" translate="yes" xml:space="preserve" uid="M:System.Type.MakeByRefType">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Das heißt, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> gibt <ph id="ph2">&lt;see langword="true" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="4091" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>An array of types to be substituted for the type parameters of the current generic type.</source>
          <target state="translated">Ein Array von Typen, die die Typparameter des aktuellen generischen Typs ersetzen sollen.</target>       </trans-unit>
        <trans-unit id="4092" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object representing the resulting constructed type.</source>
          <target state="translated">Ersetzt die Typparameter der aktuellen generischen Typdefinition durch die Elemente eines Arrays von Typen und gibt ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt zurück, das den resultierenden konstruierten Typ darstellt.</target>       </trans-unit>
        <trans-unit id="4093" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> representing the constructed type formed by substituting the elements of <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> for the type parameters of the current generic type.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>, der den konstruierten Typ darstellt, der durch Ersetzen der Typparameter des aktuellen generischen Typs durch die Elemente von <ph id="ph2">&lt;paramref name="typeArguments" /&gt;</ph> erstellt wurde.</target>       </trans-unit>
        <trans-unit id="4094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object that represents a particular constructed type.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> Methode können Sie Code schreiben, der spezifische Typen zugewiesen werden, um die Typparameter einer generischen Typdefinition, wodurch eine <ph id="ph2">&lt;xref:System.Type&gt;</ph> -Objekt, das einen bestimmten konstruierten Typ darstellt.</target>       </trans-unit>
        <trans-unit id="4095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>You can use this <ph id="ph1">&lt;xref:System.Type&gt;</ph> object to create run-time instances of the constructed type.</source>
          <target state="translated">Sie können dies <ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekt, das zur Laufzeit Instanzen des konstruierten Typs zu erstellen.</target>       </trans-unit>
        <trans-unit id="4096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Types constructed with <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> can be open, that is, some of their type arguments can be type parameters of enclosing generic methods or types.</source>
          <target state="translated">Typen mit erstellt <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> geöffnet sein können, d. h. einige ihrer Typargumente Typparameter von einschließenden generischen Methoden und Typen werden können.</target>       </trans-unit>
        <trans-unit id="4097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>You might use such open constructed types when you emit dynamic assemblies.</source>
          <target state="translated">Sie können solche offen konstruierten Typen verwenden, wenn Ausgeben von dynamischen Assemblys.</target>       </trans-unit>
        <trans-unit id="4098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>For example, consider the classes <ph id="ph1">`Base`</ph> and <ph id="ph2">`Derived`</ph> in the following code.</source>
          <target state="translated">Betrachten Sie beispielsweise die Klassen <ph id="ph1">`Base`</ph> und <ph id="ph2">`Derived`</ph> in den folgenden Code.</target>       </trans-unit>
        <trans-unit id="4099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To generate <ph id="ph1">`Derived`</ph> in a dynamic assembly, it is necessary to construct its base type.</source>
          <target state="translated">Zum generieren <ph id="ph1">`Derived`</ph> in einer dynamischen Assembly zum Erstellen von seinem Basistyps erforderlich ist.</target>       </trans-unit>
        <trans-unit id="4100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To do this, call the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method on a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object representing the class <ph id="ph3">`Base`</ph>, using the generic type arguments <ph id="ph4">&lt;xref:System.Int32&gt;</ph> and the type parameter <ph id="ph5">`V`</ph> from <ph id="ph6">`Derived`</ph>.</source>
          <target state="translated">Rufen Sie hierzu die <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> Methode auf eine <ph id="ph2">&lt;xref:System.Type&gt;</ph> Objekt, das die Klasse darstellt <ph id="ph3">`Base`</ph>, verwenden die generischen Typargumente <ph id="ph4">&lt;xref:System.Int32&gt;</ph> und die Typparameter <ph id="ph5">`V`</ph> aus <ph id="ph6">`Derived`</ph>.</target>       </trans-unit>
        <trans-unit id="4101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Because types and generic type parameters are both represented by <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects, an array containing both can be passed to the <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method.</source>
          <target state="translated">Da die Typen und generischen Typparameter von dargestellt sind <ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekte aufweist, ein Array mit diesen beiden kann übergeben werden, um die <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="4102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>A constructed type such as <ph id="ph1">`Base&lt;int, V&gt;`</ph> is useful when emitting code, but you cannot call the <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method on this type because it is not a generic type definition.</source>
          <target state="translated">Einen konstruierten Typ wie z. B. <ph id="ph1">`Base&lt;int, V&gt;`</ph> ist nützlich, wenn Code ausgeben, jedoch nicht die <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> Methode für diesen Typ, da es sich nicht um eine generische Typdefinition ist.</target>       </trans-unit>
        <trans-unit id="4103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To create a closed constructed type that can be instantiated, first call the <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method to get a <ph id="ph2">&lt;xref:System.Type&gt;</ph> object representing the generic type definition and then call <ph id="ph3">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> with the desired type arguments.</source>
          <target state="translated">Um einen geschlossenen konstruierten Typ zu erstellen, der instanziiert werden kann, rufen Sie zuerst die <ph id="ph1">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> Methode zum Abrufen einer <ph id="ph2">&lt;xref:System.Type&gt;</ph> Objekt, das die generische Typdefinition darstellt, und rufen dann <ph id="ph3">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> mit den gewünschten Typargumenten.</target>       </trans-unit>
        <trans-unit id="4104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The <ph id="ph1">&lt;xref:System.Type&gt;</ph> object returned by <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> is the same as the <ph id="ph3">&lt;xref:System.Type&gt;</ph> obtained by calling the <ph id="ph4">&lt;xref:System.Object.GetType%2A&gt;</ph> method of the resulting constructed type, or the <ph id="ph5">&lt;xref:System.Object.GetType%2A&gt;</ph> method of any constructed type that was created from the same generic type definition using the same type arguments.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type&gt;</ph> zurückgegebenes Objekt <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> ist identisch mit der <ph id="ph3">&lt;xref:System.Type&gt;</ph> abgerufen, indem die <ph id="ph4">&lt;xref:System.Object.GetType%2A&gt;</ph> Methode den resultierenden konstruierten Typ, oder die <ph id="ph5">&lt;xref:System.Object.GetType%2A&gt;</ph> -Methode einer jeglichen konstruierter Typ, der aus der gleichen generischen erstellt wurde mit den gleichen Typargumenten Typdefinition.</target>       </trans-unit>
        <trans-unit id="4105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>An array of generic types is not itself a generic type.</source>
          <target state="translated">Ein Array von generischen Typen nicht selbst ein generischer Typ ist.</target>       </trans-unit>
        <trans-unit id="4106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>You cannot call <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> on an array type such as <ph id="ph2">`C&lt;T&gt;[]`</ph> (<ph id="ph3">`Dim ac() As C(Of T)`</ph> in Visual Basic).</source>
          <target state="translated">Sie können nicht aufrufen <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> Geben Sie auf ein Array wie z. B. <ph id="ph2">`C&lt;T&gt;[]`</ph> (<ph id="ph3">`Dim ac() As C(Of T)`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="4107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To construct a closed generic type from <ph id="ph1">`C&lt;T&gt;[]`</ph>, call <ph id="ph2">&lt;xref:System.Type.GetElementType%2A&gt;</ph> to obtain the generic type definition <ph id="ph3">`C&lt;T&gt;`</ph>; call <ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> on the generic type definition to create the constructed type; and finally call the <ph id="ph5">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> method on the constructed type to create the array type.</source>
          <target state="translated">So erstellen Sie einen geschlossenen generischen Typs aus <ph id="ph1">`C&lt;T&gt;[]`</ph>, rufen Sie <ph id="ph2">&lt;xref:System.Type.GetElementType%2A&gt;</ph> zum Abrufen der generischen Typdefinition <ph id="ph3">`C&lt;T&gt;`</ph>; Aufrufen <ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> für die generische Typdefinition, erstellen den konstruierten Typ aus, und rufen Sie schließlich die <ph id="ph5">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> Methode auf den konstruierten Typ zum Erstellen des Arraytyps.</target>       </trans-unit>
        <trans-unit id="4108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The same is true of pointer types and <ph id="ph1">`ref`</ph> types (<ph id="ph2">`ByRef`</ph> in Visual Basic).</source>
          <target state="translated">Dasselbe gilt für Zeigertypen und <ph id="ph1">`ref`</ph> Typen (<ph id="ph2">`ByRef`</ph> in Visual Basic).</target>       </trans-unit>
        <trans-unit id="4109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>For a list of the invariant conditions for terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.</source>
          <target state="translated">Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Nested Types</source>
          <target state="translated">Geschachtelte Typen</target>       </trans-unit>
        <trans-unit id="4111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>If a generic type is defined using C#, C++, or Visual Basic, then its nested types are all generic.</source>
          <target state="translated">Wenn ein generischer Typ mit c#, C++ oder Visual Basic definiert ist, sind seine geschachtelten Typen alle generisch.</target>       </trans-unit>
        <trans-unit id="4112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>This is true even if the nested types have no type parameters of their own, because all three languages include the type parameters of enclosing types in the type parameter lists of nested types.</source>
          <target state="translated">Dies gilt auch, wenn die geschachtelten Typen keine eigenen Typparameter verfügen, da alle drei Sprachen die Typparameter von einschließenden Typen in der Typparameterliste des geschachtelten Typen enthalten.</target>       </trans-unit>
        <trans-unit id="4113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Consider the following classes:</source>
          <target state="translated">Betrachten Sie die folgenden Klassen:</target>       </trans-unit>
        <trans-unit id="4114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The type parameter list of the nested class <ph id="ph1">`Inner`</ph> has two type parameters, <ph id="ph2">`T`</ph> and <ph id="ph3">`U`</ph>, the first of which is the type parameter of its enclosing class.</source>
          <target state="translated">Der Typparameterliste der geschachtelten Klasse <ph id="ph1">`Inner`</ph> verfügt über zwei Typparameter <ph id="ph2">`T`</ph> und <ph id="ph3">`U`</ph>, das erste ist der Typparameter seiner einschließenden Klasse.</target>       </trans-unit>
        <trans-unit id="4115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Similarly, the type parameter list of the nested class <ph id="ph1">`Innermost1`</ph> has three type parameters, <ph id="ph2">`T`</ph>, <ph id="ph3">`U`</ph>, and <ph id="ph4">`V`</ph>, with <ph id="ph5">`T`</ph> and <ph id="ph6">`U`</ph> coming from its enclosing classes.</source>
          <target state="translated">Auf ähnliche Weise der Typparameterliste der geschachtelten Klasse <ph id="ph1">`Innermost1`</ph> verfügt über drei Typparameter, <ph id="ph2">`T`</ph>, <ph id="ph3">`U`</ph>, und <ph id="ph4">`V`</ph>, mit <ph id="ph5">`T`</ph> und <ph id="ph6">`U`</ph> aus den einschließenden Klassen stammen.</target>       </trans-unit>
        <trans-unit id="4116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The nested class <ph id="ph1">`Innermost2`</ph> has two type parameters, <ph id="ph2">`T`</ph> and <ph id="ph3">`U`</ph>, which come from its enclosing classes.</source>
          <target state="translated">Die geschachtelte Klasse <ph id="ph1">`Innermost2`</ph> verfügt über zwei Typparameter <ph id="ph2">`T`</ph> und <ph id="ph3">`U`</ph>, die aus den einschließenden Klassen stammen.</target>       </trans-unit>
        <trans-unit id="4117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>If the parameter list of the enclosing type has more than one type parameter, all the type parameters in order are included in the type parameter list of the nested type.</source>
          <target state="translated">Wenn die Parameterliste des einschließenden Typs mehrere Typparameter aufweist, werden alle Typparameter in der Reihenfolge in der Typparameterliste des geschachtelten Typs enthalten.</target>       </trans-unit>
        <trans-unit id="4118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To construct a generic type from the generic type definition for a nested type, call the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with the array formed by concatenating the type argument arrays of all the enclosing types, beginning with the outermost generic type, and ending with the type argument array of the nested type itself, if it has type parameters of its own.</source>
          <target state="translated">Um einen generischen Typ aus der generischen Typdefinition für einen geschachtelten Typ zu konstruieren, rufen Sie die <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> Methode mit dem Array gebildet durch Verketten der Typ Argument Arrays aller einschließenden Typen, ab der äußersten generische Typ, und endet mit der Geben Sie Argumentarray des geschachtelten Typs selbst verfügt über eigene Typparameter.</target>       </trans-unit>
        <trans-unit id="4119" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>To create an instance of <ph id="ph1">`Innermost1`</ph>, call the <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with an array containing three types, to be assigned to T, U, and V. To create an instance of <ph id="ph3">`Innermost2`</ph>, call the <ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with an array containing two types, to be assigned to T and U.</source>
          <target state="translated">Zum Erstellen einer Instanz des <ph id="ph1">`Innermost1`</ph>, rufen Sie die <ph id="ph2">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> Methode mit einem Array mit drei Typen, T, U und V zugewiesen werden. Zum Erstellen einer Instanz von <ph id="ph3">`Innermost2`</ph>, rufen Sie die <ph id="ph4">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> Methode mit einem Array mit zwei Typen, zuzuweisenden T "und" U.</target>       </trans-unit>
        <trans-unit id="4120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The languages propagate the type parameters of enclosing types in this fashion so you can use the type parameters of an enclosing type to define fields of nested types.</source>
          <target state="translated">Die Sprachen weitergegeben, die Typparameter von einschließenden Typen auf diese Weise, sodass Sie die Typparameter eines einschließenden Typs verwenden können, um Felder von geschachtelten Typen zu definieren.</target>       </trans-unit>
        <trans-unit id="4121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Otherwise, the type parameters would not be in scope within the bodies of the nested types.</source>
          <target state="translated">Andernfalls würde die Typparameter nicht im Gültigkeitsbereich innerhalb des Texts der geschachtelten Typen sein.</target>       </trans-unit>
        <trans-unit id="4122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>It is possible to define nested types without propagating the type parameters of enclosing types, by emitting code in dynamic assemblies or by using the <bpt id="p1">[</bpt>Ilasm.exe (IL Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</source>
          <target state="translated">Es ist möglich, geschachtelte Typen definieren, ohne die Weitergabe der Typparameter von einschließenden Typen durch Ausgeben von Code in dynamischen Assemblys oder mithilfe der <bpt id="p1">[</bpt>Ilasm.exe (IL-Assembler)<ept id="p1">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.</target>       </trans-unit>
        <trans-unit id="4123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Consider the following code for the MSIL assembler:</source>
          <target state="translated">Betrachten Sie folgenden Code für die MSIL-Assembler:</target>       </trans-unit>
        <trans-unit id="4124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>In this example, it is not possible to define a field of type <ph id="ph1">`T`</ph> or <ph id="ph2">`U`</ph> in class <ph id="ph3">`Innermost`</ph>, because those type parameters are not in scope.</source>
          <target state="translated">In diesem Beispiel ist es nicht möglich, definieren Sie ein Feld vom Typ <ph id="ph1">`T`</ph> oder <ph id="ph2">`U`</ph> in Klasse <ph id="ph3">`Innermost`</ph>, da die Typparameter nicht im Gültigkeitsbereich befinden.</target>       </trans-unit>
        <trans-unit id="4125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The following assembler code defines nested classes that behave the way they would if defined in C++, Visual Basic, and C#:</source>
          <target state="translated">Der folgende Assemblercode definiert geschachtelte Klassen, die die Verhaltensweise, wäre in C++, Visual Basic und c# definiert:</target>       </trans-unit>
        <trans-unit id="4126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>You can use the <bpt id="p1">[</bpt>Ildasm.exe (IL Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine nested classes defined in the high-level languages and observe this naming scheme.</source>
          <target state="translated">Sie können die <bpt id="p1">[</bpt>Ildasm.exe (IL-Disassembler)<ept id="p1">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> geschachtelte Klassen definiert, in hoch entwickelter Sprachen und untersuchen diese Benennungsschema.</target>       </trans-unit>
        <trans-unit id="4127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method to create a constructed type from the generic type definition for the <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> type.</source>
          <target state="translated">Im folgenden Beispiel wird die <ph id="ph1">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> Methode so erstellen Sie einen konstruierten Typ aus der Definition des generischen Typs für die <ph id="ph2">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> Typ.</target>       </trans-unit>
        <trans-unit id="4128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The constructed type represents a <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id="ph2">`Test`</ph> objects with string keys.</source>
          <target state="translated">Den konstruierte Typ darstellt, ein <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> von <ph id="ph2">`Test`</ph> Objekte mit Zeichenfolgenschlüssel.</target>       </trans-unit>
        <trans-unit id="4129" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The current type does not represent a generic type definition.</source>
          <target state="translated">Der aktuelle Typ stellt keine generische Typdefinition dar.</target>       </trans-unit>
        <trans-unit id="4130" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsGenericTypeDefinition" /&gt;</ph> returns <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Das heißt, <ph id="ph1">&lt;see cref="P:System.Type.IsGenericTypeDefinition" /&gt;</ph> gibt <ph id="ph2">&lt;see langword="false" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="4131" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4132" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="4133" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Any element of <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Ein beliebiges Element von <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4134" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The number of elements in <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> is not the same as the number of type parameters in the current generic type definition.</source>
          <target state="translated">Die Anzahl von Elementen in <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> entspricht nicht der Anzahl von Typparametern in der aktuellen generischen Typdefinition.</target>       </trans-unit>
        <trans-unit id="4135" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="4136" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Any element of <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> does not satisfy the constraints specified for the corresponding type parameter of the current generic type.</source>
          <target state="translated">Eines der Elemente von <ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> entspricht nicht den für den entsprechenden Typparameter des aktuellen generischen Typs angegebenen Einschränkungen.</target>       </trans-unit>
        <trans-unit id="4137" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="4138" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> contains an element that is a pointer type (<ph id="ph2">&lt;see cref="P:System.Type.IsPointer" /&gt;</ph> returns <ph id="ph3">&lt;see langword="true" /&gt;</ph>), a by-ref type (<ph id="ph4">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph5">&lt;see langword="true" /&gt;</ph>), or <ph id="ph6">&lt;see cref="T:System.Void" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeArguments" /&gt;</ph> enthält ein Element, das ein Zeigertyp (<ph id="ph2">&lt;see cref="P:System.Type.IsPointer" /&gt;</ph> gibt <ph id="ph3">&lt;see langword="true" /&gt;</ph> zurück), ein by-ref-Typ (<ph id="ph4">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> gibt <ph id="ph5">&lt;see langword="true" /&gt;</ph> zurück) oder <ph id="ph6">&lt;see cref="T:System.Void" /&gt;</ph> ist.</target>       </trans-unit>
        <trans-unit id="4139" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="4140" translate="yes" xml:space="preserve" uid="M:System.Type.MakeGenericType(System.Type[])">
          <source>Derived classes must provide an implementation.</source>
          <target state="translated">Abgeleitete Klassen müssen eine Implementation angeben.</target>       </trans-unit>
        <trans-unit id="4141" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a pointer to the current type.</source>
          <target state="translated">Gibt ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt zurück, das einen Zeiger auf den aktuellen Typ darstellt.</target>       </trans-unit>
        <trans-unit id="4142" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> object that represents a pointer to the current type.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt, das einen Zeiger auf den aktuellen Typ darstellt.</target>       </trans-unit>
        <trans-unit id="4143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakePointerType">
          <source>The <ph id="ph1">&lt;xref:System.Type.MakePointerType%2A&gt;</ph> method provides a way to generate pointer types for parameter lists.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Type.MakePointerType%2A&gt;</ph> Methode bietet eine Möglichkeit zum Generieren von Zeigertypen für Parameterlisten.</target>       </trans-unit>
        <trans-unit id="4144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakePointerType">
          <source>Using the syntax of Microsoft intermediate language (MSIL), if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, this method returns a <ph id="ph3">&lt;xref:System.Type&gt;</ph> object representing <ph id="ph4">`Int32*`</ph>.</source>
          <target state="translated">Verwenden die Syntax der Microsoft intermediate Language (MSIL), wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> -Objekt stellt <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, gibt diese Methode eine <ph id="ph3">&lt;xref:System.Type&gt;</ph> Objekt darstellt <ph id="ph4">`Int32*`</ph>.</target>       </trans-unit>
        <trans-unit id="4145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.MakePointerType">
          <source>The following code example creates array, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> in Visual Basic), and pointer types for the <ph id="ph3">`Test`</ph> class.</source>
          <target state="translated">Im folgenden Codebeispiel wird erstellt, Array, <ph id="ph1">`ref`</ph> (<ph id="ph2">`ByRef`</ph> in Visual Basic), und Zeigertypen für die <ph id="ph3">`Test`</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="4146" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="4147" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>The current type is <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</source>
          <target state="translated">Der aktuelle Typ ist <ph id="ph1">&lt;see cref="T:System.TypedReference" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4148" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="4149" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>The current type is a <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph> type.</source>
          <target state="translated">Der aktuelle Typ ist ein <ph id="ph1">&lt;see langword="ByRef" /&gt;</ph>-Typ.</target>       </trans-unit>
        <trans-unit id="4150" translate="yes" xml:space="preserve" uid="M:System.Type.MakePointerType">
          <source>That is, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> returns <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Das heißt, <ph id="ph1">&lt;see cref="P:System.Type.IsByRef" /&gt;</ph> gibt <ph id="ph2">&lt;see langword="true" /&gt;</ph> zurück.</target>       </trans-unit>
        <trans-unit id="4151" translate="yes" xml:space="preserve" uid="P:System.Type.MemberType">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> value indicating that this member is a type or a nested type.</source>
          <target state="translated">Ruft einen <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph>-Wert ab, der angibt, dass dieser Member ein Typ oder ein geschachtelter Typ ist.</target>       </trans-unit>
        <trans-unit id="4152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>A <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph> value indicating that this member is a type or a nested type.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Reflection.MemberTypes" /&gt;</ph>-Wert, der angibt, dass dieser Member ein Typ oder ein geschachtelter Typ ist.</target>       </trans-unit>
        <trans-unit id="4153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>This property overrides <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Diese Eigenschaft überschreibt <ph id="ph1">&lt;xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4154" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>Therefore, when you examine a set of <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects—for example, the array returned by <ph id="ph2">&lt;xref:System.Type.GetMembers%2A&gt;</ph>—the <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph> property returns <ph id="ph4">&lt;xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType&gt;</ph> when a given member is a nested type.</source>
          <target state="translated">Wenn Sie daher eine Reihe von untersuchen <ph id="ph1">&lt;xref:System.Reflection.MemberInfo&gt;</ph> Objekte – z. B. das zurückgegebene Array <ph id="ph2">&lt;xref:System.Type.GetMembers%2A&gt;</ph>– die <ph id="ph3">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph> -Eigenschaft gibt <ph id="ph4">&lt;xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType&gt;</ph> Wenn ein angegebenes Element ein geschachtelter Typ ist.</target>       </trans-unit>
        <trans-unit id="4155" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein konstruierter generischer Typ, diese Eigenschaft gilt, für die generische Typdefinition, aus der der Typ konstruiert wurde.</target>       </trans-unit>
        <trans-unit id="4156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>For example, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</source>
          <target state="translated">Z. B. wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt <ph id="ph2">`MyGenericType&lt;int&gt;`</ph> (<ph id="ph3">`MyGenericType(Of Integer)`</ph> in Visual Basic), der Wert dieser Eigenschaft richtet sich nach <ph id="ph4">`MyGenericType&lt;T&gt;`</ph>.</target>       </trans-unit>
        <trans-unit id="4157" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id="ph2">&lt;xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, auf diese Eigenschaft gibt immer <ph id="ph2">&lt;xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4158" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.MemberType">
          <source>The following code example shows the <ph id="ph1">`MemberType`</ph> field as a parameter to the <ph id="ph2">`GetMember`</ph> method:</source>
          <target state="translated">Das folgende Codebeispiel zeigt die <ph id="ph1">`MemberType`</ph> Feld als Parameter an die <ph id="ph2">`GetMember`</ph> Methode:</target>       </trans-unit>
        <trans-unit id="4159" translate="yes" xml:space="preserve" uid="F:System.Type.Missing">
          <source>Represents a missing value in the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> information.</source>
          <target state="translated">Stellt einen in den <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Informationen fehlenden Wert dar.</target>       </trans-unit>
        <trans-unit id="4160" translate="yes" xml:space="preserve" uid="F:System.Type.Missing">
          <source>This field is read-only.</source>
          <target state="translated">Dieses Feld ist schreibgeschützt.</target>       </trans-unit>
        <trans-unit id="4161" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>Use the <ph id="ph1">`Missing`</ph> field for invocation through reflection to obtain the default value of a parameter.</source>
          <target state="translated">Verwenden der <ph id="ph1">`Missing`</ph> Feld für den Aufruf durch Reflektion auf den Standardwert eines Parameters zu erhalten.</target>       </trans-unit>
        <trans-unit id="4162" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>If the <ph id="ph1">`Missing`</ph> field is passed in for a parameter value and there is no default value for that parameter, an <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> is thrown.</source>
          <target state="translated">Wenn die <ph id="ph1">`Missing`</ph> Feld für den Parameterwert übergeben wird, und es ist kein Standardwert für diesen Parameter ein <ph id="ph2">&lt;xref:System.ArgumentException&gt;</ph> ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="4163" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>The following code example shows the use of the <ph id="ph1">`Missing`</ph> field to invoke a method with its default arguments.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung von der <ph id="ph1">`Missing`</ph> Feld zum Aufrufen einer Methode mit den Standardargumenten.</target>       </trans-unit>
        <trans-unit id="4164" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>This code produces the following output:</source>
          <target state="translated">Dieser Code erzeugt die folgende Ausgabe:</target>       </trans-unit>
        <trans-unit id="4165" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>a = 10 b = 55.3 c = 12</source>
          <target state="translated">eine = 10 b = 55.3 c = 12</target>       </trans-unit>
        <trans-unit id="4166" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>a = 10 b = 1.3 c = 1</source>
          <target state="translated">eine = 10 b 1.3 c = 1 =</target>       </trans-unit>
        <trans-unit id="4167" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Type.Missing">
          <source>a = 10 b = 1.2 c = 1</source>
          <target state="translated">eine = 10 b 1.2 c = 1 =</target>       </trans-unit>
        <trans-unit id="4168" translate="yes" xml:space="preserve" uid="P:System.Type.Module">
          <source>Gets the module (the DLL) in which the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is defined.</source>
          <target state="translated">Ruft das Modul (die DLL) ab, in dem der aktuelle <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> definiert ist.</target>       </trans-unit>
        <trans-unit id="4169" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Module">
          <source>The module in which the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> is defined.</source>
          <target state="translated">Das Modul, in dem der aktuelle <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> definiert ist.</target>       </trans-unit>
        <trans-unit id="4170" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Module">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns the module in which the generic type definition was defined.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein konstruierter generischer Typ, diese Eigenschaft gibt das Modul, in dem die generische Typdefinition definiert wurde.</target>       </trans-unit>
        <trans-unit id="4171" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Module">
          <source>For example, if you create an instance of <ph id="ph1">`MyGenericStack&lt;int&gt;`</ph>, the <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> property for the constructed type returns the module in which <ph id="ph3">`MyGenericStack&lt;T&gt;`</ph> is defined.</source>
          <target state="translated">Angenommen, Sie erstellen eine Instanz von <ph id="ph1">`MyGenericStack&lt;int&gt;`</ph>, die <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> -Eigenschaft für den konstruierten Typ gibt das Modul, in dem <ph id="ph3">`MyGenericStack&lt;T&gt;`</ph> definiert ist.</target>       </trans-unit>
        <trans-unit id="4172" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Module">
          <source>Similarly, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic parameter <ph id="ph2">`T`</ph>, this property returns the assembly that contains the generic type that defines <ph id="ph3">`T`</ph>.</source>
          <target state="translated">Auf ähnliche Weise, wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen generischen Parameter <ph id="ph2">`T`</ph>, diese Eigenschaft gibt die Assembly, die den generischen Typ enthält, definiert <ph id="ph3">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="4173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Module">
          <source>This following example demonstrates a use of the <ph id="ph1">&lt;xref:System.Type.Namespace%2A&gt;</ph> and <ph id="ph2">`Module`</ph> properties and the <ph id="ph3">&lt;xref:System.Type.ToString%2A&gt;</ph> method of <ph id="ph4">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Im folgenden Beispiel veranschaulicht die <ph id="ph1">&lt;xref:System.Type.Namespace%2A&gt;</ph> und <ph id="ph2">`Module`</ph> Eigenschaften und die <ph id="ph3">&lt;xref:System.Type.ToString%2A&gt;</ph> Methode <ph id="ph4">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4174" translate="yes" xml:space="preserve" uid="P:System.Type.Namespace">
          <source>Gets the namespace of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft den Namespace von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="4175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>The namespace of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>; <ph id="ph2">&lt;see langword="null" /&gt;</ph> if the current instance has no namespace or represents a generic parameter.</source>
          <target state="translated">Der Namespace des <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>; <ph id="ph2">&lt;see langword="null" /&gt;</ph>, wenn die aktuelle Instanz über keinen Namespace verfügt oder einen generischen Parameter darstellt.</target>       </trans-unit>
        <trans-unit id="4176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure.</source>
          <target state="translated">Ein Namespace ist eine logische zur Entwurfszeit naming Annehmlichkeit, hauptsächlich zum Definieren von Bereich in einer Anwendung, und Organisieren von Klassen und anderen Typen in einer hierarchischen Struktur verwendet.</target>       </trans-unit>
        <trans-unit id="4177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>From the viewpoint of the runtime, there are no namespaces.</source>
          <target state="translated">Vom Standpunkt der Laufzeit gibt es keine Namespaces.</target>       </trans-unit>
        <trans-unit id="4178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns the namespace that contains the generic type definition.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen konstruierter generischen Typ darstellt, gibt diese Eigenschaft den Namespace, die generische Typdefinition enthält.</target>       </trans-unit>
        <trans-unit id="4179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>Similarly, if the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic parameter <ph id="ph2">`T`</ph>, this property returns the namespace that contains the generic type definition that defines <ph id="ph3">`T`</ph>.</source>
          <target state="translated">Auf ähnliche Weise, wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen generischen Parameter <ph id="ph2">`T`</ph>, diese Eigenschaft gibt den Namespace, die generische Typdefinition enthält, die definiert <ph id="ph3">`T`</ph>.</target>       </trans-unit>
        <trans-unit id="4180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> object represents a generic parameter, this property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> -Objekt einen generischen Parameter darstellt, gibt diese Eigenschaft zurück <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="4181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.Namespace">
          <source>This following example demonstrates a use of the <ph id="ph1">`Namespace`</ph> and <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> properties and the <ph id="ph3">&lt;xref:System.Type.ToString%2A&gt;</ph> method of <ph id="ph4">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Im folgenden Beispiel veranschaulicht die <ph id="ph1">`Namespace`</ph> und <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> Eigenschaften und die <ph id="ph3">&lt;xref:System.Type.ToString%2A&gt;</ph> Methode <ph id="ph4">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4182" translate="yes" xml:space="preserve" uid="M:System.Type.op_Equality(System.Type,System.Type)">
          <source>The first object to compare.</source>
          <target state="translated">Das erste zu vergleichende Objekt.</target>       </trans-unit>
        <trans-unit id="4183" translate="yes" xml:space="preserve" uid="M:System.Type.op_Equality(System.Type,System.Type)">
          <source>The second object to compare.</source>
          <target state="translated">Das zweite zu vergleichende Objekt.</target>       </trans-unit>
        <trans-unit id="4184" translate="yes" xml:space="preserve" uid="M:System.Type.op_Equality(System.Type,System.Type)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects are equal.</source>
          <target state="translated">Gibt an, ob zwei <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekte gleich sind.</target>       </trans-unit>
        <trans-unit id="4185" translate="yes" xml:space="preserve" uid="M:System.Type.op_Equality(System.Type,System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;paramref name="left" /&gt;</ph> und <ph id="ph3">&lt;paramref name="right" /&gt;</ph> gleich sind, andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4186" translate="yes" xml:space="preserve" uid="M:System.Type.op_Inequality(System.Type,System.Type)">
          <source>The first object to compare.</source>
          <target state="translated">Das erste zu vergleichende Objekt.</target>       </trans-unit>
        <trans-unit id="4187" translate="yes" xml:space="preserve" uid="M:System.Type.op_Inequality(System.Type,System.Type)">
          <source>The second object to compare.</source>
          <target state="translated">Das zweite zu vergleichende Objekt.</target>       </trans-unit>
        <trans-unit id="4188" translate="yes" xml:space="preserve" uid="M:System.Type.op_Inequality(System.Type,System.Type)">
          <source>Indicates whether two <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> objects are not equal.</source>
          <target state="translated">Gibt an, ob zwei <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>-Objekte ungleich sind.</target>       </trans-unit>
        <trans-unit id="4189" translate="yes" xml:space="preserve" uid="M:System.Type.op_Inequality(System.Type,System.Type)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> is not equal to <ph id="ph3">&lt;paramref name="right" /&gt;</ph>; otherwise, <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;paramref name="left" /&gt;</ph> und <ph id="ph3">&lt;paramref name="right" /&gt;</ph> ungleich sind, andernfalls <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4190" translate="yes" xml:space="preserve" uid="P:System.Type.ReflectedType">
          <source>Gets the class object that was used to obtain this member.</source>
          <target state="translated">Ruft das Klassenobjekt ab, über das dieser Member abgerufen wurde.</target>       </trans-unit>
        <trans-unit id="4191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ReflectedType">
          <source>The <ph id="ph1">&lt;see langword="Type" /&gt;</ph> object through which this <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> object was obtained.</source>
          <target state="translated">Das <ph id="ph1">&lt;see langword="Type" /&gt;</ph>-Objekt, über das dieses <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>-Objekt abgerufen wurde.</target>       </trans-unit>
        <trans-unit id="4192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ReflectedType">
          <source>For <ph id="ph1">&lt;xref:System.Type&gt;</ph> objects, the value of this property is always the same as the value of the <ph id="ph2">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property.</source>
          <target state="translated">Für <ph id="ph1">&lt;xref:System.Type&gt;</ph> Objekte, die der Wert dieser Eigenschaft entspricht immer der Wert von der <ph id="ph2">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="4193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.ReflectedType">
          <source>This example displays the reflected type of a nested class.</source>
          <target state="translated">Dieses Beispiel zeigt den reflektierten Typ einer geschachtelten Klasse.</target>       </trans-unit>
        <trans-unit id="4194" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly-qualified name of the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> to get.</source>
          <target state="translated">Der durch die Assembly bezeichnete Name des abzurufenden <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4195" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to throw a <ph id="ph2">&lt;see cref="T:System.TypeLoadException" /&gt;</ph> if the type cannot be found; <ph id="ph3">&lt;see langword="false" /&gt;</ph> to return <ph id="ph4">&lt;see langword="null" /&gt;</ph> if the type cannot be found.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, damit eine <ph id="ph2">&lt;see cref="T:System.TypeLoadException" /&gt;</ph> ausgelöst wird, wenn der Typ nicht gefunden wird. <ph id="ph3">&lt;see langword="false" /&gt;</ph>, damit <ph id="ph4">&lt;see langword="null" /&gt;</ph> zurückgegeben wird, wenn der Typ nicht gefunden wird.</target>       </trans-unit>
        <trans-unit id="4196" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>Specifying <ph id="ph1">&lt;see langword="false" /&gt;</ph> also suppresses some other exception conditions, but not all of them.</source>
          <target state="translated">Die Angabe von <ph id="ph1">&lt;see langword="false" /&gt;</ph> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle.</target>       </trans-unit>
        <trans-unit id="4197" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">Informationen finden Sie im Abschnitt für Ausnahmen.</target>       </trans-unit>
        <trans-unit id="4198" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to perform a case-insensitive search for <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept>; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to perform a case-sensitive search for <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, um ohne Beachtung der Groß-/Kleinschreibung nach <bpt id="p1">&lt;c&gt;</bpt>typeName<ept id="p1">&lt;/c&gt;</ept> zu suchen; <ph id="ph2">&lt;see langword="false" /&gt;</ph>, um mit Beachtung der Groß-/Kleinschreibung nach <bpt id="p2">&lt;c&gt;</bpt>typeName<ept id="p2">&lt;/c&gt;</ept> zu suchen.</target>       </trans-unit>
        <trans-unit id="4199" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found.</source>
          <target state="translated">Ruft den <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> mit dem angegebenen Namen ab. Dabei wird angegeben, ob bei der Suche die Groß- und Kleinschreibung berücksichtigt werden soll und ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird.</target>       </trans-unit>
        <trans-unit id="4200" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The type is loaded for reflection only, not for execution.</source>
          <target state="translated">Der Typ wird für die Reflektion, nicht für Ausführung geladen.</target>       </trans-unit>
        <trans-unit id="4201" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The type with the specified name, if found; otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der Typ mit dem angegebenen Namen, sofern gefunden, andernfalls <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4202" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>If the type is not found, the <ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> parameter specifies whether <ph id="ph2">&lt;see langword="null" /&gt;</ph> is returned or an exception is thrown.</source>
          <target state="translated">Wenn der Typ nicht gefunden wird, gibt der <ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph>-Parameter an, ob <ph id="ph2">&lt;see langword="null" /&gt;</ph> zurückgegeben oder eine Ausnahme ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="4203" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>In some cases, an exception is thrown regardless of the value of <ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph>.</source>
          <target state="translated">In einigen Fällen wird unabhängig vom Wert von <ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> eine Ausnahme ausgelöst.</target>       </trans-unit>
        <trans-unit id="4204" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>See the Exceptions section.</source>
          <target state="translated">Informationen finden Sie im Abschnitt für Ausnahmen.</target>       </trans-unit>
        <trans-unit id="4205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>If the assembly containing the type is not already loaded into the reflection-only context, using the <ph id="ph1">&lt;xref:System.Type.ReflectionOnlyGetType%2A&gt;</ph> method is equivalent to first loading the assembly for reflection only, using the <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> method, and then loading the type by calling the assembly's <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Wenn die Assembly mit dem Typ nicht in den reflektionsbezogenen Kontext geladen ist, mithilfe der <ph id="ph1">&lt;xref:System.Type.ReflectionOnlyGetType%2A&gt;</ph> Methode ist gleichbedeutend mit dem ersten Laden der Assembly für die Reflektion, mit der <ph id="ph2">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> -Methode, und Laden Sie dann durch Aufrufen des Typs der der Assembly <ph id="ph3">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="4206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>For information about assembly-qualified names, see the <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Informationen über qualifizierte Assemblynamen finden Sie unter der <ph id="ph1">&lt;xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="4207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>For additional details on specifying type names, see the <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload.</source>
          <target state="translated">Weitere Informationen zum Angeben der Typnamen finden Sie unter der <ph id="ph1">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> -methodenüberladung.</target>       </trans-unit>
        <trans-unit id="4208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>If the assembly is already loaded for execution, another copy is loaded into the reflection-only context.</source>
          <target state="translated">Wenn die Assembly bereits für Ausführung geladen wird, wird eine weitere Kopie in den reflektionsbezogenen Kontext geladen.</target>       </trans-unit>
        <trans-unit id="4209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The <ph id="ph1">`throwIfNotFound`</ph> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</source>
          <target state="translated">Die <ph id="ph1">`throwIfNotFound`</ph> Parameter gibt an, was geschieht, wenn der Typ nicht gefunden wird, und auch bestimmte andere Ausnahmebedingungen unterdrückt, wie im Abschnitt für Ausnahmen beschrieben.</target>       </trans-unit>
        <trans-unit id="4210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>Some exceptions are thrown regardless of the value of <ph id="ph1">`throwIfNotFound`</ph>.</source>
          <target state="translated">Einige Ausnahmen werden ausgelöst, unabhängig vom Wert der <ph id="ph1">`throwIfNotFound`</ph>.</target>       </trans-unit>
        <trans-unit id="4211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>For example, if the assembly is not valid, a <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph> is thrown even if <ph id="ph2">`throwIfNotFound`</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Wenn die Assembly nicht gültig ist, z. B. eine <ph id="ph1">&lt;xref:System.BadImageFormatException&gt;</ph> wird ausgelöst, selbst wenn <ph id="ph2">`throwIfNotFound`</ph> ist <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="4212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>For more information about using the reflection-only context, see <bpt id="p1">[</bpt>How to: Load Assemblies into the Reflection-Only Context<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)</ept>.</source>
          <target state="translated">Weitere Informationen zu den ReflectionOnly Kontext verwenden, finden Sie unter <bpt id="p1">[</bpt>wie: Laden von Assemblys in den Reflection-Kontext<ept id="p1">](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)</ept>.</target>       </trans-unit>
        <trans-unit id="4213" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4214" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>A class initializer is invoked and throws an exception.</source>
          <target state="translated">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="4215" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the type is not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und der Typ wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="4216" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="4217" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid characters, such as an embedded tab.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen.</target>       </trans-unit>
        <trans-unit id="4218" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="4219" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> is an empty string.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> ist eine leere Zeichenfolge.</target>       </trans-unit>
        <trans-unit id="4220" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="4221" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> represents an array type with an invalid size.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> stellt einen Arraytyp mit einer ungültigen Größe dar.</target>       </trans-unit>
        <trans-unit id="4222" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="4223" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents an array of <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph> objects.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt ein Array mit <ph id="ph2">&lt;see cref="T:System.TypedReference" /&gt;</ph>-Objekten dar.</target>       </trans-unit>
        <trans-unit id="4224" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> does not include the assembly name.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> enthält keinen Assemblynamen.</target>       </trans-unit>
        <trans-unit id="4225" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="4226" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> contains invalid syntax; for example, "MyType[,*,]".</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und <ph id="ph3">&lt;paramref name="typeName" /&gt;</ph> enthält ungültige Syntax (z.B. „MyType[,*,]“).</target>       </trans-unit>
        <trans-unit id="4227" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="4228" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has a pointer type, a <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph> type, or <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> as one of its type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt einen generischen Typ dar, der einen Zeigertyp, einen <ph id="ph2">&lt;see langword="ByRef" /&gt;</ph>-Typ oder <ph id="ph3">&lt;see cref="T:System.Void" /&gt;</ph> als eines seiner Typargumente aufweist.</target>       </trans-unit>
        <trans-unit id="4229" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="4230" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type that has an incorrect number of type arguments.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.</target>       </trans-unit>
        <trans-unit id="4231" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="4232" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="typeName" /&gt;</ph> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</target>       </trans-unit>
        <trans-unit id="4233" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> is <ph id="ph2">&lt;see langword="true" /&gt;</ph> and the assembly or one of its dependencies was not found.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="throwIfNotFound" /&gt;</ph> ist <ph id="ph2">&lt;see langword="true" /&gt;</ph>, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="4234" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies was found, but could not be loaded.</source>
          <target state="translated">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</target>       </trans-unit>
        <trans-unit id="4235" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly or one of its dependencies is not valid.</source>
          <target state="translated">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.</target>       </trans-unit>
        <trans-unit id="4236" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="4237" translate="yes" xml:space="preserve" uid="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)">
          <source>The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</source>
          <target state="translated">Die Assembly wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</target>       </trans-unit>
        <trans-unit id="4238" translate="yes" xml:space="preserve" uid="P:System.Type.StructLayoutAttribute">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> that describes the layout of the current type.</source>
          <target state="translated">Ruft ein <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> ab, der das Layout des aktuellen Typs beschreibt.</target>       </trans-unit>
        <trans-unit id="4239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.StructLayoutAttribute">
          <source>Gets a <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> that describes the gross layout features of the current type.</source>
          <target state="translated">Ruft ein <ph id="ph1">&lt;see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /&gt;</ph> ab, das den allgemeinen Layoutaufbau des aktuellen Typs beschreibt.</target>       </trans-unit>
        <trans-unit id="4240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.StructLayoutAttribute">
          <source><ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> is not returned by the <ph id="ph2">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> wird nicht zurückgegeben, durch die <ph id="ph2">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="4241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.StructLayoutAttribute">
          <source>Instead, use this property to get it.</source>
          <target state="translated">Verwenden Sie stattdessen diese Eigenschaft zum Abrufen.</target>       </trans-unit>
        <trans-unit id="4242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.StructLayoutAttribute">
          <source>The following code example first defines a class, a structure, and a structure with special layout attributes (the structures are nested within the class).</source>
          <target state="translated">Das folgende Codebeispiel definiert zuerst eine Klasse, eine Struktur und eine Struktur mit speziellen Layoutattribute (innerhalb der Klasse werden die Strukturen geschachtelt).</target>       </trans-unit>
        <trans-unit id="4243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.StructLayoutAttribute">
          <source>The example then uses the <ph id="ph1">&lt;xref:System.Type.StructLayoutAttribute%2A&gt;</ph> property to obtain a <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> for each type, and displays the properties of the attributes.</source>
          <target state="translated">Anschließend wird die <ph id="ph1">&lt;xref:System.Type.StructLayoutAttribute%2A&gt;</ph> -Eigenschaft zum Abrufen einer <ph id="ph2">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> für jeden Typ, und zeigt die Eigenschaften der Attribute.</target>       </trans-unit>
        <trans-unit id="4244" translate="yes" xml:space="preserve" uid="P:System.Type.StructLayoutAttribute">
          <source>The invoked method is not supported in the base class.</source>
          <target state="translated">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="4245" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Für zukünftige Verwendung reserviert.</target>       </trans-unit>
        <trans-unit id="4246" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Muss IID_NULL sein.</target>       </trans-unit>
        <trans-unit id="4247" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Passed-in array of names to be mapped.</source>
          <target state="translated">Das übergebene Array von zuzuordnenden Namen.</target>       </trans-unit>
        <trans-unit id="4248" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Count of the names to be mapped.</source>
          <target state="translated">Die Anzahl der zuzuordnenden Namen.</target>       </trans-unit>
        <trans-unit id="4249" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale context in which to interpret the names.</source>
          <target state="translated">Der Gebietsschemakontext, in dem die Namen interpretiert werden sollen.</target>       </trans-unit>
        <trans-unit id="4250" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
          <target state="translated">Das vom Aufrufer zugewiesene Array, das die IDs entsprechend den Namen empfängt.</target>       </trans-unit>
        <trans-unit id="4251" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
          <target state="translated">Ordnet eine Reihe von Namen einer entsprechenden Reihe von Dispatchbezeichnern zu.</target>       </trans-unit>
        <trans-unit id="4252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="4253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
          <target state="translated">Weitere Informationen zu <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, finden Sie in der MSDN Library.</target>       </trans-unit>
        <trans-unit id="4254" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Spät gebundener Zugriff mithilfe der <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept>-Schnittstelle in COM wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="4255" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The type information to return.</source>
          <target state="translated">Die zurückzugebenden Typinformationen.</target>       </trans-unit>
        <trans-unit id="4256" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>The locale identifier for the type information.</source>
          <target state="translated">Der Gebietsschemabezeichner für die Typinformationen.</target>       </trans-unit>
        <trans-unit id="4257" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>A pointer to the requested type information object.</source>
          <target state="translated">Ein Zeiger auf das angeforderte Objekt mit den Typinformationen.</target>       </trans-unit>
        <trans-unit id="4258" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
          <target state="translated">Ruft die Typinformationen für ein Objekt ab, die dann zum Abrufen der Typinformationen für eine Schnittstelle verwendet werden können.</target>       </trans-unit>
        <trans-unit id="4259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="4260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
          <target state="translated">Weitere Informationen zu <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, finden Sie in der MSDN Library.</target>       </trans-unit>
        <trans-unit id="4261" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Spät gebundener Zugriff mithilfe der <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept>-Schnittstelle in COM wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="4262" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
          <target state="translated">Zeigt auf einen Speicherort, der die Anzahl der Schnittstellen mit Typinformationen empfängt, die vom Objekt bereitgestellt werden.</target>       </trans-unit>
        <trans-unit id="4263" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
          <target state="translated">Ruft die Anzahl der Schnittstellen mit Typinformationen ab, die von einem Objekt bereitgestellt werden (0 oder 1).</target>       </trans-unit>
        <trans-unit id="4264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="4265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
          <target state="translated">Weitere Informationen zu <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, finden Sie in der MSDN Library.</target>       </trans-unit>
        <trans-unit id="4266" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Spät gebundener Zugriff mithilfe der <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept>-Schnittstelle in COM wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="4267" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Identifies the member.</source>
          <target state="translated">Bezeichnet den Member.</target>       </trans-unit>
        <trans-unit id="4268" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Reserved for future use.</source>
          <target state="translated">Für zukünftige Verwendung reserviert.</target>       </trans-unit>
        <trans-unit id="4269" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Must be IID_NULL.</source>
          <target state="translated">Muss IID_NULL sein.</target>       </trans-unit>
        <trans-unit id="4270" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The locale context in which to interpret arguments.</source>
          <target state="translated">Der Gebietsschemakontext, in dem Argumente interpretiert werden sollen.</target>       </trans-unit>
        <trans-unit id="4271" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Flags describing the context of the call.</source>
          <target state="translated">Flags, die den Kontext des Aufrufs beschreiben.</target>       </trans-unit>
        <trans-unit id="4272" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
          <target state="translated">Ein Zeiger auf eine Struktur, die ein Array von Argumenten und ein Array von Argument-DISPIDs für benannte Argumente sowie Zähler für die Anzahl der Elemente in jedem Array enthält.</target>       </trans-unit>
        <trans-unit id="4273" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to the location where the result is to be stored.</source>
          <target state="translated">Ein Verweis auf den Speicherort, an dem das Ergebnis gespeichert werden soll.</target>       </trans-unit>
        <trans-unit id="4274" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Pointer to a structure that contains exception information.</source>
          <target state="translated">Ein Zeiger auf eine Struktur mit Ausnahmeinformationen.</target>       </trans-unit>
        <trans-unit id="4275" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>The index of the first argument that has an error.</source>
          <target state="translated">Der Index des ersten Arguments mit einem Fehler.</target>       </trans-unit>
        <trans-unit id="4276" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Provides access to properties and methods exposed by an object.</source>
          <target state="translated">Stellt den Zugriff auf von einem Objekt verfügbar gemachte Eigenschaften und Methoden bereit.</target>       </trans-unit>
        <trans-unit id="4277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
          <target state="translated">Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code und sollte nicht von verwaltetem Code aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="4278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
          <target state="translated">Weitere Informationen zu <ph id="ph1">`IDispatch::Invoke`</ph>, finden Sie in der MSDN Library.</target>       </trans-unit>
        <trans-unit id="4279" translate="yes" xml:space="preserve" uid="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)">
          <source>Late-bound access using the COM <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept> interface is not supported.</source>
          <target state="translated">Spät gebundener Zugriff mithilfe der <bpt id="p1">&lt;c&gt;</bpt>IDispatch<ept id="p1">&lt;/c&gt;</ept>-Schnittstelle in COM wird nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="4280" translate="yes" xml:space="preserve" uid="M:System.Type.ToString">
          <source>Returns a <ph id="ph1">&lt;see langword="String" /&gt;</ph> representing the name of the current <ph id="ph2">&lt;see langword="Type" /&gt;</ph>.</source>
          <target state="translated">Gibt einen <ph id="ph1">&lt;see langword="String" /&gt;</ph> zurück, der den Namen des aktuellen <ph id="ph2">&lt;see langword="Type" /&gt;</ph> darstellt.</target>       </trans-unit>
        <trans-unit id="4281" translate="yes" xml:space="preserve" uid="M:System.Type.ToString">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> representing the name of the current <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, der den Namen des aktuellen <ph id="ph2">&lt;see cref="T:System.Type" /&gt;</ph> darstellt.</target>       </trans-unit>
        <trans-unit id="4282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>This method returns the fully qualified common language runtime namespace and name for all primitive types.</source>
          <target state="translated">Diese Methode gibt den voll gekennzeichneten common Language Runtime-Namespace und den Namen für alle primitiven Typen.</target>       </trans-unit>
        <trans-unit id="4283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>For example, the C# instruction, <ph id="ph1">`(long)0.Type().ToString()`</ph> returns "System.Int64" instead of merely "Int64".</source>
          <target state="translated">Angenommen, die C#-Anweisung, <ph id="ph1">`(long)0.Type().ToString()`</ph> "System. Int64" anstelle von "Int64" zurückgegeben.</target>       </trans-unit>
        <trans-unit id="4284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt einen generischen Typ, den Typ und ihre Typargumente durch den Namespace und durch den geschachtelten Typ, aber nicht durch die Assembly qualifiziert werden.</target>       </trans-unit>
        <trans-unit id="4285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> stellt ein Typparameter in der Definition eines generischen Typs oder generische Methode, diese Methode gibt den nicht qualifizierten Namen des Typparameters zurück.</target>       </trans-unit>
        <trans-unit id="4286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>This following example demonstrates a use of the <ph id="ph1">&lt;xref:System.Type.Namespace%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> properties and the <ph id="ph3">`ToString`</ph> method of <ph id="ph4">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Im folgenden Beispiel veranschaulicht die <ph id="ph1">&lt;xref:System.Type.Namespace%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Type.Module%2A&gt;</ph> Eigenschaften und die <ph id="ph3">`ToString`</ph> Methode <ph id="ph4">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Type.ToString">
          <source>The following example compares the strings returned by the <ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph> method and the <ph id="ph2">`Name`</ph>, <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> properties.</source>
          <target state="translated">Das folgende Beispiel vergleicht die zurückgegebene Zeichenfolgen die <ph id="ph1">&lt;xref:System.Type.ToString%2A&gt;</ph> Methode und die <ph id="ph2">`Name`</ph>, <ph id="ph3">&lt;xref:System.Type.FullName%2A&gt;</ph>, und <ph id="ph4">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> Eigenschaften.</target>       </trans-unit>
        <trans-unit id="4288" translate="yes" xml:space="preserve" uid="P:System.Type.TypeHandle">
          <source>Gets the handle for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ruft das Handle für den aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="4289" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeHandle">
          <source>The handle for the current <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Das Handle für den aktuellen <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="4290" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeHandle">
          <source><ph id="ph1">`TypeHandle`</ph> encapsulates a pointer to an internal data structure that represents the type.</source>
          <target state="translated"><ph id="ph1">`TypeHandle`</ph> Kapselt einen Zeiger auf eine interne Datenstruktur, die den Typ darstellt.</target>       </trans-unit>
        <trans-unit id="4291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeHandle">
          <source>This handle is unique during the process lifetime.</source>
          <target state="translated">Dieses Handle ist während der Prozesslebensdauer eindeutig.</target>       </trans-unit>
        <trans-unit id="4292" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeHandle">
          <source>The handle is valid only in the application domain in which it was obtained.</source>
          <target state="translated">Das Handle ist gültig, nur in der Anwendungsdomäne, in der sie abgerufen wurden.</target>       </trans-unit>
        <trans-unit id="4293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeHandle">
          <source>The following example returns the handle of the corresponding type and passes the handle to a method that gets the type from the handle and displays it.</source>
          <target state="translated">Im folgenden Beispiel gibt das Handle des entsprechenden Typs zurück, und übergibt das Handle für eine Methode, die den Typ aus dem Handle abgerufen und angezeigt.</target>       </trans-unit>
        <trans-unit id="4294" translate="yes" xml:space="preserve" uid="P:System.Type.TypeHandle">
          <source>The .NET Compact Framework does not currently support this property.</source>
          <target state="translated">Diese Eigenschaft wird von .NET Compact Framework derzeit nicht unterstützt.</target>       </trans-unit>
        <trans-unit id="4295" translate="yes" xml:space="preserve" uid="P:System.Type.TypeInitializer">
          <source>Gets the initializer for the type.</source>
          <target state="translated">Ruft den Initialisierer für den Typ ab.</target>       </trans-unit>
        <trans-unit id="4296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeInitializer">
          <source>An object that contains the name of the class constructor for the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Ein Objekt, das den Namen des Klassenkonstruktors von <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> enthält.</target>       </trans-unit>
        <trans-unit id="4297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeInitializer">
          <source>Class initializers are also available through the <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method, or through overloads of the <ph id="ph2">&lt;xref:System.Type.GetMember%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> methods that take <ph id="ph6">&lt;xref:System.Reflection.BindingFlags&gt;</ph> as a parameter.</source>
          <target state="translated">Klasseninitialisierer stehen auch über die <ph id="ph1">&lt;xref:System.Type.FindMembers%2A&gt;</ph> -Methode, oder über Überladungen des der <ph id="ph2">&lt;xref:System.Type.GetMember%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>, und <ph id="ph5">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> Methoden, die <ph id="ph6">&lt;xref:System.Reflection.BindingFlags&gt;</ph> als Parameter.</target>       </trans-unit>
        <trans-unit id="4298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.TypeInitializer">
          <source>If the current <ph id="ph1">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property returns <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Wenn die aktuelle <ph id="ph1">&lt;xref:System.Type&gt;</ph> einen Typparameter in der Definition eines generischen Typs oder generische Methode darstellt, gibt diese Eigenschaft <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="4299" translate="yes" xml:space="preserve" uid="P:System.Type.UnderlyingSystemType">
          <source>Indicates the type provided by the common language runtime that represents this type.</source>
          <target state="translated">Gibt den von der Common Language Runtime bereitgestellten Typ an, der diesen Typ darstellt.</target>       </trans-unit>
        <trans-unit id="4300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Type.UnderlyingSystemType">
          <source>The underlying system type for the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>.</source>
          <target state="translated">Der Systemtyp, der <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph>zugrunde liegt.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>