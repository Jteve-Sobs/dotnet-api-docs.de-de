<Type Name="Type" FullName="System.Type">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a209f775a8ed85aa6318ef755a4fb3fb385c15e5" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83956888" /></Metadata><TypeSignature Language="C#" Value="public abstract class Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Type extends System.Object" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="F#" Value="type Type = class" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
  <TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements IReflect" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface IReflect" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface _Type&#xA;    interface IReflect" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" FrameworkAlternate="netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="mscorlib" FromVersion="4.0.0.0" To="System.Runtime" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt Typdeklarationen dar: Klassentypen, Schnittstellentypen, Arraytypen, Werttypen, Enumerationstypen, Typparameter, generische Typdefinitionen und offen oder geschlossen konstruierte generische Typen.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Type` ist die Grundlage für die <xref:System.Reflection>-Funktionalität und ist die primäre Methode für den Zugriff auf Metadaten. Verwenden Sie die Member von <xref:System.Type>, um Informationen über eine Typdeklaration, Informationen zu den Membern eines Typs (z. b. Konstruktoren, Methoden, Felder, Eigenschaften und Ereignisse einer Klasse) sowie das Modul und die Assembly, in der die Klasse bereitgestellt wird, zu erhalten.  
  
 Es sind keine Berechtigungen erforderlich, damit der Code Reflektion verwendet, um Informationen über Typen und ihre Member zu erhalten, unabhängig von ihren Zugriffsebenen. Für den Code sind keine Berechtigungen erforderlich, um über Reflektion auf öffentliche Member oder andere Member zuzugreifen, deren Zugriffsebenen Sie während der normalen Kompilierung sichtbar machen würden. Damit Ihr Code jedoch über Reflektion auf Member zugreifen kann, auf die normalerweise nicht zugegriffen werden kann, z. b. private oder interne Methoden oder geschützte Felder eines Typs, die Ihre Klasse nicht erbt, muss der Code über <xref:System.Security.Permissions.ReflectionPermission>verfügen. Siehe [Sicherheitsüberlegungen für die Reflektion](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection).  
  
 `Type` ist eine abstrakte Basisklasse, die mehrere Implementierungen zulässt. Das System stellt immer die abgeleitete Klasse `RuntimeType`bereit. Bei der Reflektion werden alle Klassen, die mit der Word-Laufzeit beginnen, pro Objekt im System nur einmal erstellt und unterstützen Vergleichs Vorgänge.  
  
> [!NOTE]
>  Sperren Sie <xref:System.Type> Objekte in Multithreading Szenarios nicht, um den Zugriff auf `static` Daten zu synchronisieren. Anderer Code, über den Sie kein Steuerelement verfügen, kann auch den Klassentyp sperren. Dies kann zu einem Deadlock führen. Synchronisieren Sie stattdessen den Zugriff auf statische Daten durch Sperren eines privaten `static` Objekts.  
  
> [!NOTE]
>  Eine abgeleitete Klasse kann auf geschützte Member der Basisklassen des aufrufenden Codes zugreifen. Außerdem ist der Zugriff auf Assemblymember der Assembly des aufrufenden Codes zulässig. Wenn Sie in früh gebundenem Code Zugriff auf den Zugriff haben, können Sie als Regel auch in spät gebundenem Code auf den Zugriff zugreifen.  
  
> [!NOTE]
>  Schnittstellen, die andere Schnittstellen erweitern, erben nicht die Methoden, die in den erweiterten Schnittstellen definiert sind.  
  
 Inhalt dieses Abschnitts:  
  
 [Welche Typen stellt ein Typobjekt dar?](#WhatTypes)   
 [Abrufen eines Type-Objekts](#Retrieve)   
 [Vergleichen von Typobjekten auf Gleichheit](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a>Welche Typen stellt ein Typobjekt dar?  
 Diese Klasse ist Thread sicher. mehrere Threads können gleichzeitig aus einer Instanz dieses Typs gelesen werden. Eine Instanz der <xref:System.Type>-Klasse kann einen der folgenden Typen darstellen:  
  
-   Klassen  
  
-   Werttypen  
  
-   Arrays  
  
-   Schnittstellen  
  
-   Enumerationen  
  
-   Delegaten  
  
-   Konstruierte generische Typen und generische Typdefinitionen  
  
-   Typargumente und Typparameter von konstruierten generischen Typen, generischen Typdefinitionen und generischen Methoden Definitionen  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a>Abrufen eines Typobjekts  
 Das <xref:System.Type>-Objekt, das einem bestimmten Typ zugeordnet ist, kann wie folgt abgerufen werden:  
  
-   Die Instanz <xref:System.Object.GetType%2A?displayProperty=nameWithType> Methode gibt ein <xref:System.Type>-Objekt zurück, das den Typ einer-Instanz darstellt. Da alle verwalteten Typen von <xref:System.Object>abgeleitet werden, kann die <xref:System.Object.GetType%2A>-Methode für eine Instanz eines beliebigen Typs aufgerufen werden.  
  
     Im folgenden Beispiel wird die <xref:System.Object.GetType%2A?displayProperty=nameWithType>-Methode aufgerufen, um den Lauf Zeittyp der einzelnen Objekte in einem Objekt Array zu bestimmen.  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp-interactive[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   Die statischen <xref:System.Type.GetType%2A?displayProperty=nameWithType>-Methoden geben ein <xref:System.Type> Objekt zurück, das einen durch seinen voll qualifizierten Namen angegebenen Typ darstellt.  
  
-   Die Methoden <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>und <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> geben `Type` Objekte zurück, die die in einem Modul definierten Typen darstellen. Die erste Methode kann verwendet werden, um ein Array von <xref:System.Type>-Objekten für alle öffentlichen und privaten Typen abzurufen, die in einem Modul definiert sind. (Sie können eine Instanz von `Module` mithilfe der <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType>-oder <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType>-Methode oder über die <xref:System.Type.Module%2A?displayProperty=nameWithType>-Eigenschaft abrufen.)  
  
-   Das <xref:System.Reflection.Assembly?displayProperty=nameWithType>-Objekt enthält eine Reihe von Methoden zum Abrufen der Klassen, die in einer Assembly definiert sind, einschließlich <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>und <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.  
  
-   Die <xref:System.Type.FindInterfaces%2A>-Methode gibt eine gefilterte Liste von Schnittstellentypen zurück, die von einem Typ unterstützt werden.  
  
-   Die <xref:System.Type.GetElementType%2A>-Methode gibt ein `Type`-Objekt zurück, das das-Element darstellt.  
  
-   Die Methoden <xref:System.Type.GetInterfaces%2A> und <xref:System.Type.GetInterface%2A> geben <xref:System.Type> Objekte zurück, die die von einem Typ unterstützten Schnittstellentypen darstellen.  
  
-   Die <xref:System.Type.GetTypeArray%2A>-Methode gibt ein Array von <xref:System.Type>-Objekten zurück, die die durch einen beliebigen Satz von-Objekten angegebenen Typen darstellen. Die-Objekte werden mit einem Array vom Typ <xref:System.Object>angegeben.  
  
-   Die Methoden <xref:System.Type.GetTypeFromProgID%2A> und <xref:System.Type.GetTypeFromCLSID%2A> werden für die COM-Interoperabilität bereitgestellt. Sie geben ein <xref:System.Type> Objekt zurück, das den Typ darstellt, der von einem `ProgID` oder `CLSID`angegeben wird.  
  
-   Die <xref:System.Type.GetTypeFromHandle%2A>-Methode wird für die Interoperabilität bereitgestellt. Es gibt ein `Type` Objekt zurück, das den durch ein Klassen handle angegebenen Typ darstellt.  
  
-   Der C# `typeof`-Operator, C++ der `typeid`-Operator und der Visual Basic `GetType`-Operator erhalten das `Type`-Objekt für einen Typ.  
  
-   Die <xref:System.Type.MakeGenericType%2A>-Methode gibt ein <xref:System.Type> Objekt zurück, das einen konstruierten generischen Typ darstellt, bei dem es sich um einen geöffneten konstruierten Typ handelt, wenn seine <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft `true`zurückgibt, und andernfalls einen geschlossenen Ein generischer Typ kann nur instanziiert werden, wenn er geschlossen ist.  
  
-   Die Methoden <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>und <xref:System.Type.MakeByRefType%2A> geben <xref:System.Type> Objekte zurück, die bzw. ein Array mit einem angegebenen Typ, einen Zeiger auf einen angegebenen Typ und den Typ eines Verweis Parameters (`ref` in C#, `ByRef` in Visual Basic) darstellen.  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a>Vergleichen von Typobjekten auf Gleichheit  
 Ein <xref:System.Type> Objekt, das einen Typ darstellt, ist eindeutig. Das heißt, dass zwei <xref:System.Type> Objekt Verweise auf das gleiche Objekt verweisen, wenn Sie denselben Typ darstellen. Dies ermöglicht den Vergleich von <xref:System.Type> Objekten mithilfe von Verweis Gleichheit. Im folgenden Beispiel werden die <xref:System.Type>-Objekte, die eine Reihe von ganzzahligen Werten darstellen, verglichen, um zu bestimmen, ob Sie denselben Typ haben.  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp-interactive[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 Das folgende Beispiel zeigt einige repräsentative Features von <xref:System.Type>. Der C# `typeof`-Operator (`GetType` Operator in Visual Basic) wird verwendet, um ein <xref:System.Type> Objekt zu erhalten, das <xref:System.String>darstellt. Aus diesem <xref:System.Type> Objekt wird die <xref:System.Type.GetMethod%2A>-Methode verwendet, um eine <xref:System.Reflection.MethodInfo> zu erhalten, die die <xref:System.String.Substring%2A?displayProperty=nameWithType> Überladung darstellt, die eine Startposition und eine Länge annimmt.
  
 Zum Identifizieren der Überladungs Signatur erstellt das Codebeispiel ein temporäres Array, das zwei <xref:System.Type>-Objekte enthält, die `int` (`Integer` in Visual Basic) darstellen.  
  
> [!NOTE]
>  Um genau zu sein, enthält das Array zwei Verweise auf die Instanz von <xref:System.Type>, die `int` in der aktuellen Anwendungsdomäne darstellt. Für jeden Typ gibt es nur eine Instanz von <xref:System.Type> pro Anwendungsdomäne.  

 Im Codebeispiel wird die-<xref:System.Reflection.MethodInfo> verwendet, um die <xref:System.String.Substring%2A>-Methode für die Zeichenfolge "Hello, World!" aufzurufen, und das Ergebnis wird angezeigt.  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <block subset="none" type="overrides"><para>Wenn Sie von <see langword="Type" />erben, müssen Sie die folgenden Member überschreiben: 
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para></block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
    <related type="Article" href="/dotnet/framework/reflection-and-codedom/viewing-type-information">Anzeigen von Typinformationen</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1;net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1;net-5.0" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1;net-5.0" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1;net-5.0" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.1;net-5.0" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der Klasse <see cref="T:System.Type" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor wird von abgeleiteten Klassen während der Erstellung von Type-Objekten aufgerufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die <see cref="T:System.Reflection.Assembly" /> ab, in der der Typ deklariert ist. Ruft bei generischen Typen die <see cref="T:System.Reflection.Assembly" /> ab, in der der generische Typ definiert ist.</summary>
        <value>Eine <see cref="T:System.Reflection.Assembly" />-Instanz, die die Assembly mit dem aktuellen Typ beschreibt. Bei generischen Typen beschreibt die Instanz die Assembly, die die generische Typdefinition enthält, nicht die Assembly, in der ein bestimmter konstruierter Typ erstellt und verwendet wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das aktuelle <xref:System.Type>-Objekt einen konstruierten generischen Typ darstellt, gibt diese Eigenschaft die Assembly zurück, die die generische Typdefinition enthält. Nehmen Sie beispielsweise an, Sie erstellen eine Assembly mit dem Namen MyGenerics. dll, die die generische Typdefinition `MyGenericStack<T>` enthält (`MyGenericStack(Of T)` C++in Visual Basic, `generic<T> ref class MyGenericStack` in). Wenn Sie eine Instanz von `MyGenericStack<int>` (`MyGenericStack(Of Integer)` in Visual Basic) in einer anderen Assembly erstellen, gibt die <xref:System.Type.Assembly%2A>-Eigenschaft für den konstruierten Typ ein <xref:System.Reflection.Assembly> Objekt zurück, das MyGenerics. dll darstellt.  
  
 Wenn das aktuelle <xref:System.Type>-Objekt einen nicht zugewiesenen generischen Parameter `T`darstellt, gibt diese Eigenschaft die Assembly zurück, die den generischen Typ enthält, der `T`definiert.  
  
 Wenn die <xref:System.Type.Assembly%2A?displayProperty=nameWithType>-Eigenschaft für eine bestimmte .NET-Implementierung, wie z. b. .net Core oder die universelle Windows-Plattform, nicht verfügbar ist, verwenden Sie stattdessen die <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType>-Eigenschaft.      
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der AssemblyName, der der-Klasse zugeordnet ist, und der voll qualifizierte Name des-Typs angezeigt.  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den durch die Assembly qualifizierten Namen des Typs ab, der den Namen der Assembly enthält, aus der der <see cref="T:System.Type" /> geladen wurde.</summary>
        <value>Der durch die Assembly qualifizierte Name des <see cref="T:System.Type" />, der den Namen der Assembly enthält, aus der der <see cref="T:System.Type" /> geladen wurde, oder <see langword="null" />, wenn die aktuelle Instanz einen generischen Typparameter darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der durch die Assembly qualifizierte Name eines Typs besteht aus dem Typnamen, einschließlich des Namespace, gefolgt von einem Komma und dem anzeigen amen der Assembly. Der Anzeige Name einer Assembly wird mithilfe der <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType>-Eigenschaft abgerufen.  
  
> [!NOTE]
>  In der .NET Framework Version 2,0 wird die Prozessorarchitektur der Assemblyidentität hinzugefügt und kann als Teil der assemblynamenszeichenfolgen angegeben werden. Beispiel: "ProcessorArchitecture = msil". Aus Kompatibilitätsgründen ist Sie jedoch nicht in der Zeichenfolge enthalten, die von der <xref:System.Type.AssemblyQualifiedName%2A>-Eigenschaft zurückgegeben wird. Siehe <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
 Alle Compiler, die die Common Language Runtime unterstützen, geben den einfachen Namen einer geschachtelten Klasse aus, und die Reflektion erstellt bei der Abfrage einen geschachtelten Namen in Übereinstimmung mit den folgenden Konventionen.  
  
|Trennzeichen|Bedeutung|  
|---------------|-------------|  
|Umgekehrter Schrägstrich (\\)|Escapezeichen.|  
|Komma (,)|Geht vor dem Assemblynamen.|  
|Pluszeichen (+)|Geht einer-Klasse vorangestellt.|  
|Punkt (.)|Bezeichnet Namespace Bezeichner.|  
|Eckige Klammern ([])|Nach einem Typnamen steht für ein Array dieses Typs.<br /><br /> Oder<br /><br /> Schließt für einen generischen Typ die Argumentliste des generischen Typs ein.<br /><br /> Oder<br /><br /> Schließt innerhalb einer Typargument Liste einen von der Assembly qualifizierten Typ ein.|  
  
 Der durch die Assembly qualifizierte Name für eine Klasse könnte beispielsweise wie folgt aussehen:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 Wenn der Namespace ein Pluszeichen enthielt (z. b. TopNamespace. Sub + Namespace), wird dem Pluszeichen (+) ein Escapezeichen (\\) vorangestellt, um zu verhindern, dass es als Schachtelungs Trennzeichen interpretiert wird. Die Reflektion gibt diese Zeichenfolge wie folgt aus:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 Ein "+ +" wird zu "\\+\\+", und ein "\\" wird zu "\\\\".  
  
 Dieser qualifizierte Name kann persistent gespeichert und später verwendet werden, um die <xref:System.Type>zu laden. Um eine <xref:System.Type>zu suchen und zu laden, verwenden Sie <xref:System.Type.GetType%2A> entweder mit dem Typnamen oder mit dem qualifizierten Assemblynamen. <xref:System.Type.GetType%2A> mit dem Typnamen werden nur in der Assembly des Aufrufers und dann in der Systemassembly nach der <xref:System.Type> gesucht. <xref:System.Type.GetType%2A> mit dem qualifizierten Assemblynamen für die Assembly sucht in einer beliebigen Assembly nach der <xref:System.Type>.  
  
 Typnamen können nachfolgende Zeichen enthalten, die zusätzliche Informationen über den Typ angeben, z. b. ob der Typ ein Verweistyp, ein Zeigertyp oder ein Arraytyp ist. Um den Typnamen ohne diese nachfolgenden Zeichen abzurufen, verwenden Sie `t.GetElementType().ToString()`, wobei `t` der Typ ist.  
  
 Leerzeichen sind in allen Typnamen Komponenten mit Ausnahme des Assemblynamens relevant. Im Assemblynamen sind Leerzeichen vor dem Trennzeichen ', ' relevant, Leerzeichen nach dem Trennzeichen ', ' werden jedoch ignoriert.  
  
 Generische Argumente generischer Typen werden selbst anhand des Assemblynamens qualifiziert. Beispielsweise wird in der durch die Assembly qualifizierten Typnamen für `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic) `int` auf den durch die Assembly qualifizierten Typnamen für <xref:System.Int32>erweitert.  
  
 Wenn das aktuelle <xref:System.Type>-Objekt einen generischen Parameter darstellt, gibt diese Eigenschaft `null`zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der AssemblyName, der der-Klasse zugeordnet ist, und der voll qualifizierte Name des-Typs angezeigt.  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 Im folgenden Beispiel werden die von der <xref:System.Type.ToString%2A>-Methode zurückgegebenen Zeichen folgen und die Eigenschaften <xref:System.Type.Name%2A>, <xref:System.Type.FullName%2A>und `AssemblyQualifiedName` verglichen.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/specifying-fully-qualified-type-names">Angeben vollständig gekennzeichneter Typnamen</related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die dem <see cref="T:System.Type" /> zugeordneten Attribute ab.</summary>
        <value>Ein <see cref="T:System.Reflection.TypeAttributes" />-Objekt, das die Attributgruppe von <see cref="T:System.Type" /> darstellt. Falls <see cref="T:System.Type" /> jedoch einen generischen Typparameter darstellt, ist der Wert nicht festgelegt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Member der <xref:System.Reflection.TypeAttributes> Enumeration sind Masken, die eine Gruppe von Werten darstellen. Jede Gruppe enthält einen Member, dessen zugrunde liegender Wert NULL ist. Beispielsweise ist der zugrunde liegende Wert des <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType>-Elements in der <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> Gruppe 0 (null), ebenso wie das <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> Mitglied in der <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> Gruppe. Aus diesem Grund müssen Sie die Maske verwenden, bevor Sie diese Werte testen. Dies wird im Beispiel veranschaulicht.  
  
> [!TIP]
>  In den meisten Fällen sind Eigenschaften wie <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>und <xref:System.Type.IsSpecialName%2A> einfacher zu verwenden als Typattribute.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Eigenschaft die Attribute der generischen Typdefinition zurück. Beispielsweise sind die für `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic) zurückgegebenen Attribute die Attribute der `MyGenericClass<T>` (`MyGenericClass(Of T)` in Visual Basic).  
  
 Wenn die aktuelle <xref:System.Type> einen generischen Typparameter darstellt, d. h., wenn die <xref:System.Type.IsGenericParameter%2A>-Eigenschaft `true` zurückgibt, ist der von dieser Eigenschaft zurückgegebene <xref:System.Reflection.TypeAttributes> Wert nicht angegeben.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Type.Attributes%2A>-Eigenschaft verwendet.  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ ab, von dem der aktuelle <see cref="T:System.Type" /> direkt vererbt wird.</summary>
        <value>Der <see cref="T:System.Type" />, von dem der aktuelle <see cref="T:System.Type" /> direkt erbt, oder <see langword="null" />, wenn der aktuelle <see langword="Type" /> die <see cref="T:System.Object" />-Klasse oder eine Schnittstelle darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Basistyp ist der Typ, von dem der aktuelle Typ direkt erbt. <xref:System.Object> ist der einzige Typ, der keinen Basistyp hat. Deshalb wird `null` als Basistyp von <xref:System.Object>zurückgegeben.  
  
 Schnittstellen erben von NULL oder mehr Basis Schnittstellen. Daher gibt diese Eigenschaft `null` zurück, wenn das `Type`-Objekt eine Schnittstelle darstellt. Die Basis Schnittstellen können mit <xref:System.Type.GetInterfaces%2A> oder <xref:System.Type.FindInterfaces%2A>bestimmt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt der Basistyp die generischen Argumente wieder. Betrachten Sie beispielsweise die folgenden Deklarationen:  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 Für den konstruierten Typ `C<int>` (`C(Of Integer)` in Visual Basic) gibt die <xref:System.Type.BaseType%2A>-Eigenschaft `B<int>`zurück.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter einer generischen Typdefinition darstellt, gibt <xref:System.Type.BaseType%2A> die Klassen Einschränkung zurück, d. h. die Klasse, die der Typparameter erben muss. Wenn keine Klassen Einschränkung vorhanden ist, gibt <xref:System.Type.BaseType%2A> <xref:System.Object?displayProperty=nameWithType>zurück.  
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Type.BaseType%2A>-Eigenschaft veranschaulicht.  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 Im folgenden Beispiel wird Rekursion verwendet, um die vollständige Vererbungs Hierarchie der einzelnen in einer Assembly gefundenen Klassen aufzulisten. Das Beispiel definiert eine Klasse mit dem Namen `C`, die von einer Klasse mit dem Namen `B`abgeleitet wird, die wiederum von einer Klasse mit dem Namen `A`abgeleitet ist.  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/reflection-and-generic-types">Reflektion und generische Typen</related>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das aktuelle <see cref="T:System.Type" />-Objekt über Typparameter verfügt, die nicht durch bestimmte Typen ersetzt wurden.</summary>
        <value><see langword="true" />, wenn das <see cref="T:System.Type" />-Objekt selbst ein generischer Parametertyp ist oder über Typparameter verfügt, für die keine bestimmten Typen angegeben wurden, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um eine Instanz eines Typs zu erstellen, darf es keine generischen Typdefinitionen oder offenen konstruierten Typen in den Typargumenten des Typs selbst, in allen einschließenden generischen Typen oder in beliebigen Elementen des Typs geben. Eine andere Möglichkeit zu sagen, dass der Typ bei rekursiver unter Prüfung keine generischen Typparameter enthalten muss.  
  
 Da Typen beliebig komplex sein können, ist diese Bestimmung schwierig. Um die Wahrscheinlichkeit von Fehlern zu verringern, bietet die <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft eine Standardmethode zur Unterscheidung zwischen geschlossenen konstruierten Typen, die instanziiert werden können, und geöffneten konstruierten Typen. Wenn die <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft `true`zurückgibt, kann der Typ nicht instanziiert werden.  
  
 Die <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft sucht rekursiv nach Typparametern. Er gibt z. b. `true` für ein Array zurück, dessen Elemente vom Typ `A<T>` (`A(Of T)` in Visual Basic) sind, obwohl das Array nicht selbst generisch ist. Vergleichen Sie dies mit dem Verhalten der <xref:System.Type.IsGenericType%2A>-Eigenschaft, die `false` für Arrays zurückgibt.  
  
 Eine Reihe von Beispiel Klassen und eine Tabelle mit den Werten der <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft finden Sie unter <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine generische Klasse mit zwei Typparametern definiert, und anschließend wird eine zweite generische Klasse definiert, die von der ersten Klasse abgeleitet wird. Die Basisklasse der abgeleiteten Klasse verfügt über zwei Typargumente: die erste ist <xref:System.Int32>, und der zweite ist ein Typparameter des abgeleiteten Typs. Das Beispiel zeigt Informationen zu diesen generischen Klassen, einschließlich der von der <xref:System.Type.GenericParameterPosition%2A>-Eigenschaft gemeldeten Positionen.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/reflection-and-generic-types">Reflektion und generische Typen</related>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection">Gewusst wie: Untersuchen und Instanziieren von generischen Typen mit Reflektion</related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine <see cref="T:System.Reflection.MethodBase" /> ab, die die deklarierende Methode darstellt, wenn der aktuelle <see cref="T:System.Type" /> einen Typparameter einer generischen Methode darstellt.</summary>
        <value>Wenn der aktuelle <see cref="T:System.Type" /> einen Typparameter einer generischen Methode darstellt, eine <see cref="T:System.Reflection.MethodBase" />, die die deklarierende Methode darstellt, andernfalls <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der deklarierenden Methode handelt es sich um eine generische Methoden Definition. Das heißt, wenn <xref:System.Type.DeclaringMethod%2A> `null`nicht zurückgibt, gibt `DeclaringMethod.IsGenericMethodDefinition` `true`zurück.  
  
 Die Eigenschaften <xref:System.Type.DeclaringType%2A> und <xref:System.Type.DeclaringMethod%2A> identifizieren die generische Typdefinition oder generische Methoden Definition, in der der generische Typparameter ursprünglich definiert wurde:  
  
-   Wenn die <xref:System.Type.DeclaringMethod%2A>-Eigenschaft eine <xref:System.Reflection.MethodInfo>zurückgibt, stellt diese <xref:System.Reflection.MethodInfo> eine generische Methoden Definition dar, und das aktuelle <xref:System.Type>-Objekt stellt einen Typparameter dieser generischen Methoden Definition dar.  
  
-   Wenn die <xref:System.Type.DeclaringMethod%2A>-Eigenschaft `null`zurückgibt, gibt die <xref:System.Type.DeclaringType%2A>-Eigenschaft immer ein <xref:System.Type> Objekt zurück, das eine generische Typdefinition darstellt, und das aktuelle <xref:System.Type>-Objekt stellt einen Typparameter dieser generischen Typdefinition dar.  
  
-   Wenn Sie die <xref:System.Type.DeclaringMethod%2A>-Eigenschaft für einen Typ erhalten, dessen <xref:System.Type.IsGenericParameter%2A>-Eigenschaft `false` ist, wird ein <xref:System.InvalidOperationException>ausgelöst.  
  
 Der <xref:System.Reflection.MethodBase>, der von der <xref:System.Type.DeclaringMethod%2A>-Eigenschaft zurückgegeben wird, ist entweder eine <xref:System.Reflection.MethodInfo> im Fall einer generischen Methode oder eine <xref:System.Reflection.ConstructorInfo> im Fall eines generischen Konstruktors.  
  
> [!NOTE]
>  In der .NET Framework Version 2,0 werden generische Konstruktoren nicht unterstützt.  
  
 Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine-Klasse definiert, die über eine generische-Methode verfügt, der-Methode ein Typargument zuweist und die resultierende konstruierte generische Methode aufruft. Außerdem werden Informationen zur generischen Methoden Definition und der konstruierten Methode angezeigt. Beim Anzeigen von Informationen über die Typparameter der generischen Methoden Definition in der `DisplayGenericMethodInfo`-Methode zeigt der Beispielcode den Wert der <xref:System.Type.DeclaringMethod%2A>-Eigenschaft für den generischen Typparameter der Methode an.  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/reflection-and-generic-types">Reflektion und generische Typen</related>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection">Gewusst wie: Untersuchen und Instanziieren von generischen Typen mit Reflektion</related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public abstract Type DeclaringType { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property DeclaringType As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ DeclaringType { Type ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Type.DeclaringType" />
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ ab, der den aktuellen geschachtelten oder generischen Typparameter deklariert.</summary>
        <value>Ein <see cref="T:System.Type" />-Objekt, das den einschließenden Typ darstellt, wenn es sich bei dem aktuellen Typ um einen geschachtelten Typ handelt. Die generische Typdefinition, wenn es sich bei dem aktuellen Typ um einen Typparameter eines generischen Typs handelt. Der Typ, der die generische Methode deklariert, wenn es sich bei dem aktuellen Typ um einen Typparameter einer generischen Methode handelt. Andernfalls <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das aktuelle <xref:System.Type>-Objekt einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft die generische Typdefinition zurück.  
  
 Wenn das aktuelle <xref:System.Type>-Objekt einen Typparameter einer generischen Methode darstellt, gibt diese Eigenschaft den Typ zurück, der die generische Methoden Definition enthält. Wenn der Typ generisch ist, wird die generische Typdefinition zurückgegeben. Das heißt, der folgende Code gibt die generische Typdefinition der <xref:System.Collections.Generic.List%601> generischen-Klasse zurück, die die <xref:System.Collections.Generic.List%601.ConvertAll%2A> generische Methode enthält:  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, identifizieren die Eigenschaften <xref:System.Type.DeclaringType%2A> und <xref:System.Type.DeclaringMethod%2A> die generische Typdefinition oder generische Methoden Definition, in der der generische Typparameter ursprünglich definiert wurde:  
  
-   Wenn die <xref:System.Type.DeclaringMethod%2A>-Eigenschaft eine <xref:System.Reflection.MethodInfo>zurückgibt, stellt diese <xref:System.Reflection.MethodInfo> eine generische Methoden Definition dar, und das aktuelle <xref:System.Type>-Objekt stellt einen Typparameter dieser generischen Methoden Definition dar.  
  
-   Wenn die <xref:System.Type.DeclaringMethod%2A>-Eigenschaft `null`zurückgibt, gibt die <xref:System.Type.DeclaringType%2A>-Eigenschaft immer ein <xref:System.Type> Objekt zurück, das eine generische Typdefinition darstellt, und das aktuelle <xref:System.Type>-Objekt stellt einen Typparameter dieser generischen Typdefinition dar.  
  
-   Wenn Sie die <xref:System.Type.DeclaringType%2A>-Eigenschaft für einen Typ erhalten, dessen <xref:System.Type.IsGenericParameter%2A>-Eigenschaft `false` ist, wird ein <xref:System.InvalidOperationException>ausgelöst.  
  
   
  
## Examples  
 Dieses Beispiel zeigt den deklarierenden Typ einer Methode in einer abgeleiteten Klasse.  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBinder : System.Reflection.Binder" Usage="System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf den Standardbinder ab, der interne Regeln für die Auswahl der passenden Member implementiert, die von <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" /> aufgerufen werden sollen.</summary>
        <value>Ein Verweis auf den vom System verwendeten Standardbinder.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standard Binder, der mit dem Common Language Runtime bereitgestellt wird, gilt nur für die spezielleren Umstände. Wenn Sie einen Binder benötigen, der auf Regeln folgt, die sich von denen des bereitgestellten Standard Binders unterscheiden, definieren Sie einen Typ, der von der <xref:System.Reflection.Binder> Klasse abgeleitet ist, und übergeben Sie mithilfe des `binder`-Parameters einer der <xref:System.Type.InvokeMember%2A> Überladungen eine Instanz dieses Typs.  
  
 Reflektion modelliert die Zugriffsregeln für das allgemeine Typsystem. Wenn sich der Aufrufer z. b. in derselben Assembly befindet, benötigt der Aufrufer keine speziellen Berechtigungen für interne Member. Andernfalls benötigt der Aufrufer <xref:System.Security.Permissions.ReflectionPermission>. Dies entspricht der Suche nach Elementen, die geschützt, privat sind usw.  
  
 Das allgemeine Prinzip ist, dass <xref:System.Reflection.Binder.ChangeType%2A> nur erweiternde Konvertierungen durchführen soll, bei denen Daten niemals verloren gehen. Ein Beispiel für eine erweiternde Konvertierung ist das Konvertieren eines Werts, bei dem es sich um eine 32-Bit-Ganzzahl mit Vorzeichen handelt, in einen Wert, bei dem es sich um eine 64 Dies unterscheidet sich von einer einschränkenden Konvertierung, bei der Daten verloren gehen können. Ein Beispiel für eine einschränkende Konvertierung ist das Konvertieren einer 64-Bit-Ganzzahl mit Vorzeichen in eine 32-Bit-Ganzzahl mit Vorzeichen.  
  
 In der folgenden Tabelle sind die Konvertierungen aufgeführt, die vom Standard Binder unterstützt werden.  
  
|Quellentyp|Zieltyp|  
|-----------------|-----------------|  
|Beliebiger Typ|Der Basistyp.|  
|Beliebiger Typ|Die Schnittstelle, die implementiert wird.|  
|Char|Unt16, UInt32, Int32, UInt64, Int64, Single, Double|  
|Byte|Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double|  
|SByte|Int16, Int32, Int64, Single, Double|  
|UInt16|UInt32, Int32, UInt64, Int64, Single, Double|  
|Int16|Int32, Int64, Single, Double|  
|UInt32|UInt64, Int64, Single, Double|  
|Int32|Int64, Single, Double|  
|UInt64|Single, Double|  
|Int64|Single, Double|  
|Single|Double|  
|Nicht Verweis|Nach Verweis.|  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Standard Binder aus der `DefaultBinder`-Eigenschaft abgerufen und ein Member von MyClass aufgerufen, indem der `DefaultBinder`-Wert als Parameter an <xref:System.Type.InvokeMember%2A>übergeben wird.  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Delimiter : char" Usage="System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Trennt Namen im Namespace des <see cref="T:System.Type" />. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberSignature Language="F#" Value=" staticval mutable EmptyTypes : Type[]" Usage="System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt ein leeres Array vom <see cref="T:System.Type" />-Typ dar. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Das folgende Codebeispiel zeigt das `EmptyTypes` Feld, das in einer der `GetConstructor`-Methoden verwendet wird, um einen Konstruktor zu erhalten, der keine Parameter annimmt.  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Bestimmt, ob der zugrunde liegende Systemtyp des aktuellen <see cref="T:System.Type" /> mit dem zugrunde liegende Systemtyp des angegebenen <see cref="T:System.Object" /> oder <see cref="T:System.Type" /> übereinstimmt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Das Objekt, dessen zugrunde liegender Systemtyp mit dem zugrunde liegenden Systemtyp des aktuellen <see cref="T:System.Type" /> verglichen werden soll. <paramref name="o" /> muss in ein Objekt vom Typ <see cref="T:System.Type" /> umgewandelt oder konvertiert werden können, damit der Vergleich erfolgreich durchgeführt werden kann.</param>
        <summary>Bestimmt, ob der zugrunde liegende Systemtyp des aktuellen <see cref="T:System.Type" />-Objekts mit dem zugrunde liegenden Systemtyp des angegebenen <see cref="T:System.Object" />-Objekts übereinstimmt</summary>
        <returns><see langword="true" />, wenn der zugrunde liegende Systemtyp von <paramref name="o" /> mit dem zugrunde liegenden Systemtyp des aktuellen <see cref="T:System.Type" /> übereinstimmt, andernfalls <see langword="false" />. Diese Methode gibt auch in folgenden Fällen <see langword="false" /> zurück: 
-   <paramref name="o" /> ist <see langword="null" />.  
  
-   <paramref name="o" /> nicht in ein <see cref="T:System.Type" />-Objekt umgewandelt oder konvertiert werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Object.Equals%2A?displayProperty=nameWithType>. Sie wandelt `o` in ein Objekt des Typs <xref:System.Type> um und ruft die <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType>-Methode auf.  
  
   
  
## Examples  
 Im folgenden Beispiel wird <xref:System.Type.Equals%28System.Object%29> verwendet, um verschiedene <xref:System.Type> Objektinstanzen mit verschiedenen <xref:System.Object>-Instanzen zu vergleichen.  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 Zwei Punkte sind besonders erwähnenswert:  
  
-   Der Vergleich eines <xref:System.Type> Objekts, das eine ganze Zahl mit einem <xref:System.Reflection.TypeInfo> Objekt darstellt, das eine ganzzahlige Rückgabe `true` darstellt, da <xref:System.Reflection.TypeInfo> von <xref:System.Type>abgeleitet ist.  
  
-   Der Vergleich eines <xref:System.Type> Objekts, das ein <xref:System.Collections.Generic.IList%601> Objekt (ein offener generischer Typ) mit einem `List(Of String)` Objekt (ein geschlossener generischer Typ) darstellt, gibt `false`zurück.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (Type o);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(class System.Type o) cil managed" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (o As Type) As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(Type ^ o);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="override this.Equals : Type -&gt; bool" Usage="type.Equals o" />
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o">Das Objekt, dessen zugrunde liegender Systemtyp mit dem zugrunde liegenden Systemtyp des aktuellen <see cref="T:System.Type" /> verglichen werden soll.</param>
        <summary>Bestimmt, ob der zugrunde liegende Systemtyp des aktuellen <see cref="T:System.Type" /> mit dem zugrunde liegenden Systemtyp des angegebenen <see cref="T:System.Type" /> übereinstimmt.</summary>
        <returns><see langword="true" />, wenn der zugrunde liegende Systemtyp von <paramref name="o" /> mit dem zugrunde liegenden Systemtyp des aktuellen <see cref="T:System.Type" /> übereinstimmt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird `Equals` verwendet, um zwei Typen zu vergleichen.  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterAttribute : System.Reflection.MemberFilter" Usage="System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den für Attribute verwendeten Memberfilter dar. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Feld enthält einen Verweis auf den Delegaten, der von der <xref:System.Type.FindMembers%2A>-Methode verwendet wird. Die von diesem Delegaten gekapselte Methode erfordert zwei Parameter: das erste ist ein <xref:System.Reflection.MemberInfo> Objekt und das zweite ein `Object`. Die-Methode bestimmt, ob das `MemberInfo`-Objekt mit den vom `Object`angegebenen Kriterien übereinstimmt. Der `Object` kann der Wert eines der Felder in den Klassen <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>oder <xref:System.Reflection.MethodImplAttributes>zugewiesen werden.  
  
 Beispielsweise kann dem `Object` der Wert eines Felds aus `FieldAttributes` wie z. b. Public zugewiesen werden. Wenn in diesem Fall der `FilterAttribute` Delegat aufgerufen wird, gibt er nur `true` zurück, wenn die durch das `MemberInfo` Objekt dargestellte Methode mit dem öffentlichen Feld Attribut in den Metadaten versehen wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der `FilterAttribute` Delegat abgerufen, als Parameter an die <xref:System.Type.FindMembers%2A>-Methode übergeben und die angegebenen Elemente und deren Attribute angezeigt.  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterName : System.Reflection.MemberFilter" Usage="System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den für Namen verwendeten Memberfilter mit Beachtung der Groß-/Kleinschreibung dar. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Feld enthält einen Verweis auf den Delegaten, der von der <xref:System.Type.FindMembers%2A>-Methode verwendet wird. Die von diesem Delegaten gekapselte Methode erfordert zwei Parameter: das erste ist ein <xref:System.Reflection.MemberInfo> Objekt und das zweite ein `Object`. Die-Methode bestimmt, ob das `MemberInfo`-Objekt mit den vom `Object`angegebenen Kriterien übereinstimmt. Dem `Object` wird ein Zeichen folgen Wert zugewiesen, der möglicherweise ein nachfolgendes "*"-Platzhalter Zeichen enthält. Nur Platzhalter-Zeichen folgen Vergleiche werden unterstützt.  
  
 Beispielsweise kann dem `Object` der Wert "Byte *" zugewiesen werden. Wenn der `FilterName` Delegat aufgerufen wird, gibt er `true` nur dann zurück, wenn die durch das `MemberInfo` Objekt dargestellte Methode einen Namen hat, der mit "Byte" beginnt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die Methoden abgerufen, die dem benutzerdefinierten `Application`-Typ zugeordnet sind.  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterNameIgnoreCase : System.Reflection.MemberFilter" Usage="System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt den für Namen verwendeten Memberfilter ohne Beachtung der Groß-/Kleinschreibung dar. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieses Feld enthält einen Verweis auf den Delegaten, der von der <xref:System.Type.FindMembers%2A>-Methode verwendet wird. Die von diesem Delegaten gekapselte Methode erfordert zwei Parameter: das erste ist ein <xref:System.Reflection.MemberInfo> Objekt und das zweite ein `Object`. Die-Methode bestimmt, ob das `MemberInfo`-Objekt mit den vom `Object`angegebenen Kriterien übereinstimmt. Dem `Object` wird ein Zeichen folgen Wert zugewiesen, der möglicherweise ein nachfolgendes "*"-Platzhalter Zeichen enthält. Nur Platzhalter-Zeichen folgen Vergleiche werden unterstützt.  
  
 Beispielsweise kann dem `Object` der Wert "ByTe *" zugewiesen werden. Wenn der `FilterName` Delegat aufgerufen wird, wird in diesem Fall nur dann true zurückgegeben, wenn die durch das `MemberInfo`-Objekt dargestellte Methode einen Namen hat, der mit "Byte" beginnt, wobei die Groß-/Kleinschreibung ignoriert wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der `MemberFilter` Delegat abgerufen, als Parameter an die <xref:System.Type.FindMembers%2A>-Methode übergeben und die Methoden und deren Attribute der `String`-Klasse angezeigt, die mit dem Buchstaben "c" beginnen, wobei die Groß-/Kleinschreibung nicht beachtet wird.  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="type.FindInterfaces (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="filterCriteria" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="filter">Der Delegat, der die Schnittstellen anhand der <paramref name="filterCriteria" /> vergleicht.</param>
        <param name="filterCriteria">Die Suchkriterien, die bestimmen, ob eine Schnittstelle in das zurückgegebene Array aufgenommen wird.</param>
        <summary>Gibt ein Array von <see cref="T:System.Type" />-Objekten zurück, die eine gefilterte Liste von Schnittstellen darstellen, die vom aktuellen <see cref="T:System.Type" /> implementiert oder geerbt wurden.</summary>
        <returns>Ein Array von <see cref="T:System.Type" />-Objekten, das eine gefilterte Liste von Schnittstellen darstellt, die durch den aktuellen <see cref="T:System.Type" /> implementiert oder geerbt wurden, oder ein leeres Array, wenn der aktuelle <see cref="T:System.Type" /> keine dem Filter entsprechende Schnittstellen implementiert oder erbt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.  
  
 Die <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType>-und <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> Delegaten, die von der <xref:System.Reflection.Module?displayProperty=nameWithType>-Klasse bereitgestellt werden, können auch anstelle des <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> Delegaten verwendet werden.  
  
 Alle von dieser Klasse implementierten Schnittstellen werden während der Suche berücksichtigt, unabhängig davon, ob Sie von einer Basisklasse oder dieser Klasse deklariert wird.  
  
 Diese Methode durchsucht die Basisklassen Hierarchie und gibt alle übereinstimmenden Schnittstellen zurück, die von jeder Klasse implementiert werden, sowie alle übereinstimmenden Schnittstellen, die diese Schnittstellen implementieren (das heißt, die transitiv Schließung der übereinstimmenden Schnittstellen wird zurückgegeben). Doppelte Schnittstellen werden nicht zurückgegeben.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht <xref:System.Type.FindInterfaces%2A> alle Schnittstellen, die in den Einschränkungen für den Typparameter deklariert sind, und alle Schnittstellen, die über die in den Einschränkungen deklarierten Schnittstellen geerbt wurden. Wenn die aktuelle <xref:System.Type> ein Typargument eines generischen Typs darstellt, durchsucht <xref:System.Type.FindInterfaces%2A> alle durch den Typ implementierten Schnittstellen, unabhängig davon, ob Sie Einschränkungen erfüllen.  
  
> [!NOTE]
>  <xref:System.Type.FindInterfaces%2A> können generische Schnittstellen zurückgeben, auch bei Typen, die nicht generisch sind. Ein nicht generischer Typ kann z. b. `IEnumerable<int>` (`IEnumerable(Of Integer)` in Visual Basic) implementieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die angegebene, vom angegebenen Typ implementierte oder geerbte Schnittstelle gesucht, und dann werden die Schnittstellennamen angezeigt.  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filter" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein statischer Initialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]&#xA;override this.FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]" Usage="type.FindMembers (memberType, bindingAttr, filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="filterCriteria" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="memberType">Eine bitweise Kombination von Enumerationswerten, die angibt, welcher Membertyp gesucht werden soll.</param>
        <param name="bindingAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.  
  
Oder 
 <see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="filter">Der Delegat, der die Vergleiche durchführt. Der Rückgabewert ist <see langword="true" />, wenn der gerade betrachtete Member den <paramref name="filterCriteria" /> entspricht, andernfalls <see langword="false" />.</param>
        <param name="filterCriteria">Die Suchkriterien, die bestimmen, ob ein Member im Array von <see langword="MemberInfo" />-Objekten zurückgegeben wird.  
  
Die Felder von <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> und <see langword="MethodImplAttributes" /> können zusammen mit dem <see langword="FilterAttribute" />-Delegaten dieser Klasse verwendet werden.</param>
        <summary>Gibt ein gefiltertes Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten mit dem angegebenen Membertyp zurück.</summary>
        <returns>Ein gefiltertes Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten vom angegebenen Membertyp.  
  
Oder 
Ein leeres Array, wenn der aktuelle <see cref="T:System.Type" /> keine den Filterkriterien entsprechenden Member vom <paramref name="memberType" />-Typ besitzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.  
  
Member enthalten Eigenschaften, Methoden, Felder, Ereignisse usw.  

Damit die `FindMembers`-Methode Element Informationen erfolgreich abrufen kann, muss das `bindingAttr`-Argument mindestens eine <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> und <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>zusammen mit mindestens einer <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> und <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>enthalten. 

 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Elemente in die Suche eingeschlossen werden sollen:  
  
-   Geben Sie `BindingFlags.Instance` an, um Instanzmember in die Suche einzubeziehen.  
  
-   Geben Sie `BindingFlags.Static` an, um statische Member in die Suche einzubeziehen.  
  
-   Geben Sie `BindingFlags.Public` an, um öffentliche Member in die Suche einzubeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` an, dass nicht öffentliche Member (d. h. private, interne und geschützte Member) in der Suche enthalten sein sollen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags>-Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:  
  
-   `BindingFlags.DeclaredOnly`, um nur die Member zu durchsuchen, die auf dem <xref:System.Type>deklariert sind, nicht Elemente, die einfach geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
Um mithilfe dieser Methode den Klasseninitialisierer (statischer Konstruktor) zu erhalten, müssen &#124; Sie <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> angeben (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>). Sie können den Klasseninitialisierer auch mit der <xref:System.Type.TypeInitializer%2A>-Eigenschaft erhalten.  
  
Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs oder einer generischen Methode darstellt, verarbeitet <xref:System.Type.FindMembers%2A> alle von der Klassen Einschränkung deklarierten Member und die Schnittstellen Einschränkungen des Typparameters.  

Das `filter`-Argument kann ein benutzerdefinierter Delegat vom Typ <xref:System.Reflection.MemberFilter>sein, oder es kann sich um einen der folgenden vordefinierten Delegaten handeln:

- <xref:System.Type.FilterAttribute?displayProperty=nameWithType>, bei dem eine<xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>oder <xref:System.Reflection.MethodImplAttributes> Bitmaske als `filterCriteria` Wert verwendet wird.

- <xref:System.Type.FilterName?displayProperty=nameWithType>, der einen Vergleich der einzelnen Elementnamen mit Berücksichtigung der Groß-und Kleinschreibung durchführt, wobei die Zeichenfolge an `filterCriteria`übergebenen

- <xref:System.Type.FilterNameIgnoreCase?displayProperty=nameWithType>, die ohne Beachtung der Groß-/Kleinschreibung den einzelnen Elementnamen mit der an `filterCriteria`übergebenen Zeichenfolge ausführt.

## Examples  
 Im folgenden Beispiel werden alle Member einer Klasse gesucht, die den angegebenen Suchkriterien entsprechen, und anschließend werden die übereinstimmenden Member angezeigt.  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="filter" /> ist <see langword="null" /></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Type.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den voll vollqualifizierten Namen des Typs ab. Dies beinhaltet den Namespace, nicht jedoch die Assembly.</summary>
        <value>Der vollqualifizierte Name des Typs, einschließlich des Namespace, jedoch ausschließlich der Assembly, oder <see langword="null" />, wenn die aktuelle Instanz einen auf einem Typparameter basierenden generischen Typparameter, Arraytyp, Zeigertyp oder <see langword="byref" />-Typ oder einen generischen Typ darstellt, der keine generische Typdefinition ist, jedoch nicht aufgelöste Typparameter enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beispielsweise ist der voll qualifizierte Name des <xref:System.String> Typs `System.String`. Vergleichen Sie dies mit dem durch die Assembly qualifizierten Namen, der von der <xref:System.Type.AssemblyQualifiedName%2A>-Eigenschaft zurückgegeben wird, die aus dem vollständigen Namen und dem vollständigen Assemblynamen  
  
 Wenn der aktuelle Typ einen geschlossenen generischen Typ darstellt, werden die Typargumente in der von der <xref:System.Type.FullName%2A>-Eigenschaft zurückgegebenen Zeichenfolge durch den vollständigen Assemblynamen qualifiziert, auch wenn die Zeichen folgen Darstellung des generischen Typs selbst nicht durch den vollständigen Assemblynamen qualifiziert wird. Das folgende Beispiel veranschaulicht den Unterschied in der FullName-Eigenschaft für einen Typ, der die generische Typdefinition darstellt, und einen Typ, der einen geschlossenen generischen Typ darstellt.  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 Diese Eigenschaft gibt `null` zurück, wenn:  
  
-   Das aktuelle <xref:System.Type>-Objekt stellt einen Typparameter eines generischen Typs dar.  
  
     Im folgenden Beispiel wird der Typparameter des <xref:System.Nullable%601> Typs abgerufen, und es wird versucht, die <xref:System.Type.FullName%2A>-Eigenschaft anzuzeigen.  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   Das aktuelle <xref:System.Type>-Objekt stellt einen Arraytyp, einen Zeigertyp oder einen `byref` Typ dar, der auf einem generischen Typparameter basiert.  
  
     Im folgenden Beispiel wird ein generischer Typ (`Generictype1<T>`) mit drei Methoden definiert: `Display(T[])`, an die ein Array vom Typ t übermittelt wird. `HandleT(T)`, dem ein t-Objekt übermittelt wird. und `ChangeValue(ref T)`, dem ein t-Objekt als Verweis übermittelt wird. Da C# und Visual Basic die Definition von T nicht als Zeiger in der `HandleT`-Methode zulassen, müssen wir die <xref:System.Type.MakePointerType%2A>-Methode für das <xref:System.Type> Objekt aufrufen, das den Parametertyp der Methode darstellt, um einen Zeiger auf einen generischen Typ zu erstellen. Die Ausgabe des Beispiels zeigt, dass in allen drei Fällen die <xref:System.Type.FullName%2A>-Eigenschaft `null`ist.  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   Der aktuelle Typ enthält generische Typparameter, die nicht durch bestimmte Typen ersetzt wurden (d. h., die <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft gibt `true`zurück), aber der Typ ist keine generische Typdefinition (d. h., die <xref:System.Type.IsGenericTypeDefinition%2A>-Eigenschaft gibt zurück `false`  
  
     Im folgenden Beispiel erbt `Derived<T>` von `Base<T>`. Die <xref:System.Type.BaseType%2A>-Eigenschaft ruft das <xref:System.Type> Objekt ab, das den Basistyp von `Derived<T>`darstellt, und seine <xref:System.Type.FullName%2A>-Eigenschaft gibt `null`zurück.  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     Um einen <xref:System.Type.FullName%2A> zu erhalten, der nicht `null`ist, können Sie die <xref:System.Type.GetGenericTypeDefinition%2A>-Methode verwenden, um die generische Typdefinition zu erhalten, wie im Beispiel veranschaulicht.  
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der vollständige Name des angegebenen Typs angezeigt.  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 Im folgenden Beispiel werden die von der <xref:System.Type.ToString%2A>-Methode zurückgegebenen Zeichen folgen und die Eigenschaften <xref:System.Type.Name%2A>, `FullName`und <xref:System.Type.AssemblyQualifiedName%2A> verglichen.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/specifying-fully-qualified-type-names">Angeben vollständig gekennzeichneter Typnamen</related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Kombination von <see cref="T:System.Reflection.GenericParameterAttributes" />-Flags ab, die die Kovarianz und die speziellen Einschränkungen des aktuellen generischen Typparameters beschreiben.</summary>
        <value>Eine bitweise Kombination von <see cref="T:System.Reflection.GenericParameterAttributes" />-Werten, die die Kovarianz und die speziellen Einschränkungen des aktuellen generischen Typparameters beschreiben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Wert dieser Eigenschaft enthält Flags, die beschreiben, ob der aktuelle generische Typparameter kovariant ist, und Flags, die alle besonderen Einschränkungen beschreiben. Verwenden Sie den <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> Wert, um die Kovarianz Flags auszuwählen, und verwenden Sie den <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType>-Wert, um die Einschränkungs Flags auszuwählen.  
  
 Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein generischer Typ `Test` mit zwei Typparametern definiert, die unterschiedliche Einschränkungen aufweisen. Wenn das Programm ausgeführt wird, werden die Einschränkungen mithilfe der <xref:System.Type.GenericParameterAttributes%2A>-Eigenschaft und der <xref:System.Type.GetGenericParameterConstraints%2A>-Methode untersucht.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das aktuelle <see cref="T:System.Type" />-Objekt ist kein generischer Typparameter. Das bedeutet, dass die <see cref="P:System.Type.IsGenericParameter" />-Eigenschaft <see langword="false" /> zurückgibt.</exception>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/reflection-and-generic-types">Reflektion und generische Typen</related>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection">Gewusst wie: Untersuchen und Instanziieren von generischen Typen mit Reflektion</related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public abstract int GenericParameterPosition { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GenericParameterPosition As Integer" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property int GenericParameterPosition { int get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Type.GenericParameterPosition" />
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Position des Typparameters in der Typparameterliste des generischen Typs oder der Methode ab, der bzw. die den Parameter deklariert hat, wenn das <see cref="T:System.Type" />-Objekt einen Typparameter eines generischen Typs oder einer generischen Methode darstellt.</summary>
        <value>Die Position eines Typparameters in der Typparameterliste des generischen Typs oder der generischen Methode, der bzw. die den Parameter definiert. Die Positionsnummern beginnen mit 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GenericParameterPosition%2A>-Eigenschaft gibt die Position eines Typparameters in der Parameterliste der generischen Typdefinition oder der generischen Methoden Definition zurück, in der der Typparameter ursprünglich definiert wurde. Die Eigenschaften <xref:System.Type.DeclaringType%2A> und <xref:System.Type.DeclaringMethod%2A> identifizieren den generischen Typ oder die Definition der Methode:  
  
-   Wenn die <xref:System.Type.DeclaringMethod%2A>-Eigenschaft eine <xref:System.Reflection.MethodInfo>zurückgibt, stellt diese <xref:System.Reflection.MethodInfo> eine generische Methoden Definition dar, und das aktuelle <xref:System.Type>-Objekt stellt einen Typparameter dieser generischen Methoden Definition dar.  
  
-   Wenn die <xref:System.Type.DeclaringMethod%2A>-Eigenschaft `null`zurückgibt, gibt die <xref:System.Type.DeclaringType%2A>-Eigenschaft immer ein <xref:System.Type> Objekt zurück, das eine generische Typdefinition darstellt, und das aktuelle <xref:System.Type>-Objekt stellt einen Typparameter dieser generischen Typdefinition dar.  
  
 Um den korrekten Kontext für den Wert der <xref:System.Type.GenericParameterPosition%2A>-Eigenschaft bereitzustellen, müssen Sie den generischen Typ oder die Methode identifizieren, zu der ein Typparameter gehört. Sehen Sie sich beispielsweise den Rückgabewert der generischen-Methode `GetSomething` im folgenden Code an:  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 Der von `GetSomething` zurückgegebene Typ hängt von den Typargumenten ab, die für die Klasse `A` bereitgestellt werden, und zum `GetSomething` Sie können einen <xref:System.Reflection.MethodInfo> für `GetSomething`abrufen und den Rückgabetyp abrufen. Wenn Sie die Typparameter des Rückgabe Typs untersuchen, gibt <xref:System.Type.GenericParameterPosition%2A> 0 für beides zurück. Die Position `V` ist 0, da `V` der erste Typparameter in der Typparameter Liste für die Klasse `A`ist. Die Position `X` ist 0, da `X` der erste Typparameter in der Typparameter Liste für `GetSomething`ist.  
  
> [!NOTE]
>  Wenn Sie die <xref:System.Type.GenericParameterPosition%2A>-Eigenschaft aufrufen, wird eine Ausnahme ausgelöst, wenn der aktuelle <xref:System.Type> keinen Typparameter darstellt. Wenn Sie die Typargumente eines geöffneten konstruierten Typs überprüfen, verwenden Sie die <xref:System.Type.IsGenericParameter%2A>-Eigenschaft, um zu ermitteln, welche Typparameter und welche Typen sind. Die <xref:System.Type.IsGenericParameter%2A>-Eigenschaft gibt `true` für einen Typparameter zurück. Anschließend können Sie die <xref:System.Type.GenericParameterPosition%2A>-Methode verwenden, um die Position abzurufen, und die Eigenschaften <xref:System.Type.DeclaringMethod%2A> und <xref:System.Type.DeclaringType%2A> verwenden, um die generische Methode oder Typdefinition zu ermitteln, die Sie definiert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine generische Klasse mit zwei Typparametern definiert und eine zweite generische Klasse definiert, die von der ersten Klasse abgeleitet wird. Die Basisklasse der abgeleiteten Klasse hat zwei Typargumente: das erste ist <xref:System.Int32>, und das zweite ist ein Typparameter des abgeleiteten Typs. Das Beispiel zeigt Informationen zu diesen generischen Klassen, einschließlich der von der <xref:System.Type.GenericParameterPosition%2A>-Eigenschaft gemeldeten Positionen.  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Typ stellt keinen Typparameter dar. Das heißt, <see cref="P:System.Type.IsGenericParameter" /> gibt <see langword="false" /> zurück.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/reflection-and-generic-types">Reflektion und generische Typen</related>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection">Gewusst wie: Untersuchen und Instanziieren von generischen Typen mit Reflektion</related>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public abstract Type[] GenericTypeArguments { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GenericTypeArguments As Type()" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Type.GenericTypeArguments" />
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein Array von generischen Typargumenten für diesen Typ ab.</summary>
        <value>Ein Array von generischen Typargumenten für diesen Typ.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ruft nur die generischen Typargumente ab. Das heißt, die Typen, die für die generischen Typparameter des aktuellen Typs angegeben wurden. Wenn es sich bei dem aktuellen Typ um eine generische Typdefinition handelt, gibt diese Eigenschaft ein leeres Array zurück.  
  
> [!NOTE]
>  Wenn ein generischer Typ in einer generischen Methode oder einem anderen generischen Typ verwendet wird, sind einige seiner generischen Typargumente möglicherweise generische Typparameter der einschließenden Methode oder des einschließenden Typs.  
  
 Verwenden Sie die <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType>-Eigenschaft, um die generischen Typparameter eines Typs zu erhalten, der eine generische Typdefinition darstellt. Um ein <xref:System.Reflection.TypeInfo>-Objekt für das aktuelle <xref:System.Type>-Objekt zu erhalten, verwenden Sie die <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType>-Erweiterungsmethode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public abstract int GetArrayRank ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetArrayRank () As Integer" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract int GetArrayRank();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int&#xA;override this.GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die Anzahl der Dimensionen eines Arrays ab.</summary>
        <returns>Eine Ganzzahl, die die Anzahl der Dimensionen im aktuellen Typ darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die Anzahl der Dimensionen in einem Array angezeigt.  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die Funktionalität dieser Methode wird in der Basisklasse nicht unterstützt und muss stattdessen in einer abgeleiteten Klasse implementiert werden.</exception>
        <exception cref="T:System.ArgumentException">Der aktuelle Typ ist kein Array.</exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="type.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.Attributes" />-Eigenschaft und ruft eine bitweise Kombination von Enumerationswerten ab, die die <see cref="T:System.Type" /> zugeordneten Attribute anzeigen.</summary>
        <returns>Ein <see cref="T:System.Reflection.TypeAttributes" />-Objekt, das die Attributgruppe von <see cref="T:System.Type" /> darstellt.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen bestimmten Konstruktor des aktuellen <see cref="T:System.Type" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter des abzurufenden Konstruktors darstellt.  
  
Oder 
Ein leeres Array von <see cref="T:System.Type" />-Objekten zum Abrufen eines Konstruktors ohne Parameter. Das <see langword="static" />-Feld <see cref="F:System.Type.EmptyTypes" /> stellt ein entsprechendes leeres Array bereit.</param>
        <summary>Sucht einen öffentlichen Instanzkonstruktor, dessen Parameter den Typen im angegebenen Array entsprechen.</summary>
        <returns>Ein Objekt, das den öffentlichen Instanzkonstruktor darstellt, dessen Parameter den Typen im Parametertyparray entsprechen, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methoden Überladung sucht nach öffentlichen Instanzkonstruktoren und kann nicht verwendet werden, um einen Klasseninitialisierer (statischer Konstruktor) abzurufen. Um einen Klasseninitialisierer zu erhalten, verwenden Sie eine Überladung, die <xref:System.Reflection.BindingFlags>&#124; annimmt, und geben Sie <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) an. Sie können den Klasseninitialisierer auch mit der <xref:System.Type.TypeInitializer%2A>-Eigenschaft erhalten.  
  
 Wenn der angeforderte Konstruktor nicht öffentlich ist, gibt diese Methode `null`zurück.  
  
> [!NOTE]
>  Sie können Parameter nicht weglassen, wenn Sie Konstruktoren und Methoden suchen. Beim Aufrufen von können Sie nur Parameter weglassen.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.ConstructorInfo> mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden. Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese Methode immer `null`zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Typ `MyClass`abgerufen, das <xref:System.Reflection.ConstructorInfo> Objekt abgerufen und die Konstruktorsignatur angezeigt.  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> ist <see langword="null" />  
  
Oder 
Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (bindingAttr As BindingFlags, binder As Binder, types As Type(), modifiers As ParameterModifier()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.  
  
Oder 
 <see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
Oder 
Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das Anzahl, Reihenfolge und Typ der Parameter des abzurufenden Konstruktors darstellt.  
  
Oder 
Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen eines Konstruktors, der keine Parameter akzeptiert.  
  
Oder 
 [https://login.microsoftonline.com/consumers/](<see cref="F:System.Type.EmptyTypes" />).</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im Parametertyparray zugeordnet sind. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht einen Konstruktor, dessen Parameter unter Verwendung der angegebenen Bindungseinschränkungen den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein <see cref="T:System.Reflection.ConstructorInfo" />-Objekt, das den Konstruktor darstellt, der den angegebenen Anforderungen entspricht, oder <see langword="null" />, wenn kein entsprechender Konstruktor gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn keine genaue Entsprechung vorhanden ist, versucht der `binder`, die im `types` Array angegebenen Parametertypen umzuleiten, um eine Entsprechung auszuwählen. Wenn die `binder` eine Entsprechung nicht auswählen kann, wird `null` zurückgegeben.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Konstruktoren in die Suche eingeschlossen werden sollen:  
  
-   Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` an, um öffentliche Konstruktoren in die Suche einzubeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` an, um nicht öffentliche Konstruktoren (d. h. private, interne und geschützte Konstruktoren) in die Suche einzubeziehen.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Um den Klasseninitialisierer (statischer Konstruktor) mithilfe dieser Methoden Überladung zu erhalten, &#124; müssen Sie <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> angeben (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic). Sie können den Klasseninitialisierer auch mit der <xref:System.Type.TypeInitializer%2A>-Eigenschaft erhalten.  
  
> [!NOTE]
>  Sie können Parameter nicht weglassen, wenn Sie Konstruktoren und Methoden suchen. Beim Aufrufen von können Sie nur Parameter weglassen.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.ConstructorInfo> mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden. Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese Methode immer `null`zurück.  
  
   
  
## Examples  
 Das folgende Programm ruft den Typ `MyClass1` Klasse ab, ruft das <xref:System.Reflection.ConstructorInfo> Objekt ab, das mit den angegebenen Bindungsflags übereinstimmt, und zeigt die Signatur des Konstruktors an.  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> ist <see langword="null" />  
  
Oder 
Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.  
  
Oder 
 <paramref name="modifiers" /> ist mehrdimensional.  
  
Oder 
 <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (bindingAttr As BindingFlags, binder As Binder, callConvention As CallingConventions, types As Type(), modifiers As ParameterModifier()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.  
  
Oder 
 <see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
Oder 
Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="callConvention">Das Objekt, das die Regeln für die Reihenfolge und das Layout von Argumenten, die Art der Übergabe des Rückgabewerts, die für Argumente zu verwendenden Register und die Art der Stapelbereinigung angibt.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das Anzahl, Reihenfolge und Typ der Parameter des abzurufenden Konstruktors darstellt.  
  
Oder 
Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen eines Konstruktors, der keine Parameter akzeptiert.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht einen Konstruktor, dessen Parameter den angegebenen Argumenttypen und -modifizierern entsprechen, und berücksichtigt dabei die angegebenen Bindungseinschränkungen und die angegebene Aufrufkonvention.</summary>
        <returns>Ein Objekt, das den Konstruktor darstellt, der den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standard Binder verarbeitet zwar nicht <xref:System.Reflection.ParameterModifier> (den `modifiers`-Parameter), Sie können jedoch die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType>-Klasse verwenden, um einen benutzerdefinierten Binder zu schreiben, der `modifiers`verarbeitet. `ParameterModifier` wird nur beim Aufrufen über COM-Interop verwendet, und nur Parameter, die als Verweis übermittelt werden, werden behandelt.  
  
 Wenn keine genaue Entsprechung vorhanden ist, versucht der `binder`, die im `types` Array angegebenen Parametertypen umzuleiten, um eine Entsprechung auszuwählen. Wenn die `binder` eine Entsprechung nicht auswählen kann, wird `null` zurückgegeben.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Konstruktoren in die Suche eingeschlossen werden sollen:  
  
-   Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` an, um öffentliche Konstruktoren in die Suche einzubeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` an, um nicht öffentliche Konstruktoren (d. h. private, interne und geschützte Konstruktoren) in die Suche einzubeziehen.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Um mithilfe dieser Methode den Klasseninitialisierer (statischer Konstruktor) zu erhalten, müssen &#124; Sie <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> angeben (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>). Sie können den Klasseninitialisierer auch mit der <xref:System.Type.TypeInitializer%2A>-Eigenschaft erhalten.  
  
 In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.  
  
|Mitgliedstyp|statischen|Nicht statisch|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld wird immer nach Name und Signatur ausgeblendet.|  
|Ereignis|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.|  
|Der Typ "Typ"|Nein|Nein|  
|Eigenschaft|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
  
1.  "Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen. Dies ist ein binärer Vergleich.  
  
2.  Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet. Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
> [!NOTE]
>  Sie können Parameter nicht weglassen, wenn Sie Konstruktoren und Methoden suchen. Beim Aufrufen von können Sie nur Parameter weglassen.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.ConstructorInfo> mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden. Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese Methode immer `null`zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Typ `MyClass1`abgerufen, das <xref:System.Reflection.ConstructorInfo> Objekt abgerufen, das mit den angegebenen Bindungsflags übereinstimmt, und die Konstruktorsignatur wird angezeigt.  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> ist <see langword="null" />  
  
Oder 
Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.  
  
Oder 
 <paramref name="modifiers" /> ist mehrdimensional.  
  
Oder 
 <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetConstructorImpl (bindingAttr As BindingFlags, binder As Binder, callConvention As CallingConventions, types As Type(), modifiers As ParameterModifier()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.  
  
Oder 
<see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
Oder 
Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="callConvention">Das Objekt, das die Regeln für die Reihenfolge und das Layout von Argumenten, die Art der Übergabe des Rückgabewerts, die für Argumente zu verwendenden Register und die Art der Stapelbereinigung angibt.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das Anzahl, Reihenfolge und Typ der Parameter des abzurufenden Konstruktors darstellt.  
  
Oder 
Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen eines Konstruktors, der keine Parameter akzeptiert.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse, unter Verwendung der angegebenen Bindungseinschränkungen und der angegebenen Aufrufkonvention, nach einem Konstruktor, dessen Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein <see cref="T:System.Reflection.ConstructorInfo" />-Objekt, das den Konstruktor darstellt, der den angegebenen Anforderungen entspricht, oder <see langword="null" />, wenn kein entsprechender Konstruktor gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standard Binder verarbeitet zwar nicht <xref:System.Reflection.ParameterModifier> (den `modifiers`-Parameter), Sie können jedoch die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType>-Klasse verwenden, um einen benutzerdefinierten Binder zu schreiben, der `modifiers`verarbeitet. `ParameterModifier` wird nur beim Aufrufen über COM-Interop verwendet, und nur Parameter, die als Verweis übermittelt werden, werden behandelt.  
  
 Wenn keine genaue Entsprechung vorhanden ist, versucht der `binder`, die im `types` Array angegebenen Parametertypen umzuleiten, um eine Entsprechung auszuwählen. Wenn die `binder` eine Entsprechung nicht auswählen kann, wird `null` zurückgegeben.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Konstruktoren in die Suche eingeschlossen werden sollen:  
  
-   Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` an, um öffentliche Konstruktoren in die Suche einzubeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` an, um nicht öffentliche Konstruktoren (d. h. private, interne und geschützte Konstruktoren) in die Suche einzubeziehen.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Diese Methode implementiert <xref:System.Type.GetConstructor%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="types" /> ist <see langword="null" />  
  
Oder 
Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.  
  
Oder 
 <paramref name="modifiers" /> ist mehrdimensional.  
  
Oder 
 <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</exception>
        <exception cref="T:System.NotSupportedException">Der aktuelle Typ ist ein <see cref="T:System.Reflection.Emit.TypeBuilder" /> oder <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die Konstruktoren des aktuellen <see cref="T:System.Type" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]&#xA;override this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle öffentlichen Konstruktoren zurück, die für den aktuellen <see cref="T:System.Type" /> definiert sind.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.ConstructorInfo" /> -Objekten, die alle für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Instanzkonstruktoren mit Ausnahme des Typinitialisierers (statischer Konstruktor) darstellen. Wenn für den aktuellen <see cref="T:System.Type" /> keine öffentlichen Instanzkonstruktoren definiert sind oder der aktuelle <see cref="T:System.Type" /> einen Typparameter einer generischen Typ- oder Methodendefinition darstellt, wird ein leeres Array vom Typ <see cref="T:System.Reflection.ConstructorInfo" /> zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetConstructors%2A> Methode gibt keine Konstruktoren in einer bestimmten Reihenfolge zurück, z. b. in der Reihenfolge der Deklaration Der Code darf nicht von der Reihenfolge abhängen, in der Konstruktoren zurückgegeben werden, da diese Reihenfolge variiert.  
  
 In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.  
  
|Mitgliedstyp|statischen|Nicht statisch|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld wird immer nach Name und Signatur ausgeblendet.|  
|Ereignis|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.|  
|Der Typ "Typ"|Nein|Nein|  
|Eigenschaft|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
  
1.  "Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen. Dies ist ein binärer Vergleich.  
  
2.  Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet. Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Diese Methoden Überladung ruft die <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29>-Methoden Überladung &#124; mit <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> in Visual Basic) auf. Klasseninitialisierer (statischer Konstruktor) werden nicht gefunden. Um Klasseninitialisierer zu finden, verwenden Sie eine Überladung, die <xref:System.Reflection.BindingFlags>&#124; annimmt, und geben Sie <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) an. Sie können den Klasseninitialisierer auch mit der <xref:System.Type.TypeInitializer%2A>-Eigenschaft erhalten.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.ConstructorInfo> Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden. Wenn z. b. Klassen `C<T>` einen Konstruktor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic) hat, wird beim Aufrufen von <xref:System.Type.GetConstructors%2A> auf `C<int>` ein <xref:System.Reflection.ConstructorInfo> zurück C# gegeben, der `C(int t1)` in (`Sub New(ByVal t1 As Integer)` in Visual Basic) darstellt.  
  
 Wenn die aktuelle <xref:System.Type> einen generischen Typparameter darstellt, gibt die <xref:System.Type.GetConstructors%2A>-Methode ein leeres Array zurück.  
  
   
  
## Examples  
 Dieses Beispiel zeigt die Ausgabe der <xref:System.Type.GetConstructors%2A> Überladung aus einer Klasse, die über zwei Instanzkonstruktoren und einen statischen Konstruktor verfügt.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 Die Ausgabe dieses Codes lautet wie folgt:  
  
 2  
  
 False  
  
 False  
  
 Da die <xref:System.Type.GetConstructors> Überladung nur <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> und <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>verwendet, wird der statische Konstruktor weder vom `for` Ausdruck gezählt noch durch `IsStatic`ausgewertet.  
  
 Um statische Konstruktoren zu finden, verwenden Sie die <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> Überladung, und übergeben Sie die Kombination (logischer `OR`) von <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, wie im folgenden Codebeispiel gezeigt:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 Nun lautet die Ausgabe wie folgt:  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.  
  
Oder 
<see cref="F:System.Reflection.BindingFlags.Default" />, um ein leeres Array zurückzugeben.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen <see cref="T:System.Type" /> die für den aktuellen <see langword="BindingFlags" /> definierten Konstruktoren.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.ConstructorInfo" />-Objekten, die sämtliche für den aktuellen <see cref="T:System.Type" /> definierten Konstruktoren, einschließlich eines ggf. definierten Typinitialisierers, darstellen, die den angegebenen Bindungseinschränkungen entsprechen. Gibt ein leeres Array vom Typ <see cref="T:System.Reflection.ConstructorInfo" /> zurück, wenn für den aktuellen <see cref="T:System.Type" /> keine Konstruktoren definiert sind, keiner der definierten Konstruktoren den Bindungseinschränkungen entspricht oder der aktuelle <see cref="T:System.Type" /> einen Typparameter einer generischen Typ- oder Methodendefinition darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
`bindingAttr` kann verwendet werden, um anzugeben, ob nur öffentliche Konstruktoren oder sowohl öffentliche als auch nicht öffentliche Konstruktoren zurückgegeben werden sollen.  
  
Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Konstruktoren in die Suche eingeschlossen werden sollen:  
  
- Geben Sie `BindingFlags.Static` zusammen mit `BindingFlags.NonPublic` an, um den Klasseninitialisierer (statischer Konstruktor) abzurufen. Sie können den Klasseninitialisierer auch mit der <xref:System.Type.TypeInitializer%2A>-Eigenschaft erhalten.

- Geben Sie `BindingFlags.Instance` zusammen mit einem oder beiden `BindingFlags.Public` und `BindingFlags.NonPublic` an, um Instanzkonstruktoren abzurufen.   
  
Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  

Die <xref:System.Type.GetConstructors%2A> Methode gibt keine Konstruktoren in einer bestimmten Reihenfolge zurück, z. b. in der Reihenfolge der Deklaration Der Code darf nicht von der Reihenfolge abhängen, in der Konstruktoren zurückgegeben werden, da diese Reihenfolge variiert.  

Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.ConstructorInfo> Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden. Wenn z. b. Klassen `C<T>` einen Konstruktor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic) hat, wird beim Aufrufen von <xref:System.Type.GetConstructors%2A> auf `C<int>` ein <xref:System.Reflection.ConstructorInfo> zurück C# gegeben, der `C(int t1)` in (`Sub New(ByVal t1 As Integer)` in Visual Basic) darstellt.  
  
Wenn die aktuelle <xref:System.Type> einen generischen Typparameter darstellt, gibt die <xref:System.Type.GetConstructors%2A>-Methode ein leeres Array zurück.  
  
## Examples  

Dieses Beispiel zeigt die Ausgabe der <xref:System.Type.GetConstructors> Überladung aus einer Klasse, die über zwei Instanzkonstruktoren und einen statischen Konstruktor verfügt.  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 Die Ausgabe dieses Codes lautet wie folgt:  
  
 2  
  
 False  
  
 False  
  
 Da die <xref:System.Type.GetConstructors%2A> Überladung nur <xref:System.Reflection.BindingFlags.Public> und <xref:System.Reflection.BindingFlags.Instance>verwendet, wird der statische Konstruktor weder vom `for` Ausdruck gezählt noch durch `IsStatic`ausgewertet.  
  
 Wenn Sie statische Konstruktoren suchen möchten, verwenden Sie die <xref:System.Type.GetConstructors%2A> Überladung, und übergeben Sie die Kombination (logisches OR) von <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, wie im folgenden Codebeispiel gezeigt:  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 Nun lautet die Ausgabe wie folgt:  
  
 3  
  
 False  
  
 True  
  
 False  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetDefaultMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Sucht nach den für den aktuellen <see cref="T:System.Type" /> definierten Membern, deren <see cref="T:System.Reflection.DefaultMemberAttribute" /> festgelegt ist.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die alle Standardmember des aktuellen <see cref="T:System.Type" /> darstellen.  
  
Oder 
Ein leeres Array vom <see cref="T:System.Reflection.MemberInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine Standardmember besitzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetDefaultMembers%2A>-Methode gibt keine Member in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklarations Reihenfolge. Der Code darf nicht von der Reihenfolge abhängen, in der Elemente zurückgegeben werden, da diese Reihenfolge variiert.  
  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.  
  
 Member enthalten Eigenschaften, Methoden, Felder, Ereignisse usw.  
  
 In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.  
  
|Mitgliedstyp|statischen|Nicht statisch|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld wird immer nach Name und Signatur ausgeblendet.|  
|Ereignis|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.|  
|Der Typ "Typ"|Nein|Nein|  
|Eigenschaft|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
  
1.  "Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen. Dies ist ein binärer Vergleich.  
  
2.  Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet. Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MemberInfo> Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden. Wenn z. b. Klassen `C<T>` eine Eigenschaft `P` haben, die `T`zurückgibt, gibt der Aufruf von C# <xref:System.Type.GetDefaultMembers%2A> auf `C<int>` `int P` in (`Property P As Integer` in Visual Basic) zurück.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Member der Klassen Einschränkung oder die Member von <xref:System.Object>, wenn keine Klassen Einschränkung vorhanden ist.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Standardelement Informationen von `MyClass` abgerufen und die Standardmember angezeigt.  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Type" Usage="type.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt beim Überschreiben in einer abgeleiteten Klasse den <see cref="T:System.Type" /> des Objekts zurück, das der aktuelle Array-, Zeiger- oder Verweistyp einschließt bzw. auf das er verweist.</summary>
        <returns>Der <see cref="T:System.Type" /> des eingeschlossenen Objekts bzw. des Objekts, auf das durch den aktuellen Array-, Zeiger- oder Verweistyp verwiesen wird, oder <see langword="null" />, wenn der aktuelle <see cref="T:System.Type" /> kein Array oder Zeiger ist, nicht als Verweis übergeben wurde oder einen generischen Typ oder Typparameter einer generischen Typ- oder Methodendefinition darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt `null` für die <xref:System.Array>-Klasse zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `GetElementType`-Methode veranschaulicht.  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumName : obj -&gt; string&#xA;override this.GetEnumName : obj -&gt; string" Usage="type.GetEnumName value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, dessen Name abgerufen werden soll.</param>
        <summary>Gibt den Namen der Konstanten für den aktuellen Enumerationstyp zurück, die den angegebenen Wert aufweist.</summary>
        <returns>Der Name des Members des aktuellen Enumerationstyps, der über den angegebenen Wert verfügt, oder<see langword="null" />, wenn keine solche Konstante gefunden wird.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Der aktuelle Typ ist keine Enumeration.  
  
Oder 
 <paramref name="value" /> ist nicht vom aktuellen Typ und weist auch nicht den gleichen zugrunde liegenden Typ wie der aktuelle Typ auf.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumNames : unit -&gt; string[]&#xA;override this.GetEnumNames : unit -&gt; string[]" Usage="type.GetEnumNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die Namen der Member des aktuellen Enumerationstyps zurück.</summary>
        <returns>Ein Array, das die Namen der Member der Enumeration enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Elemente des Rückgabewert Arrays werden nach den binären Werten (d. h. den nicht signierten Werten) der Enumerationskonstanten sortiert. Wenn das Array Enumerationskonstanten mit dem gleichen Wert enthält, ist die Reihenfolge ihrer entsprechenden Namen nicht angegeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der aktuelle Typ ist keine Enumeration.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumUnderlyingType : unit -&gt; Type&#xA;override this.GetEnumUnderlyingType : unit -&gt; Type" Usage="type.GetEnumUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den zugrunde liegenden Typ des aktuellen Enumerationstyps zurück.</summary>
        <returns>Der zugrunde liegende Typ der aktuellen Enumeration.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig ist der zugrunde liegende Typ einer Enumeration in C# und Visual Basic <xref:System.Int32>. Andere ganzzahlige Typen können angegeben werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der aktuelle Typ ist keine Enumeration.  
  
 Oder  
  
 Der Enumerationstyp ist ungültig, da er mehr als ein Instanzfeld enthält.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumValues : unit -&gt; Array&#xA;override this.GetEnumValues : unit -&gt; Array" Usage="type.GetEnumValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Array mit den Werten der Konstanten im aktuellen Enumerationstyp zurück.</summary>
        <returns>Ein Array, das die Werte enthält. Die Elemente des Arrays sind nach den Binärwerten (den Werten ohne Vorzeichen) der Enumerationskonstanten sortiert.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Der aktuelle Typ ist keine Enumeration.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft ein bestimmtes Ereignis ab, das vom aktuellen <see cref="T:System.Type" /> deklariert oder geerbt wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.EventInfo GetEvent(string name) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string -&gt; System.Reflection.EventInfo&#xA;override this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen eines vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten Ereignisses enthält.</param>
        <summary>Gibt das <see cref="T:System.Reflection.EventInfo" />-Objekt zurück, das das angegebene öffentliche Ereignis darstellt.</summary>
        <returns>Das Objekt, das das angegebene, vom aktuellen <see cref="T:System.Type" /> deklarierte oder geerbte öffentliche Ereignis darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Ereignis gilt als öffentlich für Reflektion, wenn es mindestens eine öffentliche Methode oder einen öffentlichen Accessor hat. Andernfalls wird das Ereignis als privat angesehen, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> verwenden (in Visual Basic die Werte mit `Or`), um es zu erhalten.  
  
 Bei der Suche nach `name` wird die Groß-/Kleinschreibung beachtet. Die Suche umfasst Ereignisse für öffentliche statische Ereignisse und öffentliche Instanzen.  
  
 In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.  
  
|Mitgliedstyp|statischen|Nicht statisch|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld wird immer nach Name und Signatur ausgeblendet.|  
|Ereignis|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.|  
|Der Typ "Typ"|Nein|Nein|  
|Eigenschaft|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
  
1.  "Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen. Dies ist ein binärer Vergleich.  
  
2.  Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet. Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.EventInfo> mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Ereignisse der Klassen Einschränkung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.Reflection.EventInfo>-Objekt erstellt und das-Ereignis für eine Schaltflächen Klasse für das angegebene Ereignis abgerufen.  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="type.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen eines vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten Ereignisses enthält.</param>
        <param name="bindingAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.  
  
Oder 
 <see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Gibt beim Überschreiben in einer abgeleiteten Klasse das <see cref="T:System.Reflection.EventInfo" />-Objekt zurück, das das angegebene Ereignis unter Verwendung der angegebenen Bindungseinschränkungen darstellt.</summary>
        <returns>Das Objekt, das das angegebene vom aktuellen <see cref="T:System.Type" /> deklarierte oder geerbte Ereignis darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Ereignisse in die Suche eingeschlossen werden sollen:  
  
-   Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` an, um öffentliche Ereignisse in die Suche einzubeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` an, um nicht öffentliche Ereignisse (d. h. private, interne und geschützte Ereignisse) in der Suche einzubeziehen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` an, um `public` und `protected` statische Elemente in der Hierarchie einzuschließen. `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags>-Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:  
  
-   `BindingFlags.IgnoreCase`, die Groß-/Kleinschreibung `name`zu ignorieren.  
  
-   `BindingFlags.DeclaredOnly`, um nur die Ereignisse zu durchsuchen, die auf dem <xref:System.Type>deklariert sind, nicht Ereignisse, die einfach geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Ein Ereignis gilt als öffentlich für Reflektion, wenn es mindestens eine öffentliche Methode oder einen öffentlichen Accessor hat. Andernfalls wird das Ereignis als privat angesehen, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> verwenden (in Visual Basic die Werte mit `Or`), um es zu erhalten.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.EventInfo> mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Ereignisse der Klassen Einschränkung.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29>-Methode verwendet, um einen Typ nach einem öffentlichen oder nicht öffentlichen Ereignis namens "Click" zu suchen, das nicht `static` (`Shared` in Visual Basic).  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten Ereignisse ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : unit -&gt; System.Reflection.EventInfo[]&#xA;override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt sämtliche vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten öffentlichen Ereignisse zurück.</summary>
        <returns>Gibt ein Array von <see cref="T:System.Reflection.EventInfo" />-Objekten zurück, die sämtliche vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten öffentlichen Ereignisse darstellen.  
  
Oder 
Ein leeres Array vom <see cref="T:System.Reflection.EventInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine öffentlichen Ereignisse besitzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Ereignis gilt als öffentlich für Reflektion, wenn es mindestens eine öffentliche Methode oder einen öffentlichen Accessor hat. Andernfalls wird das Ereignis als privat angesehen, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> verwenden (in Visual Basic die Werte mit `Or`), um es zu erhalten.  
  
 Die <xref:System.Type.GetEvents%2A>-Methode gibt keine Ereignisse in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklarations Reihenfolge. Der Code darf nicht von der Reihenfolge abhängen, in der Ereignisse zurückgegeben werden, da diese Reihenfolge variiert.  
  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.  
  
 In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.  
  
|Mitgliedstyp|statischen|Nicht statisch|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld wird immer nach Name und Signatur ausgeblendet.|  
|Ereignis|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.|  
|Der Typ "Typ"|Nein|Nein|  
|Eigenschaft|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
  
1.  "Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen. Dies ist ein binärer Vergleich.  
  
2.  Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet. Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.EventInfo> Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Ereignisse der Klassen Einschränkung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array von <xref:System.Reflection.EventInfo> Objekten abgerufen, alle Ereignisse für eine `Button` Klasse abgerufen und die Ereignis Namen angezeigt. Um das Visual Basic Beispiel zu kompilieren, verwenden Sie die folgende Befehlszeile:  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.

Oder

 <see cref="F:System.Reflection.BindingFlags.Default" />, um ein leeres Array zurückzugeben.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen nach vom aktuellen <see cref="T:System.Type" /> definierten oder geerbten Ereignissen.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.EventInfo" />-Objekten, die sämtliche vom aktuellen <see cref="T:System.Type" /> deklarierten oder geerbten Ereignisse darstellen, die den angegebenen Bindungseinschränkungen entsprechen.  
  
Oder 
Ein leeres Array vom <see cref="T:System.Reflection.EventInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine Ereignisse besitzt oder keines der Ereignisse den Bindungseinschränkungen entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetEvents%2A>-Methode gibt keine Ereignisse in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklarations Reihenfolge. Der Code darf nicht von der Reihenfolge abhängen, in der Ereignisse zurückgegeben werden, da diese Reihenfolge variiert.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Ereignisse in die Suche eingeschlossen werden sollen:  
  
-   Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` an, um öffentliche Ereignisse in die Suche einzubeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` an, um nicht öffentliche Ereignisse (d. h. private, interne und geschützte Ereignisse) in der Suche einzubeziehen. Es werden nur geschützte und interne Ereignisse für Basisklassen zurückgegeben. Private Ereignisse für Basisklassen werden nicht zurückgegeben.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` an, um `public` und `protected` statische Elemente in der Hierarchie einzuschließen. `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags>-Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:  
  
-   `BindingFlags.DeclaredOnly`, um nur die Ereignisse zu durchsuchen, die auf dem <xref:System.Type>deklariert sind, nicht Ereignisse, die einfach geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Ein Ereignis gilt als öffentlich für Reflektion, wenn es mindestens eine öffentliche Methode oder einen öffentlichen Accessor hat. Andernfalls wird das Ereignis als privat angesehen, und Sie müssen <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> verwenden (in Visual Basic die Werte mit `Or`), um es zu erhalten.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.EventInfo> Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Ereignisse der Klassen Einschränkung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array von <xref:System.Reflection.EventInfo> Objekten abgerufen, die den angegebenen Bindungsflags entsprechen, alle Ereignisse für eine `Button` Klasse abrufen und die Ereignis Namen anzeigen. Um das Visual Basic Beispiel zu kompilieren, verwenden Sie die folgende Befehlszeile:  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft ein bestimmtes Feld des aktuellen <see cref="T:System.Type" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo GetField(string name) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::FieldInfo ^ GetField(System::String ^ name);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetField : string -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen des abzurufenden Datenfelds enthält.</param>
        <summary>Sucht das öffentliche Feld mit dem angegebenen Namen.</summary>
        <returns>Ein Objekt, das das öffentliche Feld mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der Suche nach `name` wird die Groß-/Kleinschreibung beachtet. Die Suche umfasst öffentliche, statische und öffentliche Instanzfelder.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.FieldInfo> mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Felder der Klassen Einschränkung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das `Type`-Objekt für die angegebene Klasse abgerufen, das <xref:System.Reflection.FieldInfo>-Objekt für das Feld abgerufen und der Wert des Felds angezeigt.  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <exception cref="T:System.NotSupportedException">Bei diesem <see cref="T:System.Type" />-Objekt handelt es sich um einen <see cref="T:System.Reflection.Emit.TypeBuilder" />, dessen <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" />-Methode noch nicht aufgerufen wurde.</exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="type.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen des abzurufenden Datenfelds enthält.</param>
        <param name="bindingAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.  
  
Oder 
 <see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Sucht das angegebene Feld unter Verwendung der angegebenen Bindungseinschränkungen.</summary>
        <returns>Ein Objekt, das das Feld darstellt, das den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.  
  
|Mitgliedstyp|statischen|Nicht statisch|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld wird immer nach Name und Signatur ausgeblendet.|  
|Ereignis|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.|  
|Der Typ "Typ"|Nein|Nein|  
|Eigenschaft|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
  
1.  "Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen. Dies ist ein binärer Vergleich.  
  
2.  Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet. Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Felder in die Suche eingeschlossen werden sollen:  
  
-   Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` an, um öffentliche Felder in die Suche einzubeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` an, um nicht öffentliche Felder (d. h. private, interne und geschützte Felder) in die Suche einzubeziehen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` an, um `public` und `protected` statische Elemente in der Hierarchie einzuschließen. `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags>-Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:  
  
-   `BindingFlags.IgnoreCase`, die Groß-/Kleinschreibung `name`zu ignorieren.  
  
-   `BindingFlags.DeclaredOnly`, um nur die Felder zu durchsuchen, die auf dem <xref:System.Type>deklariert sind, nicht Felder, die einfach geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.FieldInfo> mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Felder der Klassen Einschränkung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das `Type`-Objekt für die angegebene Klasse abgerufen, das <xref:System.Reflection.FieldInfo>-Objekt für das Feld abgerufen, das mit den angegebenen Bindungsflags übereinstimmt, und der Wert des Felds wird angezeigt.  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die Felder des aktuellen <see cref="T:System.Type" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.FieldInfo[] GetFields() cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetFields : unit -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt sämtliche öffentlichen Felder des aktuellen <see cref="T:System.Type" /> zurück.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.FieldInfo" />-Objekten, die alle für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Felder darstellen.  
  
Oder 
Ein leeres Array vom <see cref="T:System.Reflection.FieldInfo" />-Typ, wenn für den aktuellen <see cref="T:System.Type" /> keine öffentlichen Felder definiert sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetFields%2A>-Methode gibt keine Felder in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklarations Reihenfolge. Der Code darf nicht von der Reihenfolge abhängen, in der Felder zurückgegeben werden, da diese Reihenfolge variiert.  
  
 In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.  
  
|Mitgliedstyp|statischen|Nicht statisch|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld wird immer nach Name und Signatur ausgeblendet.|  
|Ereignis|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.|  
|Der Typ "Typ"|Nein|Nein|  
|Eigenschaft|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
  
1.  "Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen. Dies ist ein binärer Vergleich.  
  
2.  Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet. Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.FieldInfo> Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die öffentlichen Felder der Klassen Einschränkung.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung der `GetFields()`-Methode.  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.

Oder

 <see cref="F:System.Reflection.BindingFlags.Default" />, um ein leeres Array zurückzugeben.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die für den aktuellen <see cref="T:System.Type" /> definierten Felder.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.FieldInfo" />-Objekten, die sämtliche für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Felder darstellen, die den angegebenen Bindungseinschränkungen entsprechen.  
  
Oder 
Ein leeres Array vom <see cref="T:System.Reflection.FieldInfo" />-Typ, wenn für den aktuellen <see cref="T:System.Type" /> keine Felder definiert sind oder keines der definierten Felder den Bindungseinschränkungen entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Damit die `GetFields(BindingFlags)` Überladung Eigenschaften Informationen erfolgreich abrufen kann, muss das `bindingAttr`-Argument mindestens eine <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> und <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>enthalten, zusammen mit mindestens einer <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> und <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>. 

Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Felder in die Suche eingeschlossen werden sollen:  
  
- Geben Sie `BindingFlags.Instance` an, um Instanzmethoden einzubeziehen. 

- Geben Sie `BindingFlags.Static` an, um statische Methoden einzubeziehen. 
    
- Geben Sie `BindingFlags.Public` an, um öffentliche Felder in die Suche einzubeziehen.  
  
- Geben Sie `BindingFlags.NonPublic` an, um nicht öffentliche Felder (d. h. private, interne und geschützte Felder) in die Suche einzubeziehen. Es werden nur geschützte und interne Felder für Basisklassen zurückgegeben. private Felder für Basisklassen werden nicht zurückgegeben.  
  
- Geben Sie `BindingFlags.FlattenHierarchy` an, um `public` und `protected` statische Elemente in der Hierarchie einzuschließen. `private` statische Member in geerbten Klassen sind nicht enthalten.  

- Geben Sie `BindingFlags.Default` allein an, um ein leeres <xref:System.Reflection.PropertyInfo> Array zurückzugeben.

Die folgenden <xref:System.Reflection.BindingFlags>-Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:  
  
- `BindingFlags.DeclaredOnly`, um nur die Felder zu durchsuchen, die auf dem <xref:System.Type>deklariert sind, nicht Felder, die einfach geerbt wurden.  
  
Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
Die <xref:System.Type.GetFields%2A>-Methode gibt keine Felder in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklarations Reihenfolge. Der Code darf nicht von der Reihenfolge abhängen, in der Felder zurückgegeben werden, da diese Reihenfolge variiert.  

 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.FieldInfo> Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die öffentlichen Felder der Klassen Einschränkung.  
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung der `GetFields(BindingFlags)`-Methode.  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="type.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Array von <see cref="T:System.Type" />-Objekten zurück, die die Typargumente eines geschlossenen generischen Typs oder die Typparameter einer generischen Typdefinition darstellen.</summary>
        <returns>Ein Array von <see cref="T:System.Type" />-Objekten, die die Typargumente eines generischen Typs darstellen. Gibt ein leeres Array zurück, wenn der aktuelle Typ kein generischer Typ ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Array Elemente werden in der Reihenfolge zurückgegeben, in der Sie in der Liste der Typargumente für den generischen Typ angezeigt werden.  
  
-   Wenn es sich bei dem aktuellen Typ um einen geschlossenen konstruierten Typ handelt (d. h., die <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft gibt `false`zurück), enthält das von der <xref:System.Type.GetGenericArguments%2A>-Methode zurückgegebene Array die Typen, die den generischen Typparametern der generischen Typdefinition zugewiesen wurden.  
  
-   Wenn der aktuelle Typ eine generische Typdefinition ist, enthält das Array die Typparameter.  
  
-   Wenn es sich bei dem aktuellen Typ um einen geöffneten konstruierten Typ handelt (d. h., die <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft gibt `true`) zurück, in denen bestimmte Typen nicht allen Typparametern und Typparametern von einschließenden generischen Typen oder Methoden zugewiesen wurden, enthält das Array sowohl Typen als auch Typparameter. Verwenden Sie die <xref:System.Type.IsGenericParameter%2A>-Eigenschaft, um sie voneinander zu informieren. Eine Demonstration dieses Szenarios finden Sie im Codebeispiel für die <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft.  
  
 Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Type.GetGenericArguments%2A>-Methode verwendet, um die Typargumente eines konstruierten Typs und die Typparameter der generischen Typdefinition anzuzeigen.  
  
 Dieses Codebeispiel ist Teil eines größeren Beispiels, das für die <xref:System.Type.IsGenericTypeDefinition%2A>-Eigenschaft bereitgestellt wird. Weitere Informationen finden Sie unter Beispielausgabe.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt. Abgeleitete Klassen müssen eine Implementation angeben.</exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/reflection-and-generic-types">Reflektion und generische Typen</related>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection">Gewusst wie: Untersuchen und Instanziieren von generischen Typen mit Reflektion</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericParameterConstraints : unit -&gt; Type[]&#xA;override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="type.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein Array von <see cref="T:System.Type" />-Objekten zurück, die die Einschränkungen für den aktuellen generischen Typparameter darstellen.</summary>
        <returns>Ein Array von <see cref="T:System.Type" />-Objekten, die die Einschränkungen für den aktuellen generischen Typparameter darstellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jede Einschränkung für einen generischen Typparameter wird als <xref:System.Type> Objekt ausgedrückt. Verwenden Sie die <xref:System.Type.IsClass%2A>-Eigenschaft, um zu bestimmen, ob eine Einschränkung die Basisklassen Einschränkung ist. Wenn die Eigenschaft `false`zurückgibt, ist die Einschränkung eine Schnittstellen Einschränkung. Wenn ein Typparameter keine Klassen Einschränkung und keine Schnittstellen Einschränkungen aufweist, wird ein leeres Array zurückgegeben.  
  
 Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein generischer Typ `Test` mit zwei Typparametern definiert, die unterschiedliche Einschränkungen aufweisen. Wenn das Programm ausgeführt wird, werden die Einschränkungen mithilfe der <xref:System.Type.GenericParameterAttributes%2A>-Eigenschaft und der <xref:System.Type.GetGenericParameterConstraints%2A>-Methode untersucht.  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Das aktuelle <see cref="T:System.Type" />-Objekt ist kein generischer Typparameter. Das bedeutet, dass die <see cref="P:System.Type.IsGenericParameter" />-Eigenschaft <see langword="false" /> zurückgibt.</exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection">Gewusst wie: Untersuchen und Instanziieren von generischen Typen mit Reflektion</related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public abstract Type GetGenericTypeDefinition ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetGenericTypeDefinition () As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetGenericTypeDefinition();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type&#xA;override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das eine generische Typdefinition darstellt, aus der der aktuelle generische Typ konstruiert werden kann.</summary>
        <returns>Ein <see cref="T:System.Type" />-Objekt, das einen generischen Typ darstellt, aus dem der aktuelle Typ konstruiert werden kann.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine generische Typdefinition ist eine Vorlage, von der andere Typen erstellt werden können. Beispielsweise können Sie aus der generischen Typdefinition `G<T>` ( C# ausgedrückt in Syntax, `G(Of T)` in Visual Basic oder C++`generic <typename T> ref class G` in) den Typ `G<int>` (`G(Of Integer)` in Visual Basic) erstellen und instanziieren. Bei einem <xref:System.Type> Objekt, das diesen konstruierten Typ darstellt, gibt die <xref:System.Type.GetGenericTypeDefinition%2A>-Methode die generische Typdefinition zurück.  
  
 Wenn zwei konstruierte Typen aus der gleichen generischen Typdefinition erstellt werden, wobei die gleichen Typargumente verwendet werden, gibt die <xref:System.Type.GetGenericTypeDefinition%2A>-Methode für beide Typen dasselbe <xref:System.Type>-Objekt zurück.  
  
 Wenn Sie die <xref:System.Type.GetGenericTypeDefinition%2A>-Methode für ein <xref:System.Type> Objekt aufzurufen, das bereits eine generische Typdefinition darstellt, wird die aktuelle <xref:System.Type>zurückgegeben.  
  
> [!IMPORTANT]
>  Ein Array generischer Typen ist nicht selbst generisch. Im C# Code `A<int>[] v;` oder im Visual Basic Code `Dim v() As A(Of Integer)`ist der Typ der Variablen `v` nicht generisch. Verwenden Sie <xref:System.Type.IsGenericType%2A>, um zu bestimmen, ob ein Typ generisch ist, bevor Sie <xref:System.Type.GetGenericTypeDefinition%2A>aufrufen  
  
 Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz eines konstruierten Typs mithilfe der Erstellung der normalen Instanz erstellt. Anschließend werden die Methoden <xref:System.Type.GetType%2A> und <xref:System.Type.GetGenericTypeDefinition%2A> verwendet, um den konstruierten Typ und die generische Typdefinition abzurufen. In diesem Beispiel wird der generische <xref:System.Collections.Generic.Dictionary%602>-Typ verwendet. der konstruierte Typ stellt eine <xref:System.Collections.Generic.Dictionary%602> von `Test` Objekten mit Zeichen folgen Schlüsseln dar.  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Typ ist kein generischer Typ.  Das heißt, <see cref="P:System.Type.IsGenericType" /> gibt <see langword="false" /> zurück.</exception>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt. Abgeleitete Klassen müssen eine Implementation angeben.</exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/reflection-and-generic-types">Reflektion und generische Typen</related>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection">Gewusst wie: Untersuchen und Instanziieren von generischen Typen mit Reflektion</related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="type.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für diese Instanz zurück.</summary>
        <returns>Der Hashcode für diese Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode überschreibt <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Hashcode der `System.Windows.Forms.Button`-Klasse angezeigt.  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft eine bestimmte Schnittstelle ab, die vom aktuellen <see cref="T:System.Type" /> implementiert oder geerbt wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetInterface(string name) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetInterface(System::String ^ name);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string -&gt; Type&#xA;override this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Schnittstelle enthält. Bei generischen Schnittstellen ist dies der ergänzte Name.</param>
        <summary>Sucht die Schnittstelle mit dem angegebenen Namen.</summary>
        <returns>Ein Objekt, das die vom aktuellen <see cref="T:System.Type" /> implementierte oder geerbte Schnittstelle mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der Suche nach `name` wird die Groß-/Kleinschreibung beachtet.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Type> mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Schnittstellen Einschränkungen und alle Schnittstellen, die von Klassen-oder Schnittstellen Einschränkungen geerbt werden.  
  
> [!NOTE]
>  Bei generischen Schnittstellen ist der `name` Parameter der ergänzte Name und endet mit einem großen Akzent (\`) und der Anzahl der Typparameter. Dies gilt sowohl für generische Schnittstellendefinitionen als auch für konstruierte generische Schnittstellen. Um z. b. nach `IExample<T>` (`IExample(Of T)` in Visual Basic) oder `IExample<string>` (`IExample(Of String)` Visual Basic) zu suchen, suchen Sie nach ``"IExample`1"``.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Type.GetInterface%28System.String%29>-Methode verwendet, um die <xref:System.Collections.Hashtable>-Klasse nach der <xref:System.Runtime.Serialization.IDeserializationCallback>-Schnittstelle zu durchsuchen und die Methoden der-Schnittstelle aufführt.  
  
 Das Codebeispiel veranschaulicht auch die <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29>-Methoden Überladung und die <xref:System.Type.GetInterfaceMap%2A>-Methode.  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Der aktuelle <see cref="T:System.Type" /> stellt einen Typ dar, der dieselbe generische Schnittstelle mit unterschiedlichen Typargumenten implementiert.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string * bool -&gt; Type" Usage="type.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Schnittstelle enthält. Bei generischen Schnittstellen ist dies der ergänzte Name.</param>
        <param name="ignoreCase"><see langword="true" />, wenn die Groß-/Kleinschreibung dieses Teils von <paramref name="name" />, der den einfachen Schnittstellennamen angibt, ignoriert werden soll. (Bei der Namespaceangabe im Namen muss die Groß-/Kleinschreibung immer beachtet werden.)  
  
Oder 
 <see langword="false" />, wenn nach allen Teilen von <paramref name="name" /> mit Beachtung der Groß-/Kleinschreibung gesucht werden soll.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse die angegebene Schnittstelle, wobei festgelegt wird, ob bei der Suche des Schnittstellennamens die Groß-/Kleinschreibung beachtet wird.</summary>
        <returns>Ein Objekt, das die vom aktuellen <see cref="T:System.Type" /> implementierte oder geerbte Schnittstelle mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `ignoreCase`-Parameter gilt nur für den einfachen Schnittstellennamen, nicht für den-Namespace. Der Teil von `name`, der den Namespace angibt, muss die richtige Groß-/Kleinschreibung aufweisen, oder die Schnittstelle wird nicht gefunden. Die Zeichenfolge "System. ivergleichbare" findet z. b. die <xref:System.IComparable>-Schnittstelle, die Zeichenfolge "System. ivergleichbare" jedoch nicht.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Type> mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Schnittstellen Einschränkungen und alle Schnittstellen, die von Klassen-oder Schnittstellen Einschränkungen geerbt werden.  
  
> [!NOTE]
>  Bei generischen Schnittstellen ist der `name` Parameter der ergänzte Name und endet mit einem großen Akzent (\`) und der Anzahl der Typparameter. Dies gilt sowohl für generische Schnittstellendefinitionen als auch für konstruierte generische Schnittstellen. Wenn Sie z. b. nach `IExample<T>` suchen möchten (`IExample(Of T)` in Visual Basic) oder `IExample<string>` (`IExample(Of String)` in Visual Basic), suchen Sie nach `"IExample`1 "".  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29>-Methode verwendet, um bei der Suche nach der <xref:System.Collections.Hashtable>-Klasse für die <xref:System.Collections.IEnumerable>-Schnittstelle die Groß-/Kleinschreibung zu  
  
 Das Codebeispiel veranschaulicht auch die <xref:System.Type.GetInterface%28System.String%29>-Methoden Überladung und die <xref:System.Type.GetInterfaceMap%2A>-Methode.  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Der aktuelle <see cref="T:System.Type" /> stellt einen Typ dar, der dieselbe generische Schnittstelle mit unterschiedlichen Typargumenten implementiert.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping&#xA;override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="type.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="interfaceType">Der Schnittstellentyp, für den eine Zuordnung abgerufen werden soll.</param>
        <summary>Gibt eine Schnittstellenzuordnung für den angegebenen Schnittstellentyp zurück.</summary>
        <returns>Ein Objekt, das die Schnittstellenzuordnung für <paramref name="interfaceType" /> darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Schnittstellen Zuordnung gibt an, wie eine Schnittstelle den tatsächlichen Membern einer Klasse zugeordnet wird, die diese Schnittstelle implementiert.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, werden Typparameter durch die entsprechenden Typargumente in den Elementen des <xref:System.Reflection.InterfaceMapping> ersetzt, der von dieser Methode zurückgegeben wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Type.GetInterfaceMap%2A>-Methode aufgerufen, um zu bestimmen, wie die <xref:System.IFormatProvider>-Schnittstelle <xref:System.Globalization.CultureInfo> Methoden zugeordnet wird und wie die <xref:System.IAppDomainSetup> Schnittstelle <xref:System.AppDomainSetup> Eigenschaften zugeordnet wird. Beachten Sie Folgendes: da die <xref:System.IAppDomainSetup>-Schnittstelle eine Reihe von Eigenschaften definiert, enthält das zurückgegebene <xref:System.Reflection.InterfaceMapping>-Objekt separate <xref:System.Reflection.MethodInfo>-Objekte für Get-und Set-Accessoren einer Eigenschaft.  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="interfaceType" /> ist nicht durch den aktuellen Typ implementiert.  
  
Oder 
Das <paramref name="interfaceType" />-Argument verweist nicht auf eine Schnittstelle.  
  
Oder

Die aktuelle Instanz oder das <paramref name="interfaceType" />-Argument sind offene generische Typen, d.h. die <see cref="P:System.Type.ContainsGenericParameters" />-Eigenschaft gibt <see langword="true" /> zurück.

Oder


 <paramref name="interfaceType" /> ist eine generische Schnittstelle, und der aktuelle Typ ist ein Arraytyp.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="interfaceType" /> ist <see langword="null" /></exception>
        <exception cref="T:System.InvalidOperationException">Der aktuelle <see cref="T:System.Type" /> entspricht einem generischen Typparameter, d. h., <see cref="P:System.Type.IsGenericParameter" /> ist gleich <see langword="true" />.</exception>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt. Abgeleitete Klassen müssen eine Implementation angeben.</exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaces : unit -&gt; Type[]" Usage="type.GetInterfaces " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse sämtliche Schnittstellen ab, die vom aktuellen <see cref="T:System.Type" /> implementiert oder geerbt wurden.</summary>
        <returns>Ein Array von <see cref="T:System.Type" />-Objekten, die sämtliche vom aktuellen <see cref="T:System.Type" /> implementierten oder geerbten Schnittstellen darstellen.  
  
Oder 
Ein leeres Array vom <see cref="T:System.Type" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine Schnittstellen implementiert oder geerbt hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetInterfaces%2A>-Methode gibt keine Schnittstellen in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklaration. Der Code darf nicht von der Reihenfolge abhängen, in der Schnittstellen zurückgegeben werden, da diese Reihenfolge variiert.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Type> Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Schnittstellen Einschränkungen und alle Schnittstellen, die von Klassen-oder Schnittstellen Einschränkungen geerbt werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Typ der angegebenen Klasse abgerufen, und es werden alle Schnittstellen angezeigt, die vom Typ implementiert oder geerbt werden. Um das Visual Basic Beispiel zu kompilieren, verwenden Sie die folgenden Compilerbefehle:  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein statischer Initialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die angegebenen Member des aktuellen <see cref="T:System.Type" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen des abzurufenden öffentlichen Members enthält.</param>
        <summary>Sucht die öffentlichen Member mit dem angegebenen Namen.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die die öffentlichen Member mit dem angegebenen Namen darstellen, sofern gefunden, andernfalls ein leeres Array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der Suche nach `name` wird die Groß-/Kleinschreibung beachtet. Die Suche umfasst öffentliche statische und öffentliche Instanzmember.  
  
 Member enthalten Eigenschaften, Methoden, Felder, Ereignisse usw.  
  
 Die <xref:System.Type.GetMember%2A>-Methode gibt keine Member in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklarations Reihenfolge. Der Code darf nicht von der Reihenfolge abhängen, in der Elemente zurückgegeben werden, da diese Reihenfolge variiert.  
  
 Diese Methoden Überladung findet keine Klasseninitialisierer (statischer Konstruktor). Um Klasseninitialisierer zu finden, verwenden Sie eine Überladung, die <xref:System.Reflection.BindingFlags>&#124; annimmt, und geben Sie <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) an. Sie können den Klasseninitialisierer auch mit der <xref:System.Type.TypeInitializer%2A>-Eigenschaft erhalten.  
  
 In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.  
  
|Mitgliedstyp|statischen|Nicht statisch|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld wird immer nach Name und Signatur ausgeblendet.|  
|Ereignis|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.|  
|Der Typ "Typ"|Nein|Nein|  
|Eigenschaft|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
  
1.  "Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen. Dies ist ein binärer Vergleich.  
  
2.  Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet. Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MemberInfo> mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Member der Klassen Einschränkung oder die Member von <xref:System.Object>, wenn keine Klassen Einschränkung vorhanden ist.  
  
> [!NOTE]
>  Fügen Sie die Typargumente bei generischen Methoden nicht in `name`ein. Beispielsweise sucht der C# Code `GetMember("MyMethod<int>")` nach einem Member mit dem Textnamen "`MyMethod<int>`" und nicht nach einer Methode mit dem Namen `MyMethod`, die ein generisches Argument vom Typ `int`hat.  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle Member der `String`-Klasse angezeigt, die mit dem Buchstaben C beginnen.  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Member enthält.</param>
        <param name="bindingAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.  
  
Oder 
 <see cref="F:System.Reflection.BindingFlags.Default" />, um ein leeres Array zurückzugeben.</param>
        <summary>Sucht die angegebenen Member unter Verwendung der angegebenen Bindungseinschränkungen.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die die öffentlichen Member mit dem angegebenen Namen darstellen, sofern gefunden, andernfalls ein leeres Array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.  
  
 Member enthalten Eigenschaften, Methoden, Felder, Ereignisse usw.  
  
 Die <xref:System.Type.GetMember%2A>-Methode gibt keine Member in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklarations Reihenfolge. Der Code darf nicht von der Reihenfolge abhängen, in der Elemente zurückgegeben werden, da diese Reihenfolge variiert.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Elemente in die Suche eingeschlossen werden sollen:  
  
-   Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` an, um öffentliche Member in die Suche einzubeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` an, dass nicht öffentliche Member (d. h. private, interne und geschützte Member) in der Suche enthalten sein sollen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` an, um `public` und `protected` statische Elemente in der Hierarchie einzuschließen. `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags>-Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:  
  
-   `BindingFlags.IgnoreCase`, die Groß-/Kleinschreibung `name`zu ignorieren.  
  
-   `BindingFlags.DeclaredOnly`, um nur die Member zu durchsuchen, die auf dem <xref:System.Type>deklariert sind, nicht Elemente, die einfach geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Um den Klasseninitialisierer (statischer Konstruktor) mithilfe dieser Methoden Überladung zu erhalten, müssen Sie für `name`"statischer Konstruktor &#124; " angeben <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> und <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic) für `bindingAttr`angeben. Sie können den Klasseninitialisierer auch mit der <xref:System.Type.TypeInitializer%2A>-Eigenschaft erhalten.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MemberInfo> mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Member der Klassen Einschränkung oder die Member von <xref:System.Object>, wenn keine Klassen Einschränkung vorhanden ist.  
  
> [!NOTE]
>  Fügen Sie die Typargumente bei generischen Methoden nicht in `name`ein. Beispielsweise sucht der C# Code `GetMember("MyMethod<int>")` nach einem Member mit dem Textnamen "`MyMethod<int>`" und nicht nach einer Methode mit dem Namen `MyMethod`, die ein generisches Argument vom Typ `int`hat.  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle öffentlichen statischen Member der `myString`-Klasse angezeigt, die mit dem Buchstaben C beginnen.  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Member enthält.</param>
        <param name="type">Der zu suchende Wert.</param>
        <param name="bindingAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.  
  
Oder 
 <see cref="F:System.Reflection.BindingFlags.Default" />, um ein leeres Array zurückzugeben.</param>
        <summary>Sucht die angegebenen Member des angegebenen Membertyps unter Verwendung der angegebenen Bindungseinschränkungen.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die die öffentlichen Member mit dem angegebenen Namen darstellen, sofern gefunden, andernfalls ein leeres Array.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Member enthalten Eigenschaften, Methoden, Felder, Ereignisse usw.  
  
 Die <xref:System.Type.GetMember%2A>-Methode gibt keine Member in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklarations Reihenfolge. Der Code darf nicht von der Reihenfolge abhängen, in der Elemente zurückgegeben werden, da diese Reihenfolge variiert.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Elemente in die Suche eingeschlossen werden sollen:  
  
-   Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` an, um öffentliche Member in die Suche einzubeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` an, dass nicht öffentliche Member (d. h. private, interne und geschützte Member) in der Suche enthalten sein sollen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` an, um `public` und `protected` statische Elemente in der Hierarchie einzuschließen. `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags>-Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:  
  
-   `BindingFlags.IgnoreCase`, die Groß-/Kleinschreibung `name`zu ignorieren.  
  
-   `BindingFlags.DeclaredOnly`, um nur die Member zu durchsuchen, die auf dem <xref:System.Type>deklariert sind, nicht Elemente, die einfach geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Wenn Sie den Klasseninitialisierer (statischer Konstruktor) mithilfe dieser Methoden Überladung aufrufen möchten, müssen Sie "statischer Konstruktor" für `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> &#124; für `type`und <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> Visual Basic) für `bindingAttr`angeben. Sie können den Klasseninitialisierer auch mit der <xref:System.Type.TypeInitializer%2A>-Eigenschaft erhalten.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MemberInfo> mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Member der Klassen Einschränkung oder die Member von <xref:System.Object>, wenn keine Klassen Einschränkung vorhanden ist.  
  
> [!NOTE]
>  Fügen Sie die Typargumente bei generischen Methoden nicht in `name`ein. Beispielsweise sucht der C# Code `GetMember("MyMethod<int>")` nach einem Member mit dem Textnamen "`MyMethod<int>`" und nicht nach einer Methode mit dem Namen `MyMethod`, die ein generisches Argument vom Typ `int`hat.  
  
   
  
## Examples  
 Im folgenden Beispiel werden alle Methoden der `myString`-Klasse angezeigt, die mit dem Buchstaben C beginnen.  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <exception cref="T:System.NotSupportedException">Eine abgeleitete Klasse muss eine Implementierung bereitstellen.</exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die Member (Eigenschaften, Methoden, Felder, Ereignisse usw.) des aktuellen <see cref="T:System.Type" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MemberInfo[] GetMembers() cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt sämtliche öffentlichen Member des aktuellen <see cref="T:System.Type" /> zurück.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die sämtliche öffentlichen Member des aktuellen <see cref="T:System.Type" /> darstellen.  
  
Oder 
Ein leeres Array vom <see cref="T:System.Reflection.MemberInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine Standardmember besitzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Zu den Membern zählen Eigenschaften, Methoden, Konstruktoren, Felder, Ereignisse und Untertypen.
  
 Die <xref:System.Type.GetMembers%2A>-Methode gibt keine Member in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklarations Reihenfolge. Der Code darf nicht von der Reihenfolge abhängen, in der Elemente zurückgegeben werden, da diese Reihenfolge variiert.  
  
 Diese Methoden Überladung ruft die <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29>-Methoden Überladung &#124; mit &#124; <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in Visual Basic) auf. Klasseninitialisierer (statische Konstruktoren) werden nicht gefunden. Um Klasseninitialisierer zu suchen, müssen Sie die <xref:System.Type.GetMembers(System.Reflection.BindingFlags)> Überladung &#124; aufrufen und <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) angeben. Sie können den Klasseninitialisierer auch mit der <xref:System.Type.TypeInitializer%2A>-Eigenschaft erhalten.  
  
 In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.  
  
|Mitgliedstyp|statischen|Nicht statisch|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld wird immer nach Name und Signatur ausgeblendet.|  
|Ereignis|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.|  
|Der Typ "Typ"|Nein|Nein|  
|Eigenschaft|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
  
1.  "Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen. Dies ist ein binärer Vergleich.  
  
2.  Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet. Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MemberInfo> Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Member der Klassen Einschränkung oder die Member von <xref:System.Object>, wenn keine Klassen Einschränkung vorhanden ist. 
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Type.GetMembers>-Methoden Überladung verwendet wird, um Informationen über alle öffentlichen Member einer bestimmten Klasse zu sammeln.  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.  
  
Oder 
 <see cref="F:System.Reflection.BindingFlags.Default" />, um ein leeres Array zurückzugeben.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die für den aktuellen <see cref="T:System.Type" /> definierten Member.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.MemberInfo" />-Objekten, die sämtliche für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Member darstellen, die den angegebenen Bindungseinschränkungen entsprechen.  
  
Oder 
Ein leeres Array, wenn für den aktuellen <see cref="T:System.Type" /> keine Member definiert sind oder keiner der definierten Member den Bindungseinschränkungen entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Zu den Membern zählen Eigenschaften, Methoden, Konstruktoren, Felder, Ereignisse und Untertypen.

Damit die `GetMethods(BindingFlags)` Überladung Methoden Informationen erfolgreich abrufen kann, muss das `bindingAttr`-Argument mindestens eine <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> und <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>enthalten, zusammen mit mindestens einer <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> und <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>. Die einzige Ausnahme ist ein Methoden Aufrufwert mit <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, der Element Informationen zu den Typen von Typen zurückgibt.

Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Elemente in die Suche eingeschlossen werden sollen: 

- Geben Sie `BindingFlags.Instance` an, um Instanzmethoden einzubeziehen. 

- Geben Sie `BindingFlags.Static` an, um statische Methoden einzubeziehen. 
  
- Geben Sie `BindingFlags.Public` an, um öffentliche Methoden in die Suche einzubeziehen.  
  
- Geben Sie `BindingFlags.NonPublic` an, um nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche einzubeziehen. Es werden nur geschützte und interne Methoden für Basisklassen zurückgegeben. Private Methoden für Basisklassen werden nicht zurückgegeben.  
  
- Geben Sie `BindingFlags.FlattenHierarchy` an, um `public` und `protected` statische Elemente in der Hierarchie einzuschließen. `private` statische Member in geerbten Klassen sind nicht enthalten.  

- Geben Sie `BindingFlags.Default` allein an, um ein leeres <xref:System.Reflection.MethodInfo> Array zurückzugeben.

Die folgenden <xref:System.Reflection.BindingFlags>-Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:  
  
- `BindingFlags.DeclaredOnly`, um nur die Member zu durchsuchen, die auf dem <xref:System.Type>deklariert sind, nicht Elemente, die einfach geerbt wurden.  
  
Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  

Die <xref:System.Type.GetMembers%2A>-Methode gibt keine Member in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklarations Reihenfolge. Der Code darf nicht von der Reihenfolge abhängen, in der Elemente zurückgegeben werden, da diese Reihenfolge variiert.  

 Um den Klasseninitialisierer (statischer Konstruktor) mithilfe dieser Methoden Überladung zu erhalten, &#124; müssen Sie <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> angeben (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic). Sie können den Klasseninitialisierer auch mit der <xref:System.Type.TypeInitializer%2A>-Eigenschaft erhalten.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MemberInfo> Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Member der Klassen Einschränkung oder die Member von <xref:System.Object>, wenn keine Klassen Einschränkung vorhanden ist.  

## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29>-Methoden Überladung verwendet wird, um Informationen über alle öffentlichen Instanzmember einer bestimmten Klasse zu sammeln.  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft eine bestimmte Methode des aktuellen <see cref="T:System.Type" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Methode enthält.</param>
        <summary>Sucht die öffentliche Methode mit dem angegebenen Namen.</summary>
        <returns>Ein Objekt, das die öffentliche Methode mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der Suche nach `name` wird die Groß-/Kleinschreibung beachtet. Die Suche umfasst öffentliche statische und öffentliche Instanzmethoden.  
  
 Wenn eine Methode überladen wird und mehr als eine öffentliche Methode aufweist, löst die <xref:System.Type.GetMethod%28System.String%29> Methode eine <xref:System.Reflection.AmbiguousMatchException> Ausnahme aus. Im folgenden Beispiel wird eine Ausnahme ausgelöst, da mehrere öffentliche über Ladungen der <xref:System.Int32.ToString%2A?displayProperty=nameWithType>-Methode vorhanden sind.  Da die `Person.ToString`-Methode <xref:System.Object.ToString%2A?displayProperty=nameWithType> überschreibt und daher nicht überladen ist, kann die <xref:System.Type.GetMethod%28System.String%29>-Methode das <xref:System.Reflection.MethodInfo> Objekt abrufen.  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 Sie können eine der folgenden Aktionen ausführen, um eine bestimmte Methode abzurufen:  
  
-   Nennen Sie die <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29>-Methode, und geben Sie ein `bindingAttr` Argument an, das die Methode eindeutig identifiziert. Wenn z. b. die Ausnahme ausgelöst wird, weil ein Typ über eine statische und eine instanzüberladung verfügt, können Sie ein `bindingAttr` Argument <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>angeben.  
  
-   Aufrufen einer Überladung der <xref:System.Type.GetMethod%2A>-Methode, die einen `types`-Parameter enthält, der die Typen der Parameter der Methode definiert.  
  
-   Rufen Sie die <xref:System.Type.GetMethods>-Methode auf, um ein Array mit allen öffentlichen Methoden abzurufen, die zu einem Typ gehören. Anschließend können Sie Sie durchlaufen, um die doppelten Methoden mit dem Namen `name`zu identifizieren.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Methoden der Klassen Einschränkung oder die Methoden von <xref:System.Object>, wenn keine Klassen Einschränkung vorhanden ist.  
  
> [!NOTE]
>  Fügen Sie die Typargumente bei generischen Methoden nicht in `name`ein. Beispielsweise sucht der C# Code `GetMember("MyMethod<int>")` nach einem Member mit dem Textnamen "`MyMethod<int>`" und nicht nach einer Methode mit dem Namen `MyMethod`, die ein generisches Argument vom Typ `int`hat.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Methode mit dem Namen `MethodA`abgerufen.  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Methoden mit dem angegebenen Namen gefunden.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Methode enthält.</param>
        <param name="bindingAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.  
  
Oder 
 <see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Sucht die angegebene Methode unter Verwendung der angegebenen Bindungseinschränkungen.</summary>
        <returns>Ein Objekt, das die Methode darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Methoden in die Suche eingeschlossen werden sollen:  
  
-   Sie müssen entweder <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> oder <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> angeben, um eine Rückgabe zu erhalten.  
  
-   Geben Sie <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> an, um öffentliche Methoden in die Suche einzubeziehen.  
  
-   Geben Sie <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> an, um nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche einzubeziehen.  
  
-   Geben Sie <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> an, um `public` und `protected` statische Elemente in der Hierarchie einzuschließen. `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags>-Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:  
  
-   <xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType>, die Groß-/Kleinschreibung `name`zu ignorieren.  
  
-   <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType>, um nur die Methoden zu durchsuchen, die auf dem <xref:System.Type>deklariert sind, nicht Methoden, die einfach geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Wenn eine Methode überladen wird und mehr als eine Überladung die vom `bindingAttr` Argument angegebenen Einschränkungen erfüllt, löst die Methode eine <xref:System.Reflection.AmbiguousMatchException> Ausnahme aus. Im folgenden Beispiel wird eine Ausnahme ausgelöst:  
  
-   Der `TestClass`-Typ verfügt über zwei öffentliche Instanzüberladungen der `DisplayValue`-Methode, `DisplayValue(String)` und `DisplayValue(String, Object[])`.  
  
-   Der `TestClass`-Typ hat zwei öffentliche Instanzüberladungen der `Equals`-Methode, von denen eine von <xref:System.Object>geerbt wird: `Equals(TestClass)` und `Equals(Object)`.  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 Sie können eine der folgenden Aktionen ausführen, um eine bestimmte Methode abzurufen:  
  
-   Ändern Sie die Bindungs Einschränkungen. Im vorherigen Beispiel ruft der Versuch, eine öffentliche Instanz `Equals` Methode abzurufen, die vom-Typ deklariert und nicht geerbt wurde, `Equals(TestClass)`auf.  
  
-   Aufrufen einer Überladung der <xref:System.Type.GetMethod%2A>-Methode, die einen `types`-Parameter enthält, der die Typen der Parameter der Methode definiert.  
  
-   Rufen Sie die <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29>-Methode auf, um ein Array abzurufen, das alle Methoden enthält, die zu einem Typ gehören, der über die angegebenen Bindungs Attribute verfügt. Anschließend können Sie Sie durchlaufen, um die doppelten Methoden mit dem Namen `name`zu identifizieren. Diese Vorgehensweise wird im vorherigen Beispiel Handler für die <xref:System.Reflection.AmbiguousMatchException> Ausnahme veranschaulicht.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Methoden der Klassen Einschränkung oder die Methoden von <xref:System.Object>, wenn keine Klassen Einschränkung vorhanden ist.  
  
> [!NOTE]
>  Fügen Sie die Typargumente bei generischen Methoden nicht in `name`ein. Beispielsweise sucht der C# Code `GetMember("MyMethod<int>")` nach einem Member mit dem Textnamen "`MyMethod<int>`" und nicht nach einer Methode mit dem Namen `MyMethod`, die ein generisches Argument vom Typ `int`hat.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Methode abgerufen, die mit den angegebenen Bindungsflags übereinstimmt.  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Methoden gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Methode enthält.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.  
  
Oder 
Ein leeres Array von <see cref="T:System.Type" />-Objekten (bereitgestellt vom <see cref="F:System.Type.EmptyTypes" />-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</param>
        <summary>Sucht die angegebene öffentliche Methode, deren Parameter den angegebenen Argumenttypen entsprechen.</summary>
        <returns>Ein Objekt, das die öffentliche Methode darstellt, deren Parameter den angegebenen Argumenttypen entsprechen, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der Suche nach `name` wird die Groß-/Kleinschreibung beachtet. Die Suche umfasst öffentliche statische und öffentliche Instanzmethoden.  
  
> [!NOTE]
>  Sie können Parameter nicht weglassen, wenn Sie Konstruktoren und Methoden suchen. Beim Aufrufen von können Sie nur Parameter weglassen.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Methoden der Klassen Einschränkung oder die Methoden von <xref:System.Object>, wenn keine Klassen Einschränkung vorhanden ist.  
  
> [!NOTE]
>  Der `name`-Parameter darf keine Typargumente enthalten. Beispielsweise sucht der C# Code `GetMethod("MyGenericMethod<int>")` nach einer Methode mit dem Textnamen "`MyGenericMethod<int>`" und nicht nach einer Methode mit dem Namen `MyGenericMethod`, die ein generisches Argument vom Typ `int`hat. Verwenden Sie stattdessen `GetMethod("MyGenericMethod")` mit dem entsprechenden Parameter im `types` Array.  
  
   
  
## Examples  
 Im folgenden Beispiel werden bestimmte über Ladungen von `MethodA`und eine Vielzahl von Argument Typen ermittelt.  
  
> [!NOTE]
>  Das [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Beispiel erfordert die `/unsafe`-Compileroption.  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 Im folgenden Beispiel werden <xref:System.Reflection.MethodInfo> Objekte abgerufen, die die `Add` Methoden eines nicht generischen Typs (der <xref:System.Collections.ArrayList>-Klasse), ein offener generischer Typ (die <xref:System.Collections.Generic.List%601>-Klasse) und ein geschlossener generischer Typ (den `List(Of String)` Typ) darstellen.  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 Im Beispiel wird eine `GetAddMethod`-Methode definiert, die das entsprechende <xref:System.Reflection.MethodInfo>-Objekt abruft. Um das `types`-Argument für einen offenen generischen Typ bereitzustellen, wird die <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType>-Methode aufgerufen. Um das `types`-Argument für einen geschlossenen generischen Typ bereitzustellen, ruft es den Wert der <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType>-Eigenschaft ab.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Methoden mit dem angegebenen Namen und den angegebenen Parametern gefunden.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />  
  
Oder 
 <paramref name="types" /> ist <see langword="null" />  
  
Oder 
Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Methode enthält.</param>
        <param name="genericParameterCount">Die Anzahl der generischen Typparameter der Methode.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.

Oder

Ein leeres Array von <see cref="T:System.Type" />-Objekten (bereitgestellt vom <see cref="F:System.Type.EmptyTypes" />-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</param>
        <summary>Sucht die angegebene öffentliche Methode, deren Parameter der angegebenen Anzahl generischer Parameter und den angegebenen Argumenttypen entsprechen.</summary>
        <returns>Ein Objekt, das die öffentliche Methode darstellt, deren Parameter der angegebenen Anzahl generischer Parameter und den angegebenen Argumenttypen entsprechen, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />

Oder

<paramref name="types" /> ist <see langword="null" />

Oder

Ein Element im <paramref name="types" />-Array ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="genericParameterCount" /> ist ein negativer Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Methode enthält.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.  
  
Oder 
Ein leeres Array von <see cref="T:System.Type" />-Objekten (bereitgestellt vom <see cref="F:System.Type.EmptyTypes" />-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind. Darf nur bei Aufrufen über COM-Interop verwendet werden. Es werden außerdem nur Parameter berücksichtigt, die als Verweis übergeben werden. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht die angegebene öffentliche Methode, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein Objekt, das die öffentliche Methode darstellt, die den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standard Binder verarbeitet zwar nicht <xref:System.Reflection.ParameterModifier> (den `modifiers`-Parameter), Sie können jedoch die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType>-Klasse verwenden, um einen benutzerdefinierten Binder zu schreiben, der `modifiers`verarbeitet. `ParameterModifier` wird nur beim Aufrufen über COM-Interop verwendet, und nur Parameter, die als Verweis übermittelt werden, werden behandelt.  
  
 Bei der Suche nach `name` wird die Groß-/Kleinschreibung beachtet. Die Suche umfasst öffentliche statische und öffentliche Instanzmethoden.  
  
> [!NOTE]
>  Sie können Parameter nicht weglassen, wenn Sie Konstruktoren und Methoden suchen. Beim Aufrufen von können Sie nur Parameter weglassen.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Methoden der Klassen Einschränkung oder die Methoden von <xref:System.Object>, wenn keine Klassen Einschränkung vorhanden ist.  
  
> [!NOTE]
>  Fügen Sie die Typargumente bei generischen Methoden nicht in `name`ein. Beispielsweise sucht der C# Code `GetMethod("MyMethod<int>")` nach einem Member mit dem Textnamen "`MyMethod<int>`" und nicht nach einer Methode mit dem Namen `MyMethod`, die ein generisches Argument vom Typ `int`hat. Verwenden Sie stattdessen `GetMethod("MyMethod")` mit dem entsprechenden Parameter im `types` Array.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Methoden mit dem angegebenen Namen und den angegebenen Parametern gefunden.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />  
  
Oder 
 <paramref name="types" /> ist <see langword="null" />  
  
Oder 
Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.  
  
Oder 
 <paramref name="modifiers" /> ist mehrdimensional.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Methode enthält.</param>
        <param name="genericParameterCount">Die Anzahl der generischen Typparameter der Methode.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.

Oder

Ein leeres Array von <see cref="T:System.Type" />-Objekten (bereitgestellt vom <see cref="F:System.Type.EmptyTypes" />-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind. Darf nur bei Aufrufen über COM-Interop verwendet werden. Es werden außerdem nur Parameter berücksichtigt, die als Verweis übergeben werden. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht die angegebene öffentliche Methode, deren Parameter der angegebenen Anzahl generischer Parameter und den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein Objekt, das die öffentliche Methode darstellt, die der angegebenen Anzahl generischer Parameter und den angegebenen Argumenttypen und -modifizierern entsprechen, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />

Oder

<paramref name="types" /> ist <see langword="null" />

Oder

Ein Element im <paramref name="types" />-Array ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="genericParameterCount" /> ist ein negativer Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags, binder As Binder, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Methode enthält.</param>
        <param name="bindingAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.  
  
Oder 
 <see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
Oder 
Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.  
  
Oder 
Ein leeres Array von <see cref="T:System.Type" />-Objekten (bereitgestellt vom <see cref="F:System.Type.EmptyTypes" />-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind. Darf nur bei Aufrufen über COM-Interop verwendet werden. Es werden außerdem nur Parameter berücksichtigt, die als Verweis übergeben werden. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht unter Verwendung der angegebenen Bindungseinschränkungen nach der angegebenen Methode, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein Objekt, das die Methode darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standard Binder verarbeitet zwar nicht <xref:System.Reflection.ParameterModifier> (den `modifiers`-Parameter), Sie können jedoch die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType>-Klasse verwenden, um einen benutzerdefinierten Binder zu schreiben, der `modifiers`verarbeitet. `ParameterModifier` wird nur beim Aufrufen über COM-Interop verwendet, und nur Parameter, die als Verweis übermittelt werden, werden behandelt.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Methoden in die Suche eingeschlossen werden sollen:  
  
-   Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` an, um öffentliche Methoden in die Suche einzubeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` an, um nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche einzubeziehen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` an, um `public` und `protected` statische Elemente in der Hierarchie einzuschließen. `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags>-Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:  
  
-   `BindingFlags.IgnoreCase`, die Groß-/Kleinschreibung `name`zu ignorieren.  
  
-   `BindingFlags.DeclaredOnly`, um nur die Methoden zu durchsuchen, die auf dem <xref:System.Type>deklariert sind, nicht Methoden, die einfach geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Sie können Parameter nicht weglassen, wenn Sie Konstruktoren und Methoden suchen. Beim Aufrufen von können Sie nur Parameter weglassen.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Methoden der Klassen Einschränkung oder die Methoden von <xref:System.Object>, wenn keine Klassen Einschränkung vorhanden ist.  
  
> [!NOTE]
>  Fügen Sie die Typargumente bei generischen Methoden nicht in `name`ein. Beispielsweise sucht der C# Code `GetMember("MyMethod<int>")` nach einem Member mit dem Textnamen "`MyMethod<int>`" und nicht nach einer Methode mit dem Namen `MyMethod`, die ein generisches Argument vom Typ `int`hat.  
  
   
  
## Examples  
 Im folgenden Beispiel werden bestimmte über Ladungen von `MethodA`ermittelt, wobei Bindungs Einschränkungen und verschiedene Argument Typen angegeben werden.  
  
> [!NOTE]
>  Das [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Beispiel erfordert die `/unsafe`-Compileroption.  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Methoden gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />  
  
Oder 
 <paramref name="types" /> ist <see langword="null" />  
  
Oder 
Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.  
  
Oder 
 <paramref name="modifiers" /> ist mehrdimensional.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, bindingAttr As BindingFlags, binder As Binder, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Methode enthält.</param>
        <param name="genericParameterCount">Die Anzahl der generischen Typparameter der Methode.</param>
        <param name="bindingAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.

Oder

<see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.

Oder

Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.

Oder

Ein leeres Array von <see cref="T:System.Type" />-Objekten (bereitgestellt vom <see cref="F:System.Type.EmptyTypes" />-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind. Darf nur bei Aufrufen über COM-Interop verwendet werden. Es werden außerdem nur Parameter berücksichtigt, die als Verweis übergeben werden. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht unter Verwendung der angegebenen Bindungseinschränkungen nach der angegebenen Methode, deren Parameter der angegebenen Anzahl generischer Parameter und den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein-Objekt, das die Methode darstellt, die der angegebenen Anzahl von generischen Parametern und den angegebenen Argumenttypen, -modifizierern und Bindungseinschränkungen entspricht, sofern gefunden. Andernfalls <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />

Oder

<paramref name="types" /> ist <see langword="null" />

Oder

Ein Element im <paramref name="types" />-Array ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="genericParameterCount" /> ist ein negativer Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags, binder As Binder, callConvention As CallingConventions, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Methode enthält.</param>
        <param name="bindingAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.  
  
Oder 
 <see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
Oder 
Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="callConvention">Das Objekt, das die Regeln für Reihenfolge und Layout der Argumente, die Art der Übergabe des Rückgabewerts, die für Argumente zu verwendenden Register und die Art der Stapelbereinigung angibt.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.  
  
Oder 
Ein leeres Array von <see cref="T:System.Type" />-Objekten (bereitgestellt vom <see cref="F:System.Type.EmptyTypes" />-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind. Darf nur bei Aufrufen über COM-Interop verwendet werden. Es werden außerdem nur Parameter berücksichtigt, die als Verweis übergeben werden. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht nach der angegebenen Methode, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen, und verwendet dabei die angegebenen Bindungseinschränkungen und die angegebene Aufrufkonvention.</summary>
        <returns>Ein Objekt, das die Methode darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standard Binder verarbeitet zwar nicht <xref:System.Reflection.ParameterModifier> (den `modifiers`-Parameter), Sie können jedoch die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType>-Klasse verwenden, um einen benutzerdefinierten Binder zu schreiben, der `modifiers`verarbeitet. `ParameterModifier` wird nur beim Aufrufen über COM-Interop verwendet, und nur Parameter, die als Verweis übermittelt werden, werden behandelt.  
  
 In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `GetXXX` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.  
  
|Mitgliedstyp|statischen|Nicht statisch|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld wird immer nach Name und Signatur ausgeblendet.|  
|Ereignis|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.|  
|Der Typ "Typ"|Nein|Nein|  
|Eigenschaft|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
  
1.  "Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen. Dies ist ein binärer Vergleich.  
  
2.  Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet. Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Methoden in die Suche eingeschlossen werden sollen:  
  
-   Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` an, um öffentliche Methoden in die Suche einzubeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` an, um nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche einzubeziehen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` an, um `public` und `protected` statische Elemente in der Hierarchie einzuschließen. `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags>-Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:  
  
-   `BindingFlags.IgnoreCase`, die Groß-/Kleinschreibung `name`zu ignorieren.  
  
-   `BindingFlags.DeclaredOnly`, um nur die Methoden zu durchsuchen, die auf dem <xref:System.Type>deklariert sind, nicht Methoden, die einfach geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Sie können Parameter nicht weglassen, wenn Sie Konstruktoren und Methoden suchen. Beim Aufrufen von können Sie nur Parameter weglassen.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Methoden der Klassen Einschränkung oder die Methoden von <xref:System.Object>, wenn keine Klassen Einschränkung vorhanden ist.  
  
> [!NOTE]
>  Fügen Sie die Typargumente bei generischen Methoden nicht in `name`ein. Beispielsweise sucht der C# Code `GetMember("MyMethod<int>")` nach einem Member mit dem Textnamen "`MyMethod<int>`" und nicht nach einer Methode mit dem Namen `MyMethod`, die ein generisches Argument vom Typ `int`hat.  
  
   
  
## Examples  
 Im folgenden Beispiel werden bestimmte über Ladungen von `MethodA`gefunden, und es werden Bindungs Einschränkungen, Aufruf Konventionen und eine Vielzahl von Argument Typen angegeben.  
  
> [!NOTE]
>  Das [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] Beispiel erfordert die `/unsafe`-Compileroption.  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Methoden gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />  
  
Oder 
 <paramref name="types" /> ist <see langword="null" />  
  
Oder 
Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.  
  
Oder 
 <paramref name="modifiers" /> ist mehrdimensional.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, bindingAttr As BindingFlags, binder As Binder, callConvention As CallingConventions, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="6" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Methode enthält.</param>
        <param name="genericParameterCount">Die Anzahl der generischen Typparameter der Methode.</param>
        <param name="bindingAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.

Oder

<see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.

Oder

Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="callConvention">Das Objekt, das die Regeln für Reihenfolge und Layout der Argumente, die Art der Übergabe des Rückgabewerts, die für Argumente zu verwendenden Register und die Art der Stapelbereinigung angibt.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.

Oder

Ein leeres Array von <see cref="T:System.Type" />-Objekten (bereitgestellt vom <see cref="F:System.Type.EmptyTypes" />-Feld) zum Abrufen einer Methode, die keine Parameter akzeptiert.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind. Darf nur bei Aufrufen über COM-Interop verwendet werden. Es werden außerdem nur Parameter berücksichtigt, die als Verweis übergeben werden. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht nach der angegebenen Methode, deren Parameter der angegebenen Anzahl generischer Parameter und den angegebenen Argumenttypen und -modifizierern entsprechen, und verwendet dabei die angegebenen Bindungseinschränkungen und die angegebene Aufrufkonvention.</summary>
        <returns>Ein-Objekt, das die Methode darstellt, die der angegebenen Anzahl von generischen Parametern und den angegebenen Argumenttypen, -modifizierern, Bindungseinschränkungen und Aufrufkonventionen entspricht, sofern gefunden. Andernfalls <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />

Oder

<paramref name="types" /> ist <see langword="null" />

Oder

Ein Element im <paramref name="types" />-Array ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="genericParameterCount" /> ist ein negativer Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetMethodImpl (name As String, bindingAttr As BindingFlags, binder As Binder, callConvention As CallingConventions, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Methode enthält.</param>
        <param name="bindingAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.  
  
Oder 
 <see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
Oder 
Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="callConvention">Das Objekt, das die Regeln für Reihenfolge und Layout der Argumente, die Art der Übergabe des Rückgabewerts, die für Argumente zu verwendenden Register und den Prozess angibt, der den Stapel bereinigt.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.  
  
Oder 
Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer Methode, die keine Parameter akzeptiert.  
  
Oder 
 [https://login.microsoftonline.com/consumers/](<see langword="null" />). Wenn <paramref name="types" /><see langword="null" /> ist, wird keine Übereinstimmung von Argumenten überprüft.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen und der angegebenen Aufrufkonvention nach der angegebenen Methode, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein Objekt, das die Methode darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standard Binder verarbeitet zwar nicht <xref:System.Reflection.ParameterModifier> (den `modifiers`-Parameter), Sie können jedoch die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType>-Klasse verwenden, um einen benutzerdefinierten Binder zu schreiben, der `modifiers`verarbeitet. `ParameterModifier` wird nur beim Aufrufen über COM-Interop verwendet, und nur Parameter, die als Verweis übermittelt werden, werden behandelt.  
  
 Wenn `types``null` ist, wird keine Übereinstimmung von Argumenten überprüft.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Methoden in die Suche eingeschlossen werden sollen:  
  
-   Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` an, um öffentliche Methoden in die Suche einzubeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` an, um nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche einzubeziehen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` an, um `public` und `protected` statische Elemente in der Hierarchie einzuschließen. `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags>-Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:  
  
-   `BindingFlags.IgnoreCase`, die Groß-/Kleinschreibung `name`zu ignorieren.  
  
-   `BindingFlags.DeclaredOnly`, um nur die Methoden zu durchsuchen, die auf dem <xref:System.Type>deklariert sind, nicht Methoden, die einfach geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Methoden gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.  
  
Oder 
 <paramref name="modifiers" /> ist mehrdimensional.  
  
Oder 
 <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</exception>
        <exception cref="T:System.NotSupportedException">Der aktuelle Typ ist ein <see cref="T:System.Reflection.Emit.TypeBuilder" /> oder <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl (name As String, genericParameterCount As Integer, bindingAttr As BindingFlags, binder As Binder, callConvention As CallingConventions, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="genericParameterCount" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" Index="4" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="5" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="6" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Methode enthält.</param>
        <param name="genericParameterCount">Die Anzahl der generischen Typparameter der Methode.</param>
        <param name="bindingAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.

Oder

<see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.

Oder

Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="callConvention">Das Objekt, das die Regeln für Reihenfolge und Layout der Argumente, die Art der Übergabe des Rückgabewerts, die für Argumente zu verwendenden Register und den Prozess angibt, der den Stapel bereinigt.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, das die Anzahl, die Reihenfolge und den Typ der Parameter der abzurufenden Methode darstellt.

Oder

Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer Methode, die keine Parameter akzeptiert.

Oder

[https://login.microsoftonline.com/consumers/](<see langword="null" />). Wenn <paramref name="types" /><see langword="null" /> ist, wird keine Übereinstimmung von Argumenten überprüft.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen und der angegebenen Aufrufkonvention nach der angegebenen Methode, deren Parameter der angegebenen Anzahl generischer Parameter und den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein-Objekt, das die Methode darstellt, die der angegebenen Anzahl von generischen Parametern und den angegebenen Argumenttypen, -modifizierern, Bindungseinschränkungen und Aufrufkonventionen entspricht, sofern gefunden. Andernfalls <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">Die Methode muss überschrieben und in einer abgeleiteten Klasse aufgerufen werden.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die Methoden des aktuellen <see cref="T:System.Type" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo[] GetMethods() cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt sämtliche öffentlichen Methoden des aktuellen <see cref="T:System.Type" /> zurück.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.MethodInfo" />-Objekten, die alle für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Member darstellen.  
  
Oder 
Ein leeres Array vom <see cref="T:System.Reflection.MethodInfo" />-Typ, wenn für den aktuellen <see cref="T:System.Type" /> keine öffentlichen Methoden definiert sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

Die <xref:System.Type.GetMethods%2A>-Methode gibt keine Methoden in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklarations Reihenfolge. Der Code darf nicht von der Reihenfolge abhängen, in der Methoden zurückgegeben werden, da diese Reihenfolge variiert.  
  
 Konstruktoren sind nicht in dem Array von Methoden enthalten, die von diesem-Befehl zurückgegeben werden. Erstellen Sie einen separaten Aufruf`GetConstructors()` zum Abrufen der Konstruktormethoden.  
  
 In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.  
  
|Mitgliedstyp|statischen|Nicht statisch|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld wird immer nach Name und Signatur ausgeblendet.|  
|Ereignis|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.|  
|Der Typ "Typ"|Nein|Nein|  
|Eigenschaft|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
  
1.  "Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen. Dies ist ein binärer Vergleich.  
  
2.  Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet. Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
> [!NOTE]
>  Sie können Parameter nicht weglassen, wenn Sie Konstruktoren und Methoden suchen. Beim Aufrufen von können Sie nur Parameter weglassen.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Methoden der Klassen Einschränkung oder die Methoden von <xref:System.Object>, wenn keine Klassen Einschränkung vorhanden ist.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.

Oder

 <see cref="F:System.Reflection.BindingFlags.Default" />, um ein leeres Array zurückzugeben.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die für den aktuellen <see cref="T:System.Type" /> definierten Methoden.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.MethodInfo" />-Objekten, die sämtliche für den aktuellen <see cref="T:System.Type" /> definierten öffentlichen Methoden darstellen, die den angegebenen Bindungseinschränkungen entsprechen.  
  
Oder 
Ein leeres Array vom <see cref="T:System.Reflection.MethodInfo" />-Typ, wenn für den aktuellen <see cref="T:System.Type" /> keine Methoden definiert sind oder keine der definierten Methoden den Bindungseinschränkungen entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Damit die `GetMethods(BindingFlags)` Überladung Methoden Informationen erfolgreich abrufen kann, muss das `bindingAttr`-Argument mindestens eine <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> und <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>enthalten, zusammen mit mindestens einer <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> und <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>. 
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Methoden in die Suche eingeschlossen werden sollen:  
  
- Geben Sie `BindingFlags.Instance` an, um Instanzmethoden einzubeziehen. 

- Geben Sie `BindingFlags.Static` an, um statische Methoden einzubeziehen. 
  
- Geben Sie `BindingFlags.Public` an, um öffentliche Methoden in die Suche einzubeziehen.  
  
- Geben Sie `BindingFlags.NonPublic` an, um nicht öffentliche Methoden (d. h. private, interne und geschützte Methoden) in die Suche einzubeziehen. Es werden nur geschützte und interne Methoden für Basisklassen zurückgegeben. Private Methoden für Basisklassen werden nicht zurückgegeben.  
  
- Geben Sie `BindingFlags.FlattenHierarchy` an, um `public` und `protected` statische Elemente in der Hierarchie einzuschließen. `private` statische Member in geerbten Klassen sind nicht enthalten.  

- Geben Sie `BindingFlags.Default` allein an, um ein leeres <xref:System.Reflection.MethodInfo> Array zurückzugeben.
  
 Die folgenden <xref:System.Reflection.BindingFlags>-Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:  
  
- `BindingFlags.DeclaredOnly`, um nur die Methoden zu durchsuchen, die auf dem <xref:System.Type>deklariert sind, nicht Methoden, die einfach geerbt wurden.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  

Die <xref:System.Type.GetMethods%2A>-Methode gibt keine Methoden in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklarations Reihenfolge. Der Code darf nicht von der Reihenfolge abhängen, in der Methoden zurückgegeben werden, da diese Reihenfolge variiert.  

Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.MethodInfo> Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Methoden der Klassen Einschränkung oder die Methoden von <xref:System.Object>, wenn keine Klassen Einschränkung vorhanden ist. 
  
## Examples  
 Im folgenden Beispiel wird eine-Klasse mit zwei öffentlichen Methoden und einer geschützten Methode erstellt, ein `Type` Objekt erstellt, das `MyTypeClass`entspricht, alle öffentlichen und nicht öffentlichen Methoden erhält und deren Namen anzeigt.  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen bestimmten Typ ab, der im aktuellen <see cref="T:System.Type" /> geschachtelt ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetNestedType(string name) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetNestedType(System::String ^ name);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string -&gt; Type&#xA;override this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen des abzurufenden geschachtelten Typs enthält.</param>
        <summary>Sucht den öffentlichen geschachtelten Typ mit dem angegebenen Namen.</summary>
        <returns>Ein Objekt, das den öffentlichen geschachtelten Typ mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der Suche nach `name` wird die Groß-/Kleinschreibung beachtet.  
  
 Verwenden Sie den einfachen Namen der-Klasse für die `name`. Qualifizieren Sie diese nicht mit dem Namen der äußeren Klasse. Verwenden Sie für eine generische geschaltete Klasse den geschalteten Namen, d. h., fügen Sie einen schweren Akzent und die Anzahl der generischen Argumente an. Verwenden Sie z. b. die Zeichenfolge "Inner\`1", um die generische geschachtelte Klasse `Inner<T>` (`Inner(Of T)` in Visual Basic) zu erhalten. Fügen Sie keine sprachspezifische Syntax für Typparameter ein.  
  
 In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.  
  
|Mitgliedstyp|statischen|Nicht statisch|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld wird immer nach Name und Signatur ausgeblendet.|  
|Ereignis|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.|  
|Der Typ "Typ"|Nein|Nein|  
|Eigenschaft|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
  
1.  "Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen. Dies ist ein binärer Vergleich.  
  
2.  Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet. Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die in der Klassen Einschränkung dargestellten Typen.  
  
 Wenn ein ngenerischer Typ generisch ist, gibt diese Methode die generische Typdefinition zurück. Dies gilt auch, wenn der umschließende generische Typ ein geschlossener konstruierter Typ ist.  
  
> [!NOTE]
>  Wenn die aktuelle <xref:System.Type> einen generischen Typ darstellt, C#der in, Visual Basic C++oder definiert ist, sind die zugehörigen Typen generisch, auch wenn Sie über keine eigenen generischen Parameter verfügen. Dies trifft nicht unbedingt auf in dynamischen Assemblys definierte, in dynamischen Assemblys definierte oder mit [Ilasm. exe (Il-Assembler)](/dotnet/framework/tools/ilasm-exe-il-assembler)kompilierte Typen zu.  
  
 Informationen zu den generischen generischen Typen und zum Erstellen von generischen generischen Typen aus ihren generischen Typdefinitionen finden Sie unter <xref:System.Type.MakeGenericType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="type.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen des abzurufenden geschachtelten Typs enthält.</param>
        <param name="bindingAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.  
  
Oder 
 <see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen den angegebenen geschachtelten Typ.</summary>
        <returns>Ein Objekt, das den geschachtelten Typ darstellt, der den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls<see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie den einfachen Namen der-Klasse für die `name`. Qualifizieren Sie diese nicht mit dem Namen der äußeren Klasse. Verwenden Sie für eine generische geschaltete Klasse den geschalteten Namen, d. h., fügen Sie einen schweren Akzent und die Anzahl der generischen Parameter an. Verwenden Sie z. b. die Zeichenfolge "Inner\`1", um die generische geschachtelte Klasse `Inner<T>` (`Inner(Of T)` in Visual Basic) zu erhalten. Fügen Sie keine sprachspezifische Syntax für Typparameter ein.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche in die Suche einzuschließenden Untertypen eingeschlossen werden sollen:  
  
-   Sie müssen entweder <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> oder <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> angeben, um eine Rückgabe zu erhalten.  
  
-   Geben Sie <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> an, um öffentliche, in die Suche eingefügte Typen einzubeziehen.  
  
-   Geben Sie <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> an, um nicht öffentliche, nicht öffentliche Typen in die Suche einzubeziehen (d. h. private, interne und geschützte Typen).  
  
 Diese Methode gibt nur die Untertypen des aktuellen Typs zurück. Die Basisklassen des aktuellen Typs werden nicht durchsucht. Um Typen zu suchen, die in Basisklassen eingebettet sind, müssen Sie die Vererbungs Hierarchie durchlaufen und <xref:System.Type.GetNestedType%2A> auf jeder Ebene aufrufen.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> und <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> werden ignoriert.  
  
 Wenn diese Methode nur mit dem <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>-Flag oder nur mit dem <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>-Flag aufgerufen wird, werden die angegebenen Untertypen zurückgegeben, und es sind keine anderen Flags erforderlich.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die in der Klassen Einschränkung dargestellten Typen.  
  
 Wenn ein ngenerischer Typ generisch ist, gibt diese Methode die generische Typdefinition zurück. Dies gilt auch, wenn der umschließende generische Typ ein geschlossener konstruierter Typ ist.  
  
> [!NOTE]
>  Wenn die aktuelle <xref:System.Type> einen generischen Typ darstellt, C#der in, Visual Basic C++oder definiert ist, sind die zugehörigen Typen generisch, auch wenn Sie über keine eigenen generischen Parameter verfügen. Dies trifft nicht unbedingt auf in dynamischen Assemblys definierte, in dynamischen Assemblys definierte oder mit [Ilasm. exe (Il-Assembler)](/dotnet/framework/tools/ilasm-exe-il-assembler)kompilierte Typen zu.  
  
 Informationen zu den generischen generischen Typen und zum Erstellen von generischen generischen Typen aus ihren generischen Typdefinitionen finden Sie unter <xref:System.Type.MakeGenericType%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die im aktuellen <see cref="T:System.Type" /> geschachtelten Typen ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type[] GetNestedTypes() cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;Type ^&gt; ^ GetNestedTypes();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : unit -&gt; Type[]&#xA;override this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die im aktuellen <see cref="T:System.Type" /> geschachtelten öffentlichen Typen zurück.</summary>
        <returns>Ein Array von <see cref="T:System.Type" />-Objekten, das die im aktuellen <see cref="T:System.Type" /> geschachtelten öffentlichen Typen darstellt (die Suche ist nicht rekursiv) oder ein leeres Array vom Typ <see cref="T:System.Type" />, wenn im aktuellen <see cref="T:System.Type" /> keine öffentlichen Typen geschachtelt sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetNestedTypes%2A>-Methode gibt keine Typen in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklarations Reihenfolge. Der Code darf nicht von der Reihenfolge abhängen, in der Typen zurückgegeben werden, da diese Reihenfolge variiert.  
  
 Es werden nur die öffentlichen Typen zurückgegeben, die sofort im aktuellen Typ eingefügt werden. die Suche ist nicht rekursiv.  
  
 In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.  
  
|Mitgliedstyp|statischen|Nicht statisch|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld wird immer nach Name und Signatur ausgeblendet.|  
|Ereignis|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.|  
|Der Typ "Typ"|Nein|Nein|  
|Eigenschaft|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
  
1.  "Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen. Dies ist ein binärer Vergleich.  
  
2.  Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet. Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die in der Klassen Einschränkung dargestellten Typen.  
  
 Wenn ein ngenerischer Typ generisch ist, gibt diese Methode die generische Typdefinition zurück. Dies gilt auch, wenn der umschließende generische Typ ein geschlossener konstruierter Typ ist.  
  
> [!NOTE]
>  Wenn die aktuelle <xref:System.Type> einen generischen Typ darstellt, C#der in, Visual Basic C++oder definiert ist, sind die zugehörigen Typen generisch, auch wenn Sie über keine eigenen generischen Parameter verfügen. Dies trifft nicht unbedingt auf in dynamischen Assemblys definierte, in dynamischen Assemblys definierte oder mit [Ilasm. exe (Il-Assembler)](/dotnet/framework/tools/ilasm-exe-il-assembler)kompilierte Typen zu.  
  
 Informationen zu den generischen generischen Typen und zum Erstellen von generischen generischen Typen aus ihren generischen Typdefinitionen finden Sie unter <xref:System.Type.MakeGenericType%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel werden eine-Klasse und ein-`struct` in `MyClass`definiert, und anschließend werden die Objekte der mit dem Typ `MyClass`verwendeten Typen abgerufen.  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="type.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.  
  
Oder 
 <see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die im aktuellen <see cref="T:System.Type" /> geschachtelten Typen.</summary>
        <returns>Ein Array von <see cref="T:System.Type" />-Objekten, das alle im aktuellen <see cref="T:System.Type" /> geschachtelten Typen darstellt, die mit den angegebenen Bindungseinschränkungen übereinstimmen (die Suche ist nicht rekursiv) oder ein leeres Array vom Typ <see cref="T:System.Type" />, wenn keine geschachtelten Typen gefunden werden, die mit den Bindungseinschränkungen übereinstimmen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Suche nach nicht-Typen ist rekursiv.  
  
 Die <xref:System.Type.GetNestedTypes%2A>-Methode gibt keine Typen in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklarations Reihenfolge. Der Code darf nicht von der Reihenfolge abhängen, in der Typen zurückgegeben werden, da diese Reihenfolge variiert.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche in die Suche einzuschließenden Untertypen eingeschlossen werden sollen:  
  
-   Sie müssen entweder <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> oder <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> angeben, um eine Rückgabe zu erhalten.  
  
-   Geben Sie <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> an, um öffentliche, in die Suche eingefügte Typen einzubeziehen.  
  
-   Geben Sie <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> an, um nicht öffentliche, nicht öffentliche Typen in die Suche einzubeziehen (d. h. private, interne und geschützte Typen).  
  
 Diese Methode gibt nur die Untertypen des aktuellen Typs zurück. Die Basisklassen des aktuellen Typs werden nicht durchsucht. Um Typen zu suchen, die in Basisklassen eingebettet sind, müssen Sie die Vererbungs Hierarchie durchlaufen und <xref:System.Type.GetNestedTypes%2A> auf jeder Ebene aufrufen.  
  
 <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> und <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> werden ignoriert.  
  
 Wenn diese Methode nur mit dem <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>-Flag oder nur mit dem <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>-Flag aufgerufen wird, werden die angegebenen Untertypen zurückgegeben, und es sind keine anderen Flags erforderlich.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die in der Klassen Einschränkung dargestellten Typen.  
  
 Wenn ein ngenerischer Typ generisch ist, gibt diese Methode die generische Typdefinition zurück. Dies gilt auch, wenn der umschließende generische Typ ein geschlossener konstruierter Typ ist.  
  
> [!NOTE]
>  Wenn die aktuelle <xref:System.Type> einen generischen Typ darstellt, C#der in, Visual Basic C++oder definiert ist, sind die zugehörigen Typen generisch, auch wenn Sie über keine eigenen generischen Parameter verfügen. Dies trifft nicht unbedingt auf in dynamischen Assemblys definierte, in dynamischen Assemblys definierte oder mit [Ilasm. exe (Il-Assembler)](/dotnet/framework/tools/ilasm-exe-il-assembler)kompilierte Typen zu.  
  
 Informationen zu den generischen generischen Typen und zum Erstellen von generischen generischen Typen aus ihren generischen Typdefinitionen finden Sie unter <xref:System.Type.MakeGenericType%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel werden zwei eingefügte öffentliche Klassen und zwei in der Tabelle geschützte Klassen erstellt, und es werden Informationen für Klassen angezeigt, die den angegebenen Bindungs Einschränkungen entsprechen.  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die Eigenschaften des aktuellen <see cref="T:System.Type" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; System.Reflection.PropertyInfo[]&#xA;override this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt sämtliche öffentlichen Eigenschaften des aktuellen <see cref="T:System.Type" /> zurück.</summary>
        <returns>Ein Array von <see cref="T:System.Reflection.PropertyInfo" />-Objekten, die alle öffentlichen Eigenschaften des aktuellen <see cref="T:System.Type" /> darstellen.  
  
Oder 
Ein leeres Array vom <see cref="T:System.Reflection.PropertyInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine öffentlichen Eigenschaften besitzt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Aufrufen dieser Überladung entspricht dem Aufrufen der <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> Überladung mit einem `bindingAttr`-Argument, C# das `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` in und `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` in Visual Basic entspricht. Sie gibt alle öffentlichen Instanzen und statischen Eigenschaften zurück, sowohl die, die durch den Typ definiert sind, der durch das aktuelle <xref:System.Type>-Objekt dargestellt wird, als auch die, die von den Basis Typen geerbt werden  
  
 Eine Eigenschaft gilt als öffentlich für Reflektion, wenn Sie über mindestens einen öffentlichen Accessor verfügt. Andernfalls wird die-Eigenschaft als privat betrachtet, und Sie müssen &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> verwenden (in Visual Basic die Werte mithilfe `Or`kombinieren), um Sie zu erhalten.  
  
 Die <xref:System.Type.GetProperties%2A>-Methode gibt keine Eigenschaften in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklarations Reihenfolge. Der Code darf nicht von der Reihenfolge abhängen, in der Eigenschaften zurückgegeben werden, da diese Reihenfolge variiert.  
  
 In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.  
  
|Mitgliedstyp|statischen|Nicht statisch|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld wird immer nach Name und Signatur ausgeblendet.|  
|Ereignis|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.|  
|Der Typ "Typ"|Nein|Nein|  
|Eigenschaft|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
  
1.  "Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen. Dies ist ein binärer Vergleich.  
  
2.  Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet. Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Eigenschaften der Klassen Einschränkung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `GetProperties`-Methode gezeigt.  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.

Oder

 <see cref="F:System.Reflection.BindingFlags.Default" />, um ein leeres Array zurückzugeben.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen die Eigenschaften des aktuellen <see cref="T:System.Type" />.</summary>
        <returns>Ein Array von Objekten, die sämtliche Eigenschaften des aktuellen <see cref="T:System.Type" /> darstellen, die den angegebenen Bindungseinschränkungen entsprechen.  
  
Oder 
Ein leeres Array vom <see cref="T:System.Reflection.PropertyInfo" />-Typ, wenn der aktuelle <see cref="T:System.Type" /> keine Eigenschaften besitzt oder keine der Eigenschaften den Bindungseinschränkungen entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

Damit die `GetProperties(BindingFlags)` Überladung Eigenschaften Informationen erfolgreich abrufen kann, muss das `bindingAttr`-Argument mindestens eine <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> und <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>enthalten, zusammen mit mindestens einer <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> und <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>. 

Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Eigenschaften in die Suche eingeschlossen werden sollen:  
  
- Geben Sie `BindingFlags.Instance` an, um Instanzmethoden einzubeziehen. 

- Geben Sie `BindingFlags.Static` an, um statische Methoden einzubeziehen. 
  
- Geben Sie `BindingFlags.Public` an, um öffentliche Eigenschaften in die Suche einzubeziehen. Eine Eigenschaft gilt als öffentlich für Reflektion, wenn Sie über mindestens einen öffentlichen Accessor verfügt. 
  
- Geben Sie `BindingFlags.NonPublic` an, dass nicht öffentliche Eigenschaften (d. h. private, interne und geschützte Eigenschaften) in der Suche enthalten sein sollen. Es werden nur geschützte und interne Eigenschaften für Basisklassen zurückgegeben. private Eigenschaften für Basisklassen werden nicht zurückgegeben.  
  
- Geben Sie `BindingFlags.FlattenHierarchy` an, um `public` und `protected` statische Elemente in der Hierarchie einzuschließen. `private` statische Member in geerbten Klassen sind nicht enthalten.  

- Geben Sie `BindingFlags.Default` allein an, um ein leeres <xref:System.Reflection.PropertyInfo> Array zurückzugeben.

 Die folgenden <xref:System.Reflection.BindingFlags>-Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:  
  
- `BindingFlags.DeclaredOnly`, um nur die Eigenschaften zu durchsuchen, die auf dem <xref:System.Type>deklariert sind, und keine Eigenschaften, die einfach geerbt wurden  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
Die <xref:System.Type.GetProperties%2A>-Methode gibt keine Eigenschaften in einer bestimmten Reihenfolge zurück, z. b. alphabetisch oder Deklarations Reihenfolge. Der Code darf nicht von der Reihenfolge abhängen, in der Eigenschaften zurückgegeben werden, da diese Reihenfolge variiert.  

 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> Objekte mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Eigenschaften der Klassen Einschränkung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Klasse mit dem Namen `PropertyClass` definiert, die sechs Eigenschaften enthält: zwei sind Public, eine ist privat, eine ist geschützt, eine ist intern (`Friend` in Visual Basic) und eine ist intern geschützt (`Protected Friend` in Visual Basic). Anschließend werden einige grundlegende Eigenschafts Informationen (Name und Typ der Eigenschaft, ob es sich um Lese-/Schreibzugriff handelt, und die Sichtbarkeit der `get` und `set` Accessoren) für die Eigenschaften angezeigt, die den angegebenen Bindungs Einschränkungen entsprechen.  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft eine bestimmte Eigenschaft des aktuellen <see cref="T:System.Type" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</param>
        <summary>Sucht nach der öffentlichen Eigenschaft mit dem angegebenen Namen.</summary>
        <returns>Ein Objekt, das die öffentliche Eigenschaft mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei der Suche nach `name` wird die Groß-/Kleinschreibung beachtet. Die Suche umfasst öffentliche statische und öffentliche Instanzeigenschaften.  
  
 Eine Eigenschaft gilt als öffentlich für Reflektion, wenn Sie über mindestens einen öffentlichen Accessor verfügt. Andernfalls wird die-Eigenschaft als privat betrachtet, und Sie müssen &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> verwenden (in Visual Basic die Werte mithilfe `Or`kombinieren), um Sie zu erhalten.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Eigenschaften der Klassen Einschränkung.  
  
 Es gibt Situationen, in denen <xref:System.Reflection.AmbiguousMatchException> auftritt:  
  
-   Ein-Typ enthält zwei indizierte Eigenschaften, die denselben Namen, aber eine unterschiedliche Anzahl von Parametern aufweisen. Um die Mehrdeutigkeit aufzulösen, verwenden Sie eine Überladung der <xref:System.Type.GetProperty%2A>-Methode, die Parametertypen angibt.  
  
-   Ein abgeleiteter Typ deklariert eine Eigenschaft, die eine geerbte Eigenschaft mit demselben Namen verbirgt, indem der `new` Modifizierer (`Shadows` in Visual Basic) verwendet wird. Um die Mehrdeutigkeit aufzulösen, verwenden Sie die <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29>-Methoden Überladung, und fügen Sie das <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType>-Flag hinzu, um die Suche auf nicht geerbte Member einzuschränken.  
  
## <a name="indexers-and-default-properties"></a>Indexer und Standardeigenschaften  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft als Standardwert für den Typ. Wenn sich die Variable `myList` z. b. auf einen <xref:System.Collections.ArrayList>bezieht, ruft die Syntax `myList[3]` (`myList(3)` in Visual Basic) das-Element mit dem Index 3 ab. Sie können die-Eigenschaft überladen.  
  
 In C#wird dieses Feature als Indexer bezeichnet und kann nicht anhand des Namens bezeichnet werden. Standardmäßig wird ein C# Indexer in den Metadaten als indizierte Eigenschaft mit dem Namen "Item" angezeigt. Ein Klassen Bibliotheks Entwickler kann jedoch das <xref:System.Runtime.CompilerServices.IndexerNameAttribute>-Attribut verwenden, um den Namen des Indexers in den Metadaten zu ändern. Die <xref:System.String>-Klasse verfügt z. b. über einen Indexer namens <xref:System.String.Chars%2A>. Indizierte Eigenschaften, die mit anderen C# Sprachen als erstellt wurden, können auch andere Namen als Item aufweisen.  
  
 Um zu ermitteln, ob ein Typ eine Standard Eigenschaft aufweist, verwenden Sie die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>-Methode, um das <xref:System.Reflection.DefaultMemberAttribute>-Attribut zu testen. Wenn der Typ über <xref:System.Reflection.DefaultMemberAttribute>verfügt, gibt die <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>-Eigenschaft den Namen der Standard Eigenschaft zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das `Type`-Objekt einer benutzerdefinierten Klasse abgerufen, eine Eigenschaft dieser Klasse abgerufen und der Eigenschaften Name angezeigt.  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 Intern wird diese Eigenschaft in den Metadaten durch den Namen "Item" bezeichnet. Jeder Versuch, `PropertyInfo` mithilfe von Reflektion zu erhalten, muss diesen internen Namen angeben, damit die `PropertyInfo`-Eigenschaft ordnungsgemäß zurückgegeben wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Eigenschaften mit dem angegebenen Namen gefunden.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Eigenschaft enthält.</param>
        <param name="bindingAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.  
  
Oder 
<see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</param>
        <summary>Sucht die angegebene Eigenschaft unter Verwendung der angegebenen Bindungseinschränkungen.</summary>
        <returns>Ein Objekt, das die Eigenschaft darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Eigenschaft gilt als öffentlich für Reflektion, wenn Sie über mindestens einen öffentlichen Accessor verfügt. Andernfalls wird die-Eigenschaft als privat betrachtet, und Sie müssen &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> verwenden (in Visual Basic die Werte mithilfe `Or`kombinieren), um Sie zu erhalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Eigenschaften in die Suche eingeschlossen werden sollen:  
  
-   Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` an, um öffentliche Eigenschaften in die Suche einzubeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` an, dass nicht öffentliche Eigenschaften (d. h. private, interne und geschützte Eigenschaften) in der Suche enthalten sein sollen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` an, um `public` und `protected` statische Elemente in der Hierarchie einzuschließen. `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags>-Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:  
  
-   `BindingFlags.IgnoreCase`, die Groß-/Kleinschreibung `name`zu ignorieren.  
  
-   `BindingFlags.DeclaredOnly`, um nur die Eigenschaften zu durchsuchen, die auf dem <xref:System.Type>deklariert sind, und keine Eigenschaften, die einfach geerbt wurden  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Eigenschaften der Klassen Einschränkung.  
  
 Es gibt Situationen, in denen <xref:System.Reflection.AmbiguousMatchException> auftritt:  
  
-   Ein-Typ enthält zwei indizierte Eigenschaften, die denselben Namen, aber eine unterschiedliche Anzahl von Parametern aufweisen. Um die Mehrdeutigkeit aufzulösen, verwenden Sie eine Überladung der <xref:System.Type.GetProperty%2A>-Methode, die Parametertypen angibt.  
  
-   Ein abgeleiteter Typ deklariert eine Eigenschaft, die eine geerbte Eigenschaft mit dem gleichen Namen verbirgt, wobei der `new` Modifizierer (`Shadows` in Visual Basic) verwendet wird. Um die Mehrdeutigkeit aufzulösen, schließen Sie <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> ein, um die Suche auf Member zu beschränken, die nicht vererbt werden.  
  
## <a name="indexers-and-default-properties"></a>Indexer und Standardeigenschaften  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft als Standardwert für den Typ. Wenn sich die Variable `myList` z. b. auf einen <xref:System.Collections.ArrayList>bezieht, ruft die Syntax `myList[3]` (`myList(3)` in Visual Basic) das-Element mit dem Index 3 ab. Sie können die-Eigenschaft überladen.  
  
 In C#wird dieses Feature als Indexer bezeichnet und kann nicht anhand des Namens bezeichnet werden. Standardmäßig wird ein C# Indexer in den Metadaten als indizierte Eigenschaft mit dem Namen "Item" angezeigt. Ein Klassen Bibliotheks Entwickler kann jedoch das <xref:System.Runtime.CompilerServices.IndexerNameAttribute>-Attribut verwenden, um den Namen des Indexers in den Metadaten zu ändern. Die <xref:System.String>-Klasse verfügt z. b. über einen Indexer namens <xref:System.String.Chars%2A>. Indizierte Eigenschaften, die mit anderen C# Sprachen als erstellt wurden, können auch andere Namen als Item aufweisen.  
  
 Um zu ermitteln, ob ein Typ eine Standard Eigenschaft aufweist, verwenden Sie die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>-Methode, um das <xref:System.Reflection.DefaultMemberAttribute>-Attribut zu testen. Wenn der Typ über <xref:System.Reflection.DefaultMemberAttribute>verfügt, gibt die <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>-Eigenschaft den Namen der Standard Eigenschaft zurück.  
  
   
  
## Examples  
 Das folgende Beispiel ruft den Typ einer benutzerdefinierten Klasse ab, ruft eine Eigenschaft dieser Klasse ab und zeigt den Eigenschaftsnamen in Übereinstimmung mit den angegebenen Bindungs Einschränkungen an.  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" /></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</param>
        <param name="returnType">Der Rückgabetyp der Eigenschaft.</param>
        <summary>Sucht die öffentliche Eigenschaft mit dem angegebenen Namen und Rückgabetyp.</summary>
        <returns>Ein Objekt, das die öffentliche Eigenschaft mit dem angegebenen Namen darstellt, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Eigenschaft gilt als öffentlich für Reflektion, wenn Sie über mindestens einen öffentlichen Accessor verfügt. Andernfalls wird die-Eigenschaft als privat betrachtet, und Sie müssen &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> verwenden (in Visual Basic die Werte mithilfe `Or`kombinieren), um Sie zu erhalten.  
  
 Bei der Suche nach `name` wird die Groß-/Kleinschreibung beachtet. Die Suche umfasst öffentliche statische und öffentliche Instanzeigenschaften.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Eigenschaften der Klassen Einschränkung.  
  
## <a name="indexers-and-default-properties"></a>Indexer und Standardeigenschaften  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft als Standardwert für den Typ. Wenn sich die Variable `myList` z. b. auf einen <xref:System.Collections.ArrayList>bezieht, ruft die Syntax `myList[3]` (`myList(3)` in Visual Basic) das-Element mit dem Index 3 ab. Sie können die-Eigenschaft überladen.  
  
 In C#wird dieses Feature als Indexer bezeichnet und kann nicht anhand des Namens bezeichnet werden. Standardmäßig wird ein C# Indexer in den Metadaten als indizierte Eigenschaft mit dem Namen "Item" angezeigt. Ein Klassen Bibliotheks Entwickler kann jedoch das <xref:System.Runtime.CompilerServices.IndexerNameAttribute>-Attribut verwenden, um den Namen des Indexers in den Metadaten zu ändern. Die <xref:System.String>-Klasse verfügt z. b. über einen Indexer namens <xref:System.String.Chars%2A>. Indizierte Eigenschaften, die mit anderen C# Sprachen als erstellt wurden, können auch andere Namen als Item aufweisen.  
  
 Um zu ermitteln, ob ein Typ eine Standard Eigenschaft aufweist, verwenden Sie die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>-Methode, um das <xref:System.Reflection.DefaultMemberAttribute>-Attribut zu testen. Wenn der Typ über <xref:System.Reflection.DefaultMemberAttribute>verfügt, gibt die <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>-Eigenschaft den Namen der Standard Eigenschaft zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine-Klasse mit einer-Eigenschaft definiert, und der Name und der Typ der Eigenschaft werden abgerufen.  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Eigenschaften mit dem angegebenen Namen gefunden.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />, oder <paramref name="returnType" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.  
  
Oder 
Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</param>
        <summary>Sucht die angegebene öffentliche Eigenschaft, deren Parameter den angegebenen Argumenttypen entsprechen.</summary>
        <returns>Ein Objekt, das die öffentliche Eigenschaft darstellt, deren Parameter den angegebenen Argumenttypen entsprechen, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Eigenschaft gilt als öffentlich für Reflektion, wenn Sie über mindestens einen öffentlichen Accessor verfügt. Andernfalls wird die-Eigenschaft als privat betrachtet, und Sie müssen &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> verwenden (in Visual Basic die Werte mithilfe `Or`kombinieren), um Sie zu erhalten.  
  
 Bei der Suche nach `name` wird die Groß-/Kleinschreibung beachtet. Die Suche umfasst öffentliche statische und öffentliche Instanzeigenschaften.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Eigenschaften der Klassen Einschränkung.  
  
## <a name="indexers-and-default-properties"></a>Indexer und Standardeigenschaften  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft als Standardwert für den Typ. Wenn sich die Variable `myList` z. b. auf einen <xref:System.Collections.ArrayList>bezieht, ruft die Syntax `myList[3]` (`myList(3)` in Visual Basic) das-Element mit dem Index 3 ab. Sie können die-Eigenschaft überladen.  
  
 In C#wird dieses Feature als Indexer bezeichnet und kann nicht anhand des Namens bezeichnet werden. Standardmäßig wird ein C# Indexer in den Metadaten als indizierte Eigenschaft mit dem Namen "Item" angezeigt. Ein Klassen Bibliotheks Entwickler kann jedoch das <xref:System.Runtime.CompilerServices.IndexerNameAttribute>-Attribut verwenden, um den Namen des Indexers in den Metadaten zu ändern. Die <xref:System.String>-Klasse verfügt z. b. über einen Indexer namens <xref:System.String.Chars%2A>. Indizierte Eigenschaften, die mit anderen C# Sprachen als erstellt wurden, können auch andere Namen als Item aufweisen.  
  
 Um zu ermitteln, ob ein Typ eine Standard Eigenschaft aufweist, verwenden Sie die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>-Methode, um das <xref:System.Reflection.DefaultMemberAttribute>-Attribut zu testen. Wenn der Typ über <xref:System.Reflection.DefaultMemberAttribute>verfügt, gibt die <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>-Eigenschaft den Namen der Standard Eigenschaft zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird das `Type`-Objekt einer benutzerdefinierten Klasse abgerufen, die-Eigenschaft dieser Klasse abgerufen und der Eigenschaftsname und der Typ der Eigenschaft entsprechend der Angabe der an `GetProperty`über gebenden Argumente angezeigt.  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Argumenttypen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />  
  
Oder 
 <paramref name="types" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.</exception>
        <exception cref="T:System.NullReferenceException">Ein Element von <paramref name="types" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</param>
        <param name="returnType">Der Rückgabetyp der Eigenschaft.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.  
  
Oder 
Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</param>
        <summary>Sucht die angegebene öffentliche Eigenschaft, deren Parameter den angegebenen Argumenttypen entsprechen.</summary>
        <returns>Ein Objekt, das die öffentliche Eigenschaft darstellt, deren Parameter den angegebenen Argumenttypen entsprechen, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Eigenschaft gilt als öffentlich für Reflektion, wenn Sie über mindestens einen öffentlichen Accessor verfügt. Andernfalls wird die-Eigenschaft als privat betrachtet, und Sie müssen &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> verwenden (in Visual Basic die Werte mithilfe `Or`kombinieren), um Sie zu erhalten.  
  
 Bei der Suche nach `name` wird die Groß-/Kleinschreibung beachtet. Die Suche umfasst öffentliche statische und öffentliche Instanzeigenschaften.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Eigenschaften der Klassen Einschränkung.  
  
## <a name="indexers-and-default-properties"></a>Indexer und Standardeigenschaften  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft als Standardwert für den Typ. Wenn sich die Variable `myList` z. b. auf einen <xref:System.Collections.ArrayList>bezieht, ruft die Syntax `myList[3]` (`myList(3)` in Visual Basic) das-Element mit dem Index 3 ab. Sie können die-Eigenschaft überladen.  
  
 In C#wird dieses Feature als Indexer bezeichnet und kann nicht anhand des Namens bezeichnet werden. Standardmäßig wird ein C# Indexer in den Metadaten als indizierte Eigenschaft mit dem Namen "Item" angezeigt. Ein Klassen Bibliotheks Entwickler kann jedoch das <xref:System.Runtime.CompilerServices.IndexerNameAttribute>-Attribut verwenden, um den Namen des Indexers in den Metadaten zu ändern. Die <xref:System.String>-Klasse verfügt z. b. über einen Indexer namens <xref:System.String.Chars%2A>. Indizierte Eigenschaften, die mit anderen C# Sprachen als erstellt wurden, können auch andere Namen als Item aufweisen.  
  
 Um zu ermitteln, ob ein Typ eine Standard Eigenschaft aufweist, verwenden Sie die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>-Methode, um das <xref:System.Reflection.DefaultMemberAttribute>-Attribut zu testen. Wenn der Typ über <xref:System.Reflection.DefaultMemberAttribute>verfügt, gibt die <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>-Eigenschaft den Namen der Standard Eigenschaft zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Argumenttypen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />  
  
Oder 
 <paramref name="types" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.</exception>
        <exception cref="T:System.NullReferenceException">Ein Element von <paramref name="types" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="returnType" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden öffentlichen Eigenschaft enthält.</param>
        <param name="returnType">Der Rückgabetyp der Eigenschaft.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.  
  
Oder 
Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht die angegebene öffentliche Eigenschaft, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein Objekt, das die öffentliche Eigenschaft darstellt, die den angegebenen Anforderungen entspricht, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Eigenschaft gilt als öffentlich für Reflektion, wenn Sie über mindestens einen öffentlichen Accessor verfügt. Andernfalls wird die-Eigenschaft als privat betrachtet, und Sie müssen &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> verwenden (in Visual Basic die Werte mithilfe `Or`kombinieren), um Sie zu erhalten.  
  
 Der Standard Binder verarbeitet zwar nicht <xref:System.Reflection.ParameterModifier> (den `modifiers`-Parameter), Sie können jedoch die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType>-Klasse verwenden, um einen benutzerdefinierten Binder zu schreiben, der `modifiers`verarbeitet. `ParameterModifier` wird nur beim Aufrufen über COM-Interop verwendet, und nur Parameter, die als Verweis übermittelt werden, werden behandelt.  
  
 Bei der Suche nach `name` wird die Groß-/Kleinschreibung beachtet. Die Suche umfasst öffentliche statische und öffentliche Instanzeigenschaften.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Eigenschaften der Klassen Einschränkung.  
  
## <a name="indexers-and-default-properties"></a>Indexer und Standardeigenschaften  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft als Standardwert für den Typ. Wenn sich die Variable `myList` z. b. auf einen <xref:System.Collections.ArrayList>bezieht, ruft die Syntax `myList[3]` (`myList(3)` in Visual Basic) das-Element mit dem Index 3 ab. Sie können die-Eigenschaft überladen.  
  
 In C#wird dieses Feature als Indexer bezeichnet und kann nicht anhand des Namens bezeichnet werden. Standardmäßig wird ein C# Indexer in den Metadaten als indizierte Eigenschaft mit dem Namen "Item" angezeigt. Ein Klassen Bibliotheks Entwickler kann jedoch das <xref:System.Runtime.CompilerServices.IndexerNameAttribute>-Attribut verwenden, um den Namen des Indexers in den Metadaten zu ändern. Die <xref:System.String>-Klasse verfügt z. b. über einen Indexer namens <xref:System.String.Chars%2A>. Indizierte Eigenschaften, die mit anderen C# Sprachen als erstellt wurden, können auch andere Namen als Item aufweisen.  
  
 Um zu ermitteln, ob ein Typ eine Standard Eigenschaft aufweist, verwenden Sie die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>-Methode, um das <xref:System.Reflection.DefaultMemberAttribute>-Attribut zu testen. Wenn der Typ über <xref:System.Reflection.DefaultMemberAttribute>verfügt, gibt die <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>-Eigenschaft den Namen der Standard Eigenschaft zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein `Type` Objekt abgerufen, das `MyPropertyClass`entspricht, und die indizierte-Eigenschaft dieser Klasse wird mithilfe der Argumente abgerufen, die an die `GetProperty`-Methode übermittelt werden.  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Argumenttypen sowie Modifizierern entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />  
  
Oder 
 <paramref name="types" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.  
  
Oder 
 <paramref name="modifiers" /> ist mehrdimensional.  
  
Oder 
 <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</exception>
        <exception cref="T:System.NullReferenceException">Ein Element von <paramref name="types" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags, binder As Binder, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Eigenschaft enthält.</param>
        <param name="bindingAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.  
  
Oder 
 <see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
Oder 
Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="returnType">Der Rückgabetyp der Eigenschaft.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.  
  
Oder 
Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht anhand der angegebenen Bindungseinschränkungen nach der angegebenen Eigenschaft, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein Objekt, das die Eigenschaft darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Eigenschaft gilt als öffentlich für Reflektion, wenn Sie über mindestens einen öffentlichen Accessor verfügt. Andernfalls wird die-Eigenschaft als privat betrachtet, und Sie müssen &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> verwenden (in Visual Basic die Werte mithilfe `Or`kombinieren), um Sie zu erhalten.  
  
 Der Standard Binder verarbeitet zwar nicht <xref:System.Reflection.ParameterModifier> (den `modifiers`-Parameter), Sie können jedoch die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType>-Klasse verwenden, um einen benutzerdefinierten Binder zu schreiben, der `modifiers`verarbeitet. `ParameterModifier` wird nur beim Aufrufen über COM-Interop verwendet, und nur Parameter, die als Verweis übermittelt werden, werden behandelt.  
  
 In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.  
  
|Mitgliedstyp|statischen|Nicht statisch|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld wird immer nach Name und Signatur ausgeblendet.|  
|Ereignis|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.|  
|Der Typ "Typ"|Nein|Nein|  
|Eigenschaft|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
  
1.  "Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen. Dies ist ein binärer Vergleich.  
  
2.  Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet. Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Eigenschaften in die Suche eingeschlossen werden sollen:  
  
-   Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` an, um öffentliche Eigenschaften in die Suche einzubeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` an, dass nicht öffentliche Eigenschaften (d. h. private, interne und geschützte Eigenschaften) in der Suche enthalten sein sollen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` an, um `public` und `protected` statische Elemente in der Hierarchie einzuschließen. `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags>-Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:  
  
-   `BindingFlags.IgnoreCase`, die Groß-/Kleinschreibung `name`zu ignorieren.  
  
-   `BindingFlags.DeclaredOnly`, um nur die Eigenschaften zu durchsuchen, die auf dem <xref:System.Type>deklariert sind, und keine Eigenschaften, die einfach geerbt wurden  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Methode die <xref:System.Reflection.PropertyInfo> mit den Typparametern zurück, die durch die entsprechenden Typargumente ersetzt werden.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, durchsucht diese Methode die Eigenschaften der Klassen Einschränkung.  
  
## <a name="indexers-and-default-properties"></a>Indexer und Standardeigenschaften  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]und [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] haben eine vereinfachte Syntax für den Zugriff auf indizierte Eigenschaften und ermöglichen eine indizierte Eigenschaft als Standardwert für den Typ. Wenn sich die Variable `myList` z. b. auf einen <xref:System.Collections.ArrayList>bezieht, ruft die Syntax `myList[3]` (`myList(3)` in Visual Basic) das-Element mit dem Index 3 ab. Sie können die-Eigenschaft überladen.  
  
 In C#wird dieses Feature als Indexer bezeichnet und kann nicht anhand des Namens bezeichnet werden. Standardmäßig wird ein C# Indexer in den Metadaten als indizierte Eigenschaft mit dem Namen "Item" angezeigt. Ein Klassen Bibliotheks Entwickler kann jedoch das <xref:System.Runtime.CompilerServices.IndexerNameAttribute>-Attribut verwenden, um den Namen des Indexers in den Metadaten zu ändern. Die <xref:System.String>-Klasse verfügt z. b. über einen Indexer namens <xref:System.String.Chars%2A>. Indizierte Eigenschaften, die mit anderen C# Sprachen als erstellt wurden, können auch andere Namen als Item aufweisen.  
  
 Um zu ermitteln, ob ein Typ eine Standard Eigenschaft aufweist, verwenden Sie die <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29>-Methode, um das <xref:System.Reflection.DefaultMemberAttribute>-Attribut zu testen. Wenn der Typ über <xref:System.Reflection.DefaultMemberAttribute>verfügt, gibt die <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A>-Eigenschaft den Namen der Standard Eigenschaft zurück.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />  
  
Oder 
 <paramref name="types" /> ist <see langword="null" /></exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.  
  
Oder 
 <paramref name="modifiers" /> ist mehrdimensional.  
  
Oder 
 <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</exception>
        <exception cref="T:System.NullReferenceException">Ein Element von <paramref name="types" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetPropertyImpl (name As String, bindingAttr As BindingFlags, binder As Binder, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="returnType" Type="System.Type" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="types" Type="System.Type[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen der abzurufenden Eigenschaft enthält.</param>
        <param name="bindingAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird.  
  
Oder 
 <see cref="F:System.Reflection.BindingFlags.Default" />, damit <see langword="null" /> zurückgegeben wird.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl eines überladenen Members, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
Oder 
Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll.</param>
        <param name="returnType">Der Rückgabetyp der Eigenschaft.</param>
        <param name="types">Ein Array von <see cref="T:System.Type" />-Objekten, die Anzahl, Reihenfolge und Typ der Parameter der abzurufenden indizierten Eigenschaft darstellen.  
  
Oder 
Ein leeres Array vom <see cref="T:System.Type" />-Typ, d. h. Type[] types = new Type[0], zum Abrufen einer nicht indizierten Eigenschaft.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="types" />-Array zugeordnet sind. Der Standardbinder verarbeitet diesen Parameter nicht.</param>
        <summary>Sucht beim Überschreiben in einer abgeleiteten Klasse unter Verwendung der angegebenen Bindungseinschränkungen nach der angegebenen Eigenschaft, deren Parameter den angegebenen Argumenttypen und -modifizierern entsprechen.</summary>
        <returns>Ein Objekt, das die Eigenschaft darstellt, die den angegebenen Anforderungen entspricht, sofern diese gefunden wird. Andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standard Binder verarbeitet zwar nicht <xref:System.Reflection.ParameterModifier> (den `modifiers`-Parameter), Sie können jedoch die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType>-Klasse verwenden, um einen benutzerdefinierten Binder zu schreiben, der `modifiers`verarbeitet. `ParameterModifier` wird nur beim Aufrufen über COM-Interop verwendet, und nur Parameter, die als Verweis übermittelt werden, werden behandelt.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Eigenschaften in die Suche eingeschlossen werden sollen:  
  
-   Sie müssen entweder `BindingFlags.Instance` oder `BindingFlags.Static` angeben, um eine Rückgabe zu erhalten.  
  
-   Geben Sie `BindingFlags.Public` an, um öffentliche Eigenschaften in die Suche einzubeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` an, dass nicht öffentliche Eigenschaften (d. h. private, interne und geschützte Eigenschaften) in der Suche enthalten sein sollen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` an, um `public` und `protected` statische Elemente in der Hierarchie einzuschließen. `private` statische Member in geerbten Klassen sind nicht enthalten.  
  
 Die folgenden <xref:System.Reflection.BindingFlags>-Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:  
  
-   `BindingFlags.IgnoreCase`, die Groß-/Kleinschreibung `name`zu ignorieren.  
  
-   `BindingFlags.DeclaredOnly`, um nur die Eigenschaften zu durchsuchen, die auf dem <xref:System.Type>deklariert sind, und keine Eigenschaften, die einfach geerbt wurden  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Es wurden mehrere Eigenschaften gefunden, die den angegebenen Namen aufweisen und den angegebenen Bindungseinschränkungen entsprechen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />  
  
Oder 
 <paramref name="types" /> ist <see langword="null" />  
  
Oder 
Eines der Elemente in <paramref name="types" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="types" /> ist mehrdimensional.  
  
Oder 
 <paramref name="modifiers" /> ist mehrdimensional.  
  
Oder 
 <paramref name="types" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.</exception>
        <exception cref="T:System.NotSupportedException">Der aktuelle Typ ist ein <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" /> oder <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Type" />-Objekt ab, das den angegebenen Typ darstellt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="type.GetType " />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den aktuellen <see cref="T:System.Type" /> ab.</summary>
        <returns>Der aktuelle <see cref="T:System.Type" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <altmember cref="T:System.TypeLoadException" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/specifying-fully-qualified-type-names">Angeben vollständig gekennzeichneter Typnamen</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member GetType : string -&gt; Type" Usage="System.Type.GetType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName">Der durch die Assembly bezeichnete Name des abzurufenden Typs. Siehe <see cref="P:System.Type.AssemblyQualifiedName" />. Wenn sich der Typ in der aktuell ausgeführten Assembly oder mscorlib.dll/System.Private.CoreLib.dll befindet, ist eine Angabe des Typnamens einschließlich des qualifizierenden Namespace ausreichend.</param>
        <summary>Ruft den <see cref="T:System.Type" /> mit dem angegebenen Namen ab. Bei der Suche wird die Groß-/Kleinschreibung beachtet.</summary>
        <returns>Der Typ mit dem angegebenen Namen, sofern gefunden, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Type.GetType%2A>-Methode verwenden, um ein <xref:System.Type> Objekt für einen Typ in einer anderen Assembly zu erhalten, wenn Sie den durch die Assembly qualifizierten Namen kennen, der aus <xref:System.Type.AssemblyQualifiedName>abgerufen werden kann. <xref:System.Type.GetType%2A> bewirkt, dass die in `typeName`angegebene Assembly geladen wird. Sie können eine Assembly auch mit der <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>-Methode laden und dann die <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>-oder <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>-Methode verwenden, um <xref:System.Type> Objekte zu erhalten. Wenn ein Typ in einer Assembly ist, die dem Programm zur Kompilierzeit bekannt ist, ist es effizienter, `typeof` C# in oder den `GetType`-Operator in Visual Basic zu verwenden.
  
> [!NOTE]
>  Wenn `typeName` nicht gefunden werden kann, gibt der <xref:System.Type.GetType%28System.String%29>-Methode `null`zurück. Es wird keine Ausnahme ausgelöst. Um zu steuern, ob eine Ausnahme ausgelöst wird, müssen Sie eine Überladung der <xref:System.Type.GetType%2A>-Methode aufrufen, die über einen `throwOnError`-Parameter verfügt.  
  
 <xref:System.Type.GetType%2A> funktioniert nur für Assemblys, die vom Datenträger geladen werden Wenn Sie <xref:System.Type.GetType%2A> aufgerufen werden, um einen Typ zu suchen, der in einer dynamischen Assembly definiert ist, die mithilfe der <xref:System.Reflection.Emit> Services definiert wurde, kann das Verhalten nicht konsistent sein. Das Verhalten hängt davon ab, ob die dynamische Assembly permanent ist, d. h. mit den `RunAndSave`-oder `Save` Zugriffs Modi der <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>-Enumeration erstellt wird. Wenn die dynamische Assembly permanent ist und auf den Datenträger geschrieben wurde, bevor `GetType` aufgerufen wird, sucht das Lade Modul die gespeicherte Assembly auf dem Datenträger, lädt diese Assembly und ruft den Typ aus dieser Assembly ab. Wenn die Assembly nicht auf dem Datenträger gespeichert wurde, wenn `GetType` aufgerufen wird, gibt die Methode `null`zurück. `GetType` versteht keine vorübergehenden dynamischen Assemblys. Daher gibt das Aufrufen von `GetType` zum Abrufen eines Typs in einer vorübergehenden dynamischen Assembly `null`zurück.  
  
 Wenn Sie `GetType` für ein dynamisches Modul verwenden möchten, abonnieren Sie das <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>-Ereignis, und wenden Sie `GetType` vor dem Speichern an. Andernfalls erhalten Sie zwei Kopien der Assembly im Arbeitsspeicher.  
  
 In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.  
  
|Mitgliedstyp|statischen|Nicht statisch|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld wird immer nach Name und Signatur ausgeblendet.|  
|Ereignis|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.|  
|Der Typ "Typ"|Nein|Nein|  
|Eigenschaft|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
  
1.  "Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen. Dies ist ein binärer Vergleich.  
  
2.  Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet. Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Arrays oder COM-Typen werden nicht durchsucht, es sei denn, Sie wurden bereits in die Tabelle der verfügbaren Klassen geladen.  
  
 `typeName` kann der durch Ihren Namespace qualifizierte Typname oder ein durch die Assembly qualifizierter Name sein, der eine Assemblynamensspezifikation enthält. Siehe <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Wenn `typeName` den Namespace, jedoch nicht den Assemblynamen enthält, durchsucht diese Methode nur die Assembly des aufrufenden Objekts und die Datei "mscorlib. dll/System. private. Corelib. dll" in dieser Reihenfolge. Wenn tygtame vollständig mit dem Assemblynamen partiell oder vollständig qualifiziert ist, sucht diese Methode in der angegebenen Assembly. Wenn die Assembly einen starken Namen hat, ist ein vollständiger AssemblyName erforderlich.  
  
 Die <xref:System.Type.AssemblyQualifiedName%2A>-Eigenschaft gibt einen voll qualifizierten Typnamen zurück, einschließlich der-Typen, der Assemblynamen und der generischen Typargumente. Alle Compiler, die die Common Language Runtime unterstützen, geben den einfachen Namen einer geschachtelten Klasse aus, und die Reflektion erstellt bei der Abfrage einen geschachtelten Namen in Übereinstimmung mit den folgenden Konventionen.  
  
> [!NOTE]
>  In der .NET Framework Version 2,0 wird die Prozessorarchitektur der Assemblyidentität hinzugefügt und kann als Teil der assemblynamenszeichenfolgen angegeben werden. Beispiel: "ProcessorArchitecture = msil". Aus Kompatibilitätsgründen ist Sie jedoch nicht in der Zeichenfolge enthalten, die von der <xref:System.Type.AssemblyQualifiedName%2A>-Eigenschaft zurückgegeben wird. Sie können auch Typen laden, indem Sie ein <xref:System.Reflection.AssemblyName> Objekt erstellen und es an eine entsprechende Überladung der <xref:System.Reflection.Assembly.Load%2A> Methode übergeben. Anschließend können Sie die <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>-Methode verwenden, um Typen aus der Assembly zu laden. Siehe auch <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Trennzeichen|Bedeutung|  
|---------------|-------------|  
|Umgekehrter Schrägstrich (\\)|Escapezeichen.|  
|Backtick (')|Geht einer oder mehreren Ziffern vorangestellt, die die Anzahl der Typparameter darstellen, die sich am Ende des Namens eines generischen Typs befinden.|  
|Eckige Klammern ([])|Umschließen einer generischen Typargument Liste für einen konstruierten generischen Typ; Schließen Sie in einer Typargument Liste einen assemblyqualifizierten Typ ein.|  
|Komma (,)|Geht vor dem Assemblynamen.|  
|Punkt (.)|Bezeichnet Namespace Bezeichner.|  
|Pluszeichen (+)|Geht einer-Klasse vorangestellt.|  
  
 Der voll qualifizierte Name für eine Klasse könnte beispielsweise wie folgt aussehen:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Wenn der Namespace ein TopNamespace. Sub +-Namespace wäre, müsste die Zeichenfolge dem Pluszeichen (+) mit einem Escapezeichen (\\) vorangestellt werden, um zu verhindern, dass es als Schachtelungs Trennzeichen interpretiert wird. Die Reflektion gibt diese Zeichenfolge wie folgt aus:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Ein "+ +" wird zu "\\+\\+", und ein "\\" wird zu "\\\\".  
  
 Dieser qualifizierte Name kann persistent gespeichert und später verwendet werden, um die <xref:System.Type>zu laden. Um eine <xref:System.Type>zu suchen und zu laden, verwenden Sie <xref:System.Type.GetType%2A> entweder mit dem Typnamen oder mit dem qualifizierten Assemblynamen. <xref:System.Type.GetType%2A> mit dem Typnamen werden nur in der Assembly des Aufrufers und dann in der Systemassembly nach der <xref:System.Type> gesucht. <xref:System.Type.GetType%2A> mit dem qualifizierten Assemblynamen für die Assembly sucht in einer beliebigen Assembly nach der <xref:System.Type>.  
  
 Typnamen können nachfolgende Zeichen enthalten, die zusätzliche Informationen über den Typ angeben, z. b. ob der Typ ein Verweistyp, ein Zeigertyp oder ein Arraytyp ist. Um den Typnamen ohne diese nachfolgenden Zeichen abzurufen, verwenden Sie `t.GetElementType().ToString()`, wobei `t` der Typ ist.  
  
 Leerzeichen sind in allen Typnamen Komponenten mit Ausnahme des Assemblynamens relevant. Im Assemblynamen sind Leerzeichen vor dem Trennzeichen ', ' relevant, Leerzeichen nach dem Trennzeichen ', ' werden jedoch ignoriert.  
  
 Der Name eines generischen Typs endet mit einem Graviszeichen (\`), gefolgt von Ziffern, die die Anzahl der generischen Typargumente darstellen. Der Zweck dieses Namens besteht darin, Compiler die Unterstützung generischer Typen mit dem gleichen Namen, jedoch mit unterschiedlicher Anzahl von Typparametern, die im gleichen Bereich auftreten, zuzulassen. Reflektion gibt z. b. die geschalteten Namen `Tuple`1` and `Tupel`2` aus den generischen Methoden `Tuple(Of T)` und `Tuple(Of T0, T1)` Visual Basic, oder `Tuple<T>` und Tupel C#`\<T0, T1>` in Visual.  
  
 Bei generischen Typen wird die Typargument Liste in eckige Klammern eingeschlossen, und die Typargumente werden durch Kommas getrennt. Beispielsweise verfügt ein generisches <xref:System.Collections.Generic.Dictionary%602> über zwei Typparameter. Eine <xref:System.Collections.Generic.Dictionary%602> `MyType` mit Schlüsseln des Typs <xref:System.String> könnte wie folgt dargestellt werden:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Um einen durch die Assembly qualifizierten Typ innerhalb einer Typargument Liste anzugeben, schließen Sie den durch die Assembly qualifizierten Typ in eckige Klammern ein. Andernfalls werden die Kommas, die die Teile des durch die Assembly qualifizierten Namens trennen, als Grenzen zusätzlicher Typargumente interpretiert. Beispielsweise kann eine <xref:System.Collections.Generic.Dictionary%602> `MyType` frommyassembly. dll mit Schlüsseln vom Typ <xref:System.String>wie folgt angegeben werden:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Ein durch eine Assembly qualifizierter Typ kann nur in eckige Klammern eingeschlossen werden, wenn er in einer Typparameter Liste angezeigt wird. Die Regeln zum Durchsuchen von Assemblys für qualifizierte und nicht qualifizierte Typen in Typparameter Listen sind identisch mit den Regeln für qualifizierte und nicht qualifizierte nicht generische Typen.  
  
 Typen, die NULL-Werte zulassen, sind Sonderfälle von generischen Typen. Beispielsweise wird eine <xref:System.Int32>, die NULL-Werte zulässt, durch die Zeichenfolge "System. Werte zulässt ' 1 [System. Int32]" dargestellt.  
  
> [!NOTE]
>  In C#, C++und Visual Basic Sie mit Typoperatoren auch Typen, die NULL-Werte zulassen, erhalten. Beispielsweise wird der <xref:System.Boolean> Typ, der NULL-Werte zulässt, C#von `typeof(Nullable<bool>)` in, C++durch `Nullable<Boolean>::typeid` in und durch `GetType(Nullable(Of Boolean))` in Visual Basic zurückgegeben.  
  
 Die folgende Tabelle zeigt die Syntax, die Sie mit `GetType` für verschiedene Typen verwenden.  
  
|So erhalten Sie|Zweck|  
|------------|---------|  
|Ein <xref:System.Int32> der NULL-Werte zulassen|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|Ein nicht verwalteter Zeiger auf `MyType`|`Type.GetType("MyType*")`|  
|Ein nicht verwalteter Zeiger auf einen Zeiger auf `MyType`|`Type.GetType("MyType**")`|  
|Ein verwalteter Zeiger oder Verweis auf `MyType`|[https://login.microsoftonline.com/consumers/](`Type.GetType("MyType&")`). Beachten Sie, dass Verweise im Gegensatz zu Zeigern auf eine Ebene beschränkt sind.|  
|Eine übergeordnete Klasse und eine nicht erbt Klasse|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Ein eindimensionales Array mit einer unteren Grenze von 0.|`Type.GetType("MyType[]")`|  
|Ein eindimensionales Array mit einer unbekannten unteren Grenze.|`Type.GetType("MyType[*]")`|  
|Ein n-dimensionales Array|Ein Komma (,) innerhalb der eckige Klammern, das insgesamt n-1 Mal ist. `System.Object[,,]` stellt z. b. ein dreidimensionales `Object` Array dar.|  
|Ein Array von eindimensionalen Arrays|`Type.GetType("MyType[][]")`|  
|Ein rechteckiges zweidimensionales Array mit unbekannten unteren Begrenzungen|`Type.GetType("MyType[,]")`|  
|Ein generischer Typ mit einem Typargument.|``Type.GetType("MyGenericType`1[MyType]")``|  
|Ein generischer Typ mit zwei Typargumenten.|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|Ein generischer Typ mit zwei durch die Assembly qualifizierten Typargumenten.|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|Ein durch eine Assembly qualifizierter generischer Typ mit einem assemblyqualifizierten Typargument.|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|Ein generischer Typ, dessen Typargument ein generischer Typ mit zwei Typargumenten ist|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Typ `System.Int32` abgerufen und mithilfe dieses Type-Objekts die <xref:System.Type.FullName%2A>-Eigenschaft von `System.Int32`angezeigt.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.  
  
Oder 
 <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.  
  
Oder 
 <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.IO.IOException" /> ab.  
  
</para>
          </block>  
  
 Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.  
  
 Oder  
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und die Assembly wurde mit einer höheren Version kompiliert.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/specifying-fully-qualified-type-names">Angeben vollständig gekennzeichneter Typnamen</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName">Der durch die Assembly bezeichnete Name des abzurufenden Typs. Siehe <see cref="P:System.Type.AssemblyQualifiedName" />. Wenn sich der Typ in der aktuell ausgeführten Assembly oder mscorlib.dll/System.Private.CoreLib.dll befindet, ist eine Angabe des Typnamens einschließlich des qualifizierenden Namespace ausreichend.</param>
        <param name="throwOnError"><see langword="true" />, damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden werden kann, <see langword="false" />, damit <see langword="null" /> zurückgegeben wird. Die Angabe von <see langword="false" /> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle. Informationen finden Sie im Abschnitt für Ausnahmen.</param>
        <summary>Ruft den <see cref="T:System.Type" /> mit dem angegebenen Namen ab. Bei der Suche wird die Groß-/Kleinschreibung beachtet. Dabei wird angegeben, ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird.</summary>
        <returns>Der Typ mit dem angegebenen Namen. Wenn der Typ nicht gefunden wird, gibt der <paramref name="throwOnError" />-Parameter an, ob <see langword="null" /> zurückgegeben oder eine Ausnahme ausgelöst wird. In einigen Fällen wird unabhängig vom Wert von <paramref name="throwOnError" /> eine Ausnahme ausgelöst. Informationen finden Sie im Abschnitt für Ausnahmen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Type.GetType%2A>-Methode verwenden, um ein <xref:System.Type> Objekt für einen Typ in einer anderen Assembly zu erhalten, wenn Sie den durch die Assembly qualifizierten Namen kennen, der aus <xref:System.Type.AssemblyQualifiedName>abgerufen werden kann. <xref:System.Type.GetType%2A> bewirkt, dass die in `typeName`angegebene Assembly geladen wird. Sie können eine Assembly auch mit der <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>-Methode laden und dann die <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>-oder <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>-Methode verwenden, um <xref:System.Type> Objekte zu erhalten. Wenn ein Typ in einer Assembly ist, die dem Programm zur Kompilierzeit bekannt ist, ist es effizienter, `typeof` C# in oder den `GetType`-Operator in Visual Basic zu verwenden.
  
 `GetType` funktioniert nur für Assemblys, die vom Datenträger geladen werden Wenn Sie `GetType` aufgerufen werden, um einen Typ zu suchen, der in einer dynamischen Assembly definiert ist, die mithilfe der <xref:System.Reflection.Emit> Services definiert wurde, kann das Verhalten nicht konsistent sein. Das Verhalten hängt davon ab, ob die dynamische Assembly permanent ist, d. h. mit den `RunAndSave`-oder `Save` Zugriffs Modi der <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>-Enumeration erstellt wird. Wenn die dynamische Assembly permanent ist und auf den Datenträger geschrieben wurde, bevor `GetType` aufgerufen wird, sucht das Lade Modul die gespeicherte Assembly auf dem Datenträger, lädt diese Assembly und ruft den Typ aus dieser Assembly ab. Wenn die Assembly nicht auf dem Datenträger gespeichert wurde, wenn `GetType` aufgerufen wird, gibt die Methode `null`zurück. `GetType` versteht keine vorübergehenden dynamischen Assemblys. Daher gibt das Aufrufen von `GetType` zum Abrufen eines Typs in einer vorübergehenden dynamischen Assembly `null`zurück.  
  
 Wenn Sie `GetType` für ein dynamisches Modul verwenden möchten, abonnieren Sie das <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>-Ereignis, und wenden Sie `GetType` vor dem Speichern an. Andernfalls erhalten Sie zwei Kopien der Assembly im Arbeitsspeicher.  
  
 Der `throwOnError`-Parameter gibt an, was geschieht, wenn der Typ nicht gefunden wird, und unterdrückt auch bestimmte andere Ausnahmebedingungen, wie im Abschnitt Ausnahmen beschrieben. Einige Ausnahmen werden unabhängig vom Wert `throwOnError`ausgelöst. Wenn der Typ z. b. gefunden wurde, aber nicht geladen werden kann, wird eine <xref:System.TypeLoadException> ausgelöst, auch wenn `throwOnError` `false`ist.  
  
 In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.  
  
|Mitgliedstyp|statischen|Nicht statisch|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld wird immer nach Name und Signatur ausgeblendet.|  
|Ereignis|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.|  
|Der Typ "Typ"|Nein|Nein|  
|Eigenschaft|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
  
1.  "Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen. Dies ist ein binärer Vergleich.  
  
2.  Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet. Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Arrays oder COM-Typen werden nicht durchsucht, es sei denn, Sie wurden bereits in die Tabelle der verfügbaren Klassen geladen.  
  
 `typeName` kann der durch Ihren Namespace qualifizierte Typname oder ein durch die Assembly qualifizierter Name sein, der eine Assemblynamensspezifikation enthält. Siehe <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Wenn `typeName` den Namespace, jedoch nicht den Assemblynamen enthält, durchsucht diese Methode nur die Assembly des aufrufenden Objekts und die Datei "mscorlib. dll/System. private. Corelib. dll" in dieser Reihenfolge. Wenn tygtame vollständig mit dem Assemblynamen partiell oder vollständig qualifiziert ist, sucht diese Methode in der angegebenen Assembly. Wenn die Assembly einen starken Namen hat, ist ein vollständiger AssemblyName erforderlich.  
  
 Die <xref:System.Type.AssemblyQualifiedName%2A>-Eigenschaft gibt einen voll qualifizierten Typnamen zurück, einschließlich der-Typen, des Assemblynamens und der generischen Argumente. Alle Compiler, die die Common Language Runtime unterstützen, geben den einfachen Namen einer geschachtelten Klasse aus, und die Reflektion erstellt bei der Abfrage einen geschachtelten Namen in Übereinstimmung mit den folgenden Konventionen.  
  
> [!NOTE]
>  In der .NET Framework Version 2,0 wird die Prozessorarchitektur der Assemblyidentität hinzugefügt und kann als Teil der assemblynamenszeichenfolgen angegeben werden. Beispiel: "ProcessorArchitecture = msil". Aus Kompatibilitätsgründen ist Sie jedoch nicht in der Zeichenfolge enthalten, die von der <xref:System.Type.AssemblyQualifiedName%2A>-Eigenschaft zurückgegeben wird. Sie können auch Typen laden, indem Sie ein <xref:System.Reflection.AssemblyName> Objekt erstellen und es an eine entsprechende Überladung der <xref:System.Reflection.Assembly.Load%2A> Methode übergeben. Anschließend können Sie die <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>-Methode verwenden, um Typen aus der Assembly zu laden. Siehe auch <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Trennzeichen|Bedeutung|  
|---------------|-------------|  
|Umgekehrter Schrägstrich (\\)|Escapezeichen.|  
|Backtick (')|Geht einer oder mehreren Ziffern vorangestellt, die die Anzahl der Typparameter darstellen, die sich am Ende des Namens eines generischen Typs befinden.|  
|Eckige Klammern ([])|Umschließen einer generischen Typargument Liste für einen konstruierten generischen Typ; Schließen Sie in einer Typargument Liste einen assemblyqualifizierten Typ ein.|  
|Komma (,)|Geht vor dem Assemblynamen.|  
|Punkt (.)|Bezeichnet Namespace Bezeichner.|  
|Pluszeichen (+)|Geht einer-Klasse vorangestellt.|  
  
 Der voll qualifizierte Name für eine Klasse könnte beispielsweise wie folgt aussehen:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Wenn der Namespace ein TopNamespace. Sub +-Namespace wäre, müsste die Zeichenfolge dem Pluszeichen (+) mit einem Escapezeichen (\\) vorangestellt werden, um zu verhindern, dass es als Schachtelungs Trennzeichen interpretiert wird. Die Reflektion gibt diese Zeichenfolge wie folgt aus:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Ein "+ +" wird zu "\\+\\+", und ein "\\" wird zu "\\\\".  
  
 Dieser qualifizierte Name kann persistent gespeichert und später verwendet werden, um die <xref:System.Type>zu laden. Um eine <xref:System.Type>zu suchen und zu laden, verwenden Sie <xref:System.Type.GetType%2A> entweder mit dem Typnamen oder mit dem qualifizierten Assemblynamen. <xref:System.Type.GetType%2A> mit dem Typnamen werden nur in der Assembly des Aufrufers und dann in der Systemassembly nach der <xref:System.Type> gesucht. <xref:System.Type.GetType%2A> mit dem qualifizierten Assemblynamen für die Assembly sucht in einer beliebigen Assembly nach der <xref:System.Type>.  
  
 Typnamen können nachfolgende Zeichen enthalten, die zusätzliche Informationen über den Typ angeben, z. b. ob der Typ ein Verweistyp, ein Zeigertyp oder ein Arraytyp ist. Um den Typnamen ohne diese nachfolgenden Zeichen abzurufen, verwenden Sie `t.GetElementType().ToString()`, wobei `t` der Typ ist.  
  
 Leerzeichen sind in allen Typnamen Komponenten mit Ausnahme des Assemblynamens relevant. Im Assemblynamen sind Leerzeichen vor dem Trennzeichen ', ' relevant, Leerzeichen nach dem Trennzeichen ', ' werden jedoch ignoriert.  
  
 Der Name eines generischen Typs endet mit einem Graviszeichen (\`), gefolgt von Ziffern, die die Anzahl der generischen Typargumente darstellen. Der Zweck dieses Namens besteht darin, Compiler die Unterstützung generischer Typen mit dem gleichen Namen, jedoch mit unterschiedlicher Anzahl von Typparametern, die im gleichen Bereich auftreten, zuzulassen. Reflektion gibt z. b. die geschalteten Namen `Tuple`1` and `Tupel`2` aus den generischen Methoden `Tuple(Of T)` und `Tuple(Of T0, T1)` Visual Basic, oder `Tuple<T>` und Tupel C#`\<T0, T1>` in Visual.  
  
 Bei generischen Typen wird die Typargument Liste in eckige Klammern eingeschlossen, und die Typargumente werden durch Kommas getrennt. Beispielsweise verfügt ein generisches <xref:System.Collections.Generic.Dictionary%602> über zwei Typparameter. Eine <xref:System.Collections.Generic.Dictionary%602> `MyType` mit Schlüsseln des Typs <xref:System.String> könnte wie folgt dargestellt werden:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Um einen durch die Assembly qualifizierten Typ innerhalb einer Typargument Liste anzugeben, schließen Sie den durch die Assembly qualifizierten Typ in eckige Klammern ein. Andernfalls werden die Kommas, die die Teile des durch die Assembly qualifizierten Namens trennen, als Grenzen zusätzlicher Typargumente interpretiert. Beispielsweise kann eine <xref:System.Collections.Generic.Dictionary%602> `MyType` aus MyAssembly. dll mit Schlüsseln vom Typ <xref:System.String>wie folgt angegeben werden:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Ein durch eine Assembly qualifizierter Typ kann nur in eckige Klammern eingeschlossen werden, wenn er in einer Typparameter Liste angezeigt wird. Die Regeln zum Durchsuchen von Assemblys für qualifizierte und nicht qualifizierte Typen in Typparameter Listen sind identisch mit den Regeln für qualifizierte und nicht qualifizierte nicht generische Typen.  
  
 Typen, die NULL-Werte zulassen, sind Sonderfälle von generischen Typen. Beispielsweise wird eine <xref:System.Int32>, die NULL-Werte zulässt, durch die Zeichenfolge "System. Werte zulässt ' 1 [System. Int32]" dargestellt.  
  
> [!NOTE]
>  In C#, C++und Visual Basic Sie mit Typoperatoren auch Typen, die NULL-Werte zulassen, erhalten. Beispielsweise wird der <xref:System.Boolean> Typ, der NULL-Werte zulässt, C#von `typeof(Nullable<bool>)` in, C++durch `Nullable<Boolean>::typeid` in und durch `GetType(Nullable(Of Boolean))` in Visual Basic zurückgegeben.  
  
 Die folgende Tabelle zeigt die Syntax, die Sie mit `GetType` für verschiedene Typen verwenden.  
  
|So erhalten Sie|Zweck|  
|------------|---------|  
|Ein <xref:System.Int32> der NULL-Werte zulassen|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|Ein nicht verwalteter Zeiger auf `MyType`|`Type.GetType("MyType*")`|  
|Ein nicht verwalteter Zeiger auf einen Zeiger auf `MyType`|`Type.GetType("MyType**")`|  
|Ein verwalteter Zeiger oder Verweis auf `MyType`|[https://login.microsoftonline.com/consumers/](`Type.GetType("MyType&")`). Beachten Sie, dass Verweise im Gegensatz zu Zeigern auf eine Ebene beschränkt sind.|  
|Eine übergeordnete Klasse und eine nicht erbt Klasse|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Ein eindimensionales Array mit einer unteren Grenze von 0.|`Type.GetType("MyArray[]")`|  
|Ein eindimensionales Array mit einer unbekannten unteren Grenze.|`Type.GetType("MyArray[*]")`|  
|Ein n-dimensionales Array|Ein Komma (,) innerhalb der eckige Klammern, das insgesamt n-1 Mal ist. `System.Object[,,]` stellt z. b. ein dreidimensionales `Object` Array dar.|  
|Array eines zweidimensionalen Arrays|`Type.GetType("MyArray[][]")`|  
|Ein rechteckiges zweidimensionales Array mit unbekannten unteren Begrenzungen|`Type.GetType("MyArray[,]")`|  
|Ein generischer Typ mit einem Typargument.|``Type.GetType("MyGenericType`1[MyType]")``|  
|Ein generischer Typ mit zwei Typargumenten.|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|Ein generischer Typ mit zwei durch die Assembly qualifizierten Typargumenten.|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|Ein durch eine Assembly qualifizierter generischer Typ mit einem assemblyqualifizierten Typargument.|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|Ein generischer Typ, dessen Typargument ein generischer Typ mit zwei Typargumenten ist|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Typ `System.Int32` abgerufen und mithilfe dieses Type-Objekts die <xref:System.Type.FullName%2A>-Eigenschaft von `System.Int32`angezeigt. Wenn ein Typobjekt auf eine Assembly verweist, die nicht vorhanden ist, wird in diesem Beispiel eine Ausnahme ausgelöst.  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.  
  
Oder 
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen. 
Oder 
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> ist eine leere Zeichenfolge.  
  
Oder 
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> stellt einen Arraytyp mit einer ungültigen Größe dar.  
  
Oder 
 <paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Syntax, beispielsweise "MyType[,*,]".  
  
Oder 
 <paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.  
  
Oder 
 <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.  
  
Oder 
 <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> ist <see langword="true" />, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 Fangen Sie in <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET für Windows Store-Apps</see> oder der <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">portablen Klassenbibliothek</see> stattdessen die Basisklassenausnahme <see cref="T:System.IO.IOException" /> ab.  
  
</para>
          </block>  
  
 Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.  
  
 Oder  
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und die Assembly wurde mit einer höheren Version kompiliert.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/specifying-fully-qualified-type-names">Angeben vollständig gekennzeichneter Typnamen</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="typeName">Der durch die Assembly bezeichnete Name des abzurufenden Typs. Siehe <see cref="P:System.Type.AssemblyQualifiedName" />. Wenn sich der Typ in der aktuell ausgeführten Assembly oder mscorlib.dll/System.Private.CoreLib.dll befindet, ist eine Angabe des Typnamens einschließlich des qualifizierenden Namespace ausreichend.</param>
        <param name="throwOnError"><see langword="true" />, damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden werden kann, <see langword="false" />, damit <see langword="null" /> zurückgegeben wird. Die Angabe von <see langword="false" /> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle. Informationen finden Sie im Abschnitt für Ausnahmen.</param>
        <param name="ignoreCase"><see langword="true" />, um ohne Beachtung der Groß-/Kleinschreibung nach <paramref name="typeName" /> zu suchen, <see langword="false" />, um mit Beachtung der Groß-/Kleinschreibung nach <paramref name="typeName" /> zu suchen.</param>
        <summary>Ruft den <see cref="T:System.Type" /> mit dem angegebenen Namen ab. Dabei wird angegeben, ob bei der Suche Groß- und Kleinschreibung berücksichtigt werden soll und ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird.</summary>
        <returns>Der Typ mit dem angegebenen Namen. Wenn der Typ nicht gefunden wird, gibt der <paramref name="throwOnError" />-Parameter an, ob <see langword="null" /> zurückgegeben oder eine Ausnahme ausgelöst wird. In einigen Fällen wird unabhängig vom Wert von <paramref name="throwOnError" /> eine Ausnahme ausgelöst. Informationen finden Sie im Abschnitt für Ausnahmen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Type.GetType%2A>-Methode verwenden, um ein <xref:System.Type> Objekt für einen Typ in einer anderen Assembly zu erhalten, wenn Sie den durch die Assembly qualifizierten Namen kennen, der aus <xref:System.Type.AssemblyQualifiedName>abgerufen werden kann. <xref:System.Type.GetType%2A> bewirkt, dass die in `typeName`angegebene Assembly geladen wird. Sie können eine Assembly auch mit der <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType>-Methode laden und dann die <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>-oder <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>-Methode verwenden, um <xref:System.Type> Objekte zu erhalten. Wenn ein Typ in einer Assembly ist, die dem Programm zur Kompilierzeit bekannt ist, ist es effizienter, `typeof` C# in oder den `GetType`-Operator in Visual Basic zu verwenden.
  
 `GetType` funktioniert nur für Assemblys, die vom Datenträger geladen werden Wenn Sie `GetType` aufgerufen werden, um einen Typ zu suchen, der in einer dynamischen Assembly definiert ist, die mithilfe der <xref:System.Reflection.Emit> Services definiert wurde, kann das Verhalten nicht konsistent sein. Das Verhalten hängt davon ab, ob die dynamische Assembly permanent ist, d. h. mit den `RunAndSave`-oder `Save` Zugriffs Modi der <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType>-Enumeration erstellt wird. Wenn die dynamische Assembly permanent ist und auf den Datenträger geschrieben wurde, bevor `GetType` aufgerufen wird, sucht das Lade Modul die gespeicherte Assembly auf dem Datenträger, lädt diese Assembly und ruft den Typ aus dieser Assembly ab. Wenn die Assembly nicht auf dem Datenträger gespeichert wurde, wenn `GetType` aufgerufen wird, gibt die Methode `null`zurück. `GetType` versteht keine vorübergehenden dynamischen Assemblys. Daher gibt das Aufrufen von `GetType` zum Abrufen eines Typs in einer vorübergehenden dynamischen Assembly `null`zurück.  
  
 Wenn Sie `GetType` für ein dynamisches Modul verwenden möchten, abonnieren Sie das <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType>-Ereignis, und wenden Sie `GetType` vor dem Speichern an. Andernfalls erhalten Sie zwei Kopien der Assembly im Arbeitsspeicher.  
  
 Der `throwOnError`-Parameter gibt an, was geschieht, wenn der Typ nicht gefunden wird, und unterdrückt auch bestimmte andere Ausnahmebedingungen, wie im Abschnitt Ausnahmen beschrieben. Einige Ausnahmen werden unabhängig vom Wert `throwOnError`ausgelöst. Wenn der Typ z. b. gefunden wurde, aber nicht geladen werden kann, wird eine <xref:System.TypeLoadException> ausgelöst, auch wenn `throwOnError` `false`ist.  
  
 In der folgenden Tabelle wird gezeigt, welche Member einer Basisklasse von den `Get` Methoden zurückgegeben werden, wenn ein Typ reflektiert wird.  
  
|Mitgliedstyp|statischen|Nicht statisch|  
|-----------------|------------|-----------------|  
|Konstruktor|Nein|Nein|  
|Feld|Nein|Ja. Ein Feld wird immer nach Name und Signatur ausgeblendet.|  
|Ereignis|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
|Methode|Nein|Ja. Eine Methode (sowohl virtuell als auch nicht virtuell) kann nach Namen oder nach Name und Signatur ausgeblendet werden.|  
|Der Typ "Typ"|Nein|Nein|  
|Eigenschaft|Nicht verfügbar|Die allgemeine Typsystem Regel ist, dass die Vererbung mit der der Methoden identisch ist, die die-Eigenschaft implementieren. Die Reflektion behandelt Eigenschaften als "ausblenden nach Namen" und "Signatur". Siehe Hinweis 2 weiter unten.|  
  
1.  "Hide-by-Name-and-Signature" berücksichtigt alle Teile der Signatur, einschließlich benutzerdefinierter Modifizierer, Rückgabe Typen, Parametertypen, Sentinels und nicht verwalteter Aufruf Konventionen. Dies ist ein binärer Vergleich.  
  
2.  Für Reflektion werden Eigenschaften und Ereignisse nach Name und Signatur ausgeblendet. Wenn Sie über eine Eigenschaft verfügen, die sowohl einen get-als auch einen Set-Accessor in der Basisklasse aufweist, aber die abgeleitete Klasse nur über einen get-Accessor verfügt, blendet die Eigenschaft der abgeleiteten Klasse die Basisklassen Eigenschaft aus, und Sie können nicht auf den Setter für die Basisklasse zugreifen.  
  
3.  Benutzerdefinierte Attribute sind nicht Teil des allgemeinen Typsystems.  
  
 Arrays oder COM-Typen werden nicht durchsucht, es sei denn, Sie wurden bereits in die Tabelle der verfügbaren Klassen geladen.  
  
 `typeName` kann der durch Ihren Namespace qualifizierte Typname oder ein durch die Assembly qualifizierter Name sein, der eine Assemblynamensspezifikation enthält. Siehe <xref:System.Type.AssemblyQualifiedName%2A>.  
  
 Wenn `typeName` den Namespace, jedoch nicht den Assemblynamen enthält, durchsucht diese Methode nur die Assembly des aufrufenden Objekts und die Datei "mscorlib. dll/System. private. Corelib. dll" in dieser Reihenfolge. Wenn tygtame vollständig mit dem Assemblynamen partiell oder vollständig qualifiziert ist, sucht diese Methode in der angegebenen Assembly. Wenn die Assembly einen starken Namen hat, ist ein vollständiger AssemblyName erforderlich.  
  
 Die <xref:System.Type.AssemblyQualifiedName%2A>-Eigenschaft gibt einen voll qualifizierten Typnamen zurück, einschließlich der-Typen, des Assemblynamens und der Typargumente. Alle Compiler, die die Common Language Runtime unterstützen, geben den einfachen Namen einer geschachtelten Klasse aus, und die Reflektion erstellt bei der Abfrage einen geschachtelten Namen in Übereinstimmung mit den folgenden Konventionen.  
  
> [!NOTE]
>  In der .NET Framework Version 2,0 wird die Prozessorarchitektur der Assemblyidentität hinzugefügt und kann als Teil der assemblynamenszeichenfolgen angegeben werden. Beispiel: "ProcessorArchitecture = msil". Aus Kompatibilitätsgründen ist Sie jedoch nicht in der Zeichenfolge enthalten, die von der <xref:System.Type.AssemblyQualifiedName%2A>-Eigenschaft zurückgegeben wird. Sie können auch Typen laden, indem Sie ein <xref:System.Reflection.AssemblyName> Objekt erstellen und es an eine entsprechende Überladung der <xref:System.Reflection.Assembly.Load%2A> Methode übergeben. Anschließend können Sie die <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>-Methode verwenden, um Typen aus der Assembly zu laden. Siehe auch <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.  
  
|Trennzeichen|Bedeutung|  
|---------------|-------------|  
|Umgekehrter Schrägstrich (\\)|Escapezeichen.|  
|Backtick (')|Geht einer oder mehreren Ziffern vorangestellt, die die Anzahl der Typparameter darstellen, die sich am Ende des Namens eines generischen Typs befinden.|  
|Eckige Klammern ([])|Umschließen einer generischen Typargument Liste für einen konstruierten generischen Typ; Schließen Sie in einer Typargument Liste einen assemblyqualifizierten Typ ein.|  
|Komma (,)|Geht vor dem Assemblynamen.|  
|Punkt (.)|Bezeichnet Namespace Bezeichner.|  
|Pluszeichen (+)|Geht einer-Klasse vorangestellt.|  
  
 Der voll qualifizierte Name für eine Klasse könnte beispielsweise wie folgt aussehen:  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Wenn der Namespace ein TopNamespace. Sub +-Namespace wäre, müsste die Zeichenfolge dem Pluszeichen (+) mit einem Escapezeichen (\\) vorangestellt werden, um zu verhindern, dass es als Schachtelungs Trennzeichen interpretiert wird. Die Reflektion gibt diese Zeichenfolge wie folgt aus:  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 Ein "+ +" wird zu "\\+\\+", und ein "\\" wird zu "\\\\".  
  
 Dieser qualifizierte Name kann persistent gespeichert und später verwendet werden, um die <xref:System.Type>zu laden. Um eine <xref:System.Type>zu suchen und zu laden, verwenden Sie <xref:System.Type.GetType%2A> entweder mit dem Typnamen oder mit dem qualifizierten Assemblynamen. <xref:System.Type.GetType%2A> mit dem Typnamen werden nur in der Assembly des Aufrufers und dann in der Systemassembly nach der <xref:System.Type> gesucht. <xref:System.Type.GetType%2A> mit dem qualifizierten Assemblynamen für die Assembly sucht in einer beliebigen Assembly nach der <xref:System.Type>.  
  
 Typnamen können nachfolgende Zeichen enthalten, die zusätzliche Informationen über den Typ angeben, z. b. ob der Typ ein Verweistyp, ein Zeigertyp oder ein Arraytyp ist. Um den Typnamen ohne diese nachfolgenden Zeichen abzurufen, verwenden Sie `t.GetElementType().ToString()`, wobei `t` der Typ ist.  
  
 Leerzeichen sind in allen Typnamen Komponenten mit Ausnahme des Assemblynamens relevant. Im Assemblynamen sind Leerzeichen vor dem Trennzeichen ', ' relevant, Leerzeichen nach dem Trennzeichen ', ' werden jedoch ignoriert.  
  
 Der Name eines generischen Typs endet mit einem Graviszeichen (\`), gefolgt von Ziffern, die die Anzahl der generischen Typargumente darstellen. Der Zweck dieses Namens besteht darin, Compiler die Unterstützung generischer Typen mit dem gleichen Namen, jedoch mit unterschiedlicher Anzahl von Typparametern, die im gleichen Bereich auftreten, zuzulassen. Reflektion gibt z. b. die geschalteten Namen `Tuple`1` and `Tupel`2` aus den generischen Methoden `Tuple(Of T)` und `Tuple(Of T0, T1)` Visual Basic, oder `Tuple<T>` und Tupel C#`\<T0, T1>` in Visual.  
  
 Bei generischen Typen wird die Typargument Liste in eckige Klammern eingeschlossen, und die Typargumente werden durch Kommas getrennt. Beispielsweise verfügt ein generisches <xref:System.Collections.Generic.Dictionary%602> über zwei Typparameter. Eine <xref:System.Collections.Generic.Dictionary%602> `MyType` mit Schlüsseln des Typs <xref:System.String> könnte wie folgt dargestellt werden:  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 Um einen durch die Assembly qualifizierten Typ innerhalb einer Typargument Liste anzugeben, schließen Sie den durch die Assembly qualifizierten Typ in eckige Klammern ein. Andernfalls werden die Kommas, die die Teile des durch die Assembly qualifizierten Namens trennen, als Grenzen zusätzlicher Typargumente interpretiert. Beispielsweise kann eine <xref:System.Collections.Generic.Dictionary%602> `MyType` aus MyAssembly. dll mit Schlüsseln vom Typ <xref:System.String>wie folgt angegeben werden:  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  Ein durch eine Assembly qualifizierter Typ kann nur in eckige Klammern eingeschlossen werden, wenn er in einer Typparameter Liste angezeigt wird. Die Regeln zum Durchsuchen von Assemblys für qualifizierte und nicht qualifizierte Typen in Typparameter Listen sind identisch mit den Regeln für qualifizierte und nicht qualifizierte nicht generische Typen.  
  
 Typen, die NULL-Werte zulassen, sind Sonderfälle von generischen Typen. Beispielsweise wird eine <xref:System.Int32>, die NULL-Werte zulässt, durch die Zeichenfolge "System. Werte zulässt ' 1 [System. Int32]" dargestellt.  
  
> [!NOTE]
>  In C#, C++und Visual Basic Sie mit Typoperatoren auch Typen, die NULL-Werte zulassen, erhalten. Beispielsweise wird der <xref:System.Boolean> Typ, der NULL-Werte zulässt, C#von `typeof(Nullable<bool>)` in, C++durch `Nullable<Boolean>::typeid` in und durch `GetType(Nullable(Of Boolean))` in Visual Basic zurückgegeben.  
  
 Die folgende Tabelle zeigt die Syntax, die Sie mit `GetType` für verschiedene Typen verwenden.  
  
|So erhalten Sie|Zweck|  
|------------|---------|  
|Ein <xref:System.Int32> der NULL-Werte zulassen|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|Ein nicht verwalteter Zeiger auf `MyType`|`Type.GetType("MyType*")`|  
|Ein nicht verwalteter Zeiger auf einen Zeiger auf `MyType`|`Type.GetType("MyType**")`|  
|Ein verwalteter Zeiger oder Verweis auf `MyType`|[https://login.microsoftonline.com/consumers/](`Type.GetType("MyType&")`). Beachten Sie, dass Verweise im Gegensatz zu Zeigern auf eine Ebene beschränkt sind.|  
|Eine übergeordnete Klasse und eine nicht erbt Klasse|`Type.GetType("MyParentClass+MyNestedClass")`|  
|Ein eindimensionales Array mit einer unteren Grenze von 0.|`Type.GetType("MyArray[]")`|  
|Ein eindimensionales Array mit einer unbekannten unteren Grenze.|`Type.GetType("MyArray[*]")`|  
|Ein n-dimensionales Array|Ein Komma (,) innerhalb der eckige Klammern, das insgesamt n-1 Mal ist. `System.Object[,,]` stellt z. b. ein dreidimensionales `Object` Array dar.|  
|Array eines zweidimensionalen Arrays|`Type.GetType("MyArray[][]")`|  
|Ein rechteckiges zweidimensionales Array mit unbekannten unteren Begrenzungen|`Type.GetType("MyArray[,]")`|  
|Ein generischer Typ mit einem Typargument.|``Type.GetType("MyGenericType`1[MyType]")``|  
|Ein generischer Typ mit zwei Typargumenten.|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|Ein generischer Typ mit zwei durch die Assembly qualifizierten Typargumenten.|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|Ein durch eine Assembly qualifizierter generischer Typ mit einem assemblyqualifizierten Typargument.|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|Ein generischer Typ, dessen Typargument ein generischer Typ mit zwei Typargumenten ist|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.  
  
Oder 
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen. 
Oder 
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> ist eine leere Zeichenfolge.  
  
Oder 
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> stellt einen Arraytyp mit einer ungültigen Größe dar.  
  
Oder 
 <paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Syntax, beispielsweise "MyType[,*,]".  
  
Oder 
 <paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.  
  
Oder 
 <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.  
  
Oder 
 <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> ist <see langword="true" />, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.  
  
 Oder  
  
 Version 2.0 oder höher der Common Language Runtime ist derzeit geladen, und die Assembly wurde mit einer höheren Version kompiliert.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/specifying-fully-qualified-type-names">Angeben vollständig gekennzeichneter Typnamen</related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="typeName">Der Name des abzurufenden Typs. Wenn der <paramref name="typeResolver" />-Parameter bereitgestellt wird, kann der Typname jede Zeichenfolge sein, die vom <paramref name="typeResolver" /> aufgelöst werden kann. Wenn der <paramref name="assemblyResolver" />-Parameter bereitgestellt wird oder wenn die Standardtypauflösung verwendet wird, muss <paramref name="typeName" /> ein durch die Assembly qualifizierter Name (siehe <see cref="P:System.Type.AssemblyQualifiedName" />-Eigenschaft) sein, es sei denn, der Typ befindet sich in der gerade ausgeführten Assembly oder in mscorlib.dll/System.Private.CoreLib.dll. In diesem Fall genügt es, den von seinem Namespace qualifizierten Typnamen anzugeben.</param>
        <param name="assemblyResolver">Eine Methode, die die Assembly sucht und zurückgibt, die in <paramref name="typeName" /> angegeben wird. Der Assemblyname wird an den <paramref name="assemblyResolver" /> als ein <see cref="T:System.Reflection.AssemblyName" />-Objekt übergeben. Wenn <paramref name="typeName" /> keinen Namen einer Assembly enthält, wird der <paramref name="assemblyResolver" /> nicht aufgerufen. Wenn der <paramref name="assemblyResolver" /> nicht angegeben wird, wird die Standardassemblyauflösung ausgeführt.  
  
Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern. Andernfalls könnten Berechtigungen für bösartigen Code erweitert werden. Verwenden Sie nur Methoden, die Sie bereitstellen oder mit denen Sie vertraut sind.</param>
        <param name="typeResolver">Eine Methode, die den Typ sucht und zurückgibt, der von <paramref name="typeName" /> von der Assembly angegeben wird, die vom <paramref name="assemblyResolver" /> oder von der Standardassemblyauflösung zurückgegeben wird. Wenn keine Assembly bereitgestellt wird, kann die <paramref name="typeResolver" />-Methode eine Assembly zur Verfügung stellen. Die Methode nimmt auch einen Parameter an, der angibt, ob bei der Suche die Groß- und Kleinschreibung berücksichtigt werden soll; an diesen Parameter wird <see langword="false" /> übergeben.  
  
Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</param>
        <summary>Ruft den Typ mit dem angegebenen Namen ab und stellt optional benutzerdefinierte Methoden bereit, um die Assembly und den Typ aufzulösen.</summary>
        <returns>Der Typ mit dem angegebenen Namen oder <see langword="null" />, wenn der Typ nicht gefunden wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendungs Szenarien für diese Methode und Details zu den Parametern `assemblyResolver` und `typeResolver` finden Sie in der <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>-Methoden Überladung.  
  
> [!NOTE]
>  Wenn `typeName` nicht gefunden werden kann, gibt der <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29>-Methode `null`zurück. Es wird keine Ausnahme ausgelöst. Um zu steuern, ob eine Ausnahme ausgelöst wird, müssen Sie eine Überladung der <xref:System.Type.GetType%2A>-Methode aufrufen, die über einen `throwOnError`-Parameter verfügt.  
  
 Das Aufrufen dieser Methoden Überladung entspricht dem Aufrufen der <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>-Methoden Überladung und der Angabe von `false` für die Parameter `throwOnError` und `ignoreCase`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <exception cref="T:System.ArgumentException">Ein Fehler tritt auf, wenn <paramref name="typeName" /> in einen Typnamen und einen Assemblynamen zerlegt wird (wenn z. B. der einfache Typname ein Sonderzeichen ohne Escapezeichen enthält).  
  
Oder 
 <paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.  
  
Oder 
 <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.  
  
Oder 
 <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</exception>
        <exception cref="T:System.IO.FileLoadException">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.  
  
Oder 
 <paramref name="typeName" /> enthält einen ungültigen Assemblynamen.  
  
Oder 
 <paramref name="typeName" /> ist ein gültiger Assemblyname ohne Typnamen.</exception>
        <exception cref="T:System.BadImageFormatException">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.  
  
 Oder  
  
 Die Assembly wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="typeName">Der Name des abzurufenden Typs. Wenn der <paramref name="typeResolver" />-Parameter bereitgestellt wird, kann der Typname jede Zeichenfolge sein, die vom <paramref name="typeResolver" /> aufgelöst werden kann. Wenn der <paramref name="assemblyResolver" />-Parameter bereitgestellt wird oder wenn die Standardtypauflösung verwendet wird, muss <paramref name="typeName" /> ein durch die Assembly qualifizierter Name (siehe <see cref="P:System.Type.AssemblyQualifiedName" />-Eigenschaft) sein, es sei denn, der Typ befindet sich in der gerade ausgeführten Assembly oder in mscorlib.dll/System.Private.CoreLib.dll. In diesem Fall genügt es, den von seinem Namespace qualifizierten Typnamen anzugeben.</param>
        <param name="assemblyResolver">Eine Methode, die die Assembly sucht und zurückgibt, die in <paramref name="typeName" /> angegeben wird. Der Assemblyname wird an den <paramref name="assemblyResolver" /> als ein <see cref="T:System.Reflection.AssemblyName" />-Objekt übergeben. Wenn <paramref name="typeName" /> keinen Namen einer Assembly enthält, wird der <paramref name="assemblyResolver" /> nicht aufgerufen. Wenn der <paramref name="assemblyResolver" /> nicht angegeben wird, wird die Standardassemblyauflösung ausgeführt.  
  
Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern. Andernfalls könnten Berechtigungen für bösartigen Code erweitert werden. Verwenden Sie nur Methoden, die Sie bereitstellen oder mit denen Sie vertraut sind.</param>
        <param name="typeResolver">Eine Methode, die den Typ sucht und zurückgibt, der von <paramref name="typeName" /> von der Assembly angegeben wird, die vom <paramref name="assemblyResolver" /> oder von der Standardassemblyauflösung zurückgegeben wird. Wenn keine Assembly bereitgestellt wird, kann die Methode eine Assembly zur Verfügung stellen. Die Methode nimmt auch einen Parameter an, der angibt, ob bei der Suche die Groß- und Kleinschreibung berücksichtigt werden soll; an diesen Parameter wird <see langword="false" /> übergeben.  
  
Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</param>
        <param name="throwOnError"><see langword="true" />, damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden werden kann, <see langword="false" />, damit <see langword="null" /> zurückgegeben wird. Die Angabe von <see langword="false" /> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle. Informationen finden Sie im Abschnitt für Ausnahmen.</param>
        <summary>Ruft den Typ mit dem angegebenen Namen ab. Dabei wird angegeben, ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird, und optional werden benutzerdefinierte Methoden bereitgestellt, um die Assembly und den Typ aufzulösen.</summary>
        <returns>Der Typ mit dem angegebenen Namen. Wenn der Typ nicht gefunden wird, gibt der <paramref name="throwOnError" />-Parameter an, ob <see langword="null" /> zurückgegeben oder eine Ausnahme ausgelöst wird. In einigen Fällen wird unabhängig vom Wert von <paramref name="throwOnError" /> eine Ausnahme ausgelöst. Informationen finden Sie im Abschnitt für Ausnahmen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwendungs Szenarien für diese Methode und Details zu den Parametern `assemblyResolver` und `typeResolver` finden Sie in der <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>-Methoden Überladung.  
  
 Das Aufrufen dieser Methoden Überladung ist identisch mit dem Aufrufen der <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29>-Methoden Überladung und der Angabe von `false` für den `ignoreCase`-Parameter.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.  
  
Oder 
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen. 
Oder 
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> ist eine leere Zeichenfolge.  
  
Oder 
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> stellt einen Arraytyp mit einer ungültigen Größe dar.  
  
Oder 
 <paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</exception>
        <exception cref="T:System.ArgumentException">Ein Fehler tritt auf, wenn <paramref name="typeName" /> in einen Typnamen und einen Assemblynamen zerlegt wird (wenn z. B. der einfache Typname ein Sonderzeichen ohne Escapezeichen enthält).  
  
Oder 
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Syntax (z. B. "MyType[,*,]").  
  
Oder 
 <paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.  
  
Oder 
 <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.  
  
Oder 
 <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> ist <see langword="true" />, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.  
  
Oder 
 <paramref name="typeName" /> enthält einen ungültigen Assemblynamen.  
  
Oder 
 <paramref name="typeName" /> ist ein gültiger Assemblyname ohne Typnamen.</exception>
        <exception cref="T:System.IO.FileLoadException">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.  
  
 Oder  
  
 Die Assembly wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="typeName">Der Name des abzurufenden Typs. Wenn der <paramref name="typeResolver" />-Parameter bereitgestellt wird, kann der Typname jede Zeichenfolge sein, die vom <paramref name="typeResolver" /> aufgelöst werden kann. Wenn der <paramref name="assemblyResolver" />-Parameter bereitgestellt wird oder wenn die Standardtypauflösung verwendet wird, muss <paramref name="typeName" /> ein durch die Assembly qualifizierter Name (siehe <see cref="P:System.Type.AssemblyQualifiedName" />-Eigenschaft) sein, es sei denn, der Typ befindet sich in der gerade ausgeführten Assembly oder in mscorlib.dll/System.Private.CoreLib.dll. In diesem Fall genügt es, den von seinem Namespace qualifizierten Typnamen anzugeben.</param>
        <param name="assemblyResolver">Eine Methode, die die Assembly sucht und zurückgibt, die in <paramref name="typeName" /> angegeben wird. Der Assemblyname wird an den <paramref name="assemblyResolver" /> als ein <see cref="T:System.Reflection.AssemblyName" />-Objekt übergeben. Wenn <paramref name="typeName" /> keinen Namen einer Assembly enthält, wird der <paramref name="assemblyResolver" /> nicht aufgerufen. Wenn der <paramref name="assemblyResolver" /> nicht angegeben wird, wird die Standardassemblyauflösung ausgeführt.  
  
Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern. Andernfalls könnten Berechtigungen für bösartigen Code erweitert werden. Verwenden Sie nur Methoden, die Sie bereitstellen oder mit denen Sie vertraut sind.</param>
        <param name="typeResolver">Eine Methode, die den Typ sucht und zurückgibt, der von <paramref name="typeName" /> von der Assembly angegeben wird, die vom <paramref name="assemblyResolver" /> oder von der Standardassemblyauflösung zurückgegeben wird. Wenn keine Assembly bereitgestellt wird, kann die Methode eine Assembly zur Verfügung stellen. Die Methode nimmt auch einen Parameter an, der angibt, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll; an diesen Parameter wird der Wert von <paramref name="ignoreCase" /> übergeben.  
  
Vorsicht   Übergeben Sie keine Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern.</param>
        <param name="throwOnError"><see langword="true" />, damit eine Ausnahme ausgelöst wird, wenn der Typ nicht gefunden werden kann, <see langword="false" />, damit <see langword="null" /> zurückgegeben wird. Die Angabe von <see langword="false" /> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle. Informationen finden Sie im Abschnitt für Ausnahmen.</param>
        <param name="ignoreCase"><see langword="true" />, um ohne Beachtung der Groß-/Kleinschreibung nach <paramref name="typeName" /> zu suchen, <see langword="false" />, um mit Beachtung der Groß-/Kleinschreibung nach <paramref name="typeName" /> zu suchen.</param>
        <summary>Ruft den Typ mit dem angegebenen Namen ab. Dabei wird angegeben, ob bei der Suche die Groß-/Kleinschreibung beachtet werden soll und ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird, und optional werden benutzerdefinierte Methoden bereitgestellt, um die Assembly und den Typ aufzulösen.</summary>
        <returns>Der Typ mit dem angegebenen Namen. Wenn der Typ nicht gefunden wird, gibt der <paramref name="throwOnError" />-Parameter an, ob <see langword="null" /> zurückgegeben oder eine Ausnahme ausgelöst wird. In einigen Fällen wird unabhängig vom Wert von <paramref name="throwOnError" /> eine Ausnahme ausgelöst. Informationen finden Sie im Abschnitt für Ausnahmen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methoden Überladung und die zugehörigen über Ladungen (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> und <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>), um die Standard Implementierung der <xref:System.Type.GetType%2A>-Methode durch flexiblere Implementierungen zu ersetzen. Durch die Bereitstellung Ihrer eigenen Methoden, mit denen Typnamen und die Namen der Assemblys aufgelöst werden, die Sie enthalten, können Sie Folgendes tun:  
  
-   Steuern, aus welcher Version einer Assembly ein Typ geladen wird.  
  
-   Geben Sie einen anderen Ort an, um nach einem Typnamen zu suchen, der keinen Assemblynamen enthält.  
  
-   Lädt Assemblys mit partiellen Assemblynamen.  
  
-   Gibt Unterklassen von <xref:System.Type?displayProperty=nameWithType> zurück, die nicht vom Common Language Runtime (CLR) erstellt werden.  
  
 Bei der Versions toleranten Serialisierung können Sie mit dieser Methode z. b. nach einer "am besten geeigneten" Assembly suchen, indem Sie einen partiellen Namen verwenden. Andere über Ladungen der <xref:System.Type.GetType%2A>-Methode erfordern einen durch die Assembly qualifizierten Typnamen, der die Versionsnummer enthält.  
  
 Alternative Implementierungen des Typsystems müssen möglicherweise Unterklassen von <xref:System.Type?displayProperty=nameWithType> zurückgeben, die nicht von der CLR erstellt werden. alle Typen, die von anderen über Ladungen der <xref:System.Type.GetType%2A>-Methode zurückgegeben werden, sind Lauf Zeit Typen.  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a>Hinweise zur Verwendung  
 Diese Methoden Überladung und die zugehörigen über Ladungen analysieren `typeName` in den Namen eines Typs und den Namen einer Assembly und lösen dann die Namen auf. Die Auflösung des Assemblynamens tritt vor der Auflösung des Typnamens auf, da ein Typname im Kontext einer Assembly aufgelöst werden muss.  
  
> [!NOTE]
>  Wenn Sie mit dem Konzept der durch die Assembly qualifizierten Typnamen nicht vertraut sind, lesen Sie die <xref:System.Type.AssemblyQualifiedName%2A>-Eigenschaft.  
  
 Wenn `typeName` kein durch die Assembly qualifizierter Name ist, wird die Assemblyauflösung übersprungen. Nicht qualifizierte Typnamen können im Kontext von mscorlib. dll/System. private. Corelib. dll oder der aktuell ausgeführten Assembly aufgelöst werden, oder Sie können optional eine Assembly im `typeResolver`-Parameter bereitstellen. Die Auswirkungen, wie der AssemblyName für verschiedene Arten von Namensauflösung eingeschlossen oder weggelassen wird, werden als Tabelle im Abschnitt [gemischte Namensauflösung](#mixed_name_resolution) angezeigt.  
  
 Allgemeine Hinweise zur Verwendung:  
  
-   Übergeben Sie Methoden nicht an `assemblyResolver` oder `typeResolver`, wenn Sie von unbekannten oder nicht vertrauenswürdigen Aufrufern stammen. Verwenden Sie nur Methoden, die Sie bereitstellen oder mit denen Sie vertraut sind.  
  
    > [!CAUTION]
    >  Die Verwendung von Methoden von unbekannten oder nicht vertrauenswürdigen Aufrufern kann zu einer Erhöhung von Berechtigungen für bösartigen Code führen.  
  
-   Wenn Sie die `assemblyResolver`-und/oder `typeResolver`-Parameter weglassen, wird der Wert des `throwOnError`-Parameters an die Methoden übergeben, die die Standardauflösung durchführen.  
  
-   Wenn `throwOnError` `true`ist, löst diese Methode eine <xref:System.TypeLoadException> aus, wenn `typeResolver` `null`zurückgibt, und eine <xref:System.IO.FileNotFoundException>, wenn `assemblyResolver` `null`zurückgibt.  
  
-   Diese Methode fängt keine Ausnahmen ab, die von `assemblyResolver` und `typeResolver`ausgelöst werden. Sie sind verantwortlich für alle Ausnahmen, die von den Konflikt Löser-Methoden ausgelöst werden.  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a>Assemblys auflösen  
 Die `assemblyResolver`-Methode empfängt ein <xref:System.Reflection.AssemblyName>-Objekt, das erstellt wird, indem der Name der zeichenfolgenassembly, die in `typeName`enthalten ist, generiert wird. Wenn `typeName` keinen Assemblynamen enthält, wird `assemblyResolver` nicht aufgerufen und `null` an `typeResolver`übermittelt.  
  
 Wenn `assemblyResolver` nicht angegeben wird, wird die standardassemblyuntersuchung verwendet, um die Assembly zu suchen. Wenn `assemblyResolver` bereitgestellt wird, führt die <xref:System.Type.GetType%2A>-Methode keine Standardprüfung aus. in diesem Fall müssen Sie sicherstellen, dass Ihre `assemblyResolver` alle an Sie übergebenen Assemblys verarbeiten kann.  
  
 Die `assemblyResolver`-Methode sollte `null` zurückgeben, wenn die Assembly nicht aufgelöst werden kann. Wenn `assemblyResolver` `null`zurückgibt, wird `typeResolver` nicht aufgerufen, und es erfolgt keine weitere Verarbeitung. Wenn `throwOnError` `true`ist, wird außerdem eine <xref:System.IO.FileNotFoundException> ausgelöst.  
  
 Wenn die <xref:System.Reflection.AssemblyName>, die an `assemblyResolver` weitergegeben wird, ein partieller Name ist, werden mindestens ein Teil der Teile `null`. Wenn Sie z. b. keine Version hat, wird die <xref:System.Reflection.AssemblyName.Version%2A>-Eigenschaft `null`. Wenn die <xref:System.Reflection.AssemblyName.Version%2A>-Eigenschaft, die <xref:System.Reflection.AssemblyName.CultureInfo%2A>-Eigenschaft und die <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A>-Methode `null`zurückgeben, wurde nur der einfache Name der Assembly bereitgestellt. Die `assemblyResolver`-Methode kann alle Teile des Assemblynamens verwenden oder ignorieren.  
  
 Die Auswirkungen verschiedener Optionen für die Assemblyauflösung werden im Abschnitt [gemischte Namensauflösung](#mixed_name_resolution) als Tabelle für einfache und durch assemblyqualifizierte Typnamen angezeigt.  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a>Auflösen von Typen  
 Wenn `typeName` keinen Assemblynamen angibt, wird `typeResolver` immer aufgerufen. Wenn `typeName` einen Assemblynamen angibt, wird `typeResolver` nur aufgerufen, wenn der AssemblyName erfolgreich aufgelöst wurde. Wenn `assemblyResolver` oder die standardassemblyuntersuchung `null`zurückgibt, wird `typeResolver` nicht aufgerufen.  
  
 Die `typeResolver`-Methode empfängt drei Argumente:  
  
-   Die Assembly, die durchsucht werden soll, oder `null`, wenn `typeName` keinen Assemblynamen enthält.  
  
-   Der einfache Name des Typs. Bei einem in einem Typ eingefügten Typ ist dies der äußerste enthaltende Typ. Bei einem generischen Typ ist dies der einfache Name des generischen Typs.  
  
-   Ein boolescher Wert, der `true` ist, wenn die Groß-/Kleinschreibung von Typnamen ignoriert werden soll.  
  
 Die-Implementierung bestimmt, wie diese Argumente verwendet werden. Die `typeResolver`-Methode sollte `null` zurückgeben, wenn der Typ nicht aufgelöst werden kann. Wenn `typeResolver` `null` zurückgibt und `throwOnError` `true`ist, löst diese Überladung von <xref:System.Type.GetType%2A> eine <xref:System.TypeLoadException>aus.  
  
 Die Auswirkungen verschiedener Optionen für die Typauflösung werden als Tabelle im Abschnitt [gemischte Namensauflösung](#mixed_name_resolution) für einfache und durch assemblyqualifizierte Typnamen angezeigt.  
  
#### <a name="resolving-nested-types"></a>Auflösen von Untertypen  
 Wenn `typeName` ein Genetzter Typ ist, wird nur der Name des äußersten enthaltenden Typs an `typeResolver`übermittelt. Wenn `typeResolver` diesen Typ zurückgibt, wird die <xref:System.Type.GetNestedType%2A>-Methode rekursiv aufgerufen, bis der innerste, nicht aufgelöste Typ aufgelöst wurde.  
  
#### <a name="resolving-generic-types"></a>Auflösen von generischen Typen  
 Der <xref:System.Type.GetType%2A> wird rekursiv aufgerufen, um generische Typen aufzulösen: zunächst um den generischen Typ selbst aufzulösen und dann seine Typargumente aufzulösen. Wenn ein Typargument generisch ist, wird <xref:System.Type.GetType%2A> rekursiv aufgerufen, um die Typargumente aufzulösen, usw.  
  
 Die Kombination aus `assemblyResolver` und `typeResolver`, die Sie bereitstellen, muss in der Lage sein, alle Ebenen dieser Rekursion aufzulösen. Nehmen Sie beispielsweise an, Sie stellen eine `assemblyResolver` bereit, die das Laden von `MyAssembly`steuert. Angenommen, Sie möchten den generischen Typ `Dictionary<string, MyType>` auflösen (`Dictionary(Of String, MyType)` in Visual Basic). Sie können den folgenden generischen Typnamen übergeben:  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 Beachten Sie, dass `MyType` das einzige durch die Assembly qualifizierte Typargument ist. Die Namen der <xref:System.Collections.Generic.Dictionary%602> und <xref:System.String> Klassen sind nicht assemblyqualifiziert. Der `typeResolver` muss entweder eine Assembly oder `null`verarbeiten können, da er `null` für <xref:System.Collections.Generic.Dictionary%602> und <xref:System.String>empfängt. Dieser Fall kann verarbeitet werden, indem eine Überladung der <xref:System.Type.GetType%2A> Methode aufgerufen wird, die eine Zeichenfolge annimmt, da sich beide nicht qualifizierten Typnamen in "mscorlib. dll/System. private. Corelib. dll" befinden:  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 Die `assemblyResolver`-Methode wird nicht für den Wörter Buchtyp und den Zeichen Folgentyp aufgerufen, da diese Typnamen nicht assemblyqualifiziert sind.  
  
 Nehmen Sie nun an, dass anstelle des `System.String`der erste generische Argumenttyp aus `YourAssembly``YourType`ist:  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 Da es sich bei dieser Assembly weder um mscorlib. dll/System. private. Corelib. dll noch um die derzeit ausgeführte Assembly handelt, können `YourType` nicht ohne einen assemblyqualifizierten Namen aufgelöst werden. Da Ihre `assemblyResolve` rekursiv aufgerufen wird, muss Sie in der Lage sein, diesen Fall zu verarbeiten. Anstatt `null` für andere Assemblys als `MyAssembly`zurückzugeben, führt es nun eine assemblyauslastung mithilfe des bereitgestellten <xref:System.Reflection.AssemblyName> Objekts aus.  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 Zurück zu den [Verwendungs hinweisen](#usage_notes).  
  
#### <a name="resolving-type-names-with-special-characters"></a>Auflösen von Typnamen mit Sonderzeichen  
 Bestimmte Zeichen haben eine besondere Bedeutung in qualifizierten Assemblynamen. Wenn ein einfacher Typname diese Zeichen enthält, führen die Zeichen zu Analyse Fehlern, wenn der einfache Name Teil eines durch die Assembly qualifizierten Namens ist. Um die Analyse-Fehler zu vermeiden, müssen Sie die Sonderzeichen mit einem umgekehrten Schrägstrich versehen, bevor Sie den mit der Assembly gekennzeichneten Namen an die <xref:System.Type.GetType%2A>-Methode übergeben können. Wenn ein Typ beispielsweise `Strange]Type`benannt ist, muss das Escapezeichen wie folgt vor der eckigen Klammer eingefügt werden: `Strange\]Type`.  
  
> [!NOTE]
>  Namen mit solchen Sonderzeichen können nicht in Visual Basic oder C#erstellt werden, Sie können jedoch mithilfe von Microsoft Intermediate Language (MSIL) oder durch das Ausgeben dynamischer Assemblys erstellt werden.  
  
 In der folgenden Tabelle werden die Sonderzeichen für Typnamen angezeigt.  
  
|Zeichen|Bedeutung|  
|---------------|-------------|  
|`,` (Komma)|Trennzeichen für durch die Assembly qualifizierte Namen.|  
|`[]` (eckige Klammern)|Als suffixpaar gibt einen Arraytyp an. als Trennzeichen Paar schließt generische Argumentlisten und assemblyqualifizierte Namen ein.|  
|`&` (kaufmännisches und-Paar)|Als Suffix gibt an, dass ein Typ ein Verweistyp ist.|  
|`*` (Sternchen)|Als Suffix gibt an, dass ein Typ ein Zeigertyp ist.|  
|`+` (plus)|Trennzeichen für geschvelbte Typen.|  
|`\` (umgekehrter Schrägstrich)|Escapezeichen.|  
  
 Eigenschaften wie <xref:System.Type.AssemblyQualifiedName%2A> die Zeichen folgen mit Escapezeichen zurückgeben. Sie müssen ordnungsgemäß mit Escapezeichen versehene Zeichen folgen an <xref:System.Type.GetType%2A> die-Methode Die <xref:System.Type.GetType%2A>-Methode übergibt wiederum ordnungsgemäß Escapenamen an `typeResolver` und die Standardmethoden für die Typauflösung. Wenn Sie einen Namen in `typeResolver`mit einem Namen ohne Escapezeichen vergleichen müssen, müssen Sie die Escapezeichen entfernen.  
  
 Zurück zu den [Verwendungs hinweisen](#usage_notes).  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a>Auflösung gemischter Namen  
 In der folgenden Tabelle werden die Interaktionen zwischen `assemblyResolver`, `typeResolver`und der Standard Namensauflösung für alle Kombinationen aus Typname und Assemblyname in `typeName`zusammengefasst:  
  
|Inhalt des Typnamens|AssemblyResolver-Methode|Typresolver-Methode|Ergebnis|  
|---------------------------|------------------------------|--------------------------|------------|  
|Typ, Assembly|NULL|NULL|Äquivalent zum Aufrufen der <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>-Methoden Überladung.|  
|Typ, Assembly|bieten|NULL|`assemblyResolver` gibt die Assembly zurück oder gibt `null` zurück, wenn die Assembly nicht aufgelöst werden kann. Wenn die Assembly aufgelöst wird, wird die <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>-Methoden Überladung verwendet, um den Typ aus der Assembly zu laden. Andernfalls gibt es keinen Versuch, den Typ aufzulösen.|  
|Typ, Assembly|NULL|bieten|Äquivalent zum Umrechnen des Assemblynamens in ein <xref:System.Reflection.AssemblyName> Objekt und zum Aufrufen der <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType>-Methoden Überladung, um die Assembly zu erhalten. Wenn die Assembly aufgelöst wird, wird Sie an `typeResolver`. Andernfalls wird `typeResolver` nicht aufgerufen, und es besteht kein weiterer Versuch, den Typ aufzulösen.|  
|Typ, Assembly|bieten|bieten|`assemblyResolver` gibt die Assembly zurück oder gibt `null` zurück, wenn die Assembly nicht aufgelöst werden kann. Wenn die Assembly aufgelöst wird, wird Sie an `typeResolver`. Andernfalls wird `typeResolver` nicht aufgerufen, und es besteht kein weiterer Versuch, den Typ aufzulösen.|  
|type|NULL, bereitgestellt|NULL|Äquivalent zum Aufrufen der <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType>-Methoden Überladung. Da der Assemblyname nicht angegeben wird, werden nur "mscorlib. dll/System. private. Corelib. dll" und die derzeit ausgeführte Assembly durchsucht. Wenn `assemblyResolver` bereitgestellt wird, wird es ignoriert.|  
|type|NULL, bereitgestellt|bieten|`typeResolver` wird aufgerufen, und `null` wird für die Assembly übermittelt. `typeResolver` können einen Typ aus einer beliebigen Assembly bereitstellen, einschließlich Assemblys, die für diesen Zweck geladen werden. Wenn `assemblyResolver` bereitgestellt wird, wird es ignoriert.|  
|Assembly|NULL, bereitgestellt|NULL, bereitgestellt|Eine <xref:System.IO.FileLoadException> wird ausgelöst, da der AssemblyName so analysiert wird, als wäre er ein durch die Assembly qualifizierter Typname. Dies führt zu einem ungültigen Assemblynamen.|  
  
 Zurück zu: [Verwendungs Hinweise](#usage_notes), [Auflösen](#resolving_assemblies)von Assemblys, [Auflösen von Typen](#resolving_types).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwOnError" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.  
  
Oder 
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen. 
Oder 
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> ist eine leere Zeichenfolge.  
  
Oder 
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> stellt einen Arraytyp mit einer ungültigen Größe dar.  
  
Oder 
 <paramref name="typeName" /> stellt ein Array von <see cref="T:System.TypedReference" /> dar.</exception>
        <exception cref="T:System.ArgumentException">Ein Fehler tritt auf, wenn <paramref name="typeName" /> in einen Typnamen und einen Assemblynamen zerlegt wird (wenn z. B. der einfache Typname ein Sonderzeichen ohne Escapezeichen enthält).  
  
Oder 
 <paramref name="throwOnError" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Syntax (z. B. "MyType[,*,]").  
  
Oder 
 <paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.  
  
Oder 
 <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.  
  
Oder 
 <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwOnError" /> ist <see langword="true" />, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.  
  
Oder 
 <paramref name="typeName" /> enthält einen ungültigen Assemblynamen.  
  
Oder 
 <paramref name="typeName" /> ist ein gültiger Assemblyname ohne Typnamen.</exception>
        <exception cref="T:System.BadImageFormatException">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.  
  
 Oder  
  
 Die Assembly wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member GetTypeArray : obj[] -&gt; Type[]" Usage="System.Type.GetTypeArray args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="args">Ein Array von Objekten, deren Typen bestimmt werden sollen.</param>
        <summary>Ruft die Typen der Objekte im angegebenen Array ab.</summary>
        <returns>Ein Array von <see cref="T:System.Type" />-Objekten, die die Typen der entsprechenden Elemente in <paramref name="args" /> darstellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Type.GetTypeArray%2A>-Methode verwendet wird, um die Typen der Elemente eines Arrays aufzulisten.  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="args" /> ist <see langword="null" />  
  
Oder 
Mindestens eines der Elemente in <paramref name="args" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Die Klasseninitialisierer werden aufgerufen, und mindestens einer löst eine Ausnahme aus.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeCode (type As Type) As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetTypeCode : Type -&gt; TypeCode" Usage="System.Type.GetTypeCode type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="type">Der Typ, dessen zugrunde liegender Typcode abgerufen werden soll.</param>
        <summary>Ruft den zugrunde liegenden Typcode des angegebenen <see cref="T:System.Type" /> ab.</summary>
        <returns>Der Code des zugrunde liegenden Typs oder <see cref="F:System.TypeCode.Empty" />, wenn <paramref name="type" /><see langword="null" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie von <xref:System.Type>erben, können Sie das Verhalten dieser Methode ändern, indem Sie die <xref:System.Type.GetTypeCodeImpl%2A>-Methode überschreiben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.TypeCode>-Enumeration verwendet werden kann. In einem Entscheidungs Block innerhalb der `WriteObjectInfo`-Methode wird der <xref:System.TypeCode> eines <xref:System.Object> Parameters untersucht, und es wird eine entsprechende Meldung in die Konsole geschrieben.  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCodeImpl : unit -&gt; TypeCode&#xA;override this.GetTypeCodeImpl : unit -&gt; TypeCode" Usage="type.GetTypeCodeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den zugrunde liegenden Typcode dieser <see cref="T:System.Type" />-Instanz zurück.</summary>
        <returns>Der Typcode des zugrunde liegenden Typs.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode stellt die Implementierung für die `static` (in C#) oder `Shared` (in Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29>-Methode bereit. Wenn Sie von <xref:System.Type>erben, können Sie diese Methode überschreiben, um eine eigene Implementierung von <xref:System.Type.GetTypeCode%2A>bereitzustellen.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Typ ab, dem die angegebene Klassen-ID (CLSID) zugeordnet ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Type.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="clsid">Die CLSID des abzurufenden Typs.</param>
        <summary>Ruft den Typ ab, dem die angegebene Klassen-ID (CLSID) zugeordnet ist.</summary>
        <returns><see langword="System.__ComObject" /> unabhängig von der Gültigkeit der CLSID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetTypeFromCLSID%2A>-Methode unterstützt den spät gebundenen Zugriff auf nicht verwaltete COM-Objekte von .NET Framework-apps, wenn Sie den Klassen Bezeichner (CLSID) des COM-Objekts kennen.  Der Klassen Bezeichner für COM-Klassen wird im HKEY_CLASSES_ROOT \CLSID-Schlüssel der Registrierung definiert. Sie können den Wert der <xref:System.Type.IsCOMObject%2A>-Eigenschaft abrufen, um zu bestimmen, ob der von dieser Methode zurückgegebene Typ ein COM-Objekt ist.  
  
> [!TIP]
>  Sie können die <xref:System.Type.GetTypeFromProgID%2A>-Methode für den spät gebundenen Zugriff auf COM-Objekte aufrufen, deren Programm Bezeichner (ProgID) Sie kennen.  
  
 Das Instanziieren eines nicht verwalteten COM-Objekts aus seiner CLSID ist ein zweistufiger Prozess:  
  
1.  Rufen Sie ein <xref:System.Type> Objekt ab, das den`__ComObject` darstellt, der der CLSID entspricht, indem Sie die <xref:System.Type.GetTypeFromCLSID%2A>-Methode aufrufen.  
  
2.  Ruft die <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>-Methode auf, um das COM-Objekt zu instanziieren.  
  
 Eine Abbildung finden Sie im Beispiel.  
  
 Die <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> Überladung ignoriert alle Ausnahmen, die beim Instanziieren eines <xref:System.Type> Objekts auf der Grundlage des `clsid` Arguments auftreten können. Beachten Sie, dass keine Ausnahme ausgelöst wird, wenn `clsid` nicht in der Registrierung gefunden wurde.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die CLSID des Microsoft Word- [Anwendungs Objekts](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) zum Abrufen eines COM-Typs verwendet, der die Microsoft Word-Anwendung darstellt. Anschließend wird der Typ durch Aufrufen der <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>-Methode instanziiert und durch Aufrufen der [Application. Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) -Methode geschlossen.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Diese Methode ist für die Verwendung beim Arbeiten mit COM-Objekten gedacht, nicht für .NET Framework-Objekte. Alle verwalteten Objekte, einschließlich derjenigen, die für com sichtbar sind (d. h., Ihr <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> Attribut ist <see langword="true" />), weisen eine GUID auf, die von der <see cref="P:System.Type.GUID" />-Eigenschaft zurückgegeben wird. Obwohl die-Methode ein <see cref="T:System.Type" /> Objekt zurückgibt, das der GUID für .NET Framework-Objekte entspricht, können Sie dieses <see cref="T:System.Type" />-Objekt nicht verwenden, um eine Typinstanz zu erstellen, indem Sie die <see cref="M:System.Activator.CreateInstance(System.Type)" />-Methode aufrufen, wie im folgenden Beispiel gezeigt.  
  
[! Code-csharp[System. Type. gettypeer fromclsid # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! Code-vb[System. Type. gettypinfromclsid # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Stattdessen sollte die <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> nur zum Abrufen der GUID eines nicht verwalteten COM-Objekts verwendet werden, und das resultierende <see cref="T:System.Type" />-Objekt, das an die <see cref="M:System.Activator.CreateInstance(System.Type)" />-Methode übermittelt wird, muss ein nicht verwaltetes COM-Objekt darstellen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="clsid">Die CLSID des abzurufenden Typs.</param>
        <param name="throwOnError"><see langword="true" />, um mögliche Ausnahmen auszulösen.  
  
Oder 
 <see langword="false" />, um Ausnahmen zu ignorieren.</param>
        <summary>Ruft den Typ ab, dem die angegebene Klassen-ID (CLSID) zugeordnet ist. Dabei wird angegeben, ob bei Auftreten eines Fehlers beim Laden des Typs eine Ausnahme ausgelöst werden soll.</summary>
        <returns><see langword="System.__ComObject" /> unabhängig von der Gültigkeit der CLSID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetTypeFromCLSID%2A>-Methode unterstützt den spät gebundenen Zugriff auf nicht verwaltete COM-Objekte von .NET Framework-apps, wenn Sie den Klassen Bezeichner (CLSID) des COM-Objekts kennen.  Der Klassen Bezeichner für COM-Klassen wird im HKEY_CLASSES_ROOT \CLSID-Schlüssel der Registrierung definiert. Sie können den Wert der <xref:System.Type.IsCOMObject%2A>-Eigenschaft abrufen, um zu bestimmen, ob der von dieser Methode zurückgegebene Typ ein COM-Objekt ist.  
  
> [!TIP]
>  Sie können die <xref:System.Type.GetTypeFromProgID%2A>-Methode für den spät gebundenen Zugriff auf COM-Objekte aufrufen, deren Programm Bezeichner (ProgID) Sie kennen.  
  
 Das Instanziieren eines nicht verwalteten COM-Objekts aus seiner CLSID ist ein zweistufiger Prozess:  
  
1.  Rufen Sie ein <xref:System.Type> Objekt ab, das den `__ComObject` darstellt, der der CLSID entspricht, indem Sie die <xref:System.Type.GetTypeFromCLSID%2A>-Methode aufrufen.  
  
2.  Ruft die <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>-Methode auf, um das COM-Objekt zu instanziieren.  
  
 Eine Abbildung finden Sie im Beispiel.  
  
 Ausnahmen wie z. b. <xref:System.OutOfMemoryException> werden ausgelöst, wenn `true` für `throwOnError`angegeben werden, aber nicht für nicht registrierte CLSIDs.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die CLSID des Microsoft Word- [Anwendungs Objekts](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) zum Abrufen eines COM-Typs verwendet, der die Microsoft Word-Anwendung darstellt. Anschließend wird der Typ durch Aufrufen der <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>-Methode instanziiert und durch Aufrufen der [Application. Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) -Methode geschlossen. Eine Ausnahme wird ausgelöst, wenn beim Laden des Typs ein Fehler auftritt.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Diese Methode ist für die Verwendung beim Arbeiten mit COM-Objekten gedacht, nicht für .NET Framework-Objekte. Alle verwalteten Objekte, einschließlich derjenigen, die für com sichtbar sind (d. h., Ihr <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> Attribut ist <see langword="true" />), weisen eine GUID auf, die von der <see cref="P:System.Type.GUID" />-Eigenschaft zurückgegeben wird. Obwohl die-Methode ein <see cref="T:System.Type" /> Objekt zurückgibt, das der GUID für .NET Framework-Objekte entspricht, können Sie dieses <see cref="T:System.Type" />-Objekt nicht verwenden, um eine Typinstanz zu erstellen, indem Sie die <see cref="M:System.Activator.CreateInstance(System.Type)" />-Methode aufrufen, wie im folgenden Beispiel gezeigt.  
  
[! Code-csharp[System. Type. gettypeer fromclsid # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! Code-vb[System. Type. gettypinfromclsid # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Stattdessen sollte die <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> nur zum Abrufen der GUID eines nicht verwalteten COM-Objekts verwendet werden, und das resultierende <see cref="T:System.Type" />-Objekt, das an die <see cref="M:System.Activator.CreateInstance(System.Type)" />-Methode übermittelt wird, muss ein nicht verwaltetes COM-Objekt darstellen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="clsid">Die CLSID des abzurufenden Typs.</param>
        <param name="server">Der Server, von dem der Typ geladen werden soll. Wenn der Servername <see langword="null" /> ist, wird diese Methode automatisch auf den lokalen Computer zurückgesetzt.</param>
        <summary>Ruft den Typ, dem die angegebene Klassen-ID (CLSID) zugeordnet ist, vom angegebenen Server ab.</summary>
        <returns><see langword="System.__ComObject" /> unabhängig von der Gültigkeit der CLSID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetTypeFromCLSID%2A>-Methode unterstützt den spät gebundenen Zugriff auf nicht verwaltete COM-Objekte von .NET Framework-apps, wenn Sie den Klassen Bezeichner (CLSID) des COM-Objekts kennen.  Der Klassen Bezeichner für COM-Klassen wird im HKEY_CLASSES_ROOT \CLSID-Schlüssel der Registrierung definiert. Sie können den Wert der <xref:System.Type.IsCOMObject%2A>-Eigenschaft abrufen, um zu bestimmen, ob der von dieser Methode zurückgegebene Typ ein COM-Objekt ist.  
  
> [!TIP]
>  Sie können die <xref:System.Type.GetTypeFromProgID%2A>-Methode für den spät gebundenen Zugriff auf COM-Objekte aufrufen, deren Programm Bezeichner (ProgID) Sie kennen.  
  
 Das Instanziieren eines nicht verwalteten COM-Objekts aus seiner CLSID ist ein zweistufiger Prozess:  
  
1.  Rufen Sie ein <xref:System.Type> Objekt ab, das den `__ComObject` darstellt, der der CLSID entspricht, indem Sie die <xref:System.Type.GetTypeFromCLSID%2A>-Methode aufrufen.  
  
2.  Ruft die <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>-Methode auf, um das COM-Objekt zu instanziieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die CLSID des Microsoft Word- [Anwendungs Objekts](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) zum Abrufen eines COM-Typs verwendet, der die Microsoft Word-Anwendung von einem Server mit dem Namen computer17.Central.contoso.com darstellt. Anschließend wird der Typ durch Aufrufen der <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>-Methode instanziiert und durch Aufrufen der [Application. Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) -Methode geschlossen.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Diese Methode ist für die Verwendung beim Arbeiten mit COM-Objekten gedacht, nicht für .NET Framework-Objekte. Alle verwalteten Objekte, einschließlich derjenigen, die für com sichtbar sind (d. h., Ihr <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> Attribut ist <see langword="true" />), weisen eine GUID auf, die von der <see cref="P:System.Type.GUID" />-Eigenschaft zurückgegeben wird. Obwohl die-Methode ein <see cref="T:System.Type" /> Objekt zurückgibt, das der GUID für .NET Framework-Objekte entspricht, können Sie dieses <see cref="T:System.Type" />-Objekt nicht verwenden, um eine Typinstanz zu erstellen, indem Sie die <see cref="M:System.Activator.CreateInstance(System.Type)" />-Methode aufrufen, wie im folgenden Beispiel gezeigt.  
  
[! Code-csharp[System. Type. gettypeer fromclsid # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! Code-vb[System. Type. gettypinfromclsid # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Stattdessen sollte die <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> nur zum Abrufen der GUID eines nicht verwalteten COM-Objekts verwendet werden, und das resultierende <see cref="T:System.Type" />-Objekt, das an die <see cref="M:System.Activator.CreateInstance(System.Type)" />-Methode übermittelt wird, muss ein nicht verwaltetes COM-Objekt darstellen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="clsid">Die CLSID des abzurufenden Typs.</param>
        <param name="server">Der Server, von dem der Typ geladen werden soll. Wenn der Servername <see langword="null" /> ist, wird diese Methode automatisch auf den lokalen Computer zurückgesetzt.</param>
        <param name="throwOnError"><see langword="true" />, um mögliche Ausnahmen auszulösen.  
  
Oder 
 <see langword="false" />, um Ausnahmen zu ignorieren.</param>
        <summary>Ruft den Typ, dem die angegebene Klassen-ID (CLSID) zugeordnet ist, vom angegebenen Server ab. Dabei wird angegeben, ob bei Auftreten eines Fehlers beim Laden des Typs eine Ausnahme ausgelöst werden soll.</summary>
        <returns><see langword="System.__ComObject" /> unabhängig von der Gültigkeit der CLSID.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.GetTypeFromCLSID%2A>-Methode unterstützt den spät gebundenen Zugriff auf nicht verwaltete COM-Objekte von .NET Framework-apps, wenn Sie den Klassen Bezeichner (CLSID) des COM-Objekts kennen.  Der Klassen Bezeichner für COM-Klassen wird im HKEY_CLASSES_ROOT \CLSID-Schlüssel der Registrierung definiert. Sie können den Wert der <xref:System.Type.IsCOMObject%2A>-Eigenschaft abrufen, um zu bestimmen, ob der von dieser Methode zurückgegebene Typ ein COM-Objekt ist.  
  
> [!TIP]
>  Sie können die <xref:System.Type.GetTypeFromProgID%2A>-Methode für den spät gebundenen Zugriff auf COM-Objekte aufrufen, deren Programm Bezeichner (ProgID) Sie kennen.  
  
 Das Instanziieren eines nicht verwalteten COM-Objekts aus seiner CLSID ist ein zweistufiger Prozess:  
  
1.  Rufen Sie ein <xref:System.Type> Objekt ab, das den `__ComObject` darstellt, der der CLSID entspricht, indem Sie die <xref:System.Type.GetTypeFromCLSID%2A>-Methode aufrufen.  
  
2.  Ruft die <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType>-Methode auf, um das COM-Objekt zu instanziieren.  
  
 Ausnahmen wie z. b. <xref:System.OutOfMemoryException> werden ausgelöst, wenn `true` für `throwOnError`angegeben werden, aber nicht für nicht registrierte CLSIDs.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die CLSID des Microsoft Word- [Anwendungs Objekts](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) zum Abrufen eines COM-Typs verwendet, der die Microsoft Word-Anwendung von einem Server mit dem Namen computer17.Central.contoso.com darstellt. Anschließend wird der Typ durch Aufrufen der <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType>-Methode instanziiert und durch Aufrufen der [Application. Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) -Methode geschlossen. Eine Ausnahme wird ausgelöst, wenn beim Laden des Typs ein Fehler auftritt.  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para>Diese Methode ist für die Verwendung beim Arbeiten mit COM-Objekten gedacht, nicht für .NET Framework-Objekte. Alle verwalteten Objekte, einschließlich derjenigen, die für com sichtbar sind (d. h., Ihr <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> Attribut ist <see langword="true" />), weisen eine GUID auf, die von der <see cref="P:System.Type.GUID" />-Eigenschaft zurückgegeben wird. Obwohl die <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />-Methode ein <see cref="T:System.Type" />-Objekt zurückgibt, das der GUID für ein bestimmtes verwaltetes Objekt entspricht, können Sie dieses <see cref="T:System.Type" />-Objekt nicht verwenden, um eine Typinstanz zu erstellen, indem Sie die <see cref="M:System.Activator.CreateInstance(System.Type)" />-Methode aufrufen, wie im folgenden Beispiel gezeigt.  
  
[! Code-csharp[System. Type. gettypeer fromclsid # 11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! Code-vb[System. Type. gettypinfromclsid # 11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)] 
Stattdessen sollte die <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> nur zum Abrufen der GUID eines nicht verwalteten COM-Objekts verwendet werden, und das resultierende <see cref="T:System.Type" />-Objekt, das an die <see cref="M:System.Activator.CreateInstance(System.Type)" />-Methode übermittelt wird, muss ein nicht verwaltetes COM-Objekt darstellen.</para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromHandle : RuntimeTypeHandle -&gt; Type" Usage="System.Type.GetTypeFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle">Das Objekt, das auf den Typ verweist.</param>
        <summary>Ruft den Typ ab, auf den das angegebene Typhandle verweist.</summary>
        <returns>Der Typ, auf den das angegebene <see cref="T:System.RuntimeTypeHandle" /> verweist, oder <see langword="null" />, wenn die <see cref="P:System.RuntimeTypeHandle.Value" />-Eigenschaft von <paramref name="handle" /> den Wert <see langword="null" /> hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Handles sind nur in der Anwendungsdomäne gültig, in der Sie abgerufen wurden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Type.GetTypeFromHandle%2A>-Methode verwendet, um ein <xref:System.Type> Objekt aus einem <xref:System.RuntimeTypeHandle> zu erhalten, das von der <xref:System.Type.GetTypeHandle%2A>-Methode bereitgestellt wird  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Typ ab, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string -&gt; Type" Usage="System.Type.GetTypeFromProgID progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="progID">Die ProgID des abzurufenden Typs.</param>
        <summary>Ruft den Typ ab, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist. Wenn beim Laden des <see cref="T:System.Type" /> ein Fehler auftritt, wird NULL zurückgegeben.</summary>
        <returns>Der Typ, dem die angegebene ProgID zugeordnet ist, wenn <paramref name="progID" /> ein gültiger Eintrag in der Registrierung ist und diesem ein Typ zugeordnet ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird für COM-Unterstützung bereitgestellt. ProgIDs werden im Microsoft .NET Framework nicht verwendet, da Sie durch das Konzept von Namespace abgelöst wurden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> ist <see langword="null" /></exception>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="progID">Die ProgID des abzurufenden Typs.</param>
        <param name="throwOnError"><see langword="true" />, um mögliche Ausnahmen auszulösen.  
  
Oder 
 <see langword="false" />, um Ausnahmen zu ignorieren.</param>
        <summary>Ruft den Typ ab, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist. Dabei wird angegeben, ob bei Auftreten eines Fehlers beim Laden des Typs eine Ausnahme ausgelöst werden soll.</summary>
        <returns>Der Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, wenn <paramref name="progID" /> ein gültiger Eintrag in der Registrierung ist und diesem ein Typ zugeordnet ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird für COM-Unterstützung bereitgestellt. Programm-IDs werden in Microsoft .NET Framework nicht verwendet, da Sie durch das Konzept von Namespace abgelöst wurden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein-Typ durch Übergeben einer ProgID abgerufen. dabei wird angegeben, ob eine Ausnahme ausgelöst werden soll, wenn die ProgID ungültig ist. Im Beispiel wird dann die mit der ProgID verknüpfte ClassID zusammen mit jeder anwendbaren Ausnahme Meldung angezeigt.  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Die angegebene ProgID ist nicht registriert.</exception>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="progID">Die ProgID des abzurufenden Typs.</param>
        <param name="server">Der Server, von dem der Typ geladen werden soll. Wenn der Servername <see langword="null" /> ist, wird diese Methode automatisch auf den lokalen Computer zurückgesetzt.</param>
        <summary>Ruft den Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, vom angegebenen Server ab. Wenn bei Laden des Typs ein Fehler auftritt, wird NULL zurückgegeben.</summary>
        <returns>Der Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, wenn <paramref name="progID" /> ein gültiger Eintrag in der Registrierung ist und diesem ein Typ zugeordnet ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird für COM-Unterstützung bereitgestellt. Programm-IDs werden in Microsoft .NET Framework nicht verwendet, da Sie durch das Konzept von Namespace abgelöst wurden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein-Typ abgerufen, indem eine ProgID und ein Servername übergeben werden. Im Beispiel wird dann die ClassID angezeigt, die mit der ProgID verknüpft ist, oder es wird eine Ausnahme ausgelöst, wenn die ProgID oder der Servername ungültig ist.  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="prodID" /> ist <see langword="null" /></exception>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="server" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="throwOnError" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="progID">Die ProgID des abzurufenden <see cref="T:System.Type" />.</param>
        <param name="server">Der Server, von dem der Typ geladen werden soll. Wenn der Servername <see langword="null" /> ist, wird diese Methode automatisch auf den lokalen Computer zurückgesetzt.</param>
        <param name="throwOnError"><see langword="true" />, um mögliche Ausnahmen auszulösen.  
  
Oder 
 <see langword="false" />, um Ausnahmen zu ignorieren.</param>
        <summary>Ruft den Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, vom angegebenen Server ab. Dabei wird angegeben, ob bei Auftreten eines Fehlers beim Laden des Typs eine Ausnahme ausgelöst werden soll.</summary>
        <returns>Der Typ, dem die angegebene ProgID (Programmbezeichner) zugeordnet ist, wenn <paramref name="progID" /> ein gültiger Eintrag in der Registrierung ist und diesem ein Typ zugeordnet ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird für COM-Unterstützung bereitgestellt. Programm-IDs werden in Microsoft .NET Framework nicht verwendet, da Sie durch das Konzept von Namespace abgelöst wurden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein-Typ abgerufen, indem eine ProgID und ein Servername übergeben werden. Im Beispiel wird dann die ClassID angezeigt, die mit der ProgID verknüpft ist. dabei wird angegeben, ob eine Ausnahme ausgelöst werden soll, wenn die ProgID oder der Servername ungültig ist.  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="progID" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Runtime.InteropServices.COMException">Die angegebene progID ist nicht registriert.</exception>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetTypeHandle : obj -&gt; RuntimeTypeHandle" Usage="System.Type.GetTypeHandle o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="o">Das Objekt, für das das Typhandle abgerufen werden soll.</param>
        <summary>Ruft das Handle für den <see cref="T:System.Type" />-Wert eines angegebenen Objekts ab.</summary>
        <returns>Das Handle für den <see cref="T:System.Type" /> des angegebenen <see cref="T:System.Object" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Handles sind nur in der Anwendungsdomäne gültig, in der Sie abgerufen wurden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die-Klasse `MyClass1`definiert, eine Instanz davon abgerufen und das Lauf Zeit Handle des-Objekts abgerufen.  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="o" /> ist <see langword="null" /></exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Type.GUID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die dem <see cref="T:System.Type" /> zugeordnete GUID ab.</summary>
        <value>Die dem <see cref="T:System.Type" /> zugeordnete GUID.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine GUID ist einem Typ zugeordnet, der das <xref:System.Runtime.InteropServices.GuidAttribute>-Attribut verwendet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die-Klasse `MyClass1` mit einer öffentlichen-Methode erstellt, ein `Type`-Objekt erstellt, das `MyClass1`entspricht, und die <xref:System.Guid> Struktur wird mithilfe der `GUID`-Eigenschaft der `Type`-Klasse abgerufen.  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElementType : bool" Usage="System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle <see cref="T:System.Type" /> einen anderen Typ umfasst oder auf einen anderen Typ verweist, d. h. ob der aktuelle <see cref="T:System.Type" /> ein Array oder ein Zeiger ist oder als Verweis übergeben wird.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> ein Array oder ein Zeiger ist oder als Verweis übergeben wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beispielsweise Type.GetType("Int32[]"). HasElementType gibt `true`, wohingegen Type.GetType("Int32"). HasElementType gibt `false`. HasElementType gibt auch `true` für "Int32 *" und "Int32 &" zurück.  
  
 Wenn die aktuelle <xref:System.Type> einen generischen Typ oder einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese Eigenschaft immer `false`zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird `true` oder `false` zurückgegeben, je nachdem, ob es sich bei dem Objekt um ein Array, einen Verweistyp oder einen Zeiger handelt.  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member HasElementTypeImpl : unit -&gt; bool" Usage="type.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.HasElementType" />-Eigenschaft und bestimmt, ob der aktuelle <see cref="T:System.Type" /> einen anderen Typ umfasst oder auf einen solchen verweist, d. h. ob der aktuelle <see cref="T:System.Type" /> ein Array oder Zeiger ist oder als Verweis übergeben wird.</summary>
        <returns><see langword="true" />, wenn <see cref="T:System.Type" /> ein Array oder ein Zeiger ist oder als Verweis übergeben wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beispielsweise Type.GetType("Int32[]"). HasElementTypeImpl gibt `true`, wohingegen Type.GetType("Int32"). HasElementTypeImpl gibt `false`. HasElementTypeImpl gibt auch `true` für "Int32 *" und "Int32 &" zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die-Klasse `MyTypeDelegator`definiert, die die `HasElementTypeImpl`-Methode überschreibt. Die Hauptklasse überprüft die `HasElementType`-Eigenschaft und zeigt den Elementtyp an.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen bestimmten Member vom aktuellen <see cref="T:System.Type" /> auf.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeMember (name As String, invokeAttr As BindingFlags, binder As Binder, target As Object, args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen des Konstruktors, der Methode, der Eigenschaft oder des Feldmembers enthält, der bzw. die aufgerufen werden soll.  
  
Oder 
Eine leere Zeichenfolge ("") zum Aufrufen des Standardmembers.  
  
Oder 
Für <see langword="IDispatch" />-Member eine Zeichenfolge, die die DispID darstellt, z. B. "[DispID=3]".</param>
        <param name="invokeAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird. Der Zugriff kann aus einem der <see langword="BindingFlags" /> wie <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> usw. bestehen. Die Art der Suche muss nicht angegeben werden. Wenn die Art der Suche nicht angegeben ist, werden <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> verwendet.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
Oder 
Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll. Beachten Sie, dass möglicherweise ein <see cref="T:System.Reflection.Binder" />-Objekt explizit definiert werden muss, um erfolgreich Methodenüberladungen mit Variablenargumenten aufrufen zu können.</param>
        <param name="target">Das Objekt, für das der angegebene Member aufgerufen werden soll.</param>
        <param name="args">Ein Array mit den Argumenten, die dem aufzurufenden Member übergeben werden sollen.</param>
        <summary>Ruft den angegebenen Member auf, der den angegebenen Bindungseinschränkungen und der angegebenen Argumentliste entspricht.</summary>
        <returns>Ein Objekt, das den Rückgabewert des aufgerufenen Members darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Sie können <xref:System.Type.InvokeMember%2A> nicht verwenden, um eine generische Methode aufzurufen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Elemente in die Suche eingeschlossen werden sollen:  
  
-   Geben Sie `BindingFlags.Public` an, um öffentliche Member in die Suche einzubeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` an, um nicht öffentliche Member (d. h. private und geschützte Member) in die Suche einzubeziehen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` an, um statische Elemente in der Hierarchie nach oben einzubeziehen  
  
 Die folgenden <xref:System.Reflection.BindingFlags>-Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:  
  
-   `BindingFlags.IgnoreCase`, die Groß-/Kleinschreibung `name`zu ignorieren.  
  
-   `BindingFlags.DeclaredOnly`, um nur die Member zu durchsuchen, die auf dem <xref:System.Type>deklariert sind, nicht Elemente, die einfach geerbt wurden.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> aufzurufenden Flags können verwendet werden, um anzugeben, welche Aktion mit dem Element ausgeführt werden soll:  
  
-   `CreateInstance`, um einen Konstruktor aufzurufen. `name` wird ignoriert. Ungültig mit anderen Aufruf-Flags.  
  
-   `InvokeMethod`, um eine Methode aufzurufen, aber keinen Konstruktor oder Typinitialisierer. Ungültig bei `SetField` oder `SetProperty`. Wenn `InvokeMethod` allein angegeben ist, werden `BindingFlags.Public`, `BindingFlags.Instance`und `BindingFlags.Static` automatisch eingeschlossen.  
  
-   `GetField`, um den Wert eines Felds zu erhalten. Nicht gültig mit `SetField`.  
  
-   `SetField`, um den Wert eines Felds festzulegen. Nicht gültig mit `GetField`.  
  
-   `GetProperty`, um eine Eigenschaft zu erhalten. Nicht gültig mit `SetProperty`.  
  
-   `SetProperty`, um eine Eigenschaft festzulegen. Nicht gültig mit `GetProperty`.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Eine Methode wird aufgerufen, wenn beide der folgenden Bedingungen zutreffen:  
  
-   Die Anzahl der Parameter in der Methoden Deklaration entspricht der Anzahl der Argumente im `args` Array (es sei denn, es sind Standardargumente für den Member definiert, und `BindingFlags.OptionalParamBinding` wird angegeben).  
  
-   Der Typ jedes Arguments kann vom Binder in den Typ des Parameters konvertiert werden.  
  
 Der Binder findet alle übereinstimmenden Methoden. Diese Methoden werden basierend auf dem Typ der angeforderten Bindung gefunden (<xref:System.Reflection.BindingFlags> Werte `InvokeMethod`, `GetProperty`usw.). Der Satz von Methoden wird anhand des Namens, der Anzahl von Argumenten und einer Reihe von suchmodifizierermembern gefiltert, die im Binder definiert sind.  
  
 Nachdem die Methode ausgewählt wurde, wird Sie aufgerufen. An diesem Punkt wird Barrierefreiheit geprüft. Die Suche kann steuern, welcher Satz von Methoden basierend auf dem Barrierefreiheits Attribut, das der Methode zugeordnet ist, durchsucht wird. Die <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType>-Methode der <xref:System.Reflection.Binder>-Klasse ist verantwortlich für die Auswahl der aufzurufenden Methode. Der Standard Binder wählt die spezifischsten Übereinstimmung aus.  
  
 Zugriffs Einschränkungen werden bei voll vertrauenswürdigem Code ignoriert. Das heißt, dass auf Private Konstruktoren, Methoden, Felder und Eigenschaften zugegriffen werden kann und über <xref:System.Reflection> aufgerufen werden kann, wenn der Code vollständig vertrauenswürdig ist.  
  
 Sie können `Type.InvokeMember` verwenden, um ein Feld auf einen bestimmten Wert festzulegen, indem Sie <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>angeben. Wenn Sie z. b. ein öffentliches Instanzfeld mit dem Namen f in Class C und f als `String`festlegen möchten, können Sie Code wie den folgenden verwenden:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 Wenn F ein `String[]`ist, können Sie Code wie den folgenden verwenden:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 Dadurch wird das Feld F mit diesem neuen Array initialisiert. Sie können auch `Type.InvokeMember` verwenden, um eine Position in einem Array festzulegen, indem Sie den Index des Werts und dann den nächsten Wert mithilfe von Code wie dem folgenden angeben:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 Dadurch wird die Zeichenfolge "z" in dem Array geändert, das F in die Zeichenfolge "b" enthält.  
  
 Wenn Sie einen `IDispatch` Member aufrufen, können Sie die DISPID anstelle des Element namens angeben, indem Sie das Zeichen folgen Format "[DispID = # #]" verwenden. Wenn z. b. die DispID von MyComMethod den Wert 3 hat, können Sie die Zeichenfolge "[DispID = 3]" anstelle von "MyComMethod" angeben. Das Aufrufen eines Members durch DISPID ist schneller, als das Element nach dem Namen zu suchen. In komplexen Aggregations Szenarios ist die DISPID manchmal die einzige Möglichkeit, den gewünschten Member aufzurufen.  
  
> [!NOTE]
>  Beginnend mit dem [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]kann diese Methode verwendet werden, um auf nicht öffentliche Member zuzugreifen, wenn dem Aufrufer <xref:System.Security.Permissions.ReflectionPermission> mit dem <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>-Flag erteilt wurde, und wenn der Berechtigungs Satz der nicht öffentlichen Member auf den Berechtigungs Satz des Aufrufers oder auf eine Teilmenge beschränkt ist. (Siehe [Sicherheitsüberlegungen für die Reflektion](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
   
  
## Examples  
 Im folgenden Beispiel wird `InvokeMember` verwendet, um auf Member eines Typs zuzugreifen.  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> enthält keine <see langword="CreateInstance" />, und <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="invokeAttr" /> ist kein gültiges <see cref="T:System.Reflection.BindingFlags" />-Attribut.  
  
Oder 
 <paramref name="invokeAttr" /> enthält keines der folgenden Bindungsflags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.  
  
Oder 
 <paramref name="invokeAttr" /> enthält <see langword="CreateInstance" /> in Kombination mit <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.  
  
Oder 
 <paramref name="invokeAttr" /> enthält sowohl <see langword="GetField" /> als auch <see langword="SetField" />.  
  
Oder 
 <paramref name="invokeAttr" /> enthält sowohl <see langword="GetProperty" /> als auch <see langword="SetProperty" />.  
  
Oder 
 <paramref name="invokeAttr" /> enthält <see langword="InvokeMethod" /> in Kombination mit <see langword="SetField" /> oder <see langword="SetProperty" />.  
  
Oder 
 <paramref name="invokeAttr" /> enthält <see langword="SetField" />, und <paramref name="args" /> enthält mehr als ein Element.  
  
Oder 
Diese Methode wird für ein COM-Objekt aufgerufen, und eines der folgenden Bindungsflags wurde nicht übergeben: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> oder <see langword="BindingFlags.PutRefDispProperty" />.  
  
Oder 
Eines der benannten Parameterarrays enthält eine Zeichenfolge, die <see langword="null" /> ist.</exception>
        <exception cref="T:System.MethodAccessException">Der angegebene Member ist ein Klasseninitialisierer.</exception>
        <exception cref="T:System.MissingFieldException">Das Feld oder die Eigenschaft wurde nicht gefunden.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde keine Methode gefunden, die den Argumenten in <paramref name="args" /> entspricht.  
  
Oder 
Das aktuelle <see cref="T:System.Type" />-Objekt stellt einen Typ dar, der offene Typparameter enthält. Das bedeutet, dass <see cref="P:System.Type.ContainsGenericParameters" /> den Wert <see langword="true" /> zurückgibt.</exception>
        <exception cref="T:System.Reflection.TargetException">Der angegebene Member kann nicht für <paramref name="target" /> aufgerufen werden.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mehrere Methoden entsprechen den Bindungskriterien.</exception>
        <exception cref="T:System.NotSupportedException">Diese Methode wird von .NET Compact Framework derzeit nicht unterstützt.</exception>
        <exception cref="T:System.InvalidOperationException">Die durch <paramref name="name" /> dargestellte Methode enthält mindestens einen nicht angegebenen generischen Typparameter. Das bedeutet, dass die <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />-Eigenschaft der Methode <see langword="true" /> zurückgibt.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeMember (name As String, invokeAttr As BindingFlags, binder As Binder, target As Object, args As Object(), culture As CultureInfo) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen des Konstruktors, der Methode, der Eigenschaft oder des Feldmembers enthält, der bzw. die aufgerufen werden soll.  
  
Oder 
Eine leere Zeichenfolge ("") zum Aufrufen des Standardmembers.  
  
Oder 
Für <see langword="IDispatch" />-Member eine Zeichenfolge, die die DispID darstellt, z. B. "[DispID=3]".</param>
        <param name="invokeAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird. Der Zugriff kann aus einem der <see langword="BindingFlags" /> wie <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> usw. bestehen. Die Art der Suche muss nicht angegeben werden. Wenn die Art der Suche nicht angegeben ist, werden <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> verwendet.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
Oder 
Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll. Beachten Sie, dass möglicherweise ein <see cref="T:System.Reflection.Binder" />-Objekt explizit definiert werden muss, um erfolgreich Methodenüberladungen mit Variablenargumenten aufrufen zu können.</param>
        <param name="target">Das Objekt, für das der angegebene Member aufgerufen werden soll.</param>
        <param name="args">Ein Array mit den Argumenten, die dem aufzurufenden Member übergeben werden sollen.</param>
        <param name="culture">Das Objekt, das das zu verwendende Globalisierungsgebietsschema darstellt, das für gebietsspezifische Konvertierungen wie die Konvertierung einer numerischen <see cref="T:System.String" /> in einen <see cref="T:System.Double" /> erforderlich sein kann.  
  
Oder 
Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet werden soll.</param>
        <summary>Ruft den angegebenen Member auf, der den angegebenen Bindungseinschränkungen sowie der angegebenen Argumentliste und Kultur entspricht.</summary>
        <returns>Ein Objekt, das den Rückgabewert des aufgerufenen Members darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standard Binder verarbeitet zwar nicht <xref:System.Globalization.CultureInfo> (den `culture`-Parameter), Sie können jedoch die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType>-Klasse verwenden, um einen benutzerdefinierten Binder zu schreiben, der `culture`verarbeitet.  
  
> [!NOTE]
>  Sie können <xref:System.Type.InvokeMember%2A> nicht verwenden, um eine generische Methode aufzurufen.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Elemente in die Suche eingeschlossen werden sollen:  
  
-   Geben Sie `BindingFlags.Public` an, um öffentliche Member in die Suche einzubeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` an, dass nicht öffentliche Member (d. h. private, interne und geschützte Member) in der Suche enthalten sein sollen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` an, um statische Elemente in der Hierarchie nach oben einzubeziehen  
  
 Die folgenden <xref:System.Reflection.BindingFlags>-Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:  
  
-   `BindingFlags.IgnoreCase`, die Groß-/Kleinschreibung `name`zu ignorieren.  
  
-   `BindingFlags.DeclaredOnly`, um nur die Member zu durchsuchen, die auf dem <xref:System.Type>deklariert sind, nicht Elemente, die einfach geerbt wurden.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> aufzurufenden Flags können verwendet werden, um anzugeben, welche Aktion mit dem Element ausgeführt werden soll:  
  
-   `CreateInstance`, um einen Konstruktor aufzurufen. `name` wird ignoriert. Ungültig mit anderen Aufruf-Flags.  
  
-   `InvokeMethod`, um eine Methode aufzurufen, aber keinen Konstruktor oder Typinitialisierer. Ungültig bei `SetField` oder `SetProperty`. Wenn `InvokeMethod` allein angegeben ist, werden `BindingFlags.Public`, `BindingFlags.Instance`und `BindingFlags.Static` automatisch eingeschlossen.  
  
-   `GetField`, um den Wert eines Felds zu erhalten. Nicht gültig mit `SetField`.  
  
-   `SetField`, um den Wert eines Felds festzulegen. Nicht gültig mit `GetField`.  
  
-   `GetProperty`, um eine Eigenschaft zu erhalten. Nicht gültig mit `SetProperty`.  
  
-   `SetProperty`, um eine Eigenschaft festzulegen. Nicht gültig mit `GetProperty`.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Eine Methode wird aufgerufen, wenn beide der folgenden Bedingungen zutreffen:  
  
-   Die Anzahl der Parameter in der Methoden Deklaration entspricht der Anzahl der Argumente im `args` Array (es sei denn, es sind Standardargumente für den Member definiert, und `BindingFlags.OptionalParamBinding` wird angegeben).  
  
-   Der Typ jedes Arguments kann vom Binder in den Typ des Parameters konvertiert werden.  
  
 Der Binder findet alle übereinstimmenden Methoden. Diese Methoden werden basierend auf dem Typ der angeforderten Bindung gefunden (<xref:System.Reflection.BindingFlags> Werte `InvokeMethod`, `GetProperty`usw.). Der Satz von Methoden wird anhand des Namens, der Anzahl von Argumenten und einer Reihe von suchmodifizierermembern gefiltert, die im Binder definiert sind.  
  
 Nachdem die Methode ausgewählt wurde, wird Sie aufgerufen. An diesem Punkt wird Barrierefreiheit geprüft. Die Suche kann steuern, welcher Satz von Methoden basierend auf dem Barrierefreiheits Attribut, das der Methode zugeordnet ist, durchsucht wird. Die <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType>-Methode der <xref:System.Reflection.Binder>-Klasse ist verantwortlich für die Auswahl der aufzurufenden Methode. Der Standard Binder wählt die spezifischsten Übereinstimmung aus.  
  
 Zugriffs Einschränkungen werden bei voll vertrauenswürdigem Code ignoriert. Das heißt, dass auf Private Konstruktoren, Methoden, Felder und Eigenschaften zugegriffen werden kann und die über Reflektion aufgerufen werden, wenn der Code vollständig vertrauenswürdig ist.  
  
 Sie können `Type.InvokeMember` verwenden, um ein Feld auf einen bestimmten Wert festzulegen, indem Sie <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>angeben. Wenn Sie z. b. ein öffentliches Instanzfeld mit dem Namen f in Class C und f als `String` festlegen möchten, können Sie Code wie den folgenden verwenden:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 Wenn F ein `String[]`ist, können Sie Code wie den folgenden verwenden:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 Dadurch wird das Feld F mit diesem neuen Array initialisiert. Sie können auch `Type.InvokeMember` verwenden, um eine Position in einem Array festzulegen, indem Sie den Index des Werts und dann den nächsten Wert mithilfe von Code wie dem folgenden angeben:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 Dadurch wird die Zeichenfolge "z" in dem Array geändert, das F in die Zeichenfolge "b" enthält.  
  
 Wenn Sie ein `IDispatch` Member aufrufen, können Sie die DISPID anstelle des Element namens angeben, indem Sie das Zeichen folgen Format "[DispID = # #]" verwenden. Wenn z. b. die DispID von MyComMethod den Wert 3 hat, können Sie die Zeichenfolge "[DispID = 3]" anstelle von "MyComMethod" angeben. Das Aufrufen eines Members durch DISPID ist schneller, als das Element nach dem Namen zu suchen. In komplexen Aggregations Szenarios ist die DISPID manchmal die einzige Möglichkeit, den gewünschten Member aufzurufen.  
  
> [!NOTE]
>  Beginnend mit dem [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]kann diese Methode verwendet werden, um auf nicht öffentliche Member zuzugreifen, wenn dem Aufrufer <xref:System.Security.Permissions.ReflectionPermission> mit dem <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>-Flag erteilt wurde, und wenn der Berechtigungs Satz der nicht öffentlichen Member auf den Berechtigungs Satz des Aufrufers oder auf eine Teilmenge beschränkt ist. (Siehe [Sicherheitsüberlegungen für die Reflektion](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> enthält keine <see langword="CreateInstance" />, und <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="invokeAttr" /> ist kein gültiges <see cref="T:System.Reflection.BindingFlags" />-Attribut.  
  
Oder 
 <paramref name="invokeAttr" /> enthält keines der folgenden Bindungsflags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.  
  
Oder 
 <paramref name="invokeAttr" /> enthält <see langword="CreateInstance" /> in Kombination mit <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.  
  
Oder 
 <paramref name="invokeAttr" /> enthält sowohl <see langword="GetField" /> als auch <see langword="SetField" />.  
  
Oder 
 <paramref name="invokeAttr" /> enthält sowohl <see langword="GetProperty" /> als auch <see langword="SetProperty" />.  
  
Oder 
 <paramref name="invokeAttr" /> enthält <see langword="InvokeMethod" /> in Kombination mit <see langword="SetField" /> oder <see langword="SetProperty" />.  
  
Oder 
 <paramref name="invokeAttr" /> enthält <see langword="SetField" />, und <paramref name="args" /> enthält mehr als ein Element.  
  
Oder 
Diese Methode wird für ein COM-Objekt aufgerufen, und eines der folgenden Bindungsflags wurde nicht übergeben: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> oder <see langword="BindingFlags.PutRefDispProperty" />.  
  
Oder 
Eines der benannten Parameterarrays enthält eine Zeichenfolge, die <see langword="null" /> ist.</exception>
        <exception cref="T:System.MethodAccessException">Der angegebene Member ist ein Klasseninitialisierer.</exception>
        <exception cref="T:System.MissingFieldException">Das Feld oder die Eigenschaft wurde nicht gefunden.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde keine Methode gefunden, die den Argumenten in <paramref name="args" /> entspricht.  
  
Oder 
Das aktuelle <see cref="T:System.Type" />-Objekt stellt einen Typ dar, der offene Typparameter enthält. Das bedeutet, dass <see cref="P:System.Type.ContainsGenericParameters" /> den Wert <see langword="true" /> zurückgibt.</exception>
        <exception cref="T:System.Reflection.TargetException">Der angegebene Member kann nicht für <paramref name="target" /> aufgerufen werden.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mehrere Methoden entsprechen den Bindungskriterien.</exception>
        <exception cref="T:System.InvalidOperationException">Die durch <paramref name="name" /> dargestellte Methode enthält mindestens einen nicht angegebenen generischen Typparameter. Das bedeutet, dass die <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />-Eigenschaft der Methode <see langword="true" /> zurückgibt.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function InvokeMember (name As String, invokeAttr As BindingFlags, binder As Binder, target As Object, args As Object(), modifiers As ParameterModifier(), culture As CultureInfo, namedParameters As String()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="binder" Type="System.Reflection.Binder" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="target" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="args" Type="System.Object[]" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="namedParameters" Type="System.String[]" Index="7" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="name">Die Zeichenfolge, die den Namen des Konstruktors, der Methode, der Eigenschaft oder des Feldmembers enthält, der bzw. die aufgerufen werden soll.  
  
Oder 
Eine leere Zeichenfolge ("") zum Aufrufen des Standardmembers.  
  
Oder 
Für <see langword="IDispatch" />-Member eine Zeichenfolge, die die DispID darstellt, z. B. "[DispID=3]".</param>
        <param name="invokeAttr">Eine bitweise Kombination der Enumerationswerte, die angeben, wie die Suche durchgeführt wird. Der Zugriff kann aus einem der <see langword="BindingFlags" /> wie <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" /> usw. bestehen. Die Art der Suche muss nicht angegeben werden. Wenn die Art der Suche nicht angegeben ist, werden <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> verwendet.</param>
        <param name="binder">Ein Objekt, das eine Gruppe von Eigenschaften definiert und eine Bindung ermöglicht. Dazu kann die Auswahl einer überladenen Methode, die Umwandlung von Argumenttypen und der Aufruf eines Members durch Reflektion gehören.  
  
Oder 
Ein Nullverweis (Nothing in Visual Basic), wenn <see cref="P:System.Type.DefaultBinder" /> verwendet werden soll. Beachten Sie, dass möglicherweise ein <see cref="T:System.Reflection.Binder" />-Objekt explizit definiert werden muss, um erfolgreich Methodenüberladungen mit Variablenargumenten aufrufen zu können.</param>
        <param name="target">Das Objekt, für das der angegebene Member aufgerufen werden soll.</param>
        <param name="args">Ein Array mit den Argumenten, die dem aufzurufenden Member übergeben werden sollen.</param>
        <param name="modifiers">Ein Array von <see cref="T:System.Reflection.ParameterModifier" />-Objekten, die die Attribute darstellen, die dem entsprechenden Element im <paramref name="args" />-Array zugeordnet sind. Die einem Parameter zugeordneten Attribute werden in der Signatur des Members gespeichert.  
  
Der Standardbinder verarbeitet diesen Parameter nur, wenn eine COM-Komponente aufgerufen wird.</param>
        <param name="culture">Das <see cref="T:System.Globalization.CultureInfo" />-Objekt, das das zu verwendende Globalisierungsgebietsschema darstellt, das für gebietsspezifische Konvertierungen wie die Konvertierung einer numerischen Zeichenfolge in einen Double erforderlich sein kann.  
  
Oder 
Ein Nullverweis (<see langword="Nothing" /> in Visual Basic), wenn die <see cref="T:System.Globalization.CultureInfo" /> des aktuellen Threads verwendet werden soll.</param>
        <param name="namedParameters">Ein Array mit den Namen der Parameter, an die die Elemente des <paramref name="args" />-Arrays übergeben werden.</param>
        <summary>Ruft nach Überschreiben in einer abgeleiteten Klasse den angegebenen Member auf, der den angegebenen Bindungseinschränkungen sowie der angegebenen Argumentliste, den Modifizierern und der Kultur entspricht.</summary>
        <returns>Ein Objekt, das den Rückgabewert des aufgerufenen Members darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `InvokeMember` Ruft ein konstruktormember oder einen Methodenmember auf, Ruft einen Eigenschaftenmember ab oder legt ihn fest, Ruft einen datenfeldmember ab oder legt ihn fest oder Ruft ein Element eines Array Members ab oder legt dieses fest.  
  
> [!NOTE]
>  Sie können <xref:System.Type.InvokeMember%2A> nicht verwenden, um eine generische Methode aufzurufen.  
  
 Wenn Sie ein `IDispatch` Member aufrufen, können Sie die DISPID anstelle des Element namens angeben, indem Sie das Zeichen folgen Format "[DispID = # #]" verwenden. Wenn z. b. die DispID von MyComMethod den Wert 3 hat, können Sie die Zeichenfolge "[DispID = 3]" anstelle von "MyComMethod" angeben. Das Aufrufen eines Members durch DISPID ist schneller, als das Element nach dem Namen zu suchen. In komplexen Aggregations Szenarios ist die DISPID manchmal die einzige Möglichkeit, den gewünschten Member aufzurufen.  
  
 Obwohl der Standard Binder keine <xref:System.Reflection.ParameterModifier> oder <xref:System.Globalization.CultureInfo> verarbeitet (die Parameter `modifiers` und `culture`), können Sie die abstrakte <xref:System.Reflection.Binder?displayProperty=nameWithType> Klasse verwenden, um einen benutzerdefinierten Binder zu schreiben, der `modifiers` und `culture`verarbeitet. `ParameterModifier` wird nur beim Aufrufen über COM-Interop verwendet, und nur Parameter, die als Verweis übermittelt werden, werden behandelt.  
  
 Jeder Parameter im `namedParameters`-Array ruft den Wert im entsprechenden Element im `args`-Array ab. Wenn die Länge von `args` größer als die Länge von `namedParameters` ist, werden die restlichen Argumentwerte in der Reihenfolge übergeben.  
  
 Das `namedParameters` Array kann verwendet werden, um die Reihenfolge der Argumente in einem Eingabe Array zu ändern. Wenn beispielsweise die-Methode `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` in Visual Basic) und das Eingabe Array `{ 42, "x" }`, kann das Eingabe Array unverändert an `args` übergeben werden, wenn das Array `{ "b", "a" }` für `namedParameters`bereitgestellt wird.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> Filterflags können verwendet werden, um zu definieren, welche Elemente in die Suche eingeschlossen werden sollen:  
  
-   Geben Sie `BindingFlags.Public` an, um öffentliche Member in die Suche einzubeziehen.  
  
-   Geben Sie `BindingFlags.NonPublic` an, dass nicht öffentliche Member (d. h. private, interne und geschützte Member) in der Suche enthalten sein sollen.  
  
-   Geben Sie `BindingFlags.FlattenHierarchy` an, um statische Elemente in der Hierarchie nach oben einzubeziehen  
  
 Die folgenden <xref:System.Reflection.BindingFlags>-Modifiziererflags können verwendet werden, um die Funktionsweise der Suche zu ändern:  
  
-   `BindingFlags.IgnoreCase`, die Groß-/Kleinschreibung `name`zu ignorieren.  
  
-   `BindingFlags.DeclaredOnly`, um nur die Member zu durchsuchen, die auf dem <xref:System.Type>deklariert sind, nicht Elemente, die einfach geerbt wurden.  
  
 Die folgenden <xref:System.Reflection.BindingFlags> aufzurufenden Flags können verwendet werden, um anzugeben, welche Aktion mit dem Element ausgeführt werden soll:  
  
-   `CreateInstance`, um einen Konstruktor aufzurufen. `name` wird ignoriert. Ungültig mit anderen Aufruf-Flags.  
  
-   `InvokeMethod`, um eine Methode aufzurufen, aber keinen Konstruktor oder Typinitialisierer. Ungültig bei `SetField` oder `SetProperty`. Wenn `InvokeMethod` allein angegeben ist, werden `BindingFlags.Public`, `BindingFlags.Instance`und `BindingFlags.Static` automatisch eingeschlossen.  
  
-   `GetField`, um den Wert eines Felds zu erhalten. Nicht gültig mit `SetField`.  
  
-   `SetField`, um den Wert eines Felds festzulegen. Nicht gültig mit `GetField`.  
  
-   `GetProperty`, um eine Eigenschaft zu erhalten. Nicht gültig mit `SetProperty`.  
  
-   `SetProperty`, um eine Eigenschaft festzulegen. Nicht gültig mit `GetProperty`.  
  
 Weitere Informationen finden Sie unter <xref:System.Reflection.BindingFlags?displayProperty=nameWithType>.  
  
 Eine Methode wird aufgerufen, wenn beide der folgenden Bedingungen zutreffen:  
  
-   Die Anzahl der Parameter in der Methoden Deklaration entspricht der Anzahl der Argumente im `args` Array (es sei denn, es sind Standardargumente für den Member definiert, und `BindingFlags.OptionalParamBinding` wird angegeben).  
  
-   Der Typ jedes Arguments kann vom Binder in den Typ des Parameters konvertiert werden.  
  
 Der Binder findet alle übereinstimmenden Methoden. Diese Methoden werden basierend auf dem Typ der angeforderten Bindung gefunden (<xref:System.Reflection.BindingFlags> Werte `InvokeMethod`, `GetProperty`usw.). Der Satz von Methoden wird anhand des Namens, der Anzahl von Argumenten und einer Reihe von suchmodifizierermembern gefiltert, die im Binder definiert sind.  
  
 Nachdem die Methode ausgewählt wurde, wird Sie aufgerufen. An diesem Punkt wird Barrierefreiheit geprüft. Die Suche kann steuern, welcher Satz von Methoden basierend auf dem Barrierefreiheits Attribut, das der Methode zugeordnet ist, durchsucht wird. Die <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType>-Methode der <xref:System.Reflection.Binder>-Klasse ist verantwortlich für die Auswahl der aufzurufenden Methode. Der Standard Binder wählt die spezifischsten Übereinstimmung aus.  
  
 `InvokeMember` können verwendet werden, um Methoden mit Parametern aufzurufen, die über Standardwerte verfügen. Um an diese Methoden gebunden zu werden, muss die Reflektion <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> angegeben werden. Bei einem Parameter mit einem Standardwert können Sie entweder einen anderen Wert angeben oder <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> angeben, um den Standardwert zu verwenden.  
  
 Angenommen, eine Methode, z. b. "MyMethod" (int x, float y = 2,0). Um diese Methode nur mit dem ersten Argument als MyMethod (4) aufzurufen, übergeben Sie eines der obigen Bindungsflags und übergeben zwei Argumente, d. b. 4 für das erste Argument und `Missing.Value` für das zweite Argument. Wenn Sie `Missing.Value`nicht verwenden, dürfen Sie keine optionalen Parameter mit der `Invoke`-Methode weglassen. Wenn Sie dies tun müssen, verwenden Sie stattdessen `InvokeMember`.  
  
 Zugriffs Einschränkungen werden bei voll vertrauenswürdigem Code ignoriert. Das heißt, dass auf Private Konstruktoren, Methoden, Felder und Eigenschaften zugegriffen werden kann und über <xref:System.Reflection> aufgerufen werden kann, wenn der Code vollständig vertrauenswürdig ist.  
  
 Sie können `Type.InvokeMember` verwenden, um ein Feld auf einen bestimmten Wert festzulegen, indem Sie <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>angeben. Wenn Sie z. b. ein öffentliches Instanzfeld mit dem Namen f in Class C und f als `String`festlegen möchten, können Sie Code wie den folgenden verwenden:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 Wenn F ein `String[]`ist, können Sie Code wie den folgenden verwenden:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 Dadurch wird das Feld F mit diesem neuen Array initialisiert. Sie können auch `Type.InvokeMember` verwenden, um eine Position in einem Array festzulegen, indem Sie den Index des Werts und dann den nächsten Wert mithilfe von Code wie dem folgenden angeben:  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 Dadurch wird die Zeichenfolge "z" in dem Array geändert, das F in die Zeichenfolge "b" enthält.  
  
> [!NOTE]
>  Beginnend mit dem [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]kann diese Methode verwendet werden, um auf nicht öffentliche Member zuzugreifen, wenn dem Aufrufer <xref:System.Security.Permissions.ReflectionPermission> mit dem <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType>-Flag erteilt wurde, und wenn der Berechtigungs Satz der nicht öffentlichen Member auf den Berechtigungs Satz des Aufrufers oder auf eine Teilmenge beschränkt ist. (Siehe [Sicherheitsüberlegungen für die Reflektion](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection).)  
>   
>  Zur Verwendung dieser Funktionen sollte die Anwendung für [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] oder höher ausgelegt sein.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="invokeAttr" /> enthält keine <see langword="CreateInstance" />, und <paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="args" /> und <paramref name="modifiers" /> weisen nicht die gleiche Länge auf.  
  
Oder 
 <paramref name="invokeAttr" /> ist kein gültiges <see cref="T:System.Reflection.BindingFlags" />-Attribut.  
  
Oder 
 <paramref name="invokeAttr" /> enthält keines der folgenden Bindungsflags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.  
  
Oder 
 <paramref name="invokeAttr" /> enthält <see langword="CreateInstance" /> in Kombination mit <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> oder <see langword="SetProperty" />.  
  
Oder 
 <paramref name="invokeAttr" /> enthält sowohl <see langword="GetField" /> als auch <see langword="SetField" />.  
  
Oder 
 <paramref name="invokeAttr" /> enthält sowohl <see langword="GetProperty" /> als auch <see langword="SetProperty" />.  
  
Oder 
 <paramref name="invokeAttr" /> enthält <see langword="InvokeMethod" /> in Kombination mit <see langword="SetField" /> oder <see langword="SetProperty" />.  
  
Oder 
 <paramref name="invokeAttr" /> enthält <see langword="SetField" />, und <paramref name="args" /> enthält mehr als ein Element.  
  
Oder 
Das benannte Parameterarray ist größer als das Argumentarray.  
  
Oder 
Diese Methode wird für ein COM-Objekt aufgerufen, und eines der folgenden Bindungsflags wurde nicht übergeben: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> oder <see langword="BindingFlags.PutRefDispProperty" />.  
  
Oder 
Eines der benannten Parameterarrays enthält eine Zeichenfolge, die <see langword="null" /> ist.</exception>
        <exception cref="T:System.MethodAccessException">Der angegebene Member ist ein Klasseninitialisierer.</exception>
        <exception cref="T:System.MissingFieldException">Das Feld oder die Eigenschaft wurde nicht gefunden.</exception>
        <exception cref="T:System.MissingMethodException">Es wurde keine Methode gefunden, die den Argumenten in <paramref name="args" /> entspricht.  
  
Oder 
Es wurde kein Member gefunden, dessen Argumentnamen in <paramref name="namedParameters" /> angegeben sind.  
  
Oder 
Das aktuelle <see cref="T:System.Type" />-Objekt stellt einen Typ dar, der offene Typparameter enthält. Das bedeutet, dass <see cref="P:System.Type.ContainsGenericParameters" /> den Wert <see langword="true" /> zurückgibt.</exception>
        <exception cref="T:System.Reflection.TargetException">Der angegebene Member kann nicht für <paramref name="target" /> aufgerufen werden.</exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException">Mehrere Methoden entsprechen den Bindungskriterien.</exception>
        <exception cref="T:System.InvalidOperationException">Die durch <paramref name="name" /> dargestellte Methode enthält mindestens einen nicht angegebenen generischen Typparameter. Das bedeutet, dass die <see cref="P:System.Reflection.MethodBase.ContainsGenericParameters" />-Eigenschaft der Methode <see langword="true" /> zurückgibt.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Type" /> abstrakt ist und überschrieben werden muss.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> abstrakt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.IsAbstract%2A>-Eigenschaft gibt `true` in den folgenden Fällen zurück:  
  
-   Der aktuelle Typ ist abstrakt. Das heißt, dass es nicht instanziiert werden kann, sondern nur als Basisklasse für abgeleitete Klassen fungieren kann. In C#werden abstrakte Klassen mit dem [abstract](/dotnet/csharp/language-reference/keywords/abstract) -Schlüsselwort gekennzeichnet. in Visual Basic sind Sie mit dem [MustInherit](/dotnet/visual-basic/language-reference/modifiers/mustinherit) -Schlüsselwort gekennzeichnet.  
  
-   Der aktuelle Typ ist eine Schnittstelle.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese Eigenschaft immer `false`zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array von <xref:System.Type> Objekten erstellt, die die folgenden Typen darstellen: enthält Rückgaben `true`, wenn das angegebene Objekt `abstract`ist. Andernfalls wird `false`zurückgegeben.  
  
-   `AbstractClass`, eine abstrakte Klasse (eine Klasse, die in Visual Basic C# als `abstract` in und `MustInherit` gekennzeichnet ist).  
  
-   `DerivedClass`, eine Klasse, die von `AbstractClass`erbt.  
  
-   `SingleClass`, eine nicht vererbbare Klasse. Es ist als `sealed` in C# und `NotInheritable` in Visual Basic definiert.  
  
-   `ITypeInfo`, eine Schnittstelle.  
  
-   `ImplementingClass`, eine Klasse, die die `ITypeInfo`-Schnittstelle implementiert.  
  
 Die-Methode gibt `true` nur für `AbstractClass`, die abstrakte-Klasse und `ITypeInfo`die-Schnittstelle zurück.  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnsiClass : bool" Usage="System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob für <see langword="AnsiClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist.</summary>
        <value><see langword="true" />, wenn für <see langword="AnsiClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Reflection.TypeAttributes.StringFormatMask> wählt die Zeichen folgen Format Attribute aus. Die Attribute des Zeichen folgen Formats verbessern die Interoperabilität durch definieren, wie Zeichen folgen interpretiert werden sollen.  
  
 Wenn die aktuelle <xref:System.Type> einen generischen Typ darstellt, bezieht sich diese Eigenschaft auf die generische Typdefinition, aus der der Typ erstellt wurde. Wenn die aktuelle <xref:System.Type> z. b. `MyGenericType<int>` darstellt (`MyGenericType(Of Integer)` in Visual Basic), wird der Wert dieser Eigenschaft durch `MyGenericType<T>`bestimmt.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft immer `false`zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Feldinformationen abgerufen und das `AnsiClass` Attribut überprüft.  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public virtual bool IsArray { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsArray As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsArray { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Type.IsArray" />
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Typ ein Array ist.</summary>
        <value><see langword="true" />, wenn der aktuelle Typ ein Array ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.IsArray%2A>-Eigenschaft gibt `false` für die <xref:System.Array>-Klasse zurück. Außerdem wird `false` zurückgegeben, wenn die aktuelle Instanz ein <xref:System.Type> Objekt ist, das einen Auflistungstyp oder eine Schnittstelle darstellt, die für die Arbeit mit Auflistungen konzipiert ist, wie <xref:System.Collections.IEnumerable> oder <xref:System.Collections.Generic.IEnumerable%601>.  
  
 Um nach einem Array zu suchen, verwenden Sie Code wie z. b.:  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 Wenn der aktuelle Typ einen generischen Typ oder einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese Eigenschaft immer `false`zurück.  
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Type.IsArray%2A>-Eigenschaft veranschaulicht.  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsArrayImpl : unit -&gt; bool" Usage="type.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.IsArray" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> ein Array ist.</summary>
        <returns><see langword="true" /> , wenn <see cref="T:System.Type" /> ein Array ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine Instanz der <xref:System.Array> Klasse muss `false` zurückgeben, da es sich um ein Objekt und nicht um ein Array handelt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `IsArrayImpl`-Methode in der `MyTypeDelegator`-Klasse überschrieben, und es wird überprüft, ob eine Variable ein Array ist, und das Ergebnis wird angezeigt.  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Type -&gt; bool&#xA;override this.IsAssignableFrom : Type -&gt; bool" Usage="type.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="c">Der Typ, der mit dem aktuellen Typ verglichen werden soll.</param>
        <summary>Bestimmt, ob eine Instanz des angegebenen Typs einer Variablen des aktuellen Typs zugewiesen werden kann.</summary>
        <returns><see langword="true" />, wenn eine der folgenden Bedingungen erfüllt ist: 
-   <paramref name="c" /> und die aktuelle Instanz haben denselben Typ.  
  
-   <paramref name="c" /> ist entweder direkt oder indirekt von der aktuellen Instanz abgeleitet. <paramref name="c" /> wird direkt von der aktuellen Instanz abgeleitet, wenn es von der aktuellen Instanz erbt; <paramref name="c" /> wird indirekt von der aktuellen Instanz abgeleitet, wenn es von einer Folge von einer oder mehr Klassen erbt, die von der aktuellen Instanz erben.  
  
–   Die aktuelle Instanz ist eine Schnittstelle, die von <paramref name="c" /> implementiert wird.  
  
-   <paramref name="c" /> ist ein generischer Typparameter, und die aktuelle Instanz stellt eine der Einschränkungen von <paramref name="c" /> dar.  
  
-   <paramref name="c" /> stellt einen Werttyp dar, und die aktuelle Instanz stellt <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> in Visual Basic) dar.  
  
 <see langword="false" />, wenn keine dieser Bedingungen erfüllt sind oder wenn <paramref name="c" /><see langword="null" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.IsAssignableFrom%2A>-Methode kann verwendet werden, um zu bestimmen, ob eine Instanz von `c` einer Instanz des aktuellen Typs zugewiesen werden kann. die-Methode ist besonders nützlich, wenn Sie Objekte verarbeiten, deren Typen zur Entwurfszeit nicht bekannt sind, und die bedingte Zuweisung ermöglicht, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 Durch diese Methode wird sichergestellt, dass eine Codezeile wie die folgende zur Laufzeit ausgeführt wird, ohne dass eine <xref:System.InvalidCastException> Ausnahme oder eine ähnliche Ausnahme ausgelöst wird:  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.  
  
> [!NOTE]
>  Eine generische Typdefinition kann nicht aus einem geschlossenen konstruierten Typ zugewiesen werden. Das heißt, Sie können den geschlossenen, erstellten Typ `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) nicht einer Variablen vom Typ `MyGenericList<T>`zuweisen.  
  
 Wenn der `c`-Parameter vom Typ <xref:System.Reflection.Emit.TypeBuilder>ist, basiert das Ergebnis auf dem Typ, der erstellt werden soll. Das folgende Codebeispiel veranschaulicht dies mithilfe eines erstellten Typs mit dem Namen `B`.  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 Im folgenden Beispiel wird die `IsAssignableFrom`-Methode veranschaulicht, indem definierte Klassen, ganzzahlige Arrays und Generika verwendet werden.  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  

 Im folgenden Beispiel handelt es sich bei der aktuellen Instanz um ein <xref:System.Type>-Objekt, das die Klasse <xref:System.IO.Stream> darstellt. `GenericWithConstraint` ist ein generischer Typ, dessen generischer Typparameter vom Typ <xref:System.IO.Stream>sein muss. Durch Übergeben des generischen Typparameters an die `IsAssignableFrom`-Methode wird angegeben, dass eine Instanz des generischen Typparameters einem <xref:System.IO.Stream> Objekt zugewiesen werden kann.
  
 [!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)]
 [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]  

  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoClass : bool" Usage="System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob für <see langword="AutoClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist.</summary>
        <value><see langword="true" />, wenn für <see langword="AutoClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Reflection.TypeAttributes.StringFormatMask> wählt die Zeichen folgen Format Attribute aus. Die Attribute des Zeichen folgen Formats verbessern die Interoperabilität durch definieren, wie Zeichen folgen interpretiert werden sollen.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gilt diese Eigenschaft für die generische Typdefinition, aus der der Typ erstellt wurde. Wenn die aktuelle <xref:System.Type> z. b. `MyGenericType<int>` darstellt (`MyGenericType(Of Integer)` in Visual Basic), wird der Wert dieser Eigenschaft durch `MyGenericType<T>`bestimmt.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft immer `false`zurück.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoLayout : bool" Usage="System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Felder des aktuellen Typs automatisch von der Common Language Runtime angelegt werden.</summary>
        <value><see langword="true" />, wenn die <see cref="P:System.Type.Attributes" />-Eigenschaft des aktuellen Typs <see cref="F:System.Reflection.TypeAttributes.AutoLayout" /> umfasst; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird als praktische Hilfe bereitgestellt. Alternativ können Sie den <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>-Enumerationswert verwenden, um die Typlayoutattribute auszuwählen, und dann testen, ob <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> festgelegt ist. Die Enumerationswerte <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>und <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> geben an, wie die Felder des Typs im Arbeitsspeicher angeordnet werden.  
  
 Bei dynamischen Typen können Sie <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> beim Erstellen des Typs angeben. Wenden Sie im Code das <xref:System.Runtime.InteropServices.StructLayoutAttribute>-Attribut mit dem <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> Enumerationswert auf den-Typ an, damit die Common Language Runtime die geeignete Methode zum Anordnen der Klasse bestimmen kann.  
  
> [!NOTE]
>  Sie können die <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>-Methode nicht verwenden, um zu bestimmen, ob die <xref:System.Runtime.InteropServices.StructLayoutAttribute> auf einen Typ angewendet wurde.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gilt diese Eigenschaft für die generische Typdefinition, aus der der Typ erstellt wurde. Wenn die aktuelle <xref:System.Type> z. b. `MyGenericType<int>` darstellt (`MyGenericType(Of Integer)` in Visual Basic), wird der Wert dieser Eigenschaft von bestimmt `MyGenericType<T>.`  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese Eigenschaft immer `false`zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz des-Typs erstellt und die <xref:System.Type.IsAutoLayout%2A>-Eigenschaft angezeigt.  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="/dotnet/standard/metadata-and-self-describing-components">Metadaten und selbstbeschreibende Komponenten</related>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public virtual bool IsByRef { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRef As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRef { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.IsByRef : bool" Usage="System.Type.IsByRef" />
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> als Verweis übergeben wird.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> als Verweis übergeben wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um zum eigentlichen Typ zu gelangen, Dereferenzieren Sie den Typ, der als Verweis weitergegeben wurde, und wenden Sie dann <xref:System.Type.GetElementType%2A> für diesen Typ an.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der `IsByRef`-Eigenschaft, um zu überprüfen, ob ein angegebener Typ als Verweis übergangen wird. Das Beispiel definiert die-Klasse `MyTypeDelegator`, die die `HasElementTypeImpl`-Methode überschreibt. Die Hauptklasse überprüft die `HasElementType`-Eigenschaft und zeigt den Elementtyp an.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsByRefImpl : unit -&gt; bool" Usage="type.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.IsByRef" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> als Verweis übergeben wird.</summary>
        <returns><see langword="true" />, wenn <see cref="T:System.Type" /> als Verweis übergeben wird, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Type.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Typ eine byref-ähnliche Struktur aufweist</summary>
        <value><see langword="true" />, wenn die <see cref="T:System.Type" /> eine ByRef-ähnliche Struktur ist; Andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks
ByRef-ähnliche Strukturen werden mit `ref struct`-Schlüsselwort C#in deklariert. Eine Instanz der ByRef-like-Struktur kann nicht auf dem verwalteten Heap platziert werden. Weitere Informationen finden Sie unter [ref struct](/dotnet/csharp/language-reference/builtin-types/struct#ref-struct).

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool" Usage="System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> eine Klasse oder ein Delegat ist, d. h. weder ein Werttyp noch eine Schnittstelle.</summary>
        <value><see langword="true" /> , wenn <see cref="T:System.Type" /> eine Klasse ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt `true` für Klassen und Delegaten zurück. Sie gibt `false` für Werttypen (für Strukturen und Enumerationen) zurück, auch wenn Sie gekapselt sind.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese Eigenschaft immer `true`zurück. Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Eigenschaft `true` zurück, wenn die generische Typdefinition eine Klassendefinition ist. Das heißt, es wird keine Schnittstelle oder kein Werttyp definiert.  
  
> [!NOTE]
>  Diese Eigenschaft gibt `true` für `Type` Instanzen zurück, die die Klassen <xref:System.Enum> und <xref:System.ValueType> darstellen. Diese beiden Klassen sind die Basis Typen für Enumerationen und Werttypen, aber Sie sind nicht selbst Enumerationen oder Werttypen. Weitere Informationen finden Sie in den Ausführungen zur <xref:System.Type.IsValueType%2A>-Eigenschaft und zur <xref:System.Type.IsEnum%2A>-Eigenschaft.  
  
 Der <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType>-Enumerationswert unterscheidet eine Typdeklaration als Klasse oder Schnittstelle. Allerdings werden sowohl Klassen als auch Werttypen mit dem <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType>-Attribut gekennzeichnet. Wenn Sie den Wert der Attributeigenschaft eines Typs abrufen und den <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> Wert verwenden, um zu bestimmen, ob ein Typ eine Klasse anstelle eines Werttyps ist, müssen Sie auch die <xref:System.Type.IsValueType%2A>-Eigenschaft aufrufen. Das Beispiel für die <xref:System.Reflection.TypeAttributes>-Enumeration enthält zusätzliche Informationen und ein Beispiel.  
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz eines Typs erstellt, und es wird angegeben, ob der Typ eine Klasse ist.  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCOMObject : bool" Usage="System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> ein COM-Objekt ist.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> ein COM-Objekt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt `false` für COM-Schnittstellen zurück, da Sie keine Objekte sind. COM-Schnittstellen können von Microsoft .NET Framework-Objekten implementiert werden.  
  
 Sie können auch eine COM-Klasse laden und mithilfe des Tools " [Tlbimp. exe" (Typbibliotheks Import)](/dotnet/framework/tools/tlbimp-exe-type-library-importer) ein `Type` Objekt für diese com-Klasse erhalten.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gilt diese Eigenschaft für die generische Typdefinition, aus der der Typ erstellt wurde. Wenn die aktuelle <xref:System.Type> z. b. `MyGenericType<int`> darstellt (`MyGenericType(Of Integer)` in Visual Basic), wird der Wert dieser Eigenschaft durch `MyGenericType<T>`bestimmt.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese Eigenschaft immer `false`zurück.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsCOMObjectImpl : unit -&gt; bool" Usage="type.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.IsCOMObject" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> ein COM-Objekt ist.</summary>
        <returns><see langword="true" />, wenn <see cref="T:System.Type" /> ein COM-Objekt ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt `false` für COM-Schnittstellen zurück, da Sie keine Objekte sind. COM-Schnittstellen können von Microsoft .NET Framework-Objekten implementiert werden.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public abstract bool IsConstructedGenericType { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsConstructedGenericType As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsConstructedGenericType { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Type.IsConstructedGenericType" />
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob dieses Objekt einen konstruierten generischen Typ darstellt. Sie können Instanzen eines konstruierten generischen Typs erstellen.</summary>
        <value><see langword="true" />, wenn dieses Objekt einen konstruierten generischen Typ darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für einen konstruierten generischen Typ wurden explizite Typen für alle seine generischen Typparameter bereitgestellt. Sie wird auch als geschlossener generischer Typ bezeichnet.  
  
 Wenn diese Eigenschaft `true`ist, können Sie Instanzen des aktuellen Typs erstellen. Wenn es `false`ist, ist dies nicht möglich.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContextful : bool" Usage="System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> in einen Kontext aufgenommen werden kann.</summary>
        <value><see langword="true" /> , wenn <see cref="T:System.Type" /> in einen Kontext aufgenommen werden kann, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Kontext fängt Aufrufe der Klassenmember ab und erzwingt Richtlinien, die auf die Klasse angewendet werden, z. b. die Synchronisierung. Ausführlichere Informationen zu remotingkontexten finden Sie unter <xref:System.Runtime.Remoting.Contexts.Context>.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese Eigenschaft immer `false`zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Eigenschaften `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>und <xref:System.Type.IsPrimitive%2A> der <xref:System.Type>-Klasse veranschaulicht. Er überprüft, ob der angegebene Typ im Kontext gehostet werden kann, ob er als Verweis gemarshallt werden kann und ob der Typ ein primitiver Datentyp ist.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsContextfulImpl : unit -&gt; bool&#xA;override this.IsContextfulImpl : unit -&gt; bool" Usage="type.IsContextfulImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert die <see cref="P:System.Type.IsContextful" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> in einen Kontext aufgenommen werden kann.</summary>
        <returns><see langword="true" /> , wenn <see cref="T:System.Type" /> in einen Kontext aufgenommen werden kann, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.  
  
 Ein Kontext fängt Aufrufe der Klassenmember ab und erzwingt Richtlinien, die auf die Klasse angewendet werden, z. b. die Synchronisierung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `IsContextfulImpl`-Methode veranschaulicht.  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Type.IsEnum" />
      <MemberSignature Language="C#" Value="public bool IsEnum { get; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEnum As Boolean" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnum { bool get(); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle <see cref="T:System.Type" /> eine Enumeration darstellt.</summary>
        <value><see langword="true" />, wenn der aktuelle <see cref="T:System.Type" /> eine Enumeration darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt `true` für eine Enumeration zurück, jedoch nicht für den <xref:System.Enum> Typ selbst.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gilt diese Eigenschaft für die generische Typdefinition, aus der der Typ erstellt wurde. Wenn die aktuelle <xref:System.Type> z. b. `MyGenericType<int>` darstellt (`MyGenericType(Of Integer)` in Visual Basic), wird der Wert dieser Eigenschaft durch `MyGenericType<T>`bestimmt.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese Eigenschaft immer `false`zurück.  
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die `IsEnum`-Eigenschaft verwendet wird.  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsEnumDefined : obj -&gt; bool&#xA;override this.IsEnumDefined : obj -&gt; bool" Usage="type.IsEnumDefined value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">Der zu überprüfende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der angegebene Wert im aktuellen Enumerationstyp vorhanden ist.</summary>
        <returns><see langword="true" />, wenn der angegebene Wert ein Member des aktuellen Enumerationstyps ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">Der aktuelle Typ ist keine Enumeration.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" /></exception>
        <exception cref="T:System.InvalidOperationException"><paramref name="value" /> ist ein Typ, der nicht der zugrunde liegende Typ einer Enumeration sein kann.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentTo : Type -&gt; bool&#xA;override this.IsEquivalentTo : Type -&gt; bool" Usage="type.IsEquivalentTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="other">Der COM-Typ, der auf Äquivalenz mit dem aktuellen Typ überprüft wird.</param>
        <summary>Bestimmt, ob zwei COM-Typen die gleiche Identität haben und äquivalente Typen aufweisen können.</summary>
        <returns><see langword="true" />, wenn die COM-Typen äquivalent sind, andernfalls <see langword="false" />. Diese Methode gibt auch <see langword="false" /> zurück, wenn ein Typ in einer Assembly enthalten ist, die zum Ausführen geladen wird, und der andere in einer Assembly enthalten ist, die in den reflektionsbezogenen Kontext geladen wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beginnend mit der [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]unterstützt das Common Language Runtime die Einbettung von Typinformationen für COM-Typen direkt in verwaltete Assemblys, anstatt dass die verwalteten Assemblys Typinformationen für COM-Typen aus Interopassemblys abrufen müssen. Da die eingebettete Typinformation nur die Typen und Member enthält, die tatsächlich von einer verwalteten Assembly verwendet werden, können zwei verwaltete Assemblys möglicherweise sehr unterschiedliche Ansichten desselben COM-Typs haben. Jede verwaltete Assembly besitzt ein anderes <xref:System.Type>-Objekt, das eine Ansicht des COM-Typs darstellt. Die Common Language Runtime unterstützt Typäquivalenz zwischen diesen unterschiedlichen Ansichten für Schnittstellen, Strukturen, Enumerationen und Delegaten.  
  
 Typäquivalenz bedeutet, dass ein COM-Objekt, das von einer verwalteten Assembly an eine andere übergeben wird, für den entsprechenden verwalteten Typ in der empfangenden Assembly bereitgestellt werden kann. Die <xref:System.Type.IsEquivalentTo%2A>-Methode ermöglicht es einer Assembly zu bestimmen, dass ein COM-Objekt, das aus einer anderen Assembly abgerufen wurde, dieselbe com-Identität wie einer der eigenen eingebetteten Interop-Typen der ersten Assembly hat und daher in diesen Typ umgewandelt werden kann.  
  
 Weitere Informationen finden Sie unter [typäquivalenz und eingebettete Interop-Typen](/dotnet/framework/interop/type-equivalence-and-embedded-interop-types).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExplicitLayout : bool" Usage="System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Felder des aktuellen Typs an den explizit angegebenen Offsets angelegt werden.</summary>
        <value><see langword="true" />, wenn die <see cref="P:System.Type.Attributes" />-Eigenschaft des aktuellen Typs <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" /> umfasst; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird als praktische Hilfe bereitgestellt. Alternativ können Sie den <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>-Enumerationswert verwenden, um die Typlayoutattribute auszuwählen, und dann testen, ob <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> festgelegt ist. Die Enumerationswerte <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>und <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> geben an, wie die Felder des Typs im Arbeitsspeicher angeordnet werden.  
  
 Bei dynamischen Typen können Sie <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> beim Erstellen des Typs angeben. Wenden Sie im Code das <xref:System.Runtime.InteropServices.StructLayoutAttribute>-Attribut mit dem <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> Enumerationswert auf den-Typ an, um anzugeben, dass die Offsets, bei denen die Felder beginnen, explizit angegeben werden.  
  
> [!NOTE]
>  Sie können die <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>-Methode nicht verwenden, um zu bestimmen, ob die <xref:System.Runtime.InteropServices.StructLayoutAttribute> auf einen Typ angewendet wurde.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gilt diese Eigenschaft für die generische Typdefinition, aus der der Typ erstellt wurde. Wenn die aktuelle <xref:System.Type> z. b. `MyGenericType<int>` darstellt (`MyGenericType(Of Integer)` in Visual Basic), wird der Wert dieser Eigenschaft durch `MyGenericType<T>`bestimmt.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese Eigenschaft immer `false`zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz eines Typs erstellt und der Wert der <xref:System.Type.IsExplicitLayout%2A>-Eigenschaft angezeigt. Dabei wird die `MySystemTime`-Klasse verwendet, die auch im Codebeispiel für <xref:System.Runtime.InteropServices.StructLayoutAttribute>ist.  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <related type="Article" href="/dotnet/standard/metadata-and-self-describing-components">Metadaten und selbstbeschreibende Komponenten</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Type.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle <see cref="T:System.Type" /> einen Typparameter in der Definition einer generischen Methode darstellt</summary>
        <value><see langword="true" />, wenn das <see cref="T:System.Type" />-Objekt einen Typparameter einer generischen Methoden Definition darstellt. Andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public abstract bool IsGenericParameter { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsGenericParameter As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsGenericParameter { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Type.IsGenericParameter" />
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle <see cref="T:System.Type" /> einen Typparameter einer generischen Typ- oder Methodendefinition darstellt.</summary>
        <value><see langword="true" />, wenn das <see cref="T:System.Type" />-Objekt einen Typparameter einer generischen Typ- oder Methodendefinition darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Type> Objekte, die generische Typparameter darstellen, können abgerufen werden, indem die <xref:System.Type.GetGenericArguments%2A>-Methode eines <xref:System.Type> Objekts aufgerufen wird, das eine generische Typdefinition darstellt, oder die <xref:System.Reflection.MethodInfo.GetGenericArguments%2A>-Methode eines <xref:System.Reflection.MethodInfo> Objekts, das eine generische Methoden Definition darstellt.  
  
-   Bei einer generischen Typ-oder Methoden Definition gibt die <xref:System.Type.IsGenericParameter%2A>-Eigenschaft `true` für jedes Element des resultierenden Arrays zurück.  
  
-   Bei einem geschlossenen konstruierten Typ oder einer geschlossenen Methode gibt die <xref:System.Type.IsGenericParameter%2A>-Eigenschaft `false` für jedes Element des Arrays zurück, das von der <xref:System.Type.GetGenericArguments%2A>-Methode zurückgegeben wird.  
  
-   Bei einem offenen konstruierten Typ oder einer offenen Methode können einige Elemente des Arrays bestimmte Typen sein, und andere können Typparameter sein. <xref:System.Type.IsGenericParameter%2A> gibt `false` für die Typen und `true` für die Typparameter zurück. Das Codebeispiel für die <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft veranschaulicht eine generische Klasse mit einer Mischung aus Typen und Typparametern.  
  
 Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Type.IsGenericParameter%2A>-Eigenschaft verwendet, um auf generische Typparameter in einem generischen Typ zu testen.  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/reflection-and-generic-types">Reflektion und generische Typen</related>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection">Gewusst wie: Untersuchen und Instanziieren von generischen Typen mit Reflektion</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Typ ein generischer Typ ist.</summary>
        <value><see langword="true" />, wenn der aktuelle Typ ein generischer Typ ist. Andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Type.IsGenericType%2A>-Eigenschaft, um zu bestimmen, ob ein <xref:System.Type> Objekt einen generischen Typ darstellt. Verwenden Sie die <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft, um zu bestimmen, ob ein <xref:System.Type> Objekt einen geöffneten konstruierten Typ oder einen geschlossenen konstruierten Typ darstellt.  
  
> [!NOTE]
>  Die <xref:System.Type.IsGenericType%2A>-Eigenschaft gibt `false` zurück, wenn der unmittelbare Typ nicht generisch ist. Beispielsweise ist ein Array, dessen Elemente vom Typ `A<int>` (`A(Of Integer)` in Visual Basic), nicht selbst ein generischer Typ.  
  
 In der folgenden Tabelle werden die invarianten Bedingungen für allgemeine Begriffe zusammengefasst, die bei allgemeiner Reflektion verwendet werden.  
  
|Begriff|Invariante|  
|----------|---------------|  
|generische Typdefinition|Die <xref:System.Type.IsGenericTypeDefinition%2A>-Eigenschaft ist `true`.<br /><br /> Definiert einen generischen Typ. Ein konstruierter Typ wird erstellt, indem die <xref:System.Type.MakeGenericType%2A>-Methode für ein <xref:System.Type> Objekt aufgerufen wird, das eine generische Typdefinition darstellt und ein Array von Typargumenten angibt.<br /><br /> <xref:System.Type.MakeGenericType%2A> können nur für generische Typdefinitionen aufgerufen werden.<br /><br /> Jede generische Typdefinition ist ein generischer Typ (die <xref:System.Type.IsGenericType%2A>-Eigenschaft ist `true`), der umgekehrte Wert ist jedoch nicht "true".|  
|generischer Typ|Die <xref:System.Type.IsGenericType%2A>-Eigenschaft ist `true`.<br /><br /> Dabei kann es sich um eine generische Typdefinition, einen offenen konstruierten Typ oder einen geschlossenen konstruierten Typ handeln.<br /><br /> Beachten Sie, dass ein Arraytyp, dessen Elementtyp generisch ist, nicht selbst ein generischer Typ ist. Das gleiche gilt für ein <xref:System.Type> Objekt, das einen Zeiger auf einen generischen Typ darstellt.|  
|erstellter Typ öffnen|Die <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft ist `true`.<br /><br /> Beispiele sind ein generischer Typ, der über nicht zugewiesene Typparameter verfügt, einen Typ, der in einer generischen Typdefinition oder in einem geöffneten konstruierten Typ oder einen generischen Typ mit einem Typargument, für das die <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft `true`ist, enthält.<br /><br /> Es ist nicht möglich, eine Instanz eines geöffneten konstruierten Typs zu erstellen.<br /><br /> Beachten Sie, dass nicht alle offenen konstruierten Typen generisch sind. Beispielsweise ist ein Array, dessen Elementtyp eine generische Typdefinition ist, nicht generisch, und ein Zeiger auf einen geöffneten konstruierten Typ ist nicht generisch.|  
|geschlossener konstruierter Typ|Die <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft ist `false`.<br /><br /> Bei rekursiver unter Prüfung verfügt der Typ nicht über nicht zugewiesene generische Parameter.|  
|generischer Typparameter|Die <xref:System.Type.IsGenericParameter%2A>-Eigenschaft ist `true`.<br /><br /> Die <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft ist `true`.<br /><br /> In einer generischen Typdefinition ein Platzhalter für einen Typ, der später zugewiesen wird.|  
|generisches Typargument|Kann ein beliebiger Typ sein, einschließlich eines generischen Typparameters.<br /><br /> Typargumente werden als Array von <xref:System.Type> Objekten angegeben, die beim Erstellen eines konstruierten generischen Typs an die <xref:System.Type.MakeGenericType%2A>-Methode übermittelt werden. Wenn Instanzen des resultierenden Typs erstellt werden sollen, muss die <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft für alle Typargumente `false` werden.|  
  
 Im folgenden Codebeispiel und in der Tabelle werden einige dieser Begriffe und invarianten veranschaulicht. Die `Derived`-Klasse ist von besonderem Interesse, da ihr Basistyp ein konstruierter Typ ist, der über eine Mischung aus Typen und Typparametern in der Typargument Liste verfügt.  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 In der folgenden Tabelle sind Beispiele aufgeführt, in denen die Klassen `Base`, `Derived`und `G`verwendet und erstellt werden. Wenn der C++ - C# und der-Code identisch sind, wird nur ein Eintrag angezeigt.  
  
|Beispiel|Invarianten|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|Für diesen Typ:<br /><br /> <xref:System.Type.IsGenericType%2A> ist `true`<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> ist `true`<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> ist `true`|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|Für diesen Typ:<br /><br /> <xref:System.Type.IsGenericType%2A> ist `true`<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> ist `false`<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> ist `true`|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|Für den Typ der Variablen `d`:<br /><br /> <xref:System.Type.IsGenericType%2A> ist `false`, da `d` ein Array ist.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> ist `false`<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> ist `false`|  
|`T`, `U`und `V` (überall angezeigt)|<xref:System.Type.IsGenericParameter%2A> ist `true`<br /><br /> <xref:System.Type.IsGenericType%2A> ist `false`, da es keine Möglichkeit gibt, einen Typparameter auf generische Typen zu beschränken.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> ist `false`<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> ist `true`, da `T`, `U`und `V` selbst generische Typparameter sind. Dies impliziert nicht etwas über Typargumente, die später zugewiesen werden.|  
|Der Typ des Feld `F`|<xref:System.Type.IsGenericType%2A> ist `true`<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> ist `false`, da dem Typparameter von `G`ein Typ zugewiesen wurde. Beachten Sie, dass dies der <xref:System.Type.MakeGenericType%2A>-Methode entspricht.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> ist `true`, da der Typ des Felds `F` über ein Typargument verfügt, das einen geöffneten konstruierten Typ aufweist. Der konstruierte Typ ist offen, da sein Typargument (d. h. `Base`) eine generische Typdefinition ist. Dies veranschaulicht die rekursive Natur der <xref:System.Type.IsGenericType%2A>-Eigenschaft.|  
|Die `Nested` der-Klasse|<xref:System.Type.IsGenericType%2A> ist `true`, auch wenn die `Nested` Klasse keine eigenen generischen Typparameter besitzt, da Sie in einem generischen Typ eingebettet ist.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> ist `true` Das heißt, Sie können die <xref:System.Type.MakeGenericType%2A>-Methode aufrufen und den Typparameter des einschließenden Typs, `Derived`, angeben.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> ist `true`, da der einschließende Typ, der `Derived`, über generische Typparameter verfügt. Dies veranschaulicht die rekursive Natur der <xref:System.Type.ContainsGenericParameters%2A>-Eigenschaft.|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird der Wert der Eigenschaften <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>und <xref:System.Type.ContainsGenericParameters%2A> für die Typen angezeigt, die im Abschnitt "Hinweise" beschrieben werden. Erläuterungen zu den Eigenschafts Werten finden Sie in der zugehörigen Tabelle unter "Hinweise".  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/reflection-and-generic-types">Reflektion und generische Typen</related>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection">Gewusst wie: Untersuchen und Instanziieren von generischen Typen mit Reflektion</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle <see cref="T:System.Type" /> eine generische Typdefinition darstellt, aus der andere generische Typen konstruiert werden können.</summary>
        <value><see langword="true" />, wenn das <see cref="T:System.Type" />-Objekt eine generische Typdefinition darstellt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine generische Typdefinition ist eine Vorlage, von der andere Typen erstellt werden können. Beispielsweise können Sie aus der generischen Typdefinition `G<T>` ( C# ausgedrückt in Syntax, `G(Of T)` in Visual Basic oder C++`generic <typename T> ref class G` in) den Typ `G<int>` (`G(Of Integer)` in Visual Basic) erstellen und instanziieren, indem Sie die <xref:System.Type.MakeGenericType%2A>-Methode mit einer generischen Argumentliste aufrufen, die den <xref:System.Int32>-Typ enthält. Bei einem <xref:System.Type> Objekt, das diesen konstruierten Typ darstellt, ruft die <xref:System.Type.GetGenericTypeDefinition%2A>-Methode die generische Typdefinition wieder zurück.  
  
 Verwenden Sie die <xref:System.Type.IsGenericTypeDefinition%2A>-Eigenschaft, um zu bestimmen, ob Sie neue Typen aus dem aktuellen Typ erstellen können. Wenn die <xref:System.Type.IsGenericTypeDefinition%2A>-Eigenschaft `true`zurückgibt, können Sie die <xref:System.Type.MakeGenericType%2A>-Methode aufzurufen, um neue generische Typen zu erstellen.  
  
 Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel werden Informationen zu einem Typ, einschließlich der Angabe, ob es sich um eine generische Typdefinition handelt, angezeigt. Informationen werden für einen konstruierten Typ, für die generische Typdefinition und für einen normalen Typ angezeigt.  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/reflection-and-generic-types">Reflektion und generische Typen</related>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection">Gewusst wie: Untersuchen und Instanziieren von generischen Typen mit Reflektion</related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Type.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle <see cref="T:System.Type" /> einen Typparameter in der Definition eines generischen Typs darstellt</summary>
        <value><see langword="true" />, wenn das <see cref="T:System.Type" /> Objekt einen Typparameter einer generischen Typdefinition darstellt. Andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImport : bool" Usage="System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Type" /> ein <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />-Attribut hat, was bedeutet, dass er aus einer COM-Typbibliothek importiert wurde.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Type" /> ein <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> hat, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gilt diese Eigenschaft für die generische Typdefinition, aus der der Typ erstellt wurde. Wenn die aktuelle <xref:System.Type> z. b. `MyGenericType<int>` darstellt (`MyGenericType(Of Integer)` in Visual Basic), wird der Wert dieser Eigenschaft von bestimmt `MyGenericType<T>.`  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese Eigenschaft immer `false`zurück.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="abstract member IsInstanceOfType : obj -&gt; bool&#xA;override this.IsInstanceOfType : obj -&gt; bool" Usage="type.IsInstanceOfType o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="o">Das mit dem aktuellen Typ zu vergleichende Objekt.</param>
        <summary>Bestimmt, ob das angegebene Objekt eine Instanz des aktuellen <see cref="T:System.Type" /> ist.</summary>
        <returns><see langword="true" />, wenn der aktuelle <see langword="Type" /> in der Vererbungshierarchie des von <paramref name="o" /> dargestellten Objekts vorhanden ist oder wenn der aktuelle <see langword="Type" /> eine Schnittstelle ist, die von <paramref name="o" /> implementiert wird. <see langword="false" />, wenn keine dieser Bedingungen zutrifft, wenn <paramref name="o" /> den Wert <see langword="null" /> hat oder wenn der aktuelle <see langword="Type" /> ein offener generischer Typ ist (d. h. <see cref="P:System.Type.ContainsGenericParameters" /> gibt <see langword="true" /> zurück).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.  
  
> [!NOTE]
>  Ein konstruierter Typ ist keine Instanz seiner generischen Typdefinition. Das heißt, `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) ist keine Instanz von `MyGenericList<T>` (`MyGenericList(Of T)` in Visual Basic).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der `IsInstanceOfType`-Methode gezeigt.  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool" Usage="System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> eine Schnittstelle ist, d. h. weder eine Klasse noch ein Werttyp.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> eine Schnittstelle ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> unterscheidet eine Typdeklaration als Klasse, Schnittstelle oder Werttyp.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese Eigenschaft immer `false`zurück.  
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Schnittstelle erstellt, die auf den Schnittstellentyp überprüft wird und angegeben wird, ob für eine Klasse die `IsInterface`-Eigenschaft festgelegt ist.  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLayoutSequential : bool" Usage="System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die Felder des aktuellen Typs sequenziell angelegt werden, in der Reihenfolge, in der sie definiert oder an die Metadaten ausgegeben wurden.</summary>
        <value><see langword="true" />, wenn die <see cref="P:System.Type.Attributes" />-Eigenschaft des aktuellen Typs <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" /> umfasst; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft wird als praktische Hilfe bereitgestellt. Alternativ können Sie den <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType>-Enumerationswert verwenden, um die Typlayoutattribute auszuwählen, und dann testen, ob <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> festgelegt ist. Die Enumerationswerte <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>und <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> geben an, wie die Felder des Typs im Arbeitsspeicher angeordnet werden.  
  
 Bei dynamischen Typen können Sie <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> beim Erstellen des Typs angeben. Wenden Sie im Code das <xref:System.Runtime.InteropServices.StructLayoutAttribute>-Attribut mit dem <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType>-Enumerationswert auf den-Typ an, um anzugeben, dass das Layout sequenziell ist.  
  
> [!NOTE]
>  Sie können die <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>-Methode nicht verwenden, um zu bestimmen, ob die <xref:System.Runtime.InteropServices.StructLayoutAttribute> auf einen Typ angewendet wurde.  
  
 Weitere Informationen finden Sie im Abschnitt 9.1.2 der Spezifikation für die Common Language Infrastructure (CLI)-Dokumentation "Partition II: Metadata Definition and Semantics". Die Dokumentation ist online verfügbar. Sie finden sie unter [ECMA C# and Common Language Infrastructure Standards (Standards von ECMA C# und Common Language Infrastructure)](https://go.microsoft.com/fwlink/?LinkID=99212) auf MSDN und [Standard ECMA-335 - Common Language Infrastructure (CLI) (Standard ECMA-335 – Common Language Infrastructure (CLI))](https://go.microsoft.com/fwlink/?LinkID=65552) auf der Ecma International-Website.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gilt diese Eigenschaft für die generische Typdefinition, aus der der Typ erstellt wurde. Wenn die aktuelle <xref:System.Type> z. b. `MyGenericType<int>` darstellt (`MyGenericType(Of Integer)` in Visual Basic), wird der Wert dieser Eigenschaft durch `MyGenericType<T>`bestimmt.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese Eigenschaft immer `false`zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz einer Klasse erstellt, für die der <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> Enumerationswert in der <xref:System.Runtime.InteropServices.StructLayoutAttribute>-Klasse festgelegt wurde, die <xref:System.Type.IsLayoutSequential%2A>-Eigenschaft überprüft und das Ergebnis anzeigt.  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="/dotnet/standard/metadata-and-self-describing-components">Metadaten und selbstbeschreibende Komponenten</related>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarshalByRef : bool" Usage="System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> als Verweis gemarshallt wird.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> als Verweis gemarshallt wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel werden die Eigenschaften <xref:System.Type.IsContextful%2A>, `IsMarshalByRef`und <xref:System.Type.IsPrimitive%2A> der <xref:System.Type>-Klasse veranschaulicht. Er überprüft, ob der angegebene Typ im Kontext gehostet werden kann, ob er als Verweis gemarshallt werden kann und ob der Typ ein primitiver Datentyp ist.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsMarshalByRefImpl : unit -&gt; bool&#xA;override this.IsMarshalByRefImpl : unit -&gt; bool" Usage="type.IsMarshalByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert die <see cref="P:System.Type.IsMarshalByRef" />-Eigenschaft und bestimmt, ob der <see cref="T:System.Type" /> als Verweis gemarshallt wird.</summary>
        <returns><see langword="true" />, wenn <see cref="T:System.Type" /> als Verweis gemarshallt wird, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ermittelt, ob der angegebene Typ als Verweis gemarshallt wird, und das Ergebnis wird angezeigt.  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNested : bool" Usage="System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das aktuelle <see cref="T:System.Type" />-Objekt einen Typ darstellt, dessen Definition in der Definition eines anderen Typs geschachtelt ist.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Type" /> in einem anderen Typ geschachtelt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.IsNested%2A>-Eigenschaft gibt `true` unabhängig von der Sichtbarkeit für alle anderen Typen zurück. Verwenden Sie die zugehörigen Eigenschaften <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>oder <xref:System.Type.IsNestedPublic%2A>, um gleichzeitig auf Schachtelung und Sichtbarkeit zu testen.  
  
> [!NOTE]
>  Der <xref:System.Reflection.TypeAttributes.VisibilityMask> Enumerationsmember wählt die Sichtbarkeits Attribute für einen Typ aus.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine äußere Klasse mit einer Reihe von Klassen erstellt, die verschiedene Arten von Sichtbarkeit aufweisen. Anschließend wird der Wert einer Reihe von Sicht barkeits bezogenen <xref:System.Type> Eigenschaften für den übergeordneten Typ und die einzelnen zugehörigen Typen abgerufen.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedAssembly : bool" Usage="System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> geschachtelt und nur innerhalb der eigenen Assembly sichtbar ist.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> geschachtelt und nur innerhalb der eigenen Assembly sichtbar ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft immer `false`zurück.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> wählt die Sichtbarkeits Attribute aus.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine äußere Klasse mit einer Reihe von Klassen erstellt, die verschiedene Arten von Sichtbarkeit aufweisen. Anschließend wird der Wert einer Reihe von Sicht barkeits bezogenen <xref:System.Type> Eigenschaften für den übergeordneten Typ und die einzelnen zugehörigen Typen abgerufen.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamANDAssem : bool" Usage="System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> geschachtelt und ausschließlich für Klassen sichtbar ist, die sowohl zur eigenen Familie als auch zur eigenen Assembly gehören.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> geschachtelt und ausschließlich für Klassen sichtbar ist, die sowohl zur eigenen Familie als auch zur eigenen Assembly gehören, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft immer `false`zurück.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> wählt die Sichtbarkeits Attribute aus.  
  
> [!NOTE]
>  Die C# Sprachen und Visual Basic enthalten keine Semantik, mit der Sie einen nicht definierten Typ definieren können, der nur für geschützte Typen in der eigenen Assembly sichtbar ist. `protected internal` Sichtbarkeit C# in und `Protected Friend` Sichtbarkeit in Visual Basic einen für geschützte Typen und für Typen in derselben Assembly sichtbaren Typ definieren.  
  
 Die Familie eines <xref:System.Type> Objekts wird als alle Objekte desselben <xref:System.Type> und seiner Untertypen definiert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine äußere Klasse mit einer Reihe von Klassen erstellt, die verschiedene Arten von Sichtbarkeit aufweisen. Anschließend wird der Wert einer Reihe von Sicht barkeits bezogenen <xref:System.Type> Eigenschaften für den übergeordneten Typ und die einzelnen zugehörigen Typen abgerufen.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamily : bool" Usage="System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> geschachtelt und nur innerhalb der eigenen Familie sichtbar ist.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> geschachtelt und nur innerhalb der eigenen Familie sichtbar ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft immer `false`zurück.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> wählt die Sichtbarkeits Attribute aus.  
  
 Die Familie eines <xref:System.Type> Objekts wird als alle Objekte desselben <xref:System.Type> und seiner Untertypen definiert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine äußere Klasse mit einer Reihe von Klassen erstellt, die verschiedene Arten von Sichtbarkeit aufweisen. Anschließend wird der Wert einer Reihe von Sicht barkeits bezogenen <xref:System.Type> Eigenschaften für den übergeordneten Typ und die einzelnen zugehörigen Typen abgerufen.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamORAssem : bool" Usage="System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> geschachtelt und ausschließlich für Klassen sichtbar ist, die zur eigenen Familie oder zur eigenen Assembly gehören.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> geschachtelt und ausschließlich für Klassen sichtbar ist, die zur eigenen Familie oder zur eigenen Assembly gehören, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Sichtbarkeit eines Typs in C# Visual Basic `protected internal` oder `Protected Friend` wird, gibt die <xref:System.Type.IsNestedFamORAssem%2A>-Eigenschaft `true`zurück.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft immer `false`zurück.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> wählt die Sichtbarkeits Attribute aus.  
  
 Die Familie eines <xref:System.Type> Objekts wird als alle Objekte desselben <xref:System.Type> und seiner Untertypen definiert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine äußere Klasse mit einer Reihe von Klassen erstellt, die verschiedene Arten von Sichtbarkeit aufweisen. Anschließend wird der Wert einer Reihe von Sicht barkeits bezogenen <xref:System.Type> Eigenschaften für den übergeordneten Typ und die einzelnen zugehörigen Typen abgerufen.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPrivate : bool" Usage="System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> geschachtelt und als privat deklariert ist.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> geschachtelt und als privat deklariert ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft immer `false`zurück.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> wählt die Sichtbarkeits Attribute aus.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine äußere Klasse mit einer Reihe von Klassen erstellt, die verschiedene Arten von Sichtbarkeit aufweisen. Anschließend wird der Wert einer Reihe von Sicht barkeits bezogenen <xref:System.Type> Eigenschaften für den übergeordneten Typ und die einzelnen zugehörigen Typen abgerufen.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPublic : bool" Usage="System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob eine Klasse geschachtelt und als öffentlich deklariert ist.</summary>
        <value><see langword="true" />, wenn die Klasse geschachtelt und als öffentlich deklariert ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft immer `false`zurück.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> wählt die Sichtbarkeits Attribute aus.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine äußere Klasse mit einer Reihe von Klassen erstellt, die verschiedene Arten von Sichtbarkeit aufweisen. Anschließend wird der Wert einer Reihe von Sicht barkeits bezogenen <xref:System.Type> Eigenschaften für den übergeordneten Typ und die einzelnen zugehörigen Typen abgerufen.  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotPublic : bool" Usage="System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Type" /> nicht als öffentlich deklariert ist.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Type" /> nicht als öffentlich deklariert und kein geschachtelter Typ ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft nicht mit den folgenden Typen: Verwenden Sie stattdessen die <xref:System.Type.IsNestedPublic%2A>-Eigenschaft.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft `false`zurück.  
  
   
  
## Examples  
 In diesem Beispiel wird die `IsNotPublic`-Eigenschaft verwendet, um die Sichtbarkeit des Typs zu erhalten.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 Im folgenden Codebeispiel wird veranschaulicht, warum `IsPublic` und `IsNotPublic` für geschlagelte Klassen nicht verwendet werden können.  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 Ignorieren Sie die Ergebnisse von `IsPublic` und `IsNotPublic` bei der-Klasse, und achten Sie nur auf die Ergebnisse von `IsNestedPublic` und `IsNestedPrivate`. Die Reflektionsausgabe für dieses Code Fragment lautet wie folgt:  
  
|Klasse|IsNotPublic|IsPublic|IsNestedPublic|IsNestedPrivate|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|Ein|FALSE|TRUE|FALSE|FALSE|  
|B|FALSE|FALSE|TRUE|FALSE|  
|C|FALSE|FALSE|FALSE|TRUE|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public virtual bool IsPointer { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsPointer As Boolean" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsPointer { bool get(); };" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="member this.IsPointer : bool" Usage="System.Type.IsPointer" />
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> ein Zeiger ist.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> ein Zeiger ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> einen generischen Typ oder einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese Eigenschaft immer `false`zurück.  
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die Verwendung der `IsPointer`-Eigenschaft.  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPointerImpl : unit -&gt; bool" Usage="type.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.IsPointer" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> ein Zeiger ist.</summary>
        <returns><see langword="true" />, wenn <see cref="T:System.Type" /> ein Zeiger ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrimitive : bool" Usage="System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> zu den primitiven Typen gehört.</summary>
        <value><see langword="true" /> , wenn <see cref="T:System.Type" /> zu den primitiven Typen gehört, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die primitiven Typen sind <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>und <xref:System.Single>.  
  
 Wenn die aktuelle <xref:System.Type> einen generischen Typ oder einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese Eigenschaft immer `false`zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Eigenschaften <xref:System.Type.IsContextful%2A>, <xref:System.Type.IsMarshalByRef%2A>und `IsPrimitive` der <xref:System.Type>-Klasse veranschaulicht. Er überprüft, ob der angegebene Typ im Kontext gehostet werden kann, ob er als Verweis gemarshallt werden kann und ob der Typ ein primitiver Datentyp ist.  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPrimitiveImpl : unit -&gt; bool" Usage="type.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert beim Überschreiben in einer abgeleiteten Klasse die <see cref="P:System.Type.IsPrimitive" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> zu den primitiven Typen gehört.</summary>
        <returns><see langword="true" /> , wenn <see cref="T:System.Type" /> zu den primitiven Typen gehört, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die primitiven Typen sind <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>und <xref:System.Single>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ermittelt, ob der angegebene Typ ein primitiver Typ ist und das Ergebnis anzeigt.  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Type" /> als öffentlich deklariert ist.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Type" /> als öffentlich deklariert und kein geschachtelter Typ ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Nicht mit-Typen verwenden; Verwenden Sie stattdessen <xref:System.Type.IsNestedPublic%2A>.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft `true`zurück.  
  
 <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> wählt die Sichtbarkeits Attribute aus.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz von `MyTestClass`erstellt, die `IsPublic`-Eigenschaft überprüft und das Ergebnis angezeigt.  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 Ignorieren Sie die Ergebnisse von `IsPublic` und `IsNotPublic` bei der-Klasse, und achten Sie nur auf die Ergebnisse von <xref:System.Type.IsNestedPublic%2A> und <xref:System.Type.IsNestedPrivate%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Type" /> als versiegelt deklariert ist.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> als versiegelt deklariert ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> einen Typparameter eines generischen Typs darstellt, gibt diese Eigenschaft immer `true`zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz einer `sealed`-Klasse erstellt, die `IsSealed`-Eigenschaft überprüft und das Ergebnis angezeigt.  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitsrelevant ist und daher wichtige Vorgänge ausführen darf.</summary>
        <value><see langword="true" />, wenn der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitsrelevant ist, <see langword="false" />, wenn er sicherheitstransparent ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Eigenschaften <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>und <xref:System.Type.IsSecurityTransparent%2A> melden die Transparenz Ebene des Typs auf der aktuellen Vertrauens Ebene, wie vom Common Language Runtime (CLR) festgelegt. Die Kombinationen dieser Eigenschaften werden in der folgenden Tabelle gezeigt:  
  
|Sicherheitsstufe|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Kritisch|`true`|`false`|`false`|  
|Sicher kritisch|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.  
  
> [!IMPORTANT]
>  Für teilweise vertrauenswürdige Assemblys hängt der Wert dieser Eigenschaft von der aktuellen Vertrauens Ebene der Assembly ab. Wenn die Assembly in eine teilweise vertrauenswürdige Anwendungsdomäne geladen wird (z. b. in eine Sandbox-Anwendungsdomäne), werden die Sicherheits Anmerkungen der Assembly von der Laufzeit ignoriert. Die Assembly und alle zugehörigen Typen werden als transparent behandelt. Die Laufzeit achtet auf die Sicherheits Anmerkungen einer teilweise vertrauenswürdigen Assembly nur, wenn diese Assembly in eine voll vertrauenswürdige Anwendungsdomäne geladen wird (z. b. in die Standard Anwendungsdomäne einer Desktop Anwendung). Im Gegensatz dazu wird eine vertrauenswürdige Assembly (d. h. eine Assembly mit starkem Namen, die im globalen Assemblycache installiert ist) immer mit voller Vertrauenswürdigkeit geladen, unabhängig von der Vertrauens Ebene der Anwendungsdomäne, sodass die aktuelle Vertrauens Ebene immer voll vertrauenswürdig ist. Mithilfe der Eigenschaften <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> und <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> können Sie die aktuellen Vertrauens Ebenen von Assemblys und Anwendungs Domänen ermitteln.  
  
 Weitere Informationen zur Reflektion und Transparenz finden Sie unter [Sicherheitsüberlegungen für die Reflektion](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection). Informationen zur Transparenz finden Sie unter [Sicherheitsänderungen](/dotnet/framework/security/security-changes).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection">Sicherheitsüberlegungen für die Reflektion</related>
        <related type="Article" href="/dotnet/framework/security/security-changes">Änderungen der Sicherheit in .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitsrelevant ist, d. h. ob er wichtige Vorgänge ausführen darf und ob von transparentem Code auf ihn zugegriffen werden kann.</summary>
        <value><see langword="true" />, wenn der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitsrelevant ist, <see langword="false" /> wenn er sicherheitstransparent oder sicherheitsrelevant ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Eigenschaften <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>und <xref:System.Type.IsSecurityTransparent%2A> melden die Transparenz Ebene des Typs auf der aktuellen Vertrauens Ebene, wie vom Common Language Runtime (CLR) festgelegt. Die Kombinationen dieser Eigenschaften werden in der folgenden Tabelle gezeigt:  
  
|Sicherheitsstufe|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  
|--------------------|------------------------|----------------------------|---------------------------|  
|Kritisch|`true`|`false`|`false`|  
|Sicher kritisch|`true`|`true`|`false`|  
|Transparent|`false`|`false`|`true`|  
  
 Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.  
  
> [!IMPORTANT]
>  Für teilweise vertrauenswürdige Assemblys hängt der Wert dieser Eigenschaft von der aktuellen Vertrauens Ebene der Assembly ab. Wenn die Assembly in eine teilweise vertrauenswürdige Anwendungsdomäne geladen wird (z. b. in eine Sandbox-Anwendungsdomäne), werden die Sicherheits Anmerkungen der Assembly von der Laufzeit ignoriert. Die Assembly und alle zugehörigen Typen werden als transparent behandelt. Die Laufzeit achtet auf die Sicherheits Anmerkungen einer teilweise vertrauenswürdigen Assembly nur, wenn diese Assembly in eine voll vertrauenswürdige Anwendungsdomäne geladen wird (z. b. in die Standard Anwendungsdomäne einer Desktop Anwendung). Im Gegensatz dazu wird eine vertrauenswürdige Assembly (d. h. eine Assembly mit starkem Namen, die im globalen Assemblycache installiert ist) immer mit voller Vertrauenswürdigkeit geladen, unabhängig von der Vertrauens Ebene der Anwendungsdomäne, sodass die aktuelle Vertrauens Ebene immer voll vertrauenswürdig ist. Mithilfe der Eigenschaften <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> und <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> können Sie die aktuellen Vertrauens Ebenen von Assemblys und Anwendungs Domänen ermitteln.  
  
 Weitere Informationen zur Reflektion und Transparenz finden Sie unter [Sicherheitsüberlegungen für die Reflektion](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection). Informationen zur Transparenz finden Sie unter [Sicherheitsänderungen](/dotnet/framework/security/security-changes).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection">Sicherheitsüberlegungen für die Reflektion</related>
        <related type="Article" href="/dotnet/framework/security/security-changes">Änderungen der Sicherheit in .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der aktuelle Typ auf der aktuellen Vertrauensebene sicherheitstransparent ist und daher keine wichtigen Vorgänge ausführen kann.</summary>
        <value><see langword="true" />, wenn der Typ auf der aktuellen Vertrauensebene sicherheitstransparent ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Eigenschaft `true`zurückgibt, geben die Eigenschaften <xref:System.Type.IsSecurityCritical%2A> und <xref:System.Type.IsSecuritySafeCritical%2A> `false`zurück.  
  
 Die Eigenschaften <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>und <xref:System.Type.IsSecurityTransparent%2A> melden die Transparenz Ebene des Typs auf der aktuellen Vertrauens Ebene, wie vom Common Language Runtime (CLR) festgelegt. Ein Verwenden dieser Eigenschaften ist deutlich einfacher als das Untersuchen der Sicherheitsanmerkungen einer Assembly und der zugehörigen Typen, das Überprüfen der aktuellen Vertrauensebene und das Versuchen, die Laufzeitregeln zu duplizieren.  
  
> [!IMPORTANT]
>  Für teilweise vertrauenswürdige Assemblys hängt der Wert dieser Eigenschaft von der aktuellen Vertrauens Ebene der Assembly ab. Wenn die Assembly in eine teilweise vertrauenswürdige Anwendungsdomäne geladen wird (z. b. in eine Sandbox-Anwendungsdomäne), werden die Sicherheits Anmerkungen der Assembly von der Laufzeit ignoriert. Die Assembly und alle zugehörigen Typen werden als transparent behandelt. Die Laufzeit achtet auf die Sicherheits Anmerkungen einer teilweise vertrauenswürdigen Assembly nur, wenn diese Assembly in eine voll vertrauenswürdige Anwendungsdomäne geladen wird (z. b. in die Standard Anwendungsdomäne einer Desktop Anwendung). Im Gegensatz dazu wird eine vertrauenswürdige Assembly (d. h. eine Assembly mit starkem Namen, die im globalen Assemblycache installiert ist) immer mit voller Vertrauenswürdigkeit geladen, unabhängig von der Vertrauens Ebene der Anwendungsdomäne, sodass die aktuelle Vertrauens Ebene immer voll vertrauenswürdig ist. Mithilfe der Eigenschaften <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> und <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> können Sie die aktuellen Vertrauens Ebenen von Assemblys und Anwendungs Domänen ermitteln.  
  
 Weitere Informationen zur Reflektion und Transparenz finden Sie unter [Sicherheitsüberlegungen für die Reflektion](/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection). Informationen zur Transparenz finden Sie unter [Sicherheitsänderungen](/dotnet/framework/security/security-changes).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/security-considerations-for-reflection">Sicherheitsüberlegungen für die Reflektion</related>
        <related type="Article" href="/dotnet/framework/security/security-changes">Änderungen der Sicherheit in .NET Framework</related>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Type.IsSerializable" />
      <MemberSignature Language="C#" Value="public bool IsSerializable { get; }" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSerializable As Boolean" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSerializable { bool get(); };" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> serialisierbar ist.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Type" /> serialisierbar ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Typen, die in der .NET Standard definiert sind, sind nicht mit <xref:System.SerializableAttribute>markiert. Stattdessen bestimmt jede .NET-Implementierung, ob ein Typ serialisierbar ist. Zur Laufzeit können Sie die <xref:System.Type.IsSerializable%2A>-Eigenschaft verwenden, um zu bestimmen, ob diese Implementierung die Serialisierung einer Instanz des-Typs unterstützt. Weitere Informationen und ein Beispiel finden Sie unter [bestimmen, ob ein .NET Standard Objekt serialisierbar ist](/dotnet/standard/serialization/how-to-determine-if-netstandard-object-is-serializable).
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gilt diese Eigenschaft für die generische Typdefinition, aus der der Typ erstellt wurde. Wenn die aktuelle <xref:System.Type> z. b. `MyGenericType<int>` darstellt (`MyGenericType(Of Integer)` in Visual Basic), wird der Wert dieser Eigenschaft durch `MyGenericType<T>`bestimmt.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese Eigenschaft immer `false`zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Instanz `MyTestClass`-Klasse erstellt, das [serialisierbare]-Attribut festgelegt und die `IsSerializable`-Eigenschaft für `true` oder `false`überprüft.  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSignatureType : bool" Usage="System.Type.IsSignatureType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Typ ein Signaturtyp ist</summary>
        <value><see langword="true" />, wenn die <see cref="T:System.Type" /> ein Signatur Typen ist. Andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
Ein Signaturtyp ist ein eingeschränkter Typ, der an die <xref:System.Type.GetMethod%2A>-Methode, jedoch nicht den größten Teil der anderen Reflektionsfunktionalität unterstützt werden kann. Beispielsweise können Sie die Signatur-Typinstanz abrufen, die dem generischen Methoden Parameter entspricht, indem Sie die <xref:System.Type.MakeGenericMethodParameter%2A>-Methode aufrufen.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Typ einen Namen besitzt, der eine Sonderbehandlung erfordert.</summary>
        <value><see langword="true" /> , wenn der Typ einen Namen besitzt, der eine Sonderbehandlung erfordert, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Namen, die mit oder beginnen, enthalten einen Unterstrich (_), Eigenschaftenaccessoren und Operator Überladungsmethoden sind Beispiele für Typen, die von einigen Compilern möglicherweise eine besondere Behandlung erfordern.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gilt diese Eigenschaft für die generische Typdefinition, aus der der Typ erstellt wurde. Wenn die aktuelle <xref:System.Type> z. b. `MyGenericType<int>` darstellt (`MyGenericType(Of Integer)` in Visual Basic), wird der Wert dieser Eigenschaft durch `MyGenericType<T>`bestimmt.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese Eigenschaft immer `false`zurück.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsSubclassOf : Type -&gt; bool&#xA;override this.IsSubclassOf : Type -&gt; bool" Usage="type.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="c">Der Typ, der mit dem aktuellen Typ verglichen werden soll.</param>
        <summary>Bestimmt, ob der aktuelle <see cref="T:System.Type" /> vom angegebenen <see cref="T:System.Type" /> abgeleitet ist.</summary>
        <returns><see langword="true" />, wenn der aktuelle <see langword="Type" /> von <paramref name="c" /> abgeleitet ist, andernfalls <see langword="false" />. Diese Methode gibt auch dann <see langword="false" /> zurück, wenn <paramref name="c" /> und der aktuelle <see langword="Type" /> gleich sind.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Type.IsSubclassOf%2A>-Methode aufzurufen, um Folgendes zu bestimmen:  
  
-   Gibt an, ob eine Klasse von einer anderen abgeleitet ist.  
  
-   Gibt an, ob ein Typ von <xref:System.ValueType>abgeleitet ist. Der <xref:System.Type.IsValueType%2A> ist jedoch eine effizientere Möglichkeit, um zu bestimmen, ob ein Typ ein Werttyp ist.  
  
-   Gibt an, ob ein Typ von <xref:System.Enum>abgeleitet ist. Die <xref:System.Type.IsEnum%2A>-Methode ist jedoch eine effizientere Möglichkeit, um zu bestimmen, ob ein Typ eine Enumeration ist.  
  
-   Gibt an, ob ein Typ ein Delegat ist, d. h. ob er entweder von <xref:System.Delegate> oder <xref:System.MulticastDelegate>abgeleitet ist.  
  
 Die <xref:System.Type.IsSubclassOf%2A>-Methode kann nicht verwendet werden, um zu bestimmen, ob eine Schnittstelle von einer anderen Schnittstelle abgeleitet wird oder ob eine Klasse eine Schnittstelle implementiert. Verwenden Sie für diesen Zweck die <xref:System.Type.IsAssignableFrom%2A>-Methode, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, wird Sie von der Klassen Einschränkung oder von <xref:System.Object?displayProperty=nameWithType> abgeleitet, wenn Sie keine Klassen Einschränkung aufweist.  
  
> [!NOTE]
>  Außer bei Verwendung mit Schnittstellen ist <xref:System.Type.IsSubclassOf%2A> das Gegenteil von <xref:System.Type.IsAssignableFrom%2A>. Das heißt, wenn `t1.IsSubclassOf(t2)` `true`ist, wird `t2.IsAssignableFrom(t1)` ebenfalls `true`.  
  
 Diese Methode kann von einer abgeleiteten Klasse überschrieben werden.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt eine Klasse mit dem Namen `Class1` und eine abgeleitete Klasse mit dem Namen `DerivedC1`. Sie ruft die <xref:System.Type.IsSubclassOf%2A>-Methode auf, um anzuzeigen, dass `DerivedC1` eine Unterklasse von `Class1`ist.  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="c" /> ist <see langword="null" /></exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Typ ein Arraytyp ist, der nur ein eindimensionales Array mit einer unteren Grenze von 0 (Null) darstellen kann</summary>
        <value><see langword="true" />, wenn der aktuelle <see cref="T:System.Type" /> ein Arraytyp ist, der nur ein eindimensionales Array mit einer unteren Grenze von 0 (null) darstellen kann. Andernfalls <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Typ eine Typdefinition ist</summary>
        <value><see langword="true" />, wenn die aktuelle <see cref="T:System.Type" /> eine Typdefinition ist. Andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Eine <xref:System.Type> Instanz ist eine Typdefinition, wenn Sie den Typ darstellt, der in der Assembly direkt definiert ist, im Gegensatz zu Typen, die basierend auf anderen Typen Bedarfs gesteuert erstellt werden. Ein primitiver Typ, eine Klasse, eine Struktur oder eine generische Typdefinition ist beispielsweise eine Typdefinition, aber ein Array-, Verweis-, Zeiger-oder instanziierte generischer Typ ist nicht.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnicodeClass : bool" Usage="System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob für <see langword="UnicodeClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist.</summary>
        <value><see langword="true" />, wenn für <see langword="UnicodeClass" /> das Zeichenfolgenformatattribut <see cref="T:System.Type" /> ausgewählt ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Reflection.TypeAttributes.StringFormatMask> wird verwendet, um die Attribute des Zeichen folgen Formats auszuwählen. Die Attribute des Zeichen folgen Formats verbessern die Interoperabilität durch definieren, wie Zeichen folgen interpretiert werden sollen.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gilt diese Eigenschaft für die generische Typdefinition, aus der der Typ erstellt wurde. Wenn die aktuelle <xref:System.Type> z. b. `MyGenericType<int>` darstellt (`MyGenericType(Of Integer)` in Visual Basic), wird der Wert dieser Eigenschaft durch `MyGenericType<T>`bestimmt.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese Eigenschaft immer `false`zurück.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueType : bool" Usage="System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Type" /> ein Werttyp ist.</summary>
        <value><see langword="true" /> , wenn <see cref="T:System.Type" /> ein Werttyp ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Werttypen sind Typen, die als Sequenzen von Bits dargestellt werden. Werttypen sind keine Klassen oder Schnittstellen. Werttypen werden in einigen Programmiersprachen als "Strukturen" bezeichnet. Enumerationswerte sind ein Sonderfall von Werttypen.  
  
 Diese Eigenschaft gibt `false` für die <xref:System.ValueType>-Klasse zurück, da es sich bei <xref:System.ValueType> nicht um einen Werttyp handelt. Dabei handelt es sich um die Basisklasse für alle Werttypen. Daher kann Ihr ein beliebiger Werttyp zugewiesen werden. Dies wäre nicht möglich, wenn <xref:System.ValueType> selbst ein Werttyp wäre. Werttypen werden gekapselt, wenn Sie einem Feld vom Typ <xref:System.ValueType>zugewiesen werden.  
  
 Diese Eigenschaft gibt `true` für Enumerationen zurück, jedoch nicht für den <xref:System.Enum> Typ selbst. Ein Beispiel, in dem dieses Verhalten veranschaulicht wird, finden Sie unter <xref:System.Type.IsEnum%2A>.  
  
 Diese Eigenschaft ist schreibgeschützt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine Variable vom Typ `MyEnum`erstellt, die `IsValueType`-Eigenschaft überprüft und das Ergebnis angezeigt.  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsValueTypeImpl : unit -&gt; bool&#xA;override this.IsValueTypeImpl : unit -&gt; bool" Usage="type.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Implementiert die <see cref="P:System.Type.IsValueType" />-Eigenschaft und bestimmt, ob <see cref="T:System.Type" /> ein Werttyp ist, also weder eine Klasse noch eine Schnittstelle.</summary>
        <returns><see langword="true" /> , wenn <see cref="T:System.Type" /> ein Werttyp ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird bereitgestellt, um die Implementierung alternativer Typsysteme zu ermöglichen. Sie wird in der Regel nicht im Anwendungscode verwendet.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der Typ ein Arraytyp ist, der nur ein mehrdimensionales Array oder ein Array mit einer willkürlichen unteren Grenze darstellen kann</summary>
        <value><see langword="true" />, wenn der aktuelle <see cref="T:System.Type" /> ein Arraytyp ist, der ein mehrdimensionales Array oder ein Array mit einer willkürlichen unteren Grenze darstellen kann. Andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
Wenn der Wert dieser Eigenschaft für einen Arraytyp `true` wird, kann er verwendet werden, um eindimensionale oder mehrdimensionale Array Instanzen mit willkürlichen unteren Begrenzungen zu erstellen. Andernfalls kann der Arraytyp nur zum Erstellen von Instanzen von eindimensionalen Arrays mit einer unteren Grenze von 0 (null) verwendet werden.
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob auf den <see cref="T:System.Type" /> aus Code von außerhalb der Assembly zugegriffen werden kann.</summary>
        <value><see langword="true" />, wenn der aktuelle <see cref="T:System.Type" /> ein öffentlicher Typ oder ein öffentlicher geschachtelter Typ ist, sodass alle einschließenden Typen öffentlich sind, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Eigenschaft, um zu bestimmen, ob ein Typ Teil der öffentlichen Schnittstelle einer Komponentenassembly ist.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden zwei Klassen getestet, von denen nur eine außerhalb der Assembly sichtbar ist.  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das ein Array des aktuellen Typs darstellt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public abstract Type MakeArrayType ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MakeArrayType () As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ MakeArrayType();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type&#xA;override this.MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das ein eindimensionales Array vom aktuellen Typ mit einer unteren Grenze von 0 (null) darstellt.</summary>
        <returns>Ein <see cref="T:System.Type" />-Objekt, das ein eindimensionales Array vom aktuellen Typ mit einer unteren Grenze von 0 (null) darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.MakeArrayType%2A>-Methode bietet eine Möglichkeit, Array Typen zu generieren, deren Elementtypen zur Laufzeit berechnet werden.  
  
 **Hinweis** Der Common Language Runtime unterscheidet zwischen Vektoren (d. h. eindimensionalen Arrays, die stets NULL basiert) und mehrdimensionalen Arrays. Ein Vektor, der immer nur eine Dimension hat, ist nicht identisch mit einem mehrdimensionalen Array, das nur eine Dimension aufweist. Diese Methoden Überladung kann nur zum Erstellen von Vektor Typen verwendet werden, und Sie ist die einzige Möglichkeit, einen Vektortyp zu erstellen. Verwenden Sie die <xref:System.Type.MakeArrayType%28System.Int32%29>-Methoden Überladung zum Erstellen von mehrdimensionalen Array Typen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Array, `ref` (`ByRef` in Visual Basic) und Zeiger Typen für die `Test`-Klasse erstellt.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt. Abgeleitete Klassen müssen eine Implementation angeben.</exception>
        <exception cref="T:System.TypeLoadException">Der aktuelle Typ ist <see cref="T:System.TypedReference" />.  
  
Oder 
Der aktuelle Typ ist ein <see langword="ByRef" />-Typ. Das heißt, <see cref="P:System.Type.IsByRef" /> gibt <see langword="true" /> zurück.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public abstract Type MakeArrayType (int rank);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MakeArrayType (rank As Integer) As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ MakeArrayType(int rank);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type&#xA;override this.MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="rank">Die Anzahl von Dimensionen für das Array. Diese Zahl muss kleiner oder gleich 32 sein.</param>
        <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das ein Array vom aktuellen Typ mit der angegebenen Anzahl von Dimensionen darstellt.</summary>
        <returns>Ein Objekt, das ein Array vom aktuellen Typ mit der angegebenen Anzahl von Dimensionen darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.MakeArrayType%2A>-Methode bietet eine Möglichkeit, Array Typen zu generieren, deren Elementtypen zur Laufzeit berechnet werden.  
  
> [!NOTE]
>  Der Common Language Runtime unterscheidet zwischen Vektoren (d. h. eindimensionalen Arrays, die stets NULL basiert) und mehrdimensionalen Arrays. Ein Vektor, der immer nur eine Dimension hat, ist nicht identisch mit einem mehrdimensionalen Array, das nur eine Dimension aufweist. Sie können diese Methoden Überladung nicht zum Erstellen eines Vektor Typs verwenden. Wenn `rank` 1 ist, gibt diese Methoden Überladung einen mehrdimensionalen Arraytyp zurück, der eine Dimension hat. Verwenden Sie die <xref:System.Type.MakeArrayType>-Methoden Überladung, um Vektor Typen zu erstellen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Array, `ref` (`ByRef` in Visual Basic) und Zeiger Typen für die `Test`-Klasse erstellt.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><paramref name="rank" /> ist ungültig. Beispielsweise 0 oder ein negativer Wert.</exception>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</exception>
        <exception cref="T:System.TypeLoadException">Der aktuelle Typ ist <see cref="T:System.TypedReference" />.  
  
Oder 
Der aktuelle Typ ist ein <see langword="ByRef" />-Typ. Das heißt, <see cref="P:System.Type.IsByRef" /> gibt <see langword="true" /> zurück.  
  
Oder 
 <paramref name="rank" /> ist größer als 32.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public abstract Type MakeByRefType ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MakeByRefType () As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ MakeByRefType();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type&#xA;override this.MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das beim Übergeben als <see langword="ref" />-Parameter (<see langword="ByRef" />-Parameter in Visual Basic) den aktuellen Typ darstellt.</summary>
        <returns>Ein <see cref="T:System.Type" />-Objekt, das beim Übergeben als <see langword="ref" />-Parameter (<see langword="ByRef" />-Parameter in Visual Basic) den aktuellen Typ darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.MakeByRefType%2A>-Methode bietet eine Möglichkeit, `ref` Typen (`ByRef` in Visual Basic) für Parameterlisten zu generieren.  
  
 Bei Verwendung der Syntax von Microsoft Intermediate Language (MSIL) gibt diese Methode ein <xref:System.Type> Objekt zurück, das `Int32&`darstellt, wenn das aktuelle <xref:System.Type> Objekt <xref:System.Int32>darstellt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Array, `ref` (`ByRef` in Visual Basic) und Zeiger Typen für die `Test`-Klasse erstellt.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</exception>
        <exception cref="T:System.TypeLoadException">Der aktuelle Typ ist <see cref="T:System.TypedReference" />.  
  
Oder 
Der aktuelle Typ ist ein <see langword="ByRef" />-Typ. Das heißt, <see cref="P:System.Type.IsByRef" /> gibt <see langword="true" /> zurück.</exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberSignature Language="F#" Value="static member MakeGenericMethodParameter : int -&gt; Type" Usage="System.Type.MakeGenericMethodParameter position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="position">Die Position des generischen Typparameter</param>
        <summary>Gibt ein Signaturtypobjekt zurück, das an den Arrayparameter <c>Type[]</c> einer <see cref="Overload:System.Type.GetMethod" />-Methode übergeben werden kann, um einen generischen Parameterverweis darzustellen</summary>
        <returns>Ein Signaturtypobjekt zurück, das an den Arrayparameter <c>Type[]</c> einer <see cref="Overload:System.Type.GetMethod" />-Methode übergeben werden kann, um einen generischen Parameterverweis darzustellen</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="position" /> ist ein negativer Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericSignatureType">
      <MemberSignature Language="C#" Value="public static Type MakeGenericSignatureType (Type genericTypeDefinition, params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericSignatureType(class System.Type genericTypeDefinition, class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericSignatureType(System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericSignatureType (genericTypeDefinition As Type, ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericSignatureType(Type ^ genericTypeDefinition, ... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="static member MakeGenericSignatureType : Type * Type[] -&gt; Type" Usage="System.Type.MakeGenericSignatureType (genericTypeDefinition, typeArguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericTypeDefinition" Type="System.Type" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="typeArguments" Type="System.Type[]" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0">
          <Attributes>
            <Attribute FrameworkAlternate="netcore-3.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="genericTypeDefinition">Die generische Typdefinition.</param>
        <param name="typeArguments">Ein Array von Typargumenten.</param>
        <summary>Erstellt einen generischen Signaturtyp, der Neuimplementierungen von Reflection durch Drittanbieter zulässt, um die Verwendung von Signaturtypen bei der Abfrage von Typmembern vollständig zu unterstützen.</summary>
        <returns>Ein generischer Signaturtyp.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public abstract Type MakeGenericType (params Type[] typeArguments);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MakeGenericType (ParamArray typeArguments As Type()) As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type&#xA;override this.MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments">Ein Array von Typen, die die Typparameter des aktuellen generischen Typs ersetzen sollen.</param>
        <summary>Ersetzt die Typparameter der aktuellen generischen Typdefinition durch die Elemente eines Arrays von Typen und gibt ein <see cref="T:System.Type" />-Objekt zurück, das den resultierenden konstruierten Typ darstellt.</summary>
        <returns>Ein <see cref="T:System.Type" />, der den konstruierten Typ darstellt, der durch Ersetzen der Typparameter des aktuellen generischen Typs durch die Elemente von <paramref name="typeArguments" /> erstellt wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit der <xref:System.Type.MakeGenericType%2A>-Methode können Sie Code schreiben, der den Typparametern einer generischen Typdefinition bestimmte Typen zuweist, wodurch ein <xref:System.Type> Objekt erstellt wird, das einen bestimmten konstruierten Typ darstellt. Sie können dieses <xref:System.Type> Objekt verwenden, um Lauf Zeit Instanzen des konstruierten Typs zu erstellen.  
  
 Mit <xref:System.Type.MakeGenericType%2A> erstellte Typen können geöffnet werden, d. h., einige ihrer Typargumente können Typparameter von einschließenden generischen Methoden oder Typen sein. Bei der Ausgabe dynamischer Assemblys können solche geöffneten konstruierten Typen verwendet werden. Beachten Sie z. b. die Klassen `Base` und `Derived` im folgenden Code.  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 Um `Derived` in einer dynamischen Assembly zu generieren, muss der Basistyp erstellt werden. Um dies zu erreichen, müssen Sie die <xref:System.Type.MakeGenericType%2A>-Methode für ein <xref:System.Type> Objekt aufrufen, das die Klasse `Base`darstellt, wobei die generischen Typargumente <xref:System.Int32> und der Typparameter `V` von `Derived`verwendet werden Da Typen und generische Typparameter beide durch <xref:System.Type>-Objekte dargestellt werden, kann ein Array, das beides enthält, an die <xref:System.Type.MakeGenericType%2A>-Methode übermittelt werden.  
  
> [!NOTE]
>  Ein konstruierter Typ, wie z. b. `Base<int, V>`, ist beim Ausgeben von Code nützlich, aber Sie können die <xref:System.Type.MakeGenericType%2A>-Methode für diesen Typ nicht abrufen Um einen geschlossenen konstruierten Typ zu erstellen, der instanziiert werden kann, rufen Sie zunächst die <xref:System.Type.GetGenericTypeDefinition%2A>-Methode auf, um ein <xref:System.Type> Objekt abzurufen, das die generische Typdefinition darstellt, und rufen Sie dann <xref:System.Type.MakeGenericType%2A> mit den gewünschten Typargumenten  
  
 Das von <xref:System.Type.MakeGenericType%2A> zurückgegebene <xref:System.Type> Objekt entspricht dem <xref:System.Type>, das durch Aufrufen der <xref:System.Object.GetType%2A>-Methode des resultierenden konstruierten Typs abgerufen wurde, oder der <xref:System.Object.GetType%2A>-Methode eines konstruierten Typs, der mit denselben Typargumenten aus der gleichen generischen Typdefinition erstellt wurde.  
  
> [!NOTE]
>  Ein Array generischer Typen ist nicht selbst ein generischer Typ. Sie können <xref:System.Type.MakeGenericType%2A> für einen Arraytyp wie `C<T>[]` (`Dim ac() As C(Of T)` in Visual Basic) nicht aufzurufen. Um einen geschlossenen generischen Typ aus `C<T>[]`zu erstellen, rufen Sie <xref:System.Type.GetElementType%2A> auf, um die generische Typdefinition `C<T>`zu erhalten. Rufen Sie <xref:System.Type.MakeGenericType%2A> für die generische Typdefinition auf, um den konstruierten Typ zu erstellen. und schließlich rufen Sie die <xref:System.Type.MakeArrayType%2A>-Methode für den konstruierten Typ auf, um den Arraytyp zu erstellen. Das gleiche gilt für Zeiger Typen und `ref` Typen (`ByRef` in Visual Basic).  
  
 Eine Liste der invarianten Bedingungen für Begriffe, für Begriffe, die für die Reflektion mit generischen Methoden verwendet werden, finden Sie in den Hinweisen zur Eigenschaft <xref:System.Type.IsGenericType%2A>.  
  
## <a name="nested-types"></a>Geschachtelte Typen  
 Wenn ein generischer Typ mithilfe C#von, C++oder Visual Basic definiert wird, sind die zugehörigen nerischen Typen alle generisch. Dies ist auch dann der Fall, wenn die in der Liste für die Typen übergebenen Typen keine eigenen Typparameter aufweisen, da alle drei Sprachen die Typparameter der einschließenden Typen in den Typparameter Listen der in einem Typ untergeordneten Typen enthalten. Beachten Sie die folgenden Klassen:  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 Die Typparameter Liste der in der-Klasse `Inner`-Klasse verfügt über zwei Typparameter, `T` und `U`. der erste Parameter ist der Typparameter der einschließenden Klasse. Entsprechend verfügt die Typparameter Liste der in der-Klasse `Innermost1`-Klasse über drei Typparameter, `T`, `U`und `V`, wobei `T` und `U` von den einschließenden Klassen stammen. Die `Innermost2` für die der-Klasse verfügt über zwei Typparameter, `T` und `U`, die von ihren einschließenden Klassen stammen.  
  
 Wenn die Parameterliste des einschließenden Typs mehr als einen Typparameter aufweist, werden alle Typparameter in der Reihenfolge in der Typparameter Liste des untergeordneten Typs eingefügt.  
  
 Um einen generischen Typ aus der generischen Typdefinition für einen untergeordneten Typ zu erstellen, müssen Sie die <xref:System.Type.MakeGenericType%2A>-Methode mit dem Array aufzurufen, das durch Verkettung der Typargument Arrays aller einschließenden Typen, beginnend mit dem äußersten generischen Typ und mit dem Typargument Array des nisted Type selbst, wenn er über eigene Typparameter verfügt. Um eine Instanz von `Innermost1`zu erstellen, rufen Sie die <xref:System.Type.MakeGenericType%2A>-Methode mit einem Array auf, das drei Typen enthält, die t, U und V zugewiesen werden sollen. Um eine Instanz von `Innermost2`zu erstellen, rufen Sie die <xref:System.Type.MakeGenericType%2A>-Methode mit einem Array auf, das zwei Typen enthält, die t und U zugewiesen werden sollen.  
  
 Die Sprachen propagieren die Typparameter von einschließenden Typen auf diese Weise, sodass Sie die Typparameter eines einschließenden Typs verwenden können, um Felder von geschachtelte Types zu definieren. Andernfalls befinden sich die Typparameter nicht im Gültigkeitsbereich innerhalb der Texte der geschachtelten Typen. Es ist möglich, die Typparameter von einschließenden Typen zu definieren, indem Sie Code in dynamischen Assemblys oder mithilfe von [Ilasm. exe (Il-Assembler)](/dotnet/framework/tools/ilasm-exe-il-assembler)ausgeben. Beachten Sie den folgenden Code für den MSIL-Assembler:  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 In diesem Beispiel ist es nicht möglich, ein Feld vom Typ `T` oder `U` in der Klasse `Innermost`zu definieren, da diese Typparameter nicht im Gültigkeitsbereich liegen. Der folgende Assemblycode definiert die Klassen, die sich so Verhalten, wie Sie C++in, Visual Basic und C#definiert werden:  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 Sie können den [Ildasm. exe (IL-Disassembler)](/dotnet/framework/tools/ildasm-exe-il-disassembler) verwenden, um in den Sprachen auf hoher Ebene definierte in der Sprache definierte Klassen zu untersuchen und dieses Benennungs Schema zu beobachten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Type.MakeGenericType%2A>-Methode verwendet, um einen konstruierten Typ aus der generischen Typdefinition für den <xref:System.Collections.Generic.Dictionary%602>-Typ zu erstellen. Der konstruierte Typ stellt eine <xref:System.Collections.Generic.Dictionary%602> von `Test` Objekten mit Zeichen folgen Schlüsseln dar.  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der aktuelle Typ stellt keine generische Typdefinition dar. Das heißt, <see cref="P:System.Type.IsGenericTypeDefinition" /> gibt <see langword="false" /> zurück.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeArguments" /> ist <see langword="null" />  
  
Oder 
Ein beliebiges Element von <paramref name="typeArguments" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die Anzahl der Elemente im <paramref name="typeArguments" /> entspricht nicht der Anzahl von Typparametern in der aktuellen generischen Typdefinition.  
  
Oder 
Ein beliebiges Element von <paramref name="typeArguments" /> erfüllt nicht die Einschränkungen, die für den entsprechenden Typparameter des aktuellen generischen Typs angegeben wurden.  
  
Oder 
 <paramref name="typeArguments" /> enthält ein Element, das ein Zeigertyp (<see cref="P:System.Type.IsPointer" /> gibt <see langword="true" /> zurück), vom Typ „by-ref“ (<see cref="P:System.Type.IsByRef" /> gibt <see langword="true" /> zurück) oder <see cref="T:System.Void" /> ist.</exception>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt. Abgeleitete Klassen müssen eine Implementation angeben.</exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/reflection-and-generic-types">Reflektion und generische Typen</related>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection">Gewusst wie: Untersuchen und Instanziieren von generischen Typen mit Reflektion</related>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public abstract Type MakePointerType ();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function MakePointerType () As Type" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ MakePointerType();" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6" />
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type&#xA;override this.MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein <see cref="T:System.Type" />-Objekt zurück, das einen Zeiger auf den aktuellen Typ darstellt.</summary>
        <returns>Ein <see cref="T:System.Type" />-Objekt, das einen Zeiger auf den aktuellen Typ darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Type.MakePointerType%2A>-Methode bietet eine Möglichkeit zum Generieren von Zeiger Typen für Parameterlisten.  
  
 Bei Verwendung der Syntax von Microsoft Intermediate Language (MSIL) gibt diese Methode ein <xref:System.Type> Objekt zurück, das `Int32*`darstellt, wenn das aktuelle <xref:System.Type> Objekt <xref:System.Int32>darstellt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden Array, `ref` (`ByRef` in Visual Basic) und Zeiger Typen für die `Test`-Klasse erstellt.  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</exception>
        <exception cref="T:System.TypeLoadException">Der aktuelle Typ ist <see cref="T:System.TypedReference" />.  
  
Oder 
Der aktuelle Typ ist ein <see langword="ByRef" />-Typ. Das heißt, <see cref="P:System.Type.IsByRef" /> gibt <see langword="true" /> zurück.</exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Reflection.MemberTypes" />-Wert ab, der angibt, dass dieser Member ein Typ oder ein geschachtelter Typ ist.</summary>
        <value>Ein <see cref="T:System.Reflection.MemberTypes" />-Wert, der angibt, dass dieser Member ein Typ oder ein geschachtelter Typ ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft überschreibt <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>. Wenn Sie z. b. einen Satz von <xref:System.Reflection.MemberInfo> Objekten überprüfen, gibt das von <xref:System.Type.GetMembers%2A>-der <xref:System.Reflection.MemberInfo.MemberType%2A>-Eigenschaft zurückgegebene Array <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> zurück, wenn ein angegebener Member ein Typ ist.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gilt diese Eigenschaft für die generische Typdefinition, aus der der Typ erstellt wurde. Wenn die aktuelle <xref:System.Type> z. b. `MyGenericType<int>` darstellt (`MyGenericType(Of Integer)` in Visual Basic), wird der Wert dieser Eigenschaft durch `MyGenericType<T>`bestimmt.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese Eigenschaft immer <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird das `MemberType`-Feld als Parameter für die `GetMember`-Methode veranschaulicht:  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberSignature Language="F#" Value=" staticval mutable Missing : obj" Usage="System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Stellt einen in den <see cref="T:System.Type" />-Informationen fehlenden Wert dar. Dieses Feld ist schreibgeschützt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie das Feld `Missing` für den Aufruf durch Reflektion, um den Standardwert eines Parameters zu erhalten. Wenn das `Missing` Feld für einen Parameterwert übergeben wird und kein Standardwert für diesen Parameter vorhanden ist, wird eine <xref:System.ArgumentException> ausgelöst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie das `Missing`-Feld verwendet wird, um eine Methode mit ihren Standardargumenten aufzurufen.  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 Dieser Code erzeugt die folgende Ausgabe:  
  
 a = 10 b = 55,3 c = 12  
  
 a = 10 b = 1,3 c = 1  
  
 a = 10 b = 1,2 c = 1  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Type.Module" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Modul (die DLL) ab, in dem der aktuelle <see cref="T:System.Type" /> definiert ist.</summary>
        <value>Das Modul, in dem der aktuelle <see cref="T:System.Type" /> definiert ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Eigenschaft das Modul zurück, in dem die generische Typdefinition definiert wurde. Wenn Sie z. b. eine Instanz von `MyGenericStack<int>`erstellen, gibt die <xref:System.Type.Module%2A>-Eigenschaft für den konstruierten Typ das Modul zurück, in dem `MyGenericStack<T>` definiert ist.  
  
 Wenn die aktuelle <xref:System.Type> einen generischen Parameter `T`darstellt, gibt diese Eigenschaft die Assembly zurück, die den generischen Typ enthält, der `T`definiert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der Eigenschaften <xref:System.Type.Namespace%2A> und `Module` sowie die <xref:System.Type.ToString%2A>-Methode von <xref:System.Type>veranschaulicht.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft beim Überschreiben in einer abgeleiteten Klasse den Namen des aktuellen Typs ab.</summary>
        <value>Der Name des aktuellen Typs.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namespace von <see cref="T:System.Type" /> ab.</summary>
        <value>Der Namespace des <see cref="T:System.Type" />; <see langword="null" />, wenn die aktuelle Instanz über keinen Namespace verfügt oder einen generischen Parameter darstellt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Namespace ist eine logische Entwurfszeit-Benennungs Zweck, die hauptsächlich zum Definieren des Bereichs in einer Anwendung und zum Organisieren von Klassen und anderen Typen in einer einzelnen hierarchischen Struktur verwendet wird. Vom Standpunkt der Laufzeit sind keine Namespaces vorhanden.  
  
 Wenn die aktuelle <xref:System.Type> einen konstruierten generischen Typ darstellt, gibt diese Eigenschaft den Namespace zurück, der die generische Typdefinition enthält. Wenn die aktuelle <xref:System.Type> einen generischen Parameter `T`darstellt, gibt diese Eigenschaft den Namespace zurück, der die generische Typdefinition enthält, die `T`definiert.  
  
 Wenn das aktuelle <xref:System.Type>-Objekt einen generischen Parameter darstellt, gibt diese Eigenschaft `null`zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der Eigenschaften `Namespace` und <xref:System.Type.Module%2A> sowie die <xref:System.Type.ToString%2A>-Methode von <xref:System.Type>veranschaulicht.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/specifying-fully-qualified-type-names">Angeben vollständig gekennzeichneter Typnamen</related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Type * Type -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left">Das erste der zu vergleichenden Objekte.</param>
        <param name="right">Das zweite der zu vergleichenden Objekte.</param>
        <summary>Gibt an, ob zwei <see cref="T:System.Type" />-Objekte gleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> gleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Type * Type -&gt; bool" Usage="System.Type.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Type" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left">Das erste der zu vergleichenden Objekte.</param>
        <param name="right">Das zweite der zu vergleichenden Objekte.</param>
        <summary>Gibt an, ob zwei <see cref="T:System.Type" />-Objekte ungleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Klassenobjekt ab, über das dieser Member abgerufen wurde.</summary>
        <value>Das <see langword="Type" />-Objekt, über das dieses <see cref="T:System.Type" />-Objekt abgerufen wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei <xref:System.Type> Objekten ist der Wert dieser Eigenschaft immer identisch mit dem Wert der Eigenschaft <xref:System.Type.DeclaringType%2A>.  
  
   
  
## Examples  
 In diesem Beispiel wird der reflektierte Typ einer-Klasse angezeigt.  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyGetType : string * bool * bool -&gt; Type" Usage="System.Type.ReflectionOnlyGetType (typeName, throwIfNotFound, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ignoreCase" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="typeName">Der durch die Assembly bezeichnete Name des abzurufenden <see cref="T:System.Type" />.</param>
        <param name="throwIfNotFound"><see langword="true" />, damit eine <see cref="T:System.TypeLoadException" /> ausgelöst wird, wenn der Typ nicht gefunden wird. <see langword="false" />, damit <see langword="null" /> zurückgegeben wird, wenn der Typ nicht gefunden wird. Die Angabe von <see langword="false" /> unterdrückt auch einige andere Ausnahmebedingungen, aber nicht alle. Informationen finden Sie im Abschnitt für Ausnahmen.</param>
        <param name="ignoreCase"><see langword="true" />, um ohne Beachtung der Groß-/Kleinschreibung nach <paramref name="typeName" /> zu suchen; <see langword="false" />, um mit Beachtung der Groß-/Kleinschreibung nach <paramref name="typeName" /> zu suchen.</param>
        <summary>Ruft den <see cref="T:System.Type" /> mit dem angegebenen Namen ab. Dabei wird angegeben, ob bei der Suche die Groß- und Kleinschreibung berücksichtigt werden soll und ob eine Ausnahme ausgelöst werden soll, wenn der Typ nicht gefunden wird. Der Typ wird für die Reflektion, nicht für Ausführung geladen.</summary>
        <returns>Der Typ mit dem angegebenen Namen, sofern gefunden, andernfalls <see langword="null" />. Wenn der Typ nicht gefunden wird, gibt der <paramref name="throwIfNotFound" />-Parameter an, ob <see langword="null" /> zurückgegeben oder eine Ausnahme ausgelöst wird. In einigen Fällen wird unabhängig vom Wert von <paramref name="throwIfNotFound" /> eine Ausnahme ausgelöst. Informationen finden Sie im Abschnitt für Ausnahmen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Assembly, die den Typ enthält, nicht bereits in den Reflektionskontext geladen wurde, entspricht die <xref:System.Type.ReflectionOnlyGetType%2A>-Methode dem ersten Laden der Assembly für die Reflektion, mithilfe der <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A>-Methode und dem anschließenden Laden des Typs durch Aufrufen der <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>-Methode der Assembly. Informationen zu qualifizierten Assemblynamen finden Sie in der <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>-Eigenschaft. Weitere Informationen zum Angeben von Typnamen finden Sie in der <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29>-Methoden Überladung.  
  
 Wenn die Assembly bereits zur Ausführung geladen ist, wird eine andere Kopie in den reflektionsbasierten Kontext geladen.  
  
 Der `throwIfNotFound`-Parameter gibt an, was geschieht, wenn der Typ nicht gefunden wird, und unterdrückt auch bestimmte andere Ausnahmebedingungen, wie im Abschnitt Ausnahmen beschrieben. Einige Ausnahmen werden unabhängig vom Wert `throwIfNotFound`ausgelöst. Wenn die Assembly z. b. nicht gültig ist, wird ein <xref:System.BadImageFormatException> ausgelöst, auch wenn `throwIfNotFound` `false`ist.  
  
 Weitere Informationen zur Verwendung des reflektionsbasierten Kontexts finden Sie unter Gewusst wie: Laden von Assemblys [in den reflektionsbasierten Kontext](/dotnet/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="typeName" /> ist <see langword="null" /></exception>
        <exception cref="T:System.Reflection.TargetInvocationException">Ein Klasseninitialisierer wird aufgerufen und löst eine Ausnahme aus.</exception>
        <exception cref="T:System.TypeLoadException"><paramref name="throwIfNotFound" /> ist <see langword="true" />, und der Typ wurde nicht gefunden.  
  
Oder 
 <paramref name="throwIfNotFound" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Zeichen, z. B. ein eingebettetes Tabstoppzeichen. 
Oder 
 <paramref name="throwIfNotFound" /> ist <see langword="true" />, und <paramref name="typeName" /> ist eine leere Zeichenfolge.  
  
Oder 
 <paramref name="throwIfNotFound" /> ist <see langword="true" />, und <paramref name="typeName" /> stellt einen Arraytyp mit einer ungültigen Größe dar.  
  
Oder 
 <paramref name="typeName" /> stellt ein Array mit <see cref="T:System.TypedReference" />-Objekten dar.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="typeName" /> enthält keinen Assemblynamen.  
  
Oder 
 <paramref name="throwIfNotFound" /> ist <see langword="true" />, und <paramref name="typeName" /> enthält ungültige Syntax (z.B. „MyType[,*,]“).  
  
Oder 
 <paramref name="typeName" /> stellt einen generischen Typ dar, der einen Zeigertyp, einen <see langword="ByRef" />-Typ oder <see cref="T:System.Void" /> als eines seiner Typargumente aufweist.  
  
Oder 
 <paramref name="typeName" /> stellt einen generischen Typ dar, der eine falsche Anzahl von Typargumenten aufweist.  
  
Oder 
 <paramref name="typeName" /> stellt einen generischen Typ dar, und eines seiner Typargumente erfüllt nicht die Einschränkungen für den entsprechenden Typparameter.</exception>
        <exception cref="T:System.IO.FileNotFoundException"><paramref name="throwIfNotFound" /> ist <see langword="true" />, und die Assembly oder eine der zugehörigen Abhängigkeiten wurde nicht gefunden.</exception>
        <exception cref="T:System.IO.FileLoadException">Die Assembly oder eine der zugehörigen Abhängigkeiten wurde gefunden, konnte aber nicht geladen werden.</exception>
        <exception cref="T:System.BadImageFormatException">Die Assembly oder eine der zugehörigen Abhängigkeiten ist ungültig.  
  
 Oder  
  
 Die Assembly wurde mit einer Version der Common Language Runtime kompiliert, die höher ist als die Version, die derzeit geladen ist.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Nur .NET Core: Dieser Member wird nicht unterstützt.</exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/specifying-fully-qualified-type-names">Angeben vollständig gekennzeichneter Typnamen</related>
        <related type="Article" href="/dotnet/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context">Gewusst wie: Laden von Assemblys in den reflektionsbezogenen Kontext</related>
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StructLayoutAttribute : System.Runtime.InteropServices.StructLayoutAttribute" Usage="System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft ein <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> ab, der das Layout des aktuellen Typs beschreibt.</summary>
        <value>Ruft ein <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> ab, das den allgemeinen Layoutfunktionen des aktuellen Typs beschreibt.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Runtime.InteropServices.StructLayoutAttribute> wird von der <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A>-Methode nicht zurückgegeben. Verwenden Sie diese Eigenschaft stattdessen, um Sie zu erhalten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden zuerst eine-Klasse, eine-Struktur und eine-Struktur mit speziellen Layoutattributen definiert (die-Strukturen sind in der-Klasse geschachtelt). Das Beispiel verwendet dann die <xref:System.Type.StructLayoutAttribute%2A>-Eigenschaft, um für jeden Typ eine <xref:System.Runtime.InteropServices.StructLayoutAttribute> abzurufen, und zeigt die Eigenschaften der Attribute an.  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Die aufgerufene Methode wird in der Basisklasse nicht unterstützt.</exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._Type.GetIDsOfNames : Guid * nativeint * uint32 * uint32 * nativeint -&gt; unit&#xA;override this.System.Runtime.InteropServices._Type.GetIDsOfNames : Guid * nativeint * uint32 * uint32 * nativeint -&gt; unit" Usage="type.System.Runtime.InteropServices._Type.GetIDsOfNames (riid, rgszNames, cNames, lcid, rgDispId)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgszNames" Type="System.IntPtr" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="cNames" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="rgDispId" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="riid">Für die zukünftige Verwendung reserviert. Muss IID_NULL sein.</param>
        <param name="rgszNames">Das übergebene Array von zuzuordnenden Namen.</param>
        <param name="cNames">Die Anzahl der zuzuordnenden Namen.</param>
        <param name="lcid">Der Gebietsschemakontext, in dem die Namen interpretiert werden sollen.</param>
        <param name="rgDispId">Das vom Aufrufer zugewiesene Array, das die IDs entsprechend den Namen empfängt.</param>
        <summary>Ordnet eine Reihe von Namen einer entsprechenden Reihe von Dispatchbezeichnern zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code vorgesehen und sollte nicht aus verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetIDsOfNames`finden Sie in der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._Type.GetTypeInfo : uint32 * uint32 * nativeint -&gt; unit&#xA;override this.System.Runtime.InteropServices._Type.GetTypeInfo : uint32 * uint32 * nativeint -&gt; unit" Usage="type.System.Runtime.InteropServices._Type.GetTypeInfo (iTInfo, lcid, ppTInfo)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Die zurückzugebenden Typinformationen.</param>
        <param name="lcid">Der Gebietsschemabezeichner für die Typinformationen.</param>
        <param name="ppTInfo">Ein Zeiger auf das angeforderte Objekt mit den Typinformationen.</param>
        <summary>Ruft die Typinformationen für ein Objekt ab, die dann zum Abrufen der Typinformationen für eine Schnittstelle verwendet werden können.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code vorgesehen und sollte nicht aus verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetTypeInfo`finden Sie in der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._Type.GetTypeInfoCount : uint32 -&gt; unit&#xA;override this.System.Runtime.InteropServices._Type.GetTypeInfoCount : uint32 -&gt; unit" Usage="type.System.Runtime.InteropServices._Type.GetTypeInfoCount pcTInfo" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Zeigt auf einen Speicherort, der die Anzahl der Schnittstellen mit Typinformationen empfängt, die vom Objekt bereitgestellt werden.</param>
        <summary>Ruft die Anzahl der Schnittstellen mit Typinformationen ab, die von einem Objekt bereitgestellt werden (0 oder 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code vorgesehen und sollte nicht aus verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::GetTypeInfoCount`finden Sie in der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberSignature Language="F#" Value="abstract member System.Runtime.InteropServices._Type.Invoke : uint32 * Guid * uint32 * int16 * nativeint * nativeint * nativeint * nativeint -&gt; unit&#xA;override this.System.Runtime.InteropServices._Type.Invoke : uint32 * Guid * uint32 * int16 * nativeint * nativeint * nativeint * nativeint -&gt; unit" Usage="type.System.Runtime.InteropServices._Type.Invoke (dispIdMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" Index="0" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" Index="1" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="lcid" Type="System.UInt32" Index="2" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="wFlags" Type="System.Int16" Index="3" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pDispParams" Type="System.IntPtr" Index="4" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pVarResult" Type="System.IntPtr" Index="5" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" Index="6" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="puArgErr" Type="System.IntPtr" Index="7" FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Bezeichnet den Member.</param>
        <param name="riid">Für die zukünftige Verwendung reserviert. Muss IID_NULL sein.</param>
        <param name="lcid">Der Gebietsschemakontext, in dem Argumente interpretiert werden sollen.</param>
        <param name="wFlags">Flags, die den Kontext des Aufrufs beschreiben.</param>
        <param name="pDispParams">Ein Zeiger auf eine Struktur, die ein Array von Argumenten und ein Array von Argument-DISPIDs für benannte Argumente sowie Zähler für die Anzahl der Elemente in jedem Array enthält.</param>
        <param name="pVarResult">Ein Verweis auf den Speicherort, an dem das Ergebnis gespeichert werden soll.</param>
        <param name="pExcepInfo">Ein Zeiger auf eine Struktur mit Ausnahmeinformationen.</param>
        <param name="puArgErr">Der Index des ersten Arguments mit einem Fehler.</param>
        <summary>Stellt den Zugriff auf von einem Objekt verfügbar gemachte Eigenschaften und Methoden bereit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist für den Zugriff auf verwaltete Klassen aus nicht verwaltetem Code vorgesehen und sollte nicht aus verwaltetem Code aufgerufen werden. Weitere Informationen zu `IDispatch::Invoke`finden Sie in der MSDN Library.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Spät gebundener Zugriff mithilfe der <c>IDispatch</c>-Schnittstelle in COM wird nicht unterstützt.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="type.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen <see langword="String" /> zurück, der den Namen des aktuellen <see langword="Type" /> darstellt.</summary>
        <returns>Ein <see cref="T:System.String" />, der den Namen des aktuellen <see cref="T:System.Type" /> darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt den voll qualifizierten Common Language Runtime Namespace und den Namen für alle primitiven Typen zurück. Die C# Anweisung `(long)0.Type().ToString()` gibt beispielsweise "System. Int64" anstelle von "Int64" zurück.  
  
 Wenn die aktuelle <xref:System.Type> einen generischen Typ darstellt, werden der Typ und seine Typargumente durch den Namespace und den Typ, aber nicht durch die Assembly qualifiziert. Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese Methode den nicht qualifizierten Namen des Typparameters zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der Eigenschaften <xref:System.Type.Namespace%2A> und <xref:System.Type.Module%2A> sowie die `ToString`-Methode von <xref:System.Type>veranschaulicht.  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 Im folgenden Beispiel werden die von der `ToString`-Methode zurückgegebenen Zeichen folgen und die Eigenschaften <xref:System.Type.Name%2A>, <xref:System.Type.FullName%2A>und <xref:System.Type.AssemblyQualifiedName%2A> verglichen.  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Type.TypeHandle" />
      <MemberSignature Language="C#" Value="public abstract RuntimeTypeHandle TypeHandle { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property TypeHandle As RuntimeTypeHandle" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Handle für den aktuellen <see cref="T:System.Type" /> ab.</summary>
        <value>Das Handle für den aktuellen <see cref="T:System.Type" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `TypeHandle` kapselt einen Zeiger auf eine interne Datenstruktur, die den Typ darstellt. Dieses Handle ist während der Prozess Lebensdauer eindeutig. Das Handle ist nur in der Anwendungsdomäne gültig, in der es abgerufen wurde.  
  
   
  
## Examples  
 Das folgende Beispiel gibt das Handle des entsprechenden Typs zurück und übergibt das Handle an eine Methode, die den Typ aus dem Handle abruft und anzeigt.  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Eigenschaft wird von .NET Compact Framework derzeit nicht unterstützt.</exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeInitializer : System.Reflection.ConstructorInfo" Usage="System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Initialisierer für den Typ ab.</summary>
        <value>Ein Objekt, das den Namen des Klassenkonstruktors von <see cref="T:System.Type" /> enthält.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klasseninitialisierer sind auch über die <xref:System.Type.FindMembers%2A>-Methode oder über über Ladungen der Methoden <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>und <xref:System.Type.GetConstructors%2A> verfügbar, die <xref:System.Reflection.BindingFlags> als Parameter annehmen.  
  
 Wenn die aktuelle <xref:System.Type> einen Typparameter in der Definition eines generischen Typs oder einer generischen Methode darstellt, gibt diese Eigenschaft `null`zurück.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt den von der Common Language Runtime bereitgestellten Typ an, der diesen Typ darstellt.</summary>
        <value>Der Systemtyp, der <see cref="T:System.Type" />zugrunde liegt.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>
